(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[13],{

/***/ 1015:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (true) {
  module.exports = __webpack_require__(1016);
} else {}


/***/ }),

/***/ 1016:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React v0.18.0
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

Object.defineProperty(exports,"__esModule",{value:!0});var f,g,h,k,l;
if("undefined"===typeof window||"function"!==typeof MessageChannel){var p=null,q=null,t=function(){if(null!==p)try{var a=exports.unstable_now();p(!0,a);p=null}catch(b){throw setTimeout(t,0),b;}},u=Date.now();exports.unstable_now=function(){return Date.now()-u};f=function(a){null!==p?setTimeout(f,0,a):(p=a,setTimeout(t,0))};g=function(a,b){q=setTimeout(a,b)};h=function(){clearTimeout(q)};k=function(){return!1};l=exports.unstable_forceFrameRate=function(){}}else{var w=window.performance,x=window.Date,
y=window.setTimeout,z=window.clearTimeout;if("undefined"!==typeof console){var A=window.cancelAnimationFrame;"function"!==typeof window.requestAnimationFrame&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills");"function"!==typeof A&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills")}if("object"===
typeof w&&"function"===typeof w.now)exports.unstable_now=function(){return w.now()};else{var B=x.now();exports.unstable_now=function(){return x.now()-B}}var C=!1,D=null,E=-1,F=5,G=0;k=function(){return exports.unstable_now()>=G};l=function(){};exports.unstable_forceFrameRate=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported"):F=0<a?Math.floor(1E3/a):5};var H=new MessageChannel,I=H.port2;H.port1.onmessage=
function(){if(null!==D){var a=exports.unstable_now();G=a+F;try{D(!0,a)?I.postMessage(null):(C=!1,D=null)}catch(b){throw I.postMessage(null),b;}}else C=!1};f=function(a){D=a;C||(C=!0,I.postMessage(null))};g=function(a,b){E=y(function(){a(exports.unstable_now())},b)};h=function(){z(E);E=-1}}function J(a,b){var c=a.length;a.push(b);a:for(;;){var d=Math.floor((c-1)/2),e=a[d];if(void 0!==e&&0<K(e,b))a[d]=b,a[c]=e,c=d;else break a}}function L(a){a=a[0];return void 0===a?null:a}
function M(a){var b=a[0];if(void 0!==b){var c=a.pop();if(c!==b){a[0]=c;a:for(var d=0,e=a.length;d<e;){var m=2*(d+1)-1,n=a[m],v=m+1,r=a[v];if(void 0!==n&&0>K(n,c))void 0!==r&&0>K(r,n)?(a[d]=r,a[v]=c,d=v):(a[d]=n,a[m]=c,d=m);else if(void 0!==r&&0>K(r,c))a[d]=r,a[v]=c,d=v;else break a}}return b}return null}function K(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}var N=[],O=[],P=1,Q=null,R=3,S=!1,T=!1,U=!1;
function V(a){for(var b=L(O);null!==b;){if(null===b.callback)M(O);else if(b.startTime<=a)M(O),b.sortIndex=b.expirationTime,J(N,b);else break;b=L(O)}}function W(a){U=!1;V(a);if(!T)if(null!==L(N))T=!0,f(X);else{var b=L(O);null!==b&&g(W,b.startTime-a)}}
function X(a,b){T=!1;U&&(U=!1,h());S=!0;var c=R;try{V(b);for(Q=L(N);null!==Q&&(!(Q.expirationTime>b)||a&&!k());){var d=Q.callback;if(null!==d){Q.callback=null;R=Q.priorityLevel;var e=d(Q.expirationTime<=b);b=exports.unstable_now();"function"===typeof e?Q.callback=e:Q===L(N)&&M(N);V(b)}else M(N);Q=L(N)}if(null!==Q)var m=!0;else{var n=L(O);null!==n&&g(W,n.startTime-b);m=!1}return m}finally{Q=null,R=c,S=!1}}
function Y(a){switch(a){case 1:return-1;case 2:return 250;case 5:return 1073741823;case 4:return 1E4;default:return 5E3}}var Z=l;exports.unstable_ImmediatePriority=1;exports.unstable_UserBlockingPriority=2;exports.unstable_NormalPriority=3;exports.unstable_IdlePriority=5;exports.unstable_LowPriority=4;exports.unstable_runWithPriority=function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=R;R=a;try{return b()}finally{R=c}};
exports.unstable_next=function(a){switch(R){case 1:case 2:case 3:var b=3;break;default:b=R}var c=R;R=b;try{return a()}finally{R=c}};
exports.unstable_scheduleCallback=function(a,b,c){var d=exports.unstable_now();if("object"===typeof c&&null!==c){var e=c.delay;e="number"===typeof e&&0<e?d+e:d;c="number"===typeof c.timeout?c.timeout:Y(a)}else c=Y(a),e=d;c=e+c;a={id:P++,callback:b,priorityLevel:a,startTime:e,expirationTime:c,sortIndex:-1};e>d?(a.sortIndex=e,J(O,a),null===L(N)&&a===L(O)&&(U?h():U=!0,g(W,e-d))):(a.sortIndex=c,J(N,a),T||S||(T=!0,f(X)));return a};exports.unstable_cancelCallback=function(a){a.callback=null};
exports.unstable_wrapCallback=function(a){var b=R;return function(){var c=R;R=b;try{return a.apply(this,arguments)}finally{R=c}}};exports.unstable_getCurrentPriorityLevel=function(){return R};exports.unstable_shouldYield=function(){var a=exports.unstable_now();V(a);var b=L(N);return b!==Q&&null!==Q&&null!==b&&null!==b.callback&&b.startTime<=a&&b.expirationTime<Q.expirationTime||k()};exports.unstable_requestPaint=Z;exports.unstable_continueExecution=function(){T||S||(T=!0,f(X))};
exports.unstable_pauseExecution=function(){};exports.unstable_getFirstCallbackNode=function(){return L(N)};exports.unstable_Profiling=null;


/***/ }),

/***/ 1069:
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer, global, process) {var capability = __webpack_require__(548)
var inherits = __webpack_require__(18)
var response = __webpack_require__(549)
var stream = __webpack_require__(174)
var toArrayBuffer = __webpack_require__(1070)

var IncomingMessage = response.IncomingMessage
var rStates = response.readyStates

function decideMode (preferBinary, useFetch) {
	if (capability.fetch && useFetch) {
		return 'fetch'
	} else if (capability.mozchunkedarraybuffer) {
		return 'moz-chunked-arraybuffer'
	} else if (capability.msstream) {
		return 'ms-stream'
	} else if (capability.arraybuffer && preferBinary) {
		return 'arraybuffer'
	} else if (capability.vbArray && preferBinary) {
		return 'text:vbarray'
	} else {
		return 'text'
	}
}

var ClientRequest = module.exports = function (opts) {
	var self = this
	stream.Writable.call(self)

	self._opts = opts
	self._body = []
	self._headers = {}
	if (opts.auth)
		self.setHeader('Authorization', 'Basic ' + new Buffer(opts.auth).toString('base64'))
	Object.keys(opts.headers).forEach(function (name) {
		self.setHeader(name, opts.headers[name])
	})

	var preferBinary
	var useFetch = true
	if (opts.mode === 'disable-fetch' || ('requestTimeout' in opts && !capability.abortController)) {
		// If the use of XHR should be preferred. Not typically needed.
		useFetch = false
		preferBinary = true
	} else if (opts.mode === 'prefer-streaming') {
		// If streaming is a high priority but binary compatibility and
		// the accuracy of the 'content-type' header aren't
		preferBinary = false
	} else if (opts.mode === 'allow-wrong-content-type') {
		// If streaming is more important than preserving the 'content-type' header
		preferBinary = !capability.overrideMimeType
	} else if (!opts.mode || opts.mode === 'default' || opts.mode === 'prefer-fast') {
		// Use binary if text streaming may corrupt data or the content-type header, or for speed
		preferBinary = true
	} else {
		throw new Error('Invalid value for opts.mode')
	}
	self._mode = decideMode(preferBinary, useFetch)
	self._fetchTimer = null

	self.on('finish', function () {
		self._onFinish()
	})
}

inherits(ClientRequest, stream.Writable)

ClientRequest.prototype.setHeader = function (name, value) {
	var self = this
	var lowerName = name.toLowerCase()
	// This check is not necessary, but it prevents warnings from browsers about setting unsafe
	// headers. To be honest I'm not entirely sure hiding these warnings is a good thing, but
	// http-browserify did it, so I will too.
	if (unsafeHeaders.indexOf(lowerName) !== -1)
		return

	self._headers[lowerName] = {
		name: name,
		value: value
	}
}

ClientRequest.prototype.getHeader = function (name) {
	var header = this._headers[name.toLowerCase()]
	if (header)
		return header.value
	return null
}

ClientRequest.prototype.removeHeader = function (name) {
	var self = this
	delete self._headers[name.toLowerCase()]
}

ClientRequest.prototype._onFinish = function () {
	var self = this

	if (self._destroyed)
		return
	var opts = self._opts

	var headersObj = self._headers
	var body = null
	if (opts.method !== 'GET' && opts.method !== 'HEAD') {
		if (capability.arraybuffer) {
			body = toArrayBuffer(Buffer.concat(self._body))
		} else if (capability.blobConstructor) {
			body = new global.Blob(self._body.map(function (buffer) {
				return toArrayBuffer(buffer)
			}), {
				type: (headersObj['content-type'] || {}).value || ''
			})
		} else {
			// get utf8 string
			body = Buffer.concat(self._body).toString()
		}
	}

	// create flattened list of headers
	var headersList = []
	Object.keys(headersObj).forEach(function (keyName) {
		var name = headersObj[keyName].name
		var value = headersObj[keyName].value
		if (Array.isArray(value)) {
			value.forEach(function (v) {
				headersList.push([name, v])
			})
		} else {
			headersList.push([name, value])
		}
	})

	if (self._mode === 'fetch') {
		var signal = null
		var fetchTimer = null
		if (capability.abortController) {
			var controller = new AbortController()
			signal = controller.signal
			self._fetchAbortController = controller

			if ('requestTimeout' in opts && opts.requestTimeout !== 0) {
				self._fetchTimer = global.setTimeout(function () {
					self.emit('requestTimeout')
					if (self._fetchAbortController)
						self._fetchAbortController.abort()
				}, opts.requestTimeout)
			}
		}

		global.fetch(self._opts.url, {
			method: self._opts.method,
			headers: headersList,
			body: body || undefined,
			mode: 'cors',
			credentials: opts.withCredentials ? 'include' : 'same-origin',
			signal: signal
		}).then(function (response) {
			self._fetchResponse = response
			self._connect()
		}, function (reason) {
			global.clearTimeout(self._fetchTimer)
			if (!self._destroyed)
				self.emit('error', reason)
		})
	} else {
		var xhr = self._xhr = new global.XMLHttpRequest()
		try {
			xhr.open(self._opts.method, self._opts.url, true)
		} catch (err) {
			process.nextTick(function () {
				self.emit('error', err)
			})
			return
		}

		// Can't set responseType on really old browsers
		if ('responseType' in xhr)
			xhr.responseType = self._mode.split(':')[0]

		if ('withCredentials' in xhr)
			xhr.withCredentials = !!opts.withCredentials

		if (self._mode === 'text' && 'overrideMimeType' in xhr)
			xhr.overrideMimeType('text/plain; charset=x-user-defined')

		if ('requestTimeout' in opts) {
			xhr.timeout = opts.requestTimeout
			xhr.ontimeout = function () {
				self.emit('requestTimeout')
			}
		}

		headersList.forEach(function (header) {
			xhr.setRequestHeader(header[0], header[1])
		})

		self._response = null
		xhr.onreadystatechange = function () {
			switch (xhr.readyState) {
				case rStates.LOADING:
				case rStates.DONE:
					self._onXHRProgress()
					break
			}
		}
		// Necessary for streaming in Firefox, since xhr.response is ONLY defined
		// in onprogress, not in onreadystatechange with xhr.readyState = 3
		if (self._mode === 'moz-chunked-arraybuffer') {
			xhr.onprogress = function () {
				self._onXHRProgress()
			}
		}

		xhr.onerror = function () {
			if (self._destroyed)
				return
			self.emit('error', new Error('XHR error'))
		}

		try {
			xhr.send(body)
		} catch (err) {
			process.nextTick(function () {
				self.emit('error', err)
			})
			return
		}
	}
}

/**
 * Checks if xhr.status is readable and non-zero, indicating no error.
 * Even though the spec says it should be available in readyState 3,
 * accessing it throws an exception in IE8
 */
function statusValid (xhr) {
	try {
		var status = xhr.status
		return (status !== null && status !== 0)
	} catch (e) {
		return false
	}
}

ClientRequest.prototype._onXHRProgress = function () {
	var self = this

	if (!statusValid(self._xhr) || self._destroyed)
		return

	if (!self._response)
		self._connect()

	self._response._onXHRProgress()
}

ClientRequest.prototype._connect = function () {
	var self = this

	if (self._destroyed)
		return

	self._response = new IncomingMessage(self._xhr, self._fetchResponse, self._mode, self._fetchTimer)
	self._response.on('error', function(err) {
		self.emit('error', err)
	})

	self.emit('response', self._response)
}

ClientRequest.prototype._write = function (chunk, encoding, cb) {
	var self = this

	self._body.push(chunk)
	cb()
}

ClientRequest.prototype.abort = ClientRequest.prototype.destroy = function () {
	var self = this
	self._destroyed = true
	global.clearTimeout(self._fetchTimer)
	if (self._response)
		self._response._destroyed = true
	if (self._xhr)
		self._xhr.abort()
	else if (self._fetchAbortController)
		self._fetchAbortController.abort()
}

ClientRequest.prototype.end = function (data, encoding, cb) {
	var self = this
	if (typeof data === 'function') {
		cb = data
		data = undefined
	}

	stream.Writable.prototype.end.call(self, data, encoding, cb)
}

ClientRequest.prototype.flushHeaders = function () {}
ClientRequest.prototype.setTimeout = function () {}
ClientRequest.prototype.setNoDelay = function () {}
ClientRequest.prototype.setSocketKeepAlive = function () {}

// Taken from http://www.w3.org/TR/XMLHttpRequest/#the-setrequestheader%28%29-method
var unsafeHeaders = [
	'accept-charset',
	'accept-encoding',
	'access-control-request-headers',
	'access-control-request-method',
	'connection',
	'content-length',
	'cookie',
	'cookie2',
	'date',
	'dnt',
	'expect',
	'host',
	'keep-alive',
	'origin',
	'referer',
	'te',
	'trailer',
	'transfer-encoding',
	'upgrade',
	'via'
]

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(4).Buffer, __webpack_require__(11), __webpack_require__(28)))

/***/ }),

/***/ 1070:
/***/ (function(module, exports, __webpack_require__) {

var Buffer = __webpack_require__(4).Buffer

module.exports = function (buf) {
	// If the buffer is backed by a Uint8Array, a faster version will work
	if (buf instanceof Uint8Array) {
		// If the buffer isn't a subarray, return the underlying ArrayBuffer
		if (buf.byteOffset === 0 && buf.byteLength === buf.buffer.byteLength) {
			return buf.buffer
		} else if (typeof buf.buffer.slice === 'function') {
			// Otherwise we need to get a proper copy
			return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength)
		}
	}

	if (Buffer.isBuffer(buf)) {
		// This is the slow version that will work with any Buffer
		// implementation (even in old browsers)
		var arrayCopy = new Uint8Array(buf.length)
		var len = buf.length
		for (var i = 0; i < len; i++) {
			arrayCopy[i] = buf[i]
		}
		return arrayCopy.buffer
	} else {
		throw new Error('Argument must be a Buffer')
	}
}


/***/ }),

/***/ 1090:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const logs = __importStar(__webpack_require__(348));
exports.logs = logs;
const types = __importStar(__webpack_require__(183));
exports.types = types;
var address_1 = __webpack_require__(1096);
exports.pubkeyToAddress = address_1.pubkeyToAddress;
var decoding_1 = __webpack_require__(1120);
exports.unmarshalTx = decoding_1.unmarshalTx;
var encoding_1 = __webpack_require__(350);
exports.makeSignBytes = encoding_1.makeSignBytes;
exports.marshalTx = encoding_1.marshalTx;
var restclient_1 = __webpack_require__(351);
exports.BroadcastMode = restclient_1.BroadcastMode;
exports.RestClient = restclient_1.RestClient;
var cosmwasmclient_1 = __webpack_require__(575);
exports.CosmWasmClient = cosmwasmclient_1.CosmWasmClient;
var pen_1 = __webpack_require__(1160);
exports.makeCosmoshubPath = pen_1.makeSecretNetworkPath;
exports.makeSecretNetworkPath = pen_1.makeSecretNetworkPath;
exports.Secp256k1Pen = pen_1.Secp256k1Pen;
var pubkey_1 = __webpack_require__(576);
exports.decodeBech32Pubkey = pubkey_1.decodeBech32Pubkey;
exports.encodeBech32Pubkey = pubkey_1.encodeBech32Pubkey;
exports.encodeSecp256k1Pubkey = pubkey_1.encodeSecp256k1Pubkey;
var sequence_1 = __webpack_require__(1162);
exports.findSequenceForSignedTx = sequence_1.findSequenceForSignedTx;
var signature_1 = __webpack_require__(357);
exports.encodeSecp256k1Signature = signature_1.encodeSecp256k1Signature;
exports.decodeSignature = signature_1.decodeSignature;
var signingcosmwasmclient_1 = __webpack_require__(1163);
exports.SigningCosmWasmClient = signingcosmwasmclient_1.SigningCosmWasmClient;
const enigmautils_1 = __importDefault(__webpack_require__(565));
exports.EnigmaUtils = enigmautils_1.default;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 1096:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const crypto_1 = __webpack_require__(184);
const encoding_1 = __webpack_require__(86);
const types_1 = __webpack_require__(183);
const { fromBase64 } = encoding_1.Encoding;
function rawSecp256k1PubkeyToAddress(pubkeyRaw, prefix) {
    if (pubkeyRaw.length !== 33) {
        throw new Error(`Invalid Secp256k1 pubkey length (compressed): ${pubkeyRaw.length}`);
    }
    const hash1 = new crypto_1.Sha256(pubkeyRaw).digest();
    const hash2 = new crypto_1.Ripemd160(hash1).digest();
    return encoding_1.Bech32.encode(prefix, hash2);
}
exports.rawSecp256k1PubkeyToAddress = rawSecp256k1PubkeyToAddress;
// See https://github.com/tendermint/tendermint/blob/f2ada0a604b4c0763bda2f64fac53d506d3beca7/docs/spec/blockchain/encoding.md#public-key-cryptography
// This assumes we already have a cosmos-compressed pubkey
function pubkeyToAddress(pubkey, prefix) {
    const pubkeyBytes = fromBase64(pubkey.value);
    switch (pubkey.type) {
        case types_1.pubkeyType.secp256k1: {
            return rawSecp256k1PubkeyToAddress(pubkeyBytes, prefix);
        }
        case types_1.pubkeyType.ed25519: {
            if (pubkeyBytes.length !== 32) {
                throw new Error(`Invalid Ed25519 pubkey length: ${pubkeyBytes.length}`);
            }
            const hash = new crypto_1.Sha256(pubkeyBytes).digest();
            return encoding_1.Bech32.encode(prefix, hash.slice(0, 20));
        }
        case types_1.pubkeyType.sr25519: {
            if (pubkeyBytes.length !== 32) {
                throw new Error(`Invalid Sr25519 pubkey length: ${pubkeyBytes.length}`);
            }
            const hash = new crypto_1.Sha256(pubkeyBytes).digest();
            return encoding_1.Bech32.encode(prefix, hash.slice(0, 20));
        }
        default:
            throw new Error("Unrecognized public key algorithm");
    }
}
exports.pubkeyToAddress = pubkeyToAddress;
//# sourceMappingURL=address.js.map

/***/ }),

/***/ 1113:
/***/ (function(module, exports, __webpack_require__) {

(function (root) {
   "use strict";

/***** unorm.js *****/

/*
 * UnicodeNormalizer 1.0.0
 * Copyright (c) 2008 Matsuza
 * Dual licensed under the MIT (MIT-LICENSE.txt) and GPL (GPL-LICENSE.txt) licenses.
 * $Date: 2008-06-05 16:44:17 +0200 (Thu, 05 Jun 2008) $
 * $Rev: 13309 $
 */

   var DEFAULT_FEATURE = [null, 0, {}];
   var CACHE_THRESHOLD = 10;
   var SBase = 0xAC00, LBase = 0x1100, VBase = 0x1161, TBase = 0x11A7, LCount = 19, VCount = 21, TCount = 28;
   var NCount = VCount * TCount; // 588
   var SCount = LCount * NCount; // 11172

   var UChar = function(cp, feature){
      this.codepoint = cp;
      this.feature = feature;
   };

   // Strategies
   var cache = {};
   var cacheCounter = [];
   for (var i = 0; i <= 0xFF; ++i){
      cacheCounter[i] = 0;
   }

   function fromCache(next, cp, needFeature){
      var ret = cache[cp];
      if(!ret){
         ret = next(cp, needFeature);
         if(!!ret.feature && ++cacheCounter[(cp >> 8) & 0xFF] > CACHE_THRESHOLD){
            cache[cp] = ret;
         }
      }
      return ret;
   }

   function fromData(next, cp, needFeature){
      var hash = cp & 0xFF00;
      var dunit = UChar.udata[hash] || {};
      var f = dunit[cp];
      return f ? new UChar(cp, f) : new UChar(cp, DEFAULT_FEATURE);
   }
   function fromCpOnly(next, cp, needFeature){
      return !!needFeature ? next(cp, needFeature) : new UChar(cp, null);
   }
   function fromRuleBasedJamo(next, cp, needFeature){
      var j;
      if(cp < LBase || (LBase + LCount <= cp && cp < SBase) || (SBase + SCount < cp)){
         return next(cp, needFeature);
      }
      if(LBase <= cp && cp < LBase + LCount){
         var c = {};
         var base = (cp - LBase) * VCount;
         for (j = 0; j < VCount; ++j){
            c[VBase + j] = SBase + TCount * (j + base);
         }
         return new UChar(cp, [,,c]);
      }

      var SIndex = cp - SBase;
      var TIndex = SIndex % TCount;
      var feature = [];
      if(TIndex !== 0){
         feature[0] = [SBase + SIndex - TIndex, TBase + TIndex];
      } else {
         feature[0] = [LBase + Math.floor(SIndex / NCount), VBase + Math.floor((SIndex % NCount) / TCount)];
         feature[2] = {};
         for (j = 1; j < TCount; ++j){
            feature[2][TBase + j] = cp + j;
         }
      }
      return new UChar(cp, feature);
   }
   function fromCpFilter(next, cp, needFeature){
      return cp < 60 || 13311 < cp && cp < 42607 ? new UChar(cp, DEFAULT_FEATURE) : next(cp, needFeature);
   }

   var strategies = [fromCpFilter, fromCache, fromCpOnly, fromRuleBasedJamo, fromData];

   UChar.fromCharCode = strategies.reduceRight(function (next, strategy) {
      return function (cp, needFeature) {
         return strategy(next, cp, needFeature);
      };
   }, null);

   UChar.isHighSurrogate = function(cp){
      return cp >= 0xD800 && cp <= 0xDBFF;
   };
   UChar.isLowSurrogate = function(cp){
      return cp >= 0xDC00 && cp <= 0xDFFF;
   };

   UChar.prototype.prepFeature = function(){
      if(!this.feature){
         this.feature = UChar.fromCharCode(this.codepoint, true).feature;
      }
   };

   UChar.prototype.toString = function(){
      if(this.codepoint < 0x10000){
         return String.fromCharCode(this.codepoint);
      } else {
         var x = this.codepoint - 0x10000;
         return String.fromCharCode(Math.floor(x / 0x400) + 0xD800, x % 0x400 + 0xDC00);
      }
   };

   UChar.prototype.getDecomp = function(){
      this.prepFeature();
      return this.feature[0] || null;
   };

   UChar.prototype.isCompatibility = function(){
      this.prepFeature();
      return !!this.feature[1] && (this.feature[1] & (1 << 8));
   };
   UChar.prototype.isExclude = function(){
      this.prepFeature();
      return !!this.feature[1] && (this.feature[1] & (1 << 9));
   };
   UChar.prototype.getCanonicalClass = function(){
      this.prepFeature();
      return !!this.feature[1] ? (this.feature[1] & 0xff) : 0;
   };
   UChar.prototype.getComposite = function(following){
      this.prepFeature();
      if(!this.feature[2]){
         return null;
      }
      var cp = this.feature[2][following.codepoint];
      return cp ? UChar.fromCharCode(cp) : null;
   };

   var UCharIterator = function(str){
      this.str = str;
      this.cursor = 0;
   };
   UCharIterator.prototype.next = function(){
      if(!!this.str && this.cursor < this.str.length){
         var cp = this.str.charCodeAt(this.cursor++);
         var d;
         if(UChar.isHighSurrogate(cp) && this.cursor < this.str.length && UChar.isLowSurrogate((d = this.str.charCodeAt(this.cursor)))){
            cp = (cp - 0xD800) * 0x400 + (d -0xDC00) + 0x10000;
            ++this.cursor;
         }
         return UChar.fromCharCode(cp);
      } else {
         this.str = null;
         return null;
      }
   };

   var RecursDecompIterator = function(it, cano){
      this.it = it;
      this.canonical = cano;
      this.resBuf = [];
   };

   RecursDecompIterator.prototype.next = function(){
      function recursiveDecomp(cano, uchar){
         var decomp = uchar.getDecomp();
         if(!!decomp && !(cano && uchar.isCompatibility())){
            var ret = [];
            for(var i = 0; i < decomp.length; ++i){
               var a = recursiveDecomp(cano, UChar.fromCharCode(decomp[i]));
                ret = ret.concat(a);
            }
            return ret;
         } else {
            return [uchar];
         }
      }
      if(this.resBuf.length === 0){
         var uchar = this.it.next();
         if(!uchar){
            return null;
         }
         this.resBuf = recursiveDecomp(this.canonical, uchar);
      }
      return this.resBuf.shift();
   };

   var DecompIterator = function(it){
      this.it = it;
      this.resBuf = [];
   };

   DecompIterator.prototype.next = function(){
      var cc;
      if(this.resBuf.length === 0){
         do{
            var uchar = this.it.next();
            if(!uchar){
               break;
            }
            cc = uchar.getCanonicalClass();
            var inspt = this.resBuf.length;
            if(cc !== 0){
               for(; inspt > 0; --inspt){
                  var uchar2 = this.resBuf[inspt - 1];
                  var cc2 = uchar2.getCanonicalClass();
                  if(cc2 <= cc){
                     break;
                  }
               }
            }
            this.resBuf.splice(inspt, 0, uchar);
         } while(cc !== 0);
      }
      return this.resBuf.shift();
   };

   var CompIterator = function(it){
      this.it = it;
      this.procBuf = [];
      this.resBuf = [];
      this.lastClass = null;
   };

   CompIterator.prototype.next = function(){
      while(this.resBuf.length === 0){
         var uchar = this.it.next();
         if(!uchar){
            this.resBuf = this.procBuf;
            this.procBuf = [];
            break;
         }
         if(this.procBuf.length === 0){
            this.lastClass = uchar.getCanonicalClass();
            this.procBuf.push(uchar);
         } else {
            var starter = this.procBuf[0];
            var composite = starter.getComposite(uchar);
            var cc = uchar.getCanonicalClass();
            if(!!composite && (this.lastClass < cc || this.lastClass === 0)){
               this.procBuf[0] = composite;
            } else {
               if(cc === 0){
                  this.resBuf = this.procBuf;
                  this.procBuf = [];
               }
               this.lastClass = cc;
               this.procBuf.push(uchar);
            }
         }
      }
      return this.resBuf.shift();
   };

   var createIterator = function(mode, str){
      switch(mode){
         case "NFD":
            return new DecompIterator(new RecursDecompIterator(new UCharIterator(str), true));
         case "NFKD":
            return new DecompIterator(new RecursDecompIterator(new UCharIterator(str), false));
         case "NFC":
            return new CompIterator(new DecompIterator(new RecursDecompIterator(new UCharIterator(str), true)));
         case "NFKC":
            return new CompIterator(new DecompIterator(new RecursDecompIterator(new UCharIterator(str), false)));
      }
      throw mode + " is invalid";
   };
   var normalize = function(mode, str){
      var it = createIterator(mode, str);
      var ret = "";
      var uchar;
      while(!!(uchar = it.next())){
         ret += uchar.toString();
      }
      return ret;
   };

   /* API functions */
   function nfd(str){
      return normalize("NFD", str);
   }

   function nfkd(str){
      return normalize("NFKD", str);
   }

   function nfc(str){
      return normalize("NFC", str);
   }

   function nfkc(str){
      return normalize("NFKC", str);
   }

/* Unicode data */
UChar.udata={
0:{60:[,,{824:8814}],61:[,,{824:8800}],62:[,,{824:8815}],65:[,,{768:192,769:193,770:194,771:195,772:256,774:258,775:550,776:196,777:7842,778:197,780:461,783:512,785:514,803:7840,805:7680,808:260}],66:[,,{775:7682,803:7684,817:7686}],67:[,,{769:262,770:264,775:266,780:268,807:199}],68:[,,{775:7690,780:270,803:7692,807:7696,813:7698,817:7694}],69:[,,{768:200,769:201,770:202,771:7868,772:274,774:276,775:278,776:203,777:7866,780:282,783:516,785:518,803:7864,807:552,808:280,813:7704,816:7706}],70:[,,{775:7710}],71:[,,{769:500,770:284,772:7712,774:286,775:288,780:486,807:290}],72:[,,{770:292,775:7714,776:7718,780:542,803:7716,807:7720,814:7722}],73:[,,{768:204,769:205,770:206,771:296,772:298,774:300,775:304,776:207,777:7880,780:463,783:520,785:522,803:7882,808:302,816:7724}],74:[,,{770:308}],75:[,,{769:7728,780:488,803:7730,807:310,817:7732}],76:[,,{769:313,780:317,803:7734,807:315,813:7740,817:7738}],77:[,,{769:7742,775:7744,803:7746}],78:[,,{768:504,769:323,771:209,775:7748,780:327,803:7750,807:325,813:7754,817:7752}],79:[,,{768:210,769:211,770:212,771:213,772:332,774:334,775:558,776:214,777:7886,779:336,780:465,783:524,785:526,795:416,803:7884,808:490}],80:[,,{769:7764,775:7766}],82:[,,{769:340,775:7768,780:344,783:528,785:530,803:7770,807:342,817:7774}],83:[,,{769:346,770:348,775:7776,780:352,803:7778,806:536,807:350}],84:[,,{775:7786,780:356,803:7788,806:538,807:354,813:7792,817:7790}],85:[,,{768:217,769:218,770:219,771:360,772:362,774:364,776:220,777:7910,778:366,779:368,780:467,783:532,785:534,795:431,803:7908,804:7794,808:370,813:7798,816:7796}],86:[,,{771:7804,803:7806}],87:[,,{768:7808,769:7810,770:372,775:7814,776:7812,803:7816}],88:[,,{775:7818,776:7820}],89:[,,{768:7922,769:221,770:374,771:7928,772:562,775:7822,776:376,777:7926,803:7924}],90:[,,{769:377,770:7824,775:379,780:381,803:7826,817:7828}],97:[,,{768:224,769:225,770:226,771:227,772:257,774:259,775:551,776:228,777:7843,778:229,780:462,783:513,785:515,803:7841,805:7681,808:261}],98:[,,{775:7683,803:7685,817:7687}],99:[,,{769:263,770:265,775:267,780:269,807:231}],100:[,,{775:7691,780:271,803:7693,807:7697,813:7699,817:7695}],101:[,,{768:232,769:233,770:234,771:7869,772:275,774:277,775:279,776:235,777:7867,780:283,783:517,785:519,803:7865,807:553,808:281,813:7705,816:7707}],102:[,,{775:7711}],103:[,,{769:501,770:285,772:7713,774:287,775:289,780:487,807:291}],104:[,,{770:293,775:7715,776:7719,780:543,803:7717,807:7721,814:7723,817:7830}],105:[,,{768:236,769:237,770:238,771:297,772:299,774:301,776:239,777:7881,780:464,783:521,785:523,803:7883,808:303,816:7725}],106:[,,{770:309,780:496}],107:[,,{769:7729,780:489,803:7731,807:311,817:7733}],108:[,,{769:314,780:318,803:7735,807:316,813:7741,817:7739}],109:[,,{769:7743,775:7745,803:7747}],110:[,,{768:505,769:324,771:241,775:7749,780:328,803:7751,807:326,813:7755,817:7753}],111:[,,{768:242,769:243,770:244,771:245,772:333,774:335,775:559,776:246,777:7887,779:337,780:466,783:525,785:527,795:417,803:7885,808:491}],112:[,,{769:7765,775:7767}],114:[,,{769:341,775:7769,780:345,783:529,785:531,803:7771,807:343,817:7775}],115:[,,{769:347,770:349,775:7777,780:353,803:7779,806:537,807:351}],116:[,,{775:7787,776:7831,780:357,803:7789,806:539,807:355,813:7793,817:7791}],117:[,,{768:249,769:250,770:251,771:361,772:363,774:365,776:252,777:7911,778:367,779:369,780:468,783:533,785:535,795:432,803:7909,804:7795,808:371,813:7799,816:7797}],118:[,,{771:7805,803:7807}],119:[,,{768:7809,769:7811,770:373,775:7815,776:7813,778:7832,803:7817}],120:[,,{775:7819,776:7821}],121:[,,{768:7923,769:253,770:375,771:7929,772:563,775:7823,776:255,777:7927,778:7833,803:7925}],122:[,,{769:378,770:7825,775:380,780:382,803:7827,817:7829}],160:[[32],256],168:[[32,776],256,{768:8173,769:901,834:8129}],170:[[97],256],175:[[32,772],256],178:[[50],256],179:[[51],256],180:[[32,769],256],181:[[956],256],184:[[32,807],256],185:[[49],256],186:[[111],256],188:[[49,8260,52],256],189:[[49,8260,50],256],190:[[51,8260,52],256],192:[[65,768]],193:[[65,769]],194:[[65,770],,{768:7846,769:7844,771:7850,777:7848}],195:[[65,771]],196:[[65,776],,{772:478}],197:[[65,778],,{769:506}],198:[,,{769:508,772:482}],199:[[67,807],,{769:7688}],200:[[69,768]],201:[[69,769]],202:[[69,770],,{768:7872,769:7870,771:7876,777:7874}],203:[[69,776]],204:[[73,768]],205:[[73,769]],206:[[73,770]],207:[[73,776],,{769:7726}],209:[[78,771]],210:[[79,768]],211:[[79,769]],212:[[79,770],,{768:7890,769:7888,771:7894,777:7892}],213:[[79,771],,{769:7756,772:556,776:7758}],214:[[79,776],,{772:554}],216:[,,{769:510}],217:[[85,768]],218:[[85,769]],219:[[85,770]],220:[[85,776],,{768:475,769:471,772:469,780:473}],221:[[89,769]],224:[[97,768]],225:[[97,769]],226:[[97,770],,{768:7847,769:7845,771:7851,777:7849}],227:[[97,771]],228:[[97,776],,{772:479}],229:[[97,778],,{769:507}],230:[,,{769:509,772:483}],231:[[99,807],,{769:7689}],232:[[101,768]],233:[[101,769]],234:[[101,770],,{768:7873,769:7871,771:7877,777:7875}],235:[[101,776]],236:[[105,768]],237:[[105,769]],238:[[105,770]],239:[[105,776],,{769:7727}],241:[[110,771]],242:[[111,768]],243:[[111,769]],244:[[111,770],,{768:7891,769:7889,771:7895,777:7893}],245:[[111,771],,{769:7757,772:557,776:7759}],246:[[111,776],,{772:555}],248:[,,{769:511}],249:[[117,768]],250:[[117,769]],251:[[117,770]],252:[[117,776],,{768:476,769:472,772:470,780:474}],253:[[121,769]],255:[[121,776]]},
256:{256:[[65,772]],257:[[97,772]],258:[[65,774],,{768:7856,769:7854,771:7860,777:7858}],259:[[97,774],,{768:7857,769:7855,771:7861,777:7859}],260:[[65,808]],261:[[97,808]],262:[[67,769]],263:[[99,769]],264:[[67,770]],265:[[99,770]],266:[[67,775]],267:[[99,775]],268:[[67,780]],269:[[99,780]],270:[[68,780]],271:[[100,780]],274:[[69,772],,{768:7700,769:7702}],275:[[101,772],,{768:7701,769:7703}],276:[[69,774]],277:[[101,774]],278:[[69,775]],279:[[101,775]],280:[[69,808]],281:[[101,808]],282:[[69,780]],283:[[101,780]],284:[[71,770]],285:[[103,770]],286:[[71,774]],287:[[103,774]],288:[[71,775]],289:[[103,775]],290:[[71,807]],291:[[103,807]],292:[[72,770]],293:[[104,770]],296:[[73,771]],297:[[105,771]],298:[[73,772]],299:[[105,772]],300:[[73,774]],301:[[105,774]],302:[[73,808]],303:[[105,808]],304:[[73,775]],306:[[73,74],256],307:[[105,106],256],308:[[74,770]],309:[[106,770]],310:[[75,807]],311:[[107,807]],313:[[76,769]],314:[[108,769]],315:[[76,807]],316:[[108,807]],317:[[76,780]],318:[[108,780]],319:[[76,183],256],320:[[108,183],256],323:[[78,769]],324:[[110,769]],325:[[78,807]],326:[[110,807]],327:[[78,780]],328:[[110,780]],329:[[700,110],256],332:[[79,772],,{768:7760,769:7762}],333:[[111,772],,{768:7761,769:7763}],334:[[79,774]],335:[[111,774]],336:[[79,779]],337:[[111,779]],340:[[82,769]],341:[[114,769]],342:[[82,807]],343:[[114,807]],344:[[82,780]],345:[[114,780]],346:[[83,769],,{775:7780}],347:[[115,769],,{775:7781}],348:[[83,770]],349:[[115,770]],350:[[83,807]],351:[[115,807]],352:[[83,780],,{775:7782}],353:[[115,780],,{775:7783}],354:[[84,807]],355:[[116,807]],356:[[84,780]],357:[[116,780]],360:[[85,771],,{769:7800}],361:[[117,771],,{769:7801}],362:[[85,772],,{776:7802}],363:[[117,772],,{776:7803}],364:[[85,774]],365:[[117,774]],366:[[85,778]],367:[[117,778]],368:[[85,779]],369:[[117,779]],370:[[85,808]],371:[[117,808]],372:[[87,770]],373:[[119,770]],374:[[89,770]],375:[[121,770]],376:[[89,776]],377:[[90,769]],378:[[122,769]],379:[[90,775]],380:[[122,775]],381:[[90,780]],382:[[122,780]],383:[[115],256,{775:7835}],416:[[79,795],,{768:7900,769:7898,771:7904,777:7902,803:7906}],417:[[111,795],,{768:7901,769:7899,771:7905,777:7903,803:7907}],431:[[85,795],,{768:7914,769:7912,771:7918,777:7916,803:7920}],432:[[117,795],,{768:7915,769:7913,771:7919,777:7917,803:7921}],439:[,,{780:494}],452:[[68,381],256],453:[[68,382],256],454:[[100,382],256],455:[[76,74],256],456:[[76,106],256],457:[[108,106],256],458:[[78,74],256],459:[[78,106],256],460:[[110,106],256],461:[[65,780]],462:[[97,780]],463:[[73,780]],464:[[105,780]],465:[[79,780]],466:[[111,780]],467:[[85,780]],468:[[117,780]],469:[[220,772]],470:[[252,772]],471:[[220,769]],472:[[252,769]],473:[[220,780]],474:[[252,780]],475:[[220,768]],476:[[252,768]],478:[[196,772]],479:[[228,772]],480:[[550,772]],481:[[551,772]],482:[[198,772]],483:[[230,772]],486:[[71,780]],487:[[103,780]],488:[[75,780]],489:[[107,780]],490:[[79,808],,{772:492}],491:[[111,808],,{772:493}],492:[[490,772]],493:[[491,772]],494:[[439,780]],495:[[658,780]],496:[[106,780]],497:[[68,90],256],498:[[68,122],256],499:[[100,122],256],500:[[71,769]],501:[[103,769]],504:[[78,768]],505:[[110,768]],506:[[197,769]],507:[[229,769]],508:[[198,769]],509:[[230,769]],510:[[216,769]],511:[[248,769]],66045:[,220]},
512:{512:[[65,783]],513:[[97,783]],514:[[65,785]],515:[[97,785]],516:[[69,783]],517:[[101,783]],518:[[69,785]],519:[[101,785]],520:[[73,783]],521:[[105,783]],522:[[73,785]],523:[[105,785]],524:[[79,783]],525:[[111,783]],526:[[79,785]],527:[[111,785]],528:[[82,783]],529:[[114,783]],530:[[82,785]],531:[[114,785]],532:[[85,783]],533:[[117,783]],534:[[85,785]],535:[[117,785]],536:[[83,806]],537:[[115,806]],538:[[84,806]],539:[[116,806]],542:[[72,780]],543:[[104,780]],550:[[65,775],,{772:480}],551:[[97,775],,{772:481}],552:[[69,807],,{774:7708}],553:[[101,807],,{774:7709}],554:[[214,772]],555:[[246,772]],556:[[213,772]],557:[[245,772]],558:[[79,775],,{772:560}],559:[[111,775],,{772:561}],560:[[558,772]],561:[[559,772]],562:[[89,772]],563:[[121,772]],658:[,,{780:495}],688:[[104],256],689:[[614],256],690:[[106],256],691:[[114],256],692:[[633],256],693:[[635],256],694:[[641],256],695:[[119],256],696:[[121],256],728:[[32,774],256],729:[[32,775],256],730:[[32,778],256],731:[[32,808],256],732:[[32,771],256],733:[[32,779],256],736:[[611],256],737:[[108],256],738:[[115],256],739:[[120],256],740:[[661],256],66272:[,220]},
768:{768:[,230],769:[,230],770:[,230],771:[,230],772:[,230],773:[,230],774:[,230],775:[,230],776:[,230,{769:836}],777:[,230],778:[,230],779:[,230],780:[,230],781:[,230],782:[,230],783:[,230],784:[,230],785:[,230],786:[,230],787:[,230],788:[,230],789:[,232],790:[,220],791:[,220],792:[,220],793:[,220],794:[,232],795:[,216],796:[,220],797:[,220],798:[,220],799:[,220],800:[,220],801:[,202],802:[,202],803:[,220],804:[,220],805:[,220],806:[,220],807:[,202],808:[,202],809:[,220],810:[,220],811:[,220],812:[,220],813:[,220],814:[,220],815:[,220],816:[,220],817:[,220],818:[,220],819:[,220],820:[,1],821:[,1],822:[,1],823:[,1],824:[,1],825:[,220],826:[,220],827:[,220],828:[,220],829:[,230],830:[,230],831:[,230],832:[[768],230],833:[[769],230],834:[,230],835:[[787],230],836:[[776,769],230],837:[,240],838:[,230],839:[,220],840:[,220],841:[,220],842:[,230],843:[,230],844:[,230],845:[,220],846:[,220],848:[,230],849:[,230],850:[,230],851:[,220],852:[,220],853:[,220],854:[,220],855:[,230],856:[,232],857:[,220],858:[,220],859:[,230],860:[,233],861:[,234],862:[,234],863:[,233],864:[,234],865:[,234],866:[,233],867:[,230],868:[,230],869:[,230],870:[,230],871:[,230],872:[,230],873:[,230],874:[,230],875:[,230],876:[,230],877:[,230],878:[,230],879:[,230],884:[[697]],890:[[32,837],256],894:[[59]],900:[[32,769],256],901:[[168,769]],902:[[913,769]],903:[[183]],904:[[917,769]],905:[[919,769]],906:[[921,769]],908:[[927,769]],910:[[933,769]],911:[[937,769]],912:[[970,769]],913:[,,{768:8122,769:902,772:8121,774:8120,787:7944,788:7945,837:8124}],917:[,,{768:8136,769:904,787:7960,788:7961}],919:[,,{768:8138,769:905,787:7976,788:7977,837:8140}],921:[,,{768:8154,769:906,772:8153,774:8152,776:938,787:7992,788:7993}],927:[,,{768:8184,769:908,787:8008,788:8009}],929:[,,{788:8172}],933:[,,{768:8170,769:910,772:8169,774:8168,776:939,788:8025}],937:[,,{768:8186,769:911,787:8040,788:8041,837:8188}],938:[[921,776]],939:[[933,776]],940:[[945,769],,{837:8116}],941:[[949,769]],942:[[951,769],,{837:8132}],943:[[953,769]],944:[[971,769]],945:[,,{768:8048,769:940,772:8113,774:8112,787:7936,788:7937,834:8118,837:8115}],949:[,,{768:8050,769:941,787:7952,788:7953}],951:[,,{768:8052,769:942,787:7968,788:7969,834:8134,837:8131}],953:[,,{768:8054,769:943,772:8145,774:8144,776:970,787:7984,788:7985,834:8150}],959:[,,{768:8056,769:972,787:8000,788:8001}],961:[,,{787:8164,788:8165}],965:[,,{768:8058,769:973,772:8161,774:8160,776:971,787:8016,788:8017,834:8166}],969:[,,{768:8060,769:974,787:8032,788:8033,834:8182,837:8179}],970:[[953,776],,{768:8146,769:912,834:8151}],971:[[965,776],,{768:8162,769:944,834:8167}],972:[[959,769]],973:[[965,769]],974:[[969,769],,{837:8180}],976:[[946],256],977:[[952],256],978:[[933],256,{769:979,776:980}],979:[[978,769]],980:[[978,776]],981:[[966],256],982:[[960],256],1008:[[954],256],1009:[[961],256],1010:[[962],256],1012:[[920],256],1013:[[949],256],1017:[[931],256],66422:[,230],66423:[,230],66424:[,230],66425:[,230],66426:[,230]},
1024:{1024:[[1045,768]],1025:[[1045,776]],1027:[[1043,769]],1030:[,,{776:1031}],1031:[[1030,776]],1036:[[1050,769]],1037:[[1048,768]],1038:[[1059,774]],1040:[,,{774:1232,776:1234}],1043:[,,{769:1027}],1045:[,,{768:1024,774:1238,776:1025}],1046:[,,{774:1217,776:1244}],1047:[,,{776:1246}],1048:[,,{768:1037,772:1250,774:1049,776:1252}],1049:[[1048,774]],1050:[,,{769:1036}],1054:[,,{776:1254}],1059:[,,{772:1262,774:1038,776:1264,779:1266}],1063:[,,{776:1268}],1067:[,,{776:1272}],1069:[,,{776:1260}],1072:[,,{774:1233,776:1235}],1075:[,,{769:1107}],1077:[,,{768:1104,774:1239,776:1105}],1078:[,,{774:1218,776:1245}],1079:[,,{776:1247}],1080:[,,{768:1117,772:1251,774:1081,776:1253}],1081:[[1080,774]],1082:[,,{769:1116}],1086:[,,{776:1255}],1091:[,,{772:1263,774:1118,776:1265,779:1267}],1095:[,,{776:1269}],1099:[,,{776:1273}],1101:[,,{776:1261}],1104:[[1077,768]],1105:[[1077,776]],1107:[[1075,769]],1110:[,,{776:1111}],1111:[[1110,776]],1116:[[1082,769]],1117:[[1080,768]],1118:[[1091,774]],1140:[,,{783:1142}],1141:[,,{783:1143}],1142:[[1140,783]],1143:[[1141,783]],1155:[,230],1156:[,230],1157:[,230],1158:[,230],1159:[,230],1217:[[1046,774]],1218:[[1078,774]],1232:[[1040,774]],1233:[[1072,774]],1234:[[1040,776]],1235:[[1072,776]],1238:[[1045,774]],1239:[[1077,774]],1240:[,,{776:1242}],1241:[,,{776:1243}],1242:[[1240,776]],1243:[[1241,776]],1244:[[1046,776]],1245:[[1078,776]],1246:[[1047,776]],1247:[[1079,776]],1250:[[1048,772]],1251:[[1080,772]],1252:[[1048,776]],1253:[[1080,776]],1254:[[1054,776]],1255:[[1086,776]],1256:[,,{776:1258}],1257:[,,{776:1259}],1258:[[1256,776]],1259:[[1257,776]],1260:[[1069,776]],1261:[[1101,776]],1262:[[1059,772]],1263:[[1091,772]],1264:[[1059,776]],1265:[[1091,776]],1266:[[1059,779]],1267:[[1091,779]],1268:[[1063,776]],1269:[[1095,776]],1272:[[1067,776]],1273:[[1099,776]]},
1280:{1415:[[1381,1410],256],1425:[,220],1426:[,230],1427:[,230],1428:[,230],1429:[,230],1430:[,220],1431:[,230],1432:[,230],1433:[,230],1434:[,222],1435:[,220],1436:[,230],1437:[,230],1438:[,230],1439:[,230],1440:[,230],1441:[,230],1442:[,220],1443:[,220],1444:[,220],1445:[,220],1446:[,220],1447:[,220],1448:[,230],1449:[,230],1450:[,220],1451:[,230],1452:[,230],1453:[,222],1454:[,228],1455:[,230],1456:[,10],1457:[,11],1458:[,12],1459:[,13],1460:[,14],1461:[,15],1462:[,16],1463:[,17],1464:[,18],1465:[,19],1466:[,19],1467:[,20],1468:[,21],1469:[,22],1471:[,23],1473:[,24],1474:[,25],1476:[,230],1477:[,220],1479:[,18]},
1536:{1552:[,230],1553:[,230],1554:[,230],1555:[,230],1556:[,230],1557:[,230],1558:[,230],1559:[,230],1560:[,30],1561:[,31],1562:[,32],1570:[[1575,1619]],1571:[[1575,1620]],1572:[[1608,1620]],1573:[[1575,1621]],1574:[[1610,1620]],1575:[,,{1619:1570,1620:1571,1621:1573}],1608:[,,{1620:1572}],1610:[,,{1620:1574}],1611:[,27],1612:[,28],1613:[,29],1614:[,30],1615:[,31],1616:[,32],1617:[,33],1618:[,34],1619:[,230],1620:[,230],1621:[,220],1622:[,220],1623:[,230],1624:[,230],1625:[,230],1626:[,230],1627:[,230],1628:[,220],1629:[,230],1630:[,230],1631:[,220],1648:[,35],1653:[[1575,1652],256],1654:[[1608,1652],256],1655:[[1735,1652],256],1656:[[1610,1652],256],1728:[[1749,1620]],1729:[,,{1620:1730}],1730:[[1729,1620]],1746:[,,{1620:1747}],1747:[[1746,1620]],1749:[,,{1620:1728}],1750:[,230],1751:[,230],1752:[,230],1753:[,230],1754:[,230],1755:[,230],1756:[,230],1759:[,230],1760:[,230],1761:[,230],1762:[,230],1763:[,220],1764:[,230],1767:[,230],1768:[,230],1770:[,220],1771:[,230],1772:[,230],1773:[,220]},
1792:{1809:[,36],1840:[,230],1841:[,220],1842:[,230],1843:[,230],1844:[,220],1845:[,230],1846:[,230],1847:[,220],1848:[,220],1849:[,220],1850:[,230],1851:[,220],1852:[,220],1853:[,230],1854:[,220],1855:[,230],1856:[,230],1857:[,230],1858:[,220],1859:[,230],1860:[,220],1861:[,230],1862:[,220],1863:[,230],1864:[,220],1865:[,230],1866:[,230],2027:[,230],2028:[,230],2029:[,230],2030:[,230],2031:[,230],2032:[,230],2033:[,230],2034:[,220],2035:[,230]},
2048:{2070:[,230],2071:[,230],2072:[,230],2073:[,230],2075:[,230],2076:[,230],2077:[,230],2078:[,230],2079:[,230],2080:[,230],2081:[,230],2082:[,230],2083:[,230],2085:[,230],2086:[,230],2087:[,230],2089:[,230],2090:[,230],2091:[,230],2092:[,230],2093:[,230],2137:[,220],2138:[,220],2139:[,220],2276:[,230],2277:[,230],2278:[,220],2279:[,230],2280:[,230],2281:[,220],2282:[,230],2283:[,230],2284:[,230],2285:[,220],2286:[,220],2287:[,220],2288:[,27],2289:[,28],2290:[,29],2291:[,230],2292:[,230],2293:[,230],2294:[,220],2295:[,230],2296:[,230],2297:[,220],2298:[,220],2299:[,230],2300:[,230],2301:[,230],2302:[,230],2303:[,230]},
2304:{2344:[,,{2364:2345}],2345:[[2344,2364]],2352:[,,{2364:2353}],2353:[[2352,2364]],2355:[,,{2364:2356}],2356:[[2355,2364]],2364:[,7],2381:[,9],2385:[,230],2386:[,220],2387:[,230],2388:[,230],2392:[[2325,2364],512],2393:[[2326,2364],512],2394:[[2327,2364],512],2395:[[2332,2364],512],2396:[[2337,2364],512],2397:[[2338,2364],512],2398:[[2347,2364],512],2399:[[2351,2364],512],2492:[,7],2503:[,,{2494:2507,2519:2508}],2507:[[2503,2494]],2508:[[2503,2519]],2509:[,9],2524:[[2465,2492],512],2525:[[2466,2492],512],2527:[[2479,2492],512]},
2560:{2611:[[2610,2620],512],2614:[[2616,2620],512],2620:[,7],2637:[,9],2649:[[2582,2620],512],2650:[[2583,2620],512],2651:[[2588,2620],512],2654:[[2603,2620],512],2748:[,7],2765:[,9],68109:[,220],68111:[,230],68152:[,230],68153:[,1],68154:[,220],68159:[,9],68325:[,230],68326:[,220]},
2816:{2876:[,7],2887:[,,{2878:2891,2902:2888,2903:2892}],2888:[[2887,2902]],2891:[[2887,2878]],2892:[[2887,2903]],2893:[,9],2908:[[2849,2876],512],2909:[[2850,2876],512],2962:[,,{3031:2964}],2964:[[2962,3031]],3014:[,,{3006:3018,3031:3020}],3015:[,,{3006:3019}],3018:[[3014,3006]],3019:[[3015,3006]],3020:[[3014,3031]],3021:[,9]},
3072:{3142:[,,{3158:3144}],3144:[[3142,3158]],3149:[,9],3157:[,84],3158:[,91],3260:[,7],3263:[,,{3285:3264}],3264:[[3263,3285]],3270:[,,{3266:3274,3285:3271,3286:3272}],3271:[[3270,3285]],3272:[[3270,3286]],3274:[[3270,3266],,{3285:3275}],3275:[[3274,3285]],3277:[,9]},
3328:{3398:[,,{3390:3402,3415:3404}],3399:[,,{3390:3403}],3402:[[3398,3390]],3403:[[3399,3390]],3404:[[3398,3415]],3405:[,9],3530:[,9],3545:[,,{3530:3546,3535:3548,3551:3550}],3546:[[3545,3530]],3548:[[3545,3535],,{3530:3549}],3549:[[3548,3530]],3550:[[3545,3551]]},
3584:{3635:[[3661,3634],256],3640:[,103],3641:[,103],3642:[,9],3656:[,107],3657:[,107],3658:[,107],3659:[,107],3763:[[3789,3762],256],3768:[,118],3769:[,118],3784:[,122],3785:[,122],3786:[,122],3787:[,122],3804:[[3755,3737],256],3805:[[3755,3745],256]},
3840:{3852:[[3851],256],3864:[,220],3865:[,220],3893:[,220],3895:[,220],3897:[,216],3907:[[3906,4023],512],3917:[[3916,4023],512],3922:[[3921,4023],512],3927:[[3926,4023],512],3932:[[3931,4023],512],3945:[[3904,4021],512],3953:[,129],3954:[,130],3955:[[3953,3954],512],3956:[,132],3957:[[3953,3956],512],3958:[[4018,3968],512],3959:[[4018,3969],256],3960:[[4019,3968],512],3961:[[4019,3969],256],3962:[,130],3963:[,130],3964:[,130],3965:[,130],3968:[,130],3969:[[3953,3968],512],3970:[,230],3971:[,230],3972:[,9],3974:[,230],3975:[,230],3987:[[3986,4023],512],3997:[[3996,4023],512],4002:[[4001,4023],512],4007:[[4006,4023],512],4012:[[4011,4023],512],4025:[[3984,4021],512],4038:[,220]},
4096:{4133:[,,{4142:4134}],4134:[[4133,4142]],4151:[,7],4153:[,9],4154:[,9],4237:[,220],4348:[[4316],256],69702:[,9],69759:[,9],69785:[,,{69818:69786}],69786:[[69785,69818]],69787:[,,{69818:69788}],69788:[[69787,69818]],69797:[,,{69818:69803}],69803:[[69797,69818]],69817:[,9],69818:[,7]},
4352:{69888:[,230],69889:[,230],69890:[,230],69934:[[69937,69927]],69935:[[69938,69927]],69937:[,,{69927:69934}],69938:[,,{69927:69935}],69939:[,9],69940:[,9],70003:[,7],70080:[,9]},
4608:{70197:[,9],70198:[,7],70377:[,7],70378:[,9]},
4864:{4957:[,230],4958:[,230],4959:[,230],70460:[,7],70471:[,,{70462:70475,70487:70476}],70475:[[70471,70462]],70476:[[70471,70487]],70477:[,9],70502:[,230],70503:[,230],70504:[,230],70505:[,230],70506:[,230],70507:[,230],70508:[,230],70512:[,230],70513:[,230],70514:[,230],70515:[,230],70516:[,230]},
5120:{70841:[,,{70832:70844,70842:70843,70845:70846}],70843:[[70841,70842]],70844:[[70841,70832]],70846:[[70841,70845]],70850:[,9],70851:[,7]},
5376:{71096:[,,{71087:71098}],71097:[,,{71087:71099}],71098:[[71096,71087]],71099:[[71097,71087]],71103:[,9],71104:[,7]},
5632:{71231:[,9],71350:[,9],71351:[,7]},
5888:{5908:[,9],5940:[,9],6098:[,9],6109:[,230]},
6144:{6313:[,228]},
6400:{6457:[,222],6458:[,230],6459:[,220]},
6656:{6679:[,230],6680:[,220],6752:[,9],6773:[,230],6774:[,230],6775:[,230],6776:[,230],6777:[,230],6778:[,230],6779:[,230],6780:[,230],6783:[,220],6832:[,230],6833:[,230],6834:[,230],6835:[,230],6836:[,230],6837:[,220],6838:[,220],6839:[,220],6840:[,220],6841:[,220],6842:[,220],6843:[,230],6844:[,230],6845:[,220]},
6912:{6917:[,,{6965:6918}],6918:[[6917,6965]],6919:[,,{6965:6920}],6920:[[6919,6965]],6921:[,,{6965:6922}],6922:[[6921,6965]],6923:[,,{6965:6924}],6924:[[6923,6965]],6925:[,,{6965:6926}],6926:[[6925,6965]],6929:[,,{6965:6930}],6930:[[6929,6965]],6964:[,7],6970:[,,{6965:6971}],6971:[[6970,6965]],6972:[,,{6965:6973}],6973:[[6972,6965]],6974:[,,{6965:6976}],6975:[,,{6965:6977}],6976:[[6974,6965]],6977:[[6975,6965]],6978:[,,{6965:6979}],6979:[[6978,6965]],6980:[,9],7019:[,230],7020:[,220],7021:[,230],7022:[,230],7023:[,230],7024:[,230],7025:[,230],7026:[,230],7027:[,230],7082:[,9],7083:[,9],7142:[,7],7154:[,9],7155:[,9]},
7168:{7223:[,7],7376:[,230],7377:[,230],7378:[,230],7380:[,1],7381:[,220],7382:[,220],7383:[,220],7384:[,220],7385:[,220],7386:[,230],7387:[,230],7388:[,220],7389:[,220],7390:[,220],7391:[,220],7392:[,230],7394:[,1],7395:[,1],7396:[,1],7397:[,1],7398:[,1],7399:[,1],7400:[,1],7405:[,220],7412:[,230],7416:[,230],7417:[,230]},
7424:{7468:[[65],256],7469:[[198],256],7470:[[66],256],7472:[[68],256],7473:[[69],256],7474:[[398],256],7475:[[71],256],7476:[[72],256],7477:[[73],256],7478:[[74],256],7479:[[75],256],7480:[[76],256],7481:[[77],256],7482:[[78],256],7484:[[79],256],7485:[[546],256],7486:[[80],256],7487:[[82],256],7488:[[84],256],7489:[[85],256],7490:[[87],256],7491:[[97],256],7492:[[592],256],7493:[[593],256],7494:[[7426],256],7495:[[98],256],7496:[[100],256],7497:[[101],256],7498:[[601],256],7499:[[603],256],7500:[[604],256],7501:[[103],256],7503:[[107],256],7504:[[109],256],7505:[[331],256],7506:[[111],256],7507:[[596],256],7508:[[7446],256],7509:[[7447],256],7510:[[112],256],7511:[[116],256],7512:[[117],256],7513:[[7453],256],7514:[[623],256],7515:[[118],256],7516:[[7461],256],7517:[[946],256],7518:[[947],256],7519:[[948],256],7520:[[966],256],7521:[[967],256],7522:[[105],256],7523:[[114],256],7524:[[117],256],7525:[[118],256],7526:[[946],256],7527:[[947],256],7528:[[961],256],7529:[[966],256],7530:[[967],256],7544:[[1085],256],7579:[[594],256],7580:[[99],256],7581:[[597],256],7582:[[240],256],7583:[[604],256],7584:[[102],256],7585:[[607],256],7586:[[609],256],7587:[[613],256],7588:[[616],256],7589:[[617],256],7590:[[618],256],7591:[[7547],256],7592:[[669],256],7593:[[621],256],7594:[[7557],256],7595:[[671],256],7596:[[625],256],7597:[[624],256],7598:[[626],256],7599:[[627],256],7600:[[628],256],7601:[[629],256],7602:[[632],256],7603:[[642],256],7604:[[643],256],7605:[[427],256],7606:[[649],256],7607:[[650],256],7608:[[7452],256],7609:[[651],256],7610:[[652],256],7611:[[122],256],7612:[[656],256],7613:[[657],256],7614:[[658],256],7615:[[952],256],7616:[,230],7617:[,230],7618:[,220],7619:[,230],7620:[,230],7621:[,230],7622:[,230],7623:[,230],7624:[,230],7625:[,230],7626:[,220],7627:[,230],7628:[,230],7629:[,234],7630:[,214],7631:[,220],7632:[,202],7633:[,230],7634:[,230],7635:[,230],7636:[,230],7637:[,230],7638:[,230],7639:[,230],7640:[,230],7641:[,230],7642:[,230],7643:[,230],7644:[,230],7645:[,230],7646:[,230],7647:[,230],7648:[,230],7649:[,230],7650:[,230],7651:[,230],7652:[,230],7653:[,230],7654:[,230],7655:[,230],7656:[,230],7657:[,230],7658:[,230],7659:[,230],7660:[,230],7661:[,230],7662:[,230],7663:[,230],7664:[,230],7665:[,230],7666:[,230],7667:[,230],7668:[,230],7669:[,230],7676:[,233],7677:[,220],7678:[,230],7679:[,220]},
7680:{7680:[[65,805]],7681:[[97,805]],7682:[[66,775]],7683:[[98,775]],7684:[[66,803]],7685:[[98,803]],7686:[[66,817]],7687:[[98,817]],7688:[[199,769]],7689:[[231,769]],7690:[[68,775]],7691:[[100,775]],7692:[[68,803]],7693:[[100,803]],7694:[[68,817]],7695:[[100,817]],7696:[[68,807]],7697:[[100,807]],7698:[[68,813]],7699:[[100,813]],7700:[[274,768]],7701:[[275,768]],7702:[[274,769]],7703:[[275,769]],7704:[[69,813]],7705:[[101,813]],7706:[[69,816]],7707:[[101,816]],7708:[[552,774]],7709:[[553,774]],7710:[[70,775]],7711:[[102,775]],7712:[[71,772]],7713:[[103,772]],7714:[[72,775]],7715:[[104,775]],7716:[[72,803]],7717:[[104,803]],7718:[[72,776]],7719:[[104,776]],7720:[[72,807]],7721:[[104,807]],7722:[[72,814]],7723:[[104,814]],7724:[[73,816]],7725:[[105,816]],7726:[[207,769]],7727:[[239,769]],7728:[[75,769]],7729:[[107,769]],7730:[[75,803]],7731:[[107,803]],7732:[[75,817]],7733:[[107,817]],7734:[[76,803],,{772:7736}],7735:[[108,803],,{772:7737}],7736:[[7734,772]],7737:[[7735,772]],7738:[[76,817]],7739:[[108,817]],7740:[[76,813]],7741:[[108,813]],7742:[[77,769]],7743:[[109,769]],7744:[[77,775]],7745:[[109,775]],7746:[[77,803]],7747:[[109,803]],7748:[[78,775]],7749:[[110,775]],7750:[[78,803]],7751:[[110,803]],7752:[[78,817]],7753:[[110,817]],7754:[[78,813]],7755:[[110,813]],7756:[[213,769]],7757:[[245,769]],7758:[[213,776]],7759:[[245,776]],7760:[[332,768]],7761:[[333,768]],7762:[[332,769]],7763:[[333,769]],7764:[[80,769]],7765:[[112,769]],7766:[[80,775]],7767:[[112,775]],7768:[[82,775]],7769:[[114,775]],7770:[[82,803],,{772:7772}],7771:[[114,803],,{772:7773}],7772:[[7770,772]],7773:[[7771,772]],7774:[[82,817]],7775:[[114,817]],7776:[[83,775]],7777:[[115,775]],7778:[[83,803],,{775:7784}],7779:[[115,803],,{775:7785}],7780:[[346,775]],7781:[[347,775]],7782:[[352,775]],7783:[[353,775]],7784:[[7778,775]],7785:[[7779,775]],7786:[[84,775]],7787:[[116,775]],7788:[[84,803]],7789:[[116,803]],7790:[[84,817]],7791:[[116,817]],7792:[[84,813]],7793:[[116,813]],7794:[[85,804]],7795:[[117,804]],7796:[[85,816]],7797:[[117,816]],7798:[[85,813]],7799:[[117,813]],7800:[[360,769]],7801:[[361,769]],7802:[[362,776]],7803:[[363,776]],7804:[[86,771]],7805:[[118,771]],7806:[[86,803]],7807:[[118,803]],7808:[[87,768]],7809:[[119,768]],7810:[[87,769]],7811:[[119,769]],7812:[[87,776]],7813:[[119,776]],7814:[[87,775]],7815:[[119,775]],7816:[[87,803]],7817:[[119,803]],7818:[[88,775]],7819:[[120,775]],7820:[[88,776]],7821:[[120,776]],7822:[[89,775]],7823:[[121,775]],7824:[[90,770]],7825:[[122,770]],7826:[[90,803]],7827:[[122,803]],7828:[[90,817]],7829:[[122,817]],7830:[[104,817]],7831:[[116,776]],7832:[[119,778]],7833:[[121,778]],7834:[[97,702],256],7835:[[383,775]],7840:[[65,803],,{770:7852,774:7862}],7841:[[97,803],,{770:7853,774:7863}],7842:[[65,777]],7843:[[97,777]],7844:[[194,769]],7845:[[226,769]],7846:[[194,768]],7847:[[226,768]],7848:[[194,777]],7849:[[226,777]],7850:[[194,771]],7851:[[226,771]],7852:[[7840,770]],7853:[[7841,770]],7854:[[258,769]],7855:[[259,769]],7856:[[258,768]],7857:[[259,768]],7858:[[258,777]],7859:[[259,777]],7860:[[258,771]],7861:[[259,771]],7862:[[7840,774]],7863:[[7841,774]],7864:[[69,803],,{770:7878}],7865:[[101,803],,{770:7879}],7866:[[69,777]],7867:[[101,777]],7868:[[69,771]],7869:[[101,771]],7870:[[202,769]],7871:[[234,769]],7872:[[202,768]],7873:[[234,768]],7874:[[202,777]],7875:[[234,777]],7876:[[202,771]],7877:[[234,771]],7878:[[7864,770]],7879:[[7865,770]],7880:[[73,777]],7881:[[105,777]],7882:[[73,803]],7883:[[105,803]],7884:[[79,803],,{770:7896}],7885:[[111,803],,{770:7897}],7886:[[79,777]],7887:[[111,777]],7888:[[212,769]],7889:[[244,769]],7890:[[212,768]],7891:[[244,768]],7892:[[212,777]],7893:[[244,777]],7894:[[212,771]],7895:[[244,771]],7896:[[7884,770]],7897:[[7885,770]],7898:[[416,769]],7899:[[417,769]],7900:[[416,768]],7901:[[417,768]],7902:[[416,777]],7903:[[417,777]],7904:[[416,771]],7905:[[417,771]],7906:[[416,803]],7907:[[417,803]],7908:[[85,803]],7909:[[117,803]],7910:[[85,777]],7911:[[117,777]],7912:[[431,769]],7913:[[432,769]],7914:[[431,768]],7915:[[432,768]],7916:[[431,777]],7917:[[432,777]],7918:[[431,771]],7919:[[432,771]],7920:[[431,803]],7921:[[432,803]],7922:[[89,768]],7923:[[121,768]],7924:[[89,803]],7925:[[121,803]],7926:[[89,777]],7927:[[121,777]],7928:[[89,771]],7929:[[121,771]]},
7936:{7936:[[945,787],,{768:7938,769:7940,834:7942,837:8064}],7937:[[945,788],,{768:7939,769:7941,834:7943,837:8065}],7938:[[7936,768],,{837:8066}],7939:[[7937,768],,{837:8067}],7940:[[7936,769],,{837:8068}],7941:[[7937,769],,{837:8069}],7942:[[7936,834],,{837:8070}],7943:[[7937,834],,{837:8071}],7944:[[913,787],,{768:7946,769:7948,834:7950,837:8072}],7945:[[913,788],,{768:7947,769:7949,834:7951,837:8073}],7946:[[7944,768],,{837:8074}],7947:[[7945,768],,{837:8075}],7948:[[7944,769],,{837:8076}],7949:[[7945,769],,{837:8077}],7950:[[7944,834],,{837:8078}],7951:[[7945,834],,{837:8079}],7952:[[949,787],,{768:7954,769:7956}],7953:[[949,788],,{768:7955,769:7957}],7954:[[7952,768]],7955:[[7953,768]],7956:[[7952,769]],7957:[[7953,769]],7960:[[917,787],,{768:7962,769:7964}],7961:[[917,788],,{768:7963,769:7965}],7962:[[7960,768]],7963:[[7961,768]],7964:[[7960,769]],7965:[[7961,769]],7968:[[951,787],,{768:7970,769:7972,834:7974,837:8080}],7969:[[951,788],,{768:7971,769:7973,834:7975,837:8081}],7970:[[7968,768],,{837:8082}],7971:[[7969,768],,{837:8083}],7972:[[7968,769],,{837:8084}],7973:[[7969,769],,{837:8085}],7974:[[7968,834],,{837:8086}],7975:[[7969,834],,{837:8087}],7976:[[919,787],,{768:7978,769:7980,834:7982,837:8088}],7977:[[919,788],,{768:7979,769:7981,834:7983,837:8089}],7978:[[7976,768],,{837:8090}],7979:[[7977,768],,{837:8091}],7980:[[7976,769],,{837:8092}],7981:[[7977,769],,{837:8093}],7982:[[7976,834],,{837:8094}],7983:[[7977,834],,{837:8095}],7984:[[953,787],,{768:7986,769:7988,834:7990}],7985:[[953,788],,{768:7987,769:7989,834:7991}],7986:[[7984,768]],7987:[[7985,768]],7988:[[7984,769]],7989:[[7985,769]],7990:[[7984,834]],7991:[[7985,834]],7992:[[921,787],,{768:7994,769:7996,834:7998}],7993:[[921,788],,{768:7995,769:7997,834:7999}],7994:[[7992,768]],7995:[[7993,768]],7996:[[7992,769]],7997:[[7993,769]],7998:[[7992,834]],7999:[[7993,834]],8000:[[959,787],,{768:8002,769:8004}],8001:[[959,788],,{768:8003,769:8005}],8002:[[8000,768]],8003:[[8001,768]],8004:[[8000,769]],8005:[[8001,769]],8008:[[927,787],,{768:8010,769:8012}],8009:[[927,788],,{768:8011,769:8013}],8010:[[8008,768]],8011:[[8009,768]],8012:[[8008,769]],8013:[[8009,769]],8016:[[965,787],,{768:8018,769:8020,834:8022}],8017:[[965,788],,{768:8019,769:8021,834:8023}],8018:[[8016,768]],8019:[[8017,768]],8020:[[8016,769]],8021:[[8017,769]],8022:[[8016,834]],8023:[[8017,834]],8025:[[933,788],,{768:8027,769:8029,834:8031}],8027:[[8025,768]],8029:[[8025,769]],8031:[[8025,834]],8032:[[969,787],,{768:8034,769:8036,834:8038,837:8096}],8033:[[969,788],,{768:8035,769:8037,834:8039,837:8097}],8034:[[8032,768],,{837:8098}],8035:[[8033,768],,{837:8099}],8036:[[8032,769],,{837:8100}],8037:[[8033,769],,{837:8101}],8038:[[8032,834],,{837:8102}],8039:[[8033,834],,{837:8103}],8040:[[937,787],,{768:8042,769:8044,834:8046,837:8104}],8041:[[937,788],,{768:8043,769:8045,834:8047,837:8105}],8042:[[8040,768],,{837:8106}],8043:[[8041,768],,{837:8107}],8044:[[8040,769],,{837:8108}],8045:[[8041,769],,{837:8109}],8046:[[8040,834],,{837:8110}],8047:[[8041,834],,{837:8111}],8048:[[945,768],,{837:8114}],8049:[[940]],8050:[[949,768]],8051:[[941]],8052:[[951,768],,{837:8130}],8053:[[942]],8054:[[953,768]],8055:[[943]],8056:[[959,768]],8057:[[972]],8058:[[965,768]],8059:[[973]],8060:[[969,768],,{837:8178}],8061:[[974]],8064:[[7936,837]],8065:[[7937,837]],8066:[[7938,837]],8067:[[7939,837]],8068:[[7940,837]],8069:[[7941,837]],8070:[[7942,837]],8071:[[7943,837]],8072:[[7944,837]],8073:[[7945,837]],8074:[[7946,837]],8075:[[7947,837]],8076:[[7948,837]],8077:[[7949,837]],8078:[[7950,837]],8079:[[7951,837]],8080:[[7968,837]],8081:[[7969,837]],8082:[[7970,837]],8083:[[7971,837]],8084:[[7972,837]],8085:[[7973,837]],8086:[[7974,837]],8087:[[7975,837]],8088:[[7976,837]],8089:[[7977,837]],8090:[[7978,837]],8091:[[7979,837]],8092:[[7980,837]],8093:[[7981,837]],8094:[[7982,837]],8095:[[7983,837]],8096:[[8032,837]],8097:[[8033,837]],8098:[[8034,837]],8099:[[8035,837]],8100:[[8036,837]],8101:[[8037,837]],8102:[[8038,837]],8103:[[8039,837]],8104:[[8040,837]],8105:[[8041,837]],8106:[[8042,837]],8107:[[8043,837]],8108:[[8044,837]],8109:[[8045,837]],8110:[[8046,837]],8111:[[8047,837]],8112:[[945,774]],8113:[[945,772]],8114:[[8048,837]],8115:[[945,837]],8116:[[940,837]],8118:[[945,834],,{837:8119}],8119:[[8118,837]],8120:[[913,774]],8121:[[913,772]],8122:[[913,768]],8123:[[902]],8124:[[913,837]],8125:[[32,787],256],8126:[[953]],8127:[[32,787],256,{768:8141,769:8142,834:8143}],8128:[[32,834],256],8129:[[168,834]],8130:[[8052,837]],8131:[[951,837]],8132:[[942,837]],8134:[[951,834],,{837:8135}],8135:[[8134,837]],8136:[[917,768]],8137:[[904]],8138:[[919,768]],8139:[[905]],8140:[[919,837]],8141:[[8127,768]],8142:[[8127,769]],8143:[[8127,834]],8144:[[953,774]],8145:[[953,772]],8146:[[970,768]],8147:[[912]],8150:[[953,834]],8151:[[970,834]],8152:[[921,774]],8153:[[921,772]],8154:[[921,768]],8155:[[906]],8157:[[8190,768]],8158:[[8190,769]],8159:[[8190,834]],8160:[[965,774]],8161:[[965,772]],8162:[[971,768]],8163:[[944]],8164:[[961,787]],8165:[[961,788]],8166:[[965,834]],8167:[[971,834]],8168:[[933,774]],8169:[[933,772]],8170:[[933,768]],8171:[[910]],8172:[[929,788]],8173:[[168,768]],8174:[[901]],8175:[[96]],8178:[[8060,837]],8179:[[969,837]],8180:[[974,837]],8182:[[969,834],,{837:8183}],8183:[[8182,837]],8184:[[927,768]],8185:[[908]],8186:[[937,768]],8187:[[911]],8188:[[937,837]],8189:[[180]],8190:[[32,788],256,{768:8157,769:8158,834:8159}]},
8192:{8192:[[8194]],8193:[[8195]],8194:[[32],256],8195:[[32],256],8196:[[32],256],8197:[[32],256],8198:[[32],256],8199:[[32],256],8200:[[32],256],8201:[[32],256],8202:[[32],256],8209:[[8208],256],8215:[[32,819],256],8228:[[46],256],8229:[[46,46],256],8230:[[46,46,46],256],8239:[[32],256],8243:[[8242,8242],256],8244:[[8242,8242,8242],256],8246:[[8245,8245],256],8247:[[8245,8245,8245],256],8252:[[33,33],256],8254:[[32,773],256],8263:[[63,63],256],8264:[[63,33],256],8265:[[33,63],256],8279:[[8242,8242,8242,8242],256],8287:[[32],256],8304:[[48],256],8305:[[105],256],8308:[[52],256],8309:[[53],256],8310:[[54],256],8311:[[55],256],8312:[[56],256],8313:[[57],256],8314:[[43],256],8315:[[8722],256],8316:[[61],256],8317:[[40],256],8318:[[41],256],8319:[[110],256],8320:[[48],256],8321:[[49],256],8322:[[50],256],8323:[[51],256],8324:[[52],256],8325:[[53],256],8326:[[54],256],8327:[[55],256],8328:[[56],256],8329:[[57],256],8330:[[43],256],8331:[[8722],256],8332:[[61],256],8333:[[40],256],8334:[[41],256],8336:[[97],256],8337:[[101],256],8338:[[111],256],8339:[[120],256],8340:[[601],256],8341:[[104],256],8342:[[107],256],8343:[[108],256],8344:[[109],256],8345:[[110],256],8346:[[112],256],8347:[[115],256],8348:[[116],256],8360:[[82,115],256],8400:[,230],8401:[,230],8402:[,1],8403:[,1],8404:[,230],8405:[,230],8406:[,230],8407:[,230],8408:[,1],8409:[,1],8410:[,1],8411:[,230],8412:[,230],8417:[,230],8421:[,1],8422:[,1],8423:[,230],8424:[,220],8425:[,230],8426:[,1],8427:[,1],8428:[,220],8429:[,220],8430:[,220],8431:[,220],8432:[,230]},
8448:{8448:[[97,47,99],256],8449:[[97,47,115],256],8450:[[67],256],8451:[[176,67],256],8453:[[99,47,111],256],8454:[[99,47,117],256],8455:[[400],256],8457:[[176,70],256],8458:[[103],256],8459:[[72],256],8460:[[72],256],8461:[[72],256],8462:[[104],256],8463:[[295],256],8464:[[73],256],8465:[[73],256],8466:[[76],256],8467:[[108],256],8469:[[78],256],8470:[[78,111],256],8473:[[80],256],8474:[[81],256],8475:[[82],256],8476:[[82],256],8477:[[82],256],8480:[[83,77],256],8481:[[84,69,76],256],8482:[[84,77],256],8484:[[90],256],8486:[[937]],8488:[[90],256],8490:[[75]],8491:[[197]],8492:[[66],256],8493:[[67],256],8495:[[101],256],8496:[[69],256],8497:[[70],256],8499:[[77],256],8500:[[111],256],8501:[[1488],256],8502:[[1489],256],8503:[[1490],256],8504:[[1491],256],8505:[[105],256],8507:[[70,65,88],256],8508:[[960],256],8509:[[947],256],8510:[[915],256],8511:[[928],256],8512:[[8721],256],8517:[[68],256],8518:[[100],256],8519:[[101],256],8520:[[105],256],8521:[[106],256],8528:[[49,8260,55],256],8529:[[49,8260,57],256],8530:[[49,8260,49,48],256],8531:[[49,8260,51],256],8532:[[50,8260,51],256],8533:[[49,8260,53],256],8534:[[50,8260,53],256],8535:[[51,8260,53],256],8536:[[52,8260,53],256],8537:[[49,8260,54],256],8538:[[53,8260,54],256],8539:[[49,8260,56],256],8540:[[51,8260,56],256],8541:[[53,8260,56],256],8542:[[55,8260,56],256],8543:[[49,8260],256],8544:[[73],256],8545:[[73,73],256],8546:[[73,73,73],256],8547:[[73,86],256],8548:[[86],256],8549:[[86,73],256],8550:[[86,73,73],256],8551:[[86,73,73,73],256],8552:[[73,88],256],8553:[[88],256],8554:[[88,73],256],8555:[[88,73,73],256],8556:[[76],256],8557:[[67],256],8558:[[68],256],8559:[[77],256],8560:[[105],256],8561:[[105,105],256],8562:[[105,105,105],256],8563:[[105,118],256],8564:[[118],256],8565:[[118,105],256],8566:[[118,105,105],256],8567:[[118,105,105,105],256],8568:[[105,120],256],8569:[[120],256],8570:[[120,105],256],8571:[[120,105,105],256],8572:[[108],256],8573:[[99],256],8574:[[100],256],8575:[[109],256],8585:[[48,8260,51],256],8592:[,,{824:8602}],8594:[,,{824:8603}],8596:[,,{824:8622}],8602:[[8592,824]],8603:[[8594,824]],8622:[[8596,824]],8653:[[8656,824]],8654:[[8660,824]],8655:[[8658,824]],8656:[,,{824:8653}],8658:[,,{824:8655}],8660:[,,{824:8654}]},
8704:{8707:[,,{824:8708}],8708:[[8707,824]],8712:[,,{824:8713}],8713:[[8712,824]],8715:[,,{824:8716}],8716:[[8715,824]],8739:[,,{824:8740}],8740:[[8739,824]],8741:[,,{824:8742}],8742:[[8741,824]],8748:[[8747,8747],256],8749:[[8747,8747,8747],256],8751:[[8750,8750],256],8752:[[8750,8750,8750],256],8764:[,,{824:8769}],8769:[[8764,824]],8771:[,,{824:8772}],8772:[[8771,824]],8773:[,,{824:8775}],8775:[[8773,824]],8776:[,,{824:8777}],8777:[[8776,824]],8781:[,,{824:8813}],8800:[[61,824]],8801:[,,{824:8802}],8802:[[8801,824]],8804:[,,{824:8816}],8805:[,,{824:8817}],8813:[[8781,824]],8814:[[60,824]],8815:[[62,824]],8816:[[8804,824]],8817:[[8805,824]],8818:[,,{824:8820}],8819:[,,{824:8821}],8820:[[8818,824]],8821:[[8819,824]],8822:[,,{824:8824}],8823:[,,{824:8825}],8824:[[8822,824]],8825:[[8823,824]],8826:[,,{824:8832}],8827:[,,{824:8833}],8828:[,,{824:8928}],8829:[,,{824:8929}],8832:[[8826,824]],8833:[[8827,824]],8834:[,,{824:8836}],8835:[,,{824:8837}],8836:[[8834,824]],8837:[[8835,824]],8838:[,,{824:8840}],8839:[,,{824:8841}],8840:[[8838,824]],8841:[[8839,824]],8849:[,,{824:8930}],8850:[,,{824:8931}],8866:[,,{824:8876}],8872:[,,{824:8877}],8873:[,,{824:8878}],8875:[,,{824:8879}],8876:[[8866,824]],8877:[[8872,824]],8878:[[8873,824]],8879:[[8875,824]],8882:[,,{824:8938}],8883:[,,{824:8939}],8884:[,,{824:8940}],8885:[,,{824:8941}],8928:[[8828,824]],8929:[[8829,824]],8930:[[8849,824]],8931:[[8850,824]],8938:[[8882,824]],8939:[[8883,824]],8940:[[8884,824]],8941:[[8885,824]]},
8960:{9001:[[12296]],9002:[[12297]]},
9216:{9312:[[49],256],9313:[[50],256],9314:[[51],256],9315:[[52],256],9316:[[53],256],9317:[[54],256],9318:[[55],256],9319:[[56],256],9320:[[57],256],9321:[[49,48],256],9322:[[49,49],256],9323:[[49,50],256],9324:[[49,51],256],9325:[[49,52],256],9326:[[49,53],256],9327:[[49,54],256],9328:[[49,55],256],9329:[[49,56],256],9330:[[49,57],256],9331:[[50,48],256],9332:[[40,49,41],256],9333:[[40,50,41],256],9334:[[40,51,41],256],9335:[[40,52,41],256],9336:[[40,53,41],256],9337:[[40,54,41],256],9338:[[40,55,41],256],9339:[[40,56,41],256],9340:[[40,57,41],256],9341:[[40,49,48,41],256],9342:[[40,49,49,41],256],9343:[[40,49,50,41],256],9344:[[40,49,51,41],256],9345:[[40,49,52,41],256],9346:[[40,49,53,41],256],9347:[[40,49,54,41],256],9348:[[40,49,55,41],256],9349:[[40,49,56,41],256],9350:[[40,49,57,41],256],9351:[[40,50,48,41],256],9352:[[49,46],256],9353:[[50,46],256],9354:[[51,46],256],9355:[[52,46],256],9356:[[53,46],256],9357:[[54,46],256],9358:[[55,46],256],9359:[[56,46],256],9360:[[57,46],256],9361:[[49,48,46],256],9362:[[49,49,46],256],9363:[[49,50,46],256],9364:[[49,51,46],256],9365:[[49,52,46],256],9366:[[49,53,46],256],9367:[[49,54,46],256],9368:[[49,55,46],256],9369:[[49,56,46],256],9370:[[49,57,46],256],9371:[[50,48,46],256],9372:[[40,97,41],256],9373:[[40,98,41],256],9374:[[40,99,41],256],9375:[[40,100,41],256],9376:[[40,101,41],256],9377:[[40,102,41],256],9378:[[40,103,41],256],9379:[[40,104,41],256],9380:[[40,105,41],256],9381:[[40,106,41],256],9382:[[40,107,41],256],9383:[[40,108,41],256],9384:[[40,109,41],256],9385:[[40,110,41],256],9386:[[40,111,41],256],9387:[[40,112,41],256],9388:[[40,113,41],256],9389:[[40,114,41],256],9390:[[40,115,41],256],9391:[[40,116,41],256],9392:[[40,117,41],256],9393:[[40,118,41],256],9394:[[40,119,41],256],9395:[[40,120,41],256],9396:[[40,121,41],256],9397:[[40,122,41],256],9398:[[65],256],9399:[[66],256],9400:[[67],256],9401:[[68],256],9402:[[69],256],9403:[[70],256],9404:[[71],256],9405:[[72],256],9406:[[73],256],9407:[[74],256],9408:[[75],256],9409:[[76],256],9410:[[77],256],9411:[[78],256],9412:[[79],256],9413:[[80],256],9414:[[81],256],9415:[[82],256],9416:[[83],256],9417:[[84],256],9418:[[85],256],9419:[[86],256],9420:[[87],256],9421:[[88],256],9422:[[89],256],9423:[[90],256],9424:[[97],256],9425:[[98],256],9426:[[99],256],9427:[[100],256],9428:[[101],256],9429:[[102],256],9430:[[103],256],9431:[[104],256],9432:[[105],256],9433:[[106],256],9434:[[107],256],9435:[[108],256],9436:[[109],256],9437:[[110],256],9438:[[111],256],9439:[[112],256],9440:[[113],256],9441:[[114],256],9442:[[115],256],9443:[[116],256],9444:[[117],256],9445:[[118],256],9446:[[119],256],9447:[[120],256],9448:[[121],256],9449:[[122],256],9450:[[48],256]},
10752:{10764:[[8747,8747,8747,8747],256],10868:[[58,58,61],256],10869:[[61,61],256],10870:[[61,61,61],256],10972:[[10973,824],512]},
11264:{11388:[[106],256],11389:[[86],256],11503:[,230],11504:[,230],11505:[,230]},
11520:{11631:[[11617],256],11647:[,9],11744:[,230],11745:[,230],11746:[,230],11747:[,230],11748:[,230],11749:[,230],11750:[,230],11751:[,230],11752:[,230],11753:[,230],11754:[,230],11755:[,230],11756:[,230],11757:[,230],11758:[,230],11759:[,230],11760:[,230],11761:[,230],11762:[,230],11763:[,230],11764:[,230],11765:[,230],11766:[,230],11767:[,230],11768:[,230],11769:[,230],11770:[,230],11771:[,230],11772:[,230],11773:[,230],11774:[,230],11775:[,230]},
11776:{11935:[[27597],256],12019:[[40863],256]},
12032:{12032:[[19968],256],12033:[[20008],256],12034:[[20022],256],12035:[[20031],256],12036:[[20057],256],12037:[[20101],256],12038:[[20108],256],12039:[[20128],256],12040:[[20154],256],12041:[[20799],256],12042:[[20837],256],12043:[[20843],256],12044:[[20866],256],12045:[[20886],256],12046:[[20907],256],12047:[[20960],256],12048:[[20981],256],12049:[[20992],256],12050:[[21147],256],12051:[[21241],256],12052:[[21269],256],12053:[[21274],256],12054:[[21304],256],12055:[[21313],256],12056:[[21340],256],12057:[[21353],256],12058:[[21378],256],12059:[[21430],256],12060:[[21448],256],12061:[[21475],256],12062:[[22231],256],12063:[[22303],256],12064:[[22763],256],12065:[[22786],256],12066:[[22794],256],12067:[[22805],256],12068:[[22823],256],12069:[[22899],256],12070:[[23376],256],12071:[[23424],256],12072:[[23544],256],12073:[[23567],256],12074:[[23586],256],12075:[[23608],256],12076:[[23662],256],12077:[[23665],256],12078:[[24027],256],12079:[[24037],256],12080:[[24049],256],12081:[[24062],256],12082:[[24178],256],12083:[[24186],256],12084:[[24191],256],12085:[[24308],256],12086:[[24318],256],12087:[[24331],256],12088:[[24339],256],12089:[[24400],256],12090:[[24417],256],12091:[[24435],256],12092:[[24515],256],12093:[[25096],256],12094:[[25142],256],12095:[[25163],256],12096:[[25903],256],12097:[[25908],256],12098:[[25991],256],12099:[[26007],256],12100:[[26020],256],12101:[[26041],256],12102:[[26080],256],12103:[[26085],256],12104:[[26352],256],12105:[[26376],256],12106:[[26408],256],12107:[[27424],256],12108:[[27490],256],12109:[[27513],256],12110:[[27571],256],12111:[[27595],256],12112:[[27604],256],12113:[[27611],256],12114:[[27663],256],12115:[[27668],256],12116:[[27700],256],12117:[[28779],256],12118:[[29226],256],12119:[[29238],256],12120:[[29243],256],12121:[[29247],256],12122:[[29255],256],12123:[[29273],256],12124:[[29275],256],12125:[[29356],256],12126:[[29572],256],12127:[[29577],256],12128:[[29916],256],12129:[[29926],256],12130:[[29976],256],12131:[[29983],256],12132:[[29992],256],12133:[[30000],256],12134:[[30091],256],12135:[[30098],256],12136:[[30326],256],12137:[[30333],256],12138:[[30382],256],12139:[[30399],256],12140:[[30446],256],12141:[[30683],256],12142:[[30690],256],12143:[[30707],256],12144:[[31034],256],12145:[[31160],256],12146:[[31166],256],12147:[[31348],256],12148:[[31435],256],12149:[[31481],256],12150:[[31859],256],12151:[[31992],256],12152:[[32566],256],12153:[[32593],256],12154:[[32650],256],12155:[[32701],256],12156:[[32769],256],12157:[[32780],256],12158:[[32786],256],12159:[[32819],256],12160:[[32895],256],12161:[[32905],256],12162:[[33251],256],12163:[[33258],256],12164:[[33267],256],12165:[[33276],256],12166:[[33292],256],12167:[[33307],256],12168:[[33311],256],12169:[[33390],256],12170:[[33394],256],12171:[[33400],256],12172:[[34381],256],12173:[[34411],256],12174:[[34880],256],12175:[[34892],256],12176:[[34915],256],12177:[[35198],256],12178:[[35211],256],12179:[[35282],256],12180:[[35328],256],12181:[[35895],256],12182:[[35910],256],12183:[[35925],256],12184:[[35960],256],12185:[[35997],256],12186:[[36196],256],12187:[[36208],256],12188:[[36275],256],12189:[[36523],256],12190:[[36554],256],12191:[[36763],256],12192:[[36784],256],12193:[[36789],256],12194:[[37009],256],12195:[[37193],256],12196:[[37318],256],12197:[[37324],256],12198:[[37329],256],12199:[[38263],256],12200:[[38272],256],12201:[[38428],256],12202:[[38582],256],12203:[[38585],256],12204:[[38632],256],12205:[[38737],256],12206:[[38750],256],12207:[[38754],256],12208:[[38761],256],12209:[[38859],256],12210:[[38893],256],12211:[[38899],256],12212:[[38913],256],12213:[[39080],256],12214:[[39131],256],12215:[[39135],256],12216:[[39318],256],12217:[[39321],256],12218:[[39340],256],12219:[[39592],256],12220:[[39640],256],12221:[[39647],256],12222:[[39717],256],12223:[[39727],256],12224:[[39730],256],12225:[[39740],256],12226:[[39770],256],12227:[[40165],256],12228:[[40565],256],12229:[[40575],256],12230:[[40613],256],12231:[[40635],256],12232:[[40643],256],12233:[[40653],256],12234:[[40657],256],12235:[[40697],256],12236:[[40701],256],12237:[[40718],256],12238:[[40723],256],12239:[[40736],256],12240:[[40763],256],12241:[[40778],256],12242:[[40786],256],12243:[[40845],256],12244:[[40860],256],12245:[[40864],256]},
12288:{12288:[[32],256],12330:[,218],12331:[,228],12332:[,232],12333:[,222],12334:[,224],12335:[,224],12342:[[12306],256],12344:[[21313],256],12345:[[21316],256],12346:[[21317],256],12358:[,,{12441:12436}],12363:[,,{12441:12364}],12364:[[12363,12441]],12365:[,,{12441:12366}],12366:[[12365,12441]],12367:[,,{12441:12368}],12368:[[12367,12441]],12369:[,,{12441:12370}],12370:[[12369,12441]],12371:[,,{12441:12372}],12372:[[12371,12441]],12373:[,,{12441:12374}],12374:[[12373,12441]],12375:[,,{12441:12376}],12376:[[12375,12441]],12377:[,,{12441:12378}],12378:[[12377,12441]],12379:[,,{12441:12380}],12380:[[12379,12441]],12381:[,,{12441:12382}],12382:[[12381,12441]],12383:[,,{12441:12384}],12384:[[12383,12441]],12385:[,,{12441:12386}],12386:[[12385,12441]],12388:[,,{12441:12389}],12389:[[12388,12441]],12390:[,,{12441:12391}],12391:[[12390,12441]],12392:[,,{12441:12393}],12393:[[12392,12441]],12399:[,,{12441:12400,12442:12401}],12400:[[12399,12441]],12401:[[12399,12442]],12402:[,,{12441:12403,12442:12404}],12403:[[12402,12441]],12404:[[12402,12442]],12405:[,,{12441:12406,12442:12407}],12406:[[12405,12441]],12407:[[12405,12442]],12408:[,,{12441:12409,12442:12410}],12409:[[12408,12441]],12410:[[12408,12442]],12411:[,,{12441:12412,12442:12413}],12412:[[12411,12441]],12413:[[12411,12442]],12436:[[12358,12441]],12441:[,8],12442:[,8],12443:[[32,12441],256],12444:[[32,12442],256],12445:[,,{12441:12446}],12446:[[12445,12441]],12447:[[12424,12426],256],12454:[,,{12441:12532}],12459:[,,{12441:12460}],12460:[[12459,12441]],12461:[,,{12441:12462}],12462:[[12461,12441]],12463:[,,{12441:12464}],12464:[[12463,12441]],12465:[,,{12441:12466}],12466:[[12465,12441]],12467:[,,{12441:12468}],12468:[[12467,12441]],12469:[,,{12441:12470}],12470:[[12469,12441]],12471:[,,{12441:12472}],12472:[[12471,12441]],12473:[,,{12441:12474}],12474:[[12473,12441]],12475:[,,{12441:12476}],12476:[[12475,12441]],12477:[,,{12441:12478}],12478:[[12477,12441]],12479:[,,{12441:12480}],12480:[[12479,12441]],12481:[,,{12441:12482}],12482:[[12481,12441]],12484:[,,{12441:12485}],12485:[[12484,12441]],12486:[,,{12441:12487}],12487:[[12486,12441]],12488:[,,{12441:12489}],12489:[[12488,12441]],12495:[,,{12441:12496,12442:12497}],12496:[[12495,12441]],12497:[[12495,12442]],12498:[,,{12441:12499,12442:12500}],12499:[[12498,12441]],12500:[[12498,12442]],12501:[,,{12441:12502,12442:12503}],12502:[[12501,12441]],12503:[[12501,12442]],12504:[,,{12441:12505,12442:12506}],12505:[[12504,12441]],12506:[[12504,12442]],12507:[,,{12441:12508,12442:12509}],12508:[[12507,12441]],12509:[[12507,12442]],12527:[,,{12441:12535}],12528:[,,{12441:12536}],12529:[,,{12441:12537}],12530:[,,{12441:12538}],12532:[[12454,12441]],12535:[[12527,12441]],12536:[[12528,12441]],12537:[[12529,12441]],12538:[[12530,12441]],12541:[,,{12441:12542}],12542:[[12541,12441]],12543:[[12467,12488],256]},
12544:{12593:[[4352],256],12594:[[4353],256],12595:[[4522],256],12596:[[4354],256],12597:[[4524],256],12598:[[4525],256],12599:[[4355],256],12600:[[4356],256],12601:[[4357],256],12602:[[4528],256],12603:[[4529],256],12604:[[4530],256],12605:[[4531],256],12606:[[4532],256],12607:[[4533],256],12608:[[4378],256],12609:[[4358],256],12610:[[4359],256],12611:[[4360],256],12612:[[4385],256],12613:[[4361],256],12614:[[4362],256],12615:[[4363],256],12616:[[4364],256],12617:[[4365],256],12618:[[4366],256],12619:[[4367],256],12620:[[4368],256],12621:[[4369],256],12622:[[4370],256],12623:[[4449],256],12624:[[4450],256],12625:[[4451],256],12626:[[4452],256],12627:[[4453],256],12628:[[4454],256],12629:[[4455],256],12630:[[4456],256],12631:[[4457],256],12632:[[4458],256],12633:[[4459],256],12634:[[4460],256],12635:[[4461],256],12636:[[4462],256],12637:[[4463],256],12638:[[4464],256],12639:[[4465],256],12640:[[4466],256],12641:[[4467],256],12642:[[4468],256],12643:[[4469],256],12644:[[4448],256],12645:[[4372],256],12646:[[4373],256],12647:[[4551],256],12648:[[4552],256],12649:[[4556],256],12650:[[4558],256],12651:[[4563],256],12652:[[4567],256],12653:[[4569],256],12654:[[4380],256],12655:[[4573],256],12656:[[4575],256],12657:[[4381],256],12658:[[4382],256],12659:[[4384],256],12660:[[4386],256],12661:[[4387],256],12662:[[4391],256],12663:[[4393],256],12664:[[4395],256],12665:[[4396],256],12666:[[4397],256],12667:[[4398],256],12668:[[4399],256],12669:[[4402],256],12670:[[4406],256],12671:[[4416],256],12672:[[4423],256],12673:[[4428],256],12674:[[4593],256],12675:[[4594],256],12676:[[4439],256],12677:[[4440],256],12678:[[4441],256],12679:[[4484],256],12680:[[4485],256],12681:[[4488],256],12682:[[4497],256],12683:[[4498],256],12684:[[4500],256],12685:[[4510],256],12686:[[4513],256],12690:[[19968],256],12691:[[20108],256],12692:[[19977],256],12693:[[22235],256],12694:[[19978],256],12695:[[20013],256],12696:[[19979],256],12697:[[30002],256],12698:[[20057],256],12699:[[19993],256],12700:[[19969],256],12701:[[22825],256],12702:[[22320],256],12703:[[20154],256]},
12800:{12800:[[40,4352,41],256],12801:[[40,4354,41],256],12802:[[40,4355,41],256],12803:[[40,4357,41],256],12804:[[40,4358,41],256],12805:[[40,4359,41],256],12806:[[40,4361,41],256],12807:[[40,4363,41],256],12808:[[40,4364,41],256],12809:[[40,4366,41],256],12810:[[40,4367,41],256],12811:[[40,4368,41],256],12812:[[40,4369,41],256],12813:[[40,4370,41],256],12814:[[40,4352,4449,41],256],12815:[[40,4354,4449,41],256],12816:[[40,4355,4449,41],256],12817:[[40,4357,4449,41],256],12818:[[40,4358,4449,41],256],12819:[[40,4359,4449,41],256],12820:[[40,4361,4449,41],256],12821:[[40,4363,4449,41],256],12822:[[40,4364,4449,41],256],12823:[[40,4366,4449,41],256],12824:[[40,4367,4449,41],256],12825:[[40,4368,4449,41],256],12826:[[40,4369,4449,41],256],12827:[[40,4370,4449,41],256],12828:[[40,4364,4462,41],256],12829:[[40,4363,4457,4364,4453,4523,41],256],12830:[[40,4363,4457,4370,4462,41],256],12832:[[40,19968,41],256],12833:[[40,20108,41],256],12834:[[40,19977,41],256],12835:[[40,22235,41],256],12836:[[40,20116,41],256],12837:[[40,20845,41],256],12838:[[40,19971,41],256],12839:[[40,20843,41],256],12840:[[40,20061,41],256],12841:[[40,21313,41],256],12842:[[40,26376,41],256],12843:[[40,28779,41],256],12844:[[40,27700,41],256],12845:[[40,26408,41],256],12846:[[40,37329,41],256],12847:[[40,22303,41],256],12848:[[40,26085,41],256],12849:[[40,26666,41],256],12850:[[40,26377,41],256],12851:[[40,31038,41],256],12852:[[40,21517,41],256],12853:[[40,29305,41],256],12854:[[40,36001,41],256],12855:[[40,31069,41],256],12856:[[40,21172,41],256],12857:[[40,20195,41],256],12858:[[40,21628,41],256],12859:[[40,23398,41],256],12860:[[40,30435,41],256],12861:[[40,20225,41],256],12862:[[40,36039,41],256],12863:[[40,21332,41],256],12864:[[40,31085,41],256],12865:[[40,20241,41],256],12866:[[40,33258,41],256],12867:[[40,33267,41],256],12868:[[21839],256],12869:[[24188],256],12870:[[25991],256],12871:[[31631],256],12880:[[80,84,69],256],12881:[[50,49],256],12882:[[50,50],256],12883:[[50,51],256],12884:[[50,52],256],12885:[[50,53],256],12886:[[50,54],256],12887:[[50,55],256],12888:[[50,56],256],12889:[[50,57],256],12890:[[51,48],256],12891:[[51,49],256],12892:[[51,50],256],12893:[[51,51],256],12894:[[51,52],256],12895:[[51,53],256],12896:[[4352],256],12897:[[4354],256],12898:[[4355],256],12899:[[4357],256],12900:[[4358],256],12901:[[4359],256],12902:[[4361],256],12903:[[4363],256],12904:[[4364],256],12905:[[4366],256],12906:[[4367],256],12907:[[4368],256],12908:[[4369],256],12909:[[4370],256],12910:[[4352,4449],256],12911:[[4354,4449],256],12912:[[4355,4449],256],12913:[[4357,4449],256],12914:[[4358,4449],256],12915:[[4359,4449],256],12916:[[4361,4449],256],12917:[[4363,4449],256],12918:[[4364,4449],256],12919:[[4366,4449],256],12920:[[4367,4449],256],12921:[[4368,4449],256],12922:[[4369,4449],256],12923:[[4370,4449],256],12924:[[4366,4449,4535,4352,4457],256],12925:[[4364,4462,4363,4468],256],12926:[[4363,4462],256],12928:[[19968],256],12929:[[20108],256],12930:[[19977],256],12931:[[22235],256],12932:[[20116],256],12933:[[20845],256],12934:[[19971],256],12935:[[20843],256],12936:[[20061],256],12937:[[21313],256],12938:[[26376],256],12939:[[28779],256],12940:[[27700],256],12941:[[26408],256],12942:[[37329],256],12943:[[22303],256],12944:[[26085],256],12945:[[26666],256],12946:[[26377],256],12947:[[31038],256],12948:[[21517],256],12949:[[29305],256],12950:[[36001],256],12951:[[31069],256],12952:[[21172],256],12953:[[31192],256],12954:[[30007],256],12955:[[22899],256],12956:[[36969],256],12957:[[20778],256],12958:[[21360],256],12959:[[27880],256],12960:[[38917],256],12961:[[20241],256],12962:[[20889],256],12963:[[27491],256],12964:[[19978],256],12965:[[20013],256],12966:[[19979],256],12967:[[24038],256],12968:[[21491],256],12969:[[21307],256],12970:[[23447],256],12971:[[23398],256],12972:[[30435],256],12973:[[20225],256],12974:[[36039],256],12975:[[21332],256],12976:[[22812],256],12977:[[51,54],256],12978:[[51,55],256],12979:[[51,56],256],12980:[[51,57],256],12981:[[52,48],256],12982:[[52,49],256],12983:[[52,50],256],12984:[[52,51],256],12985:[[52,52],256],12986:[[52,53],256],12987:[[52,54],256],12988:[[52,55],256],12989:[[52,56],256],12990:[[52,57],256],12991:[[53,48],256],12992:[[49,26376],256],12993:[[50,26376],256],12994:[[51,26376],256],12995:[[52,26376],256],12996:[[53,26376],256],12997:[[54,26376],256],12998:[[55,26376],256],12999:[[56,26376],256],13000:[[57,26376],256],13001:[[49,48,26376],256],13002:[[49,49,26376],256],13003:[[49,50,26376],256],13004:[[72,103],256],13005:[[101,114,103],256],13006:[[101,86],256],13007:[[76,84,68],256],13008:[[12450],256],13009:[[12452],256],13010:[[12454],256],13011:[[12456],256],13012:[[12458],256],13013:[[12459],256],13014:[[12461],256],13015:[[12463],256],13016:[[12465],256],13017:[[12467],256],13018:[[12469],256],13019:[[12471],256],13020:[[12473],256],13021:[[12475],256],13022:[[12477],256],13023:[[12479],256],13024:[[12481],256],13025:[[12484],256],13026:[[12486],256],13027:[[12488],256],13028:[[12490],256],13029:[[12491],256],13030:[[12492],256],13031:[[12493],256],13032:[[12494],256],13033:[[12495],256],13034:[[12498],256],13035:[[12501],256],13036:[[12504],256],13037:[[12507],256],13038:[[12510],256],13039:[[12511],256],13040:[[12512],256],13041:[[12513],256],13042:[[12514],256],13043:[[12516],256],13044:[[12518],256],13045:[[12520],256],13046:[[12521],256],13047:[[12522],256],13048:[[12523],256],13049:[[12524],256],13050:[[12525],256],13051:[[12527],256],13052:[[12528],256],13053:[[12529],256],13054:[[12530],256]},
13056:{13056:[[12450,12497,12540,12488],256],13057:[[12450,12523,12501,12449],256],13058:[[12450,12531,12506,12450],256],13059:[[12450,12540,12523],256],13060:[[12452,12491,12531,12464],256],13061:[[12452,12531,12481],256],13062:[[12454,12457,12531],256],13063:[[12456,12473,12463,12540,12489],256],13064:[[12456,12540,12459,12540],256],13065:[[12458,12531,12473],256],13066:[[12458,12540,12512],256],13067:[[12459,12452,12522],256],13068:[[12459,12521,12483,12488],256],13069:[[12459,12525,12522,12540],256],13070:[[12460,12525,12531],256],13071:[[12460,12531,12510],256],13072:[[12462,12460],256],13073:[[12462,12491,12540],256],13074:[[12461,12517,12522,12540],256],13075:[[12462,12523,12480,12540],256],13076:[[12461,12525],256],13077:[[12461,12525,12464,12521,12512],256],13078:[[12461,12525,12513,12540,12488,12523],256],13079:[[12461,12525,12527,12483,12488],256],13080:[[12464,12521,12512],256],13081:[[12464,12521,12512,12488,12531],256],13082:[[12463,12523,12476,12452,12525],256],13083:[[12463,12525,12540,12493],256],13084:[[12465,12540,12473],256],13085:[[12467,12523,12490],256],13086:[[12467,12540,12509],256],13087:[[12469,12452,12463,12523],256],13088:[[12469,12531,12481,12540,12512],256],13089:[[12471,12522,12531,12464],256],13090:[[12475,12531,12481],256],13091:[[12475,12531,12488],256],13092:[[12480,12540,12473],256],13093:[[12487,12471],256],13094:[[12489,12523],256],13095:[[12488,12531],256],13096:[[12490,12494],256],13097:[[12494,12483,12488],256],13098:[[12495,12452,12484],256],13099:[[12497,12540,12475,12531,12488],256],13100:[[12497,12540,12484],256],13101:[[12496,12540,12524,12523],256],13102:[[12500,12450,12473,12488,12523],256],13103:[[12500,12463,12523],256],13104:[[12500,12467],256],13105:[[12499,12523],256],13106:[[12501,12449,12521,12483,12489],256],13107:[[12501,12451,12540,12488],256],13108:[[12502,12483,12471,12455,12523],256],13109:[[12501,12521,12531],256],13110:[[12504,12463,12479,12540,12523],256],13111:[[12506,12477],256],13112:[[12506,12491,12498],256],13113:[[12504,12523,12484],256],13114:[[12506,12531,12473],256],13115:[[12506,12540,12472],256],13116:[[12505,12540,12479],256],13117:[[12509,12452,12531,12488],256],13118:[[12508,12523,12488],256],13119:[[12507,12531],256],13120:[[12509,12531,12489],256],13121:[[12507,12540,12523],256],13122:[[12507,12540,12531],256],13123:[[12510,12452,12463,12525],256],13124:[[12510,12452,12523],256],13125:[[12510,12483,12495],256],13126:[[12510,12523,12463],256],13127:[[12510,12531,12471,12519,12531],256],13128:[[12511,12463,12525,12531],256],13129:[[12511,12522],256],13130:[[12511,12522,12496,12540,12523],256],13131:[[12513,12460],256],13132:[[12513,12460,12488,12531],256],13133:[[12513,12540,12488,12523],256],13134:[[12516,12540,12489],256],13135:[[12516,12540,12523],256],13136:[[12518,12450,12531],256],13137:[[12522,12483,12488,12523],256],13138:[[12522,12521],256],13139:[[12523,12500,12540],256],13140:[[12523,12540,12502,12523],256],13141:[[12524,12512],256],13142:[[12524,12531,12488,12466,12531],256],13143:[[12527,12483,12488],256],13144:[[48,28857],256],13145:[[49,28857],256],13146:[[50,28857],256],13147:[[51,28857],256],13148:[[52,28857],256],13149:[[53,28857],256],13150:[[54,28857],256],13151:[[55,28857],256],13152:[[56,28857],256],13153:[[57,28857],256],13154:[[49,48,28857],256],13155:[[49,49,28857],256],13156:[[49,50,28857],256],13157:[[49,51,28857],256],13158:[[49,52,28857],256],13159:[[49,53,28857],256],13160:[[49,54,28857],256],13161:[[49,55,28857],256],13162:[[49,56,28857],256],13163:[[49,57,28857],256],13164:[[50,48,28857],256],13165:[[50,49,28857],256],13166:[[50,50,28857],256],13167:[[50,51,28857],256],13168:[[50,52,28857],256],13169:[[104,80,97],256],13170:[[100,97],256],13171:[[65,85],256],13172:[[98,97,114],256],13173:[[111,86],256],13174:[[112,99],256],13175:[[100,109],256],13176:[[100,109,178],256],13177:[[100,109,179],256],13178:[[73,85],256],13179:[[24179,25104],256],13180:[[26157,21644],256],13181:[[22823,27491],256],13182:[[26126,27835],256],13183:[[26666,24335,20250,31038],256],13184:[[112,65],256],13185:[[110,65],256],13186:[[956,65],256],13187:[[109,65],256],13188:[[107,65],256],13189:[[75,66],256],13190:[[77,66],256],13191:[[71,66],256],13192:[[99,97,108],256],13193:[[107,99,97,108],256],13194:[[112,70],256],13195:[[110,70],256],13196:[[956,70],256],13197:[[956,103],256],13198:[[109,103],256],13199:[[107,103],256],13200:[[72,122],256],13201:[[107,72,122],256],13202:[[77,72,122],256],13203:[[71,72,122],256],13204:[[84,72,122],256],13205:[[956,8467],256],13206:[[109,8467],256],13207:[[100,8467],256],13208:[[107,8467],256],13209:[[102,109],256],13210:[[110,109],256],13211:[[956,109],256],13212:[[109,109],256],13213:[[99,109],256],13214:[[107,109],256],13215:[[109,109,178],256],13216:[[99,109,178],256],13217:[[109,178],256],13218:[[107,109,178],256],13219:[[109,109,179],256],13220:[[99,109,179],256],13221:[[109,179],256],13222:[[107,109,179],256],13223:[[109,8725,115],256],13224:[[109,8725,115,178],256],13225:[[80,97],256],13226:[[107,80,97],256],13227:[[77,80,97],256],13228:[[71,80,97],256],13229:[[114,97,100],256],13230:[[114,97,100,8725,115],256],13231:[[114,97,100,8725,115,178],256],13232:[[112,115],256],13233:[[110,115],256],13234:[[956,115],256],13235:[[109,115],256],13236:[[112,86],256],13237:[[110,86],256],13238:[[956,86],256],13239:[[109,86],256],13240:[[107,86],256],13241:[[77,86],256],13242:[[112,87],256],13243:[[110,87],256],13244:[[956,87],256],13245:[[109,87],256],13246:[[107,87],256],13247:[[77,87],256],13248:[[107,937],256],13249:[[77,937],256],13250:[[97,46,109,46],256],13251:[[66,113],256],13252:[[99,99],256],13253:[[99,100],256],13254:[[67,8725,107,103],256],13255:[[67,111,46],256],13256:[[100,66],256],13257:[[71,121],256],13258:[[104,97],256],13259:[[72,80],256],13260:[[105,110],256],13261:[[75,75],256],13262:[[75,77],256],13263:[[107,116],256],13264:[[108,109],256],13265:[[108,110],256],13266:[[108,111,103],256],13267:[[108,120],256],13268:[[109,98],256],13269:[[109,105,108],256],13270:[[109,111,108],256],13271:[[80,72],256],13272:[[112,46,109,46],256],13273:[[80,80,77],256],13274:[[80,82],256],13275:[[115,114],256],13276:[[83,118],256],13277:[[87,98],256],13278:[[86,8725,109],256],13279:[[65,8725,109],256],13280:[[49,26085],256],13281:[[50,26085],256],13282:[[51,26085],256],13283:[[52,26085],256],13284:[[53,26085],256],13285:[[54,26085],256],13286:[[55,26085],256],13287:[[56,26085],256],13288:[[57,26085],256],13289:[[49,48,26085],256],13290:[[49,49,26085],256],13291:[[49,50,26085],256],13292:[[49,51,26085],256],13293:[[49,52,26085],256],13294:[[49,53,26085],256],13295:[[49,54,26085],256],13296:[[49,55,26085],256],13297:[[49,56,26085],256],13298:[[49,57,26085],256],13299:[[50,48,26085],256],13300:[[50,49,26085],256],13301:[[50,50,26085],256],13302:[[50,51,26085],256],13303:[[50,52,26085],256],13304:[[50,53,26085],256],13305:[[50,54,26085],256],13306:[[50,55,26085],256],13307:[[50,56,26085],256],13308:[[50,57,26085],256],13309:[[51,48,26085],256],13310:[[51,49,26085],256],13311:[[103,97,108],256]},
27136:{92912:[,1],92913:[,1],92914:[,1],92915:[,1],92916:[,1]},
27392:{92976:[,230],92977:[,230],92978:[,230],92979:[,230],92980:[,230],92981:[,230],92982:[,230]},
42496:{42607:[,230],42612:[,230],42613:[,230],42614:[,230],42615:[,230],42616:[,230],42617:[,230],42618:[,230],42619:[,230],42620:[,230],42621:[,230],42652:[[1098],256],42653:[[1100],256],42655:[,230],42736:[,230],42737:[,230]},
42752:{42864:[[42863],256],43000:[[294],256],43001:[[339],256]},
43008:{43014:[,9],43204:[,9],43232:[,230],43233:[,230],43234:[,230],43235:[,230],43236:[,230],43237:[,230],43238:[,230],43239:[,230],43240:[,230],43241:[,230],43242:[,230],43243:[,230],43244:[,230],43245:[,230],43246:[,230],43247:[,230],43248:[,230],43249:[,230]},
43264:{43307:[,220],43308:[,220],43309:[,220],43347:[,9],43443:[,7],43456:[,9]},
43520:{43696:[,230],43698:[,230],43699:[,230],43700:[,220],43703:[,230],43704:[,230],43710:[,230],43711:[,230],43713:[,230],43766:[,9]},
43776:{43868:[[42791],256],43869:[[43831],256],43870:[[619],256],43871:[[43858],256],44013:[,9]},
48128:{113822:[,1]},
53504:{119134:[[119127,119141],512],119135:[[119128,119141],512],119136:[[119135,119150],512],119137:[[119135,119151],512],119138:[[119135,119152],512],119139:[[119135,119153],512],119140:[[119135,119154],512],119141:[,216],119142:[,216],119143:[,1],119144:[,1],119145:[,1],119149:[,226],119150:[,216],119151:[,216],119152:[,216],119153:[,216],119154:[,216],119163:[,220],119164:[,220],119165:[,220],119166:[,220],119167:[,220],119168:[,220],119169:[,220],119170:[,220],119173:[,230],119174:[,230],119175:[,230],119176:[,230],119177:[,230],119178:[,220],119179:[,220],119210:[,230],119211:[,230],119212:[,230],119213:[,230],119227:[[119225,119141],512],119228:[[119226,119141],512],119229:[[119227,119150],512],119230:[[119228,119150],512],119231:[[119227,119151],512],119232:[[119228,119151],512]},
53760:{119362:[,230],119363:[,230],119364:[,230]},
54272:{119808:[[65],256],119809:[[66],256],119810:[[67],256],119811:[[68],256],119812:[[69],256],119813:[[70],256],119814:[[71],256],119815:[[72],256],119816:[[73],256],119817:[[74],256],119818:[[75],256],119819:[[76],256],119820:[[77],256],119821:[[78],256],119822:[[79],256],119823:[[80],256],119824:[[81],256],119825:[[82],256],119826:[[83],256],119827:[[84],256],119828:[[85],256],119829:[[86],256],119830:[[87],256],119831:[[88],256],119832:[[89],256],119833:[[90],256],119834:[[97],256],119835:[[98],256],119836:[[99],256],119837:[[100],256],119838:[[101],256],119839:[[102],256],119840:[[103],256],119841:[[104],256],119842:[[105],256],119843:[[106],256],119844:[[107],256],119845:[[108],256],119846:[[109],256],119847:[[110],256],119848:[[111],256],119849:[[112],256],119850:[[113],256],119851:[[114],256],119852:[[115],256],119853:[[116],256],119854:[[117],256],119855:[[118],256],119856:[[119],256],119857:[[120],256],119858:[[121],256],119859:[[122],256],119860:[[65],256],119861:[[66],256],119862:[[67],256],119863:[[68],256],119864:[[69],256],119865:[[70],256],119866:[[71],256],119867:[[72],256],119868:[[73],256],119869:[[74],256],119870:[[75],256],119871:[[76],256],119872:[[77],256],119873:[[78],256],119874:[[79],256],119875:[[80],256],119876:[[81],256],119877:[[82],256],119878:[[83],256],119879:[[84],256],119880:[[85],256],119881:[[86],256],119882:[[87],256],119883:[[88],256],119884:[[89],256],119885:[[90],256],119886:[[97],256],119887:[[98],256],119888:[[99],256],119889:[[100],256],119890:[[101],256],119891:[[102],256],119892:[[103],256],119894:[[105],256],119895:[[106],256],119896:[[107],256],119897:[[108],256],119898:[[109],256],119899:[[110],256],119900:[[111],256],119901:[[112],256],119902:[[113],256],119903:[[114],256],119904:[[115],256],119905:[[116],256],119906:[[117],256],119907:[[118],256],119908:[[119],256],119909:[[120],256],119910:[[121],256],119911:[[122],256],119912:[[65],256],119913:[[66],256],119914:[[67],256],119915:[[68],256],119916:[[69],256],119917:[[70],256],119918:[[71],256],119919:[[72],256],119920:[[73],256],119921:[[74],256],119922:[[75],256],119923:[[76],256],119924:[[77],256],119925:[[78],256],119926:[[79],256],119927:[[80],256],119928:[[81],256],119929:[[82],256],119930:[[83],256],119931:[[84],256],119932:[[85],256],119933:[[86],256],119934:[[87],256],119935:[[88],256],119936:[[89],256],119937:[[90],256],119938:[[97],256],119939:[[98],256],119940:[[99],256],119941:[[100],256],119942:[[101],256],119943:[[102],256],119944:[[103],256],119945:[[104],256],119946:[[105],256],119947:[[106],256],119948:[[107],256],119949:[[108],256],119950:[[109],256],119951:[[110],256],119952:[[111],256],119953:[[112],256],119954:[[113],256],119955:[[114],256],119956:[[115],256],119957:[[116],256],119958:[[117],256],119959:[[118],256],119960:[[119],256],119961:[[120],256],119962:[[121],256],119963:[[122],256],119964:[[65],256],119966:[[67],256],119967:[[68],256],119970:[[71],256],119973:[[74],256],119974:[[75],256],119977:[[78],256],119978:[[79],256],119979:[[80],256],119980:[[81],256],119982:[[83],256],119983:[[84],256],119984:[[85],256],119985:[[86],256],119986:[[87],256],119987:[[88],256],119988:[[89],256],119989:[[90],256],119990:[[97],256],119991:[[98],256],119992:[[99],256],119993:[[100],256],119995:[[102],256],119997:[[104],256],119998:[[105],256],119999:[[106],256],120000:[[107],256],120001:[[108],256],120002:[[109],256],120003:[[110],256],120005:[[112],256],120006:[[113],256],120007:[[114],256],120008:[[115],256],120009:[[116],256],120010:[[117],256],120011:[[118],256],120012:[[119],256],120013:[[120],256],120014:[[121],256],120015:[[122],256],120016:[[65],256],120017:[[66],256],120018:[[67],256],120019:[[68],256],120020:[[69],256],120021:[[70],256],120022:[[71],256],120023:[[72],256],120024:[[73],256],120025:[[74],256],120026:[[75],256],120027:[[76],256],120028:[[77],256],120029:[[78],256],120030:[[79],256],120031:[[80],256],120032:[[81],256],120033:[[82],256],120034:[[83],256],120035:[[84],256],120036:[[85],256],120037:[[86],256],120038:[[87],256],120039:[[88],256],120040:[[89],256],120041:[[90],256],120042:[[97],256],120043:[[98],256],120044:[[99],256],120045:[[100],256],120046:[[101],256],120047:[[102],256],120048:[[103],256],120049:[[104],256],120050:[[105],256],120051:[[106],256],120052:[[107],256],120053:[[108],256],120054:[[109],256],120055:[[110],256],120056:[[111],256],120057:[[112],256],120058:[[113],256],120059:[[114],256],120060:[[115],256],120061:[[116],256],120062:[[117],256],120063:[[118],256]},
54528:{120064:[[119],256],120065:[[120],256],120066:[[121],256],120067:[[122],256],120068:[[65],256],120069:[[66],256],120071:[[68],256],120072:[[69],256],120073:[[70],256],120074:[[71],256],120077:[[74],256],120078:[[75],256],120079:[[76],256],120080:[[77],256],120081:[[78],256],120082:[[79],256],120083:[[80],256],120084:[[81],256],120086:[[83],256],120087:[[84],256],120088:[[85],256],120089:[[86],256],120090:[[87],256],120091:[[88],256],120092:[[89],256],120094:[[97],256],120095:[[98],256],120096:[[99],256],120097:[[100],256],120098:[[101],256],120099:[[102],256],120100:[[103],256],120101:[[104],256],120102:[[105],256],120103:[[106],256],120104:[[107],256],120105:[[108],256],120106:[[109],256],120107:[[110],256],120108:[[111],256],120109:[[112],256],120110:[[113],256],120111:[[114],256],120112:[[115],256],120113:[[116],256],120114:[[117],256],120115:[[118],256],120116:[[119],256],120117:[[120],256],120118:[[121],256],120119:[[122],256],120120:[[65],256],120121:[[66],256],120123:[[68],256],120124:[[69],256],120125:[[70],256],120126:[[71],256],120128:[[73],256],120129:[[74],256],120130:[[75],256],120131:[[76],256],120132:[[77],256],120134:[[79],256],120138:[[83],256],120139:[[84],256],120140:[[85],256],120141:[[86],256],120142:[[87],256],120143:[[88],256],120144:[[89],256],120146:[[97],256],120147:[[98],256],120148:[[99],256],120149:[[100],256],120150:[[101],256],120151:[[102],256],120152:[[103],256],120153:[[104],256],120154:[[105],256],120155:[[106],256],120156:[[107],256],120157:[[108],256],120158:[[109],256],120159:[[110],256],120160:[[111],256],120161:[[112],256],120162:[[113],256],120163:[[114],256],120164:[[115],256],120165:[[116],256],120166:[[117],256],120167:[[118],256],120168:[[119],256],120169:[[120],256],120170:[[121],256],120171:[[122],256],120172:[[65],256],120173:[[66],256],120174:[[67],256],120175:[[68],256],120176:[[69],256],120177:[[70],256],120178:[[71],256],120179:[[72],256],120180:[[73],256],120181:[[74],256],120182:[[75],256],120183:[[76],256],120184:[[77],256],120185:[[78],256],120186:[[79],256],120187:[[80],256],120188:[[81],256],120189:[[82],256],120190:[[83],256],120191:[[84],256],120192:[[85],256],120193:[[86],256],120194:[[87],256],120195:[[88],256],120196:[[89],256],120197:[[90],256],120198:[[97],256],120199:[[98],256],120200:[[99],256],120201:[[100],256],120202:[[101],256],120203:[[102],256],120204:[[103],256],120205:[[104],256],120206:[[105],256],120207:[[106],256],120208:[[107],256],120209:[[108],256],120210:[[109],256],120211:[[110],256],120212:[[111],256],120213:[[112],256],120214:[[113],256],120215:[[114],256],120216:[[115],256],120217:[[116],256],120218:[[117],256],120219:[[118],256],120220:[[119],256],120221:[[120],256],120222:[[121],256],120223:[[122],256],120224:[[65],256],120225:[[66],256],120226:[[67],256],120227:[[68],256],120228:[[69],256],120229:[[70],256],120230:[[71],256],120231:[[72],256],120232:[[73],256],120233:[[74],256],120234:[[75],256],120235:[[76],256],120236:[[77],256],120237:[[78],256],120238:[[79],256],120239:[[80],256],120240:[[81],256],120241:[[82],256],120242:[[83],256],120243:[[84],256],120244:[[85],256],120245:[[86],256],120246:[[87],256],120247:[[88],256],120248:[[89],256],120249:[[90],256],120250:[[97],256],120251:[[98],256],120252:[[99],256],120253:[[100],256],120254:[[101],256],120255:[[102],256],120256:[[103],256],120257:[[104],256],120258:[[105],256],120259:[[106],256],120260:[[107],256],120261:[[108],256],120262:[[109],256],120263:[[110],256],120264:[[111],256],120265:[[112],256],120266:[[113],256],120267:[[114],256],120268:[[115],256],120269:[[116],256],120270:[[117],256],120271:[[118],256],120272:[[119],256],120273:[[120],256],120274:[[121],256],120275:[[122],256],120276:[[65],256],120277:[[66],256],120278:[[67],256],120279:[[68],256],120280:[[69],256],120281:[[70],256],120282:[[71],256],120283:[[72],256],120284:[[73],256],120285:[[74],256],120286:[[75],256],120287:[[76],256],120288:[[77],256],120289:[[78],256],120290:[[79],256],120291:[[80],256],120292:[[81],256],120293:[[82],256],120294:[[83],256],120295:[[84],256],120296:[[85],256],120297:[[86],256],120298:[[87],256],120299:[[88],256],120300:[[89],256],120301:[[90],256],120302:[[97],256],120303:[[98],256],120304:[[99],256],120305:[[100],256],120306:[[101],256],120307:[[102],256],120308:[[103],256],120309:[[104],256],120310:[[105],256],120311:[[106],256],120312:[[107],256],120313:[[108],256],120314:[[109],256],120315:[[110],256],120316:[[111],256],120317:[[112],256],120318:[[113],256],120319:[[114],256]},
54784:{120320:[[115],256],120321:[[116],256],120322:[[117],256],120323:[[118],256],120324:[[119],256],120325:[[120],256],120326:[[121],256],120327:[[122],256],120328:[[65],256],120329:[[66],256],120330:[[67],256],120331:[[68],256],120332:[[69],256],120333:[[70],256],120334:[[71],256],120335:[[72],256],120336:[[73],256],120337:[[74],256],120338:[[75],256],120339:[[76],256],120340:[[77],256],120341:[[78],256],120342:[[79],256],120343:[[80],256],120344:[[81],256],120345:[[82],256],120346:[[83],256],120347:[[84],256],120348:[[85],256],120349:[[86],256],120350:[[87],256],120351:[[88],256],120352:[[89],256],120353:[[90],256],120354:[[97],256],120355:[[98],256],120356:[[99],256],120357:[[100],256],120358:[[101],256],120359:[[102],256],120360:[[103],256],120361:[[104],256],120362:[[105],256],120363:[[106],256],120364:[[107],256],120365:[[108],256],120366:[[109],256],120367:[[110],256],120368:[[111],256],120369:[[112],256],120370:[[113],256],120371:[[114],256],120372:[[115],256],120373:[[116],256],120374:[[117],256],120375:[[118],256],120376:[[119],256],120377:[[120],256],120378:[[121],256],120379:[[122],256],120380:[[65],256],120381:[[66],256],120382:[[67],256],120383:[[68],256],120384:[[69],256],120385:[[70],256],120386:[[71],256],120387:[[72],256],120388:[[73],256],120389:[[74],256],120390:[[75],256],120391:[[76],256],120392:[[77],256],120393:[[78],256],120394:[[79],256],120395:[[80],256],120396:[[81],256],120397:[[82],256],120398:[[83],256],120399:[[84],256],120400:[[85],256],120401:[[86],256],120402:[[87],256],120403:[[88],256],120404:[[89],256],120405:[[90],256],120406:[[97],256],120407:[[98],256],120408:[[99],256],120409:[[100],256],120410:[[101],256],120411:[[102],256],120412:[[103],256],120413:[[104],256],120414:[[105],256],120415:[[106],256],120416:[[107],256],120417:[[108],256],120418:[[109],256],120419:[[110],256],120420:[[111],256],120421:[[112],256],120422:[[113],256],120423:[[114],256],120424:[[115],256],120425:[[116],256],120426:[[117],256],120427:[[118],256],120428:[[119],256],120429:[[120],256],120430:[[121],256],120431:[[122],256],120432:[[65],256],120433:[[66],256],120434:[[67],256],120435:[[68],256],120436:[[69],256],120437:[[70],256],120438:[[71],256],120439:[[72],256],120440:[[73],256],120441:[[74],256],120442:[[75],256],120443:[[76],256],120444:[[77],256],120445:[[78],256],120446:[[79],256],120447:[[80],256],120448:[[81],256],120449:[[82],256],120450:[[83],256],120451:[[84],256],120452:[[85],256],120453:[[86],256],120454:[[87],256],120455:[[88],256],120456:[[89],256],120457:[[90],256],120458:[[97],256],120459:[[98],256],120460:[[99],256],120461:[[100],256],120462:[[101],256],120463:[[102],256],120464:[[103],256],120465:[[104],256],120466:[[105],256],120467:[[106],256],120468:[[107],256],120469:[[108],256],120470:[[109],256],120471:[[110],256],120472:[[111],256],120473:[[112],256],120474:[[113],256],120475:[[114],256],120476:[[115],256],120477:[[116],256],120478:[[117],256],120479:[[118],256],120480:[[119],256],120481:[[120],256],120482:[[121],256],120483:[[122],256],120484:[[305],256],120485:[[567],256],120488:[[913],256],120489:[[914],256],120490:[[915],256],120491:[[916],256],120492:[[917],256],120493:[[918],256],120494:[[919],256],120495:[[920],256],120496:[[921],256],120497:[[922],256],120498:[[923],256],120499:[[924],256],120500:[[925],256],120501:[[926],256],120502:[[927],256],120503:[[928],256],120504:[[929],256],120505:[[1012],256],120506:[[931],256],120507:[[932],256],120508:[[933],256],120509:[[934],256],120510:[[935],256],120511:[[936],256],120512:[[937],256],120513:[[8711],256],120514:[[945],256],120515:[[946],256],120516:[[947],256],120517:[[948],256],120518:[[949],256],120519:[[950],256],120520:[[951],256],120521:[[952],256],120522:[[953],256],120523:[[954],256],120524:[[955],256],120525:[[956],256],120526:[[957],256],120527:[[958],256],120528:[[959],256],120529:[[960],256],120530:[[961],256],120531:[[962],256],120532:[[963],256],120533:[[964],256],120534:[[965],256],120535:[[966],256],120536:[[967],256],120537:[[968],256],120538:[[969],256],120539:[[8706],256],120540:[[1013],256],120541:[[977],256],120542:[[1008],256],120543:[[981],256],120544:[[1009],256],120545:[[982],256],120546:[[913],256],120547:[[914],256],120548:[[915],256],120549:[[916],256],120550:[[917],256],120551:[[918],256],120552:[[919],256],120553:[[920],256],120554:[[921],256],120555:[[922],256],120556:[[923],256],120557:[[924],256],120558:[[925],256],120559:[[926],256],120560:[[927],256],120561:[[928],256],120562:[[929],256],120563:[[1012],256],120564:[[931],256],120565:[[932],256],120566:[[933],256],120567:[[934],256],120568:[[935],256],120569:[[936],256],120570:[[937],256],120571:[[8711],256],120572:[[945],256],120573:[[946],256],120574:[[947],256],120575:[[948],256]},
55040:{120576:[[949],256],120577:[[950],256],120578:[[951],256],120579:[[952],256],120580:[[953],256],120581:[[954],256],120582:[[955],256],120583:[[956],256],120584:[[957],256],120585:[[958],256],120586:[[959],256],120587:[[960],256],120588:[[961],256],120589:[[962],256],120590:[[963],256],120591:[[964],256],120592:[[965],256],120593:[[966],256],120594:[[967],256],120595:[[968],256],120596:[[969],256],120597:[[8706],256],120598:[[1013],256],120599:[[977],256],120600:[[1008],256],120601:[[981],256],120602:[[1009],256],120603:[[982],256],120604:[[913],256],120605:[[914],256],120606:[[915],256],120607:[[916],256],120608:[[917],256],120609:[[918],256],120610:[[919],256],120611:[[920],256],120612:[[921],256],120613:[[922],256],120614:[[923],256],120615:[[924],256],120616:[[925],256],120617:[[926],256],120618:[[927],256],120619:[[928],256],120620:[[929],256],120621:[[1012],256],120622:[[931],256],120623:[[932],256],120624:[[933],256],120625:[[934],256],120626:[[935],256],120627:[[936],256],120628:[[937],256],120629:[[8711],256],120630:[[945],256],120631:[[946],256],120632:[[947],256],120633:[[948],256],120634:[[949],256],120635:[[950],256],120636:[[951],256],120637:[[952],256],120638:[[953],256],120639:[[954],256],120640:[[955],256],120641:[[956],256],120642:[[957],256],120643:[[958],256],120644:[[959],256],120645:[[960],256],120646:[[961],256],120647:[[962],256],120648:[[963],256],120649:[[964],256],120650:[[965],256],120651:[[966],256],120652:[[967],256],120653:[[968],256],120654:[[969],256],120655:[[8706],256],120656:[[1013],256],120657:[[977],256],120658:[[1008],256],120659:[[981],256],120660:[[1009],256],120661:[[982],256],120662:[[913],256],120663:[[914],256],120664:[[915],256],120665:[[916],256],120666:[[917],256],120667:[[918],256],120668:[[919],256],120669:[[920],256],120670:[[921],256],120671:[[922],256],120672:[[923],256],120673:[[924],256],120674:[[925],256],120675:[[926],256],120676:[[927],256],120677:[[928],256],120678:[[929],256],120679:[[1012],256],120680:[[931],256],120681:[[932],256],120682:[[933],256],120683:[[934],256],120684:[[935],256],120685:[[936],256],120686:[[937],256],120687:[[8711],256],120688:[[945],256],120689:[[946],256],120690:[[947],256],120691:[[948],256],120692:[[949],256],120693:[[950],256],120694:[[951],256],120695:[[952],256],120696:[[953],256],120697:[[954],256],120698:[[955],256],120699:[[956],256],120700:[[957],256],120701:[[958],256],120702:[[959],256],120703:[[960],256],120704:[[961],256],120705:[[962],256],120706:[[963],256],120707:[[964],256],120708:[[965],256],120709:[[966],256],120710:[[967],256],120711:[[968],256],120712:[[969],256],120713:[[8706],256],120714:[[1013],256],120715:[[977],256],120716:[[1008],256],120717:[[981],256],120718:[[1009],256],120719:[[982],256],120720:[[913],256],120721:[[914],256],120722:[[915],256],120723:[[916],256],120724:[[917],256],120725:[[918],256],120726:[[919],256],120727:[[920],256],120728:[[921],256],120729:[[922],256],120730:[[923],256],120731:[[924],256],120732:[[925],256],120733:[[926],256],120734:[[927],256],120735:[[928],256],120736:[[929],256],120737:[[1012],256],120738:[[931],256],120739:[[932],256],120740:[[933],256],120741:[[934],256],120742:[[935],256],120743:[[936],256],120744:[[937],256],120745:[[8711],256],120746:[[945],256],120747:[[946],256],120748:[[947],256],120749:[[948],256],120750:[[949],256],120751:[[950],256],120752:[[951],256],120753:[[952],256],120754:[[953],256],120755:[[954],256],120756:[[955],256],120757:[[956],256],120758:[[957],256],120759:[[958],256],120760:[[959],256],120761:[[960],256],120762:[[961],256],120763:[[962],256],120764:[[963],256],120765:[[964],256],120766:[[965],256],120767:[[966],256],120768:[[967],256],120769:[[968],256],120770:[[969],256],120771:[[8706],256],120772:[[1013],256],120773:[[977],256],120774:[[1008],256],120775:[[981],256],120776:[[1009],256],120777:[[982],256],120778:[[988],256],120779:[[989],256],120782:[[48],256],120783:[[49],256],120784:[[50],256],120785:[[51],256],120786:[[52],256],120787:[[53],256],120788:[[54],256],120789:[[55],256],120790:[[56],256],120791:[[57],256],120792:[[48],256],120793:[[49],256],120794:[[50],256],120795:[[51],256],120796:[[52],256],120797:[[53],256],120798:[[54],256],120799:[[55],256],120800:[[56],256],120801:[[57],256],120802:[[48],256],120803:[[49],256],120804:[[50],256],120805:[[51],256],120806:[[52],256],120807:[[53],256],120808:[[54],256],120809:[[55],256],120810:[[56],256],120811:[[57],256],120812:[[48],256],120813:[[49],256],120814:[[50],256],120815:[[51],256],120816:[[52],256],120817:[[53],256],120818:[[54],256],120819:[[55],256],120820:[[56],256],120821:[[57],256],120822:[[48],256],120823:[[49],256],120824:[[50],256],120825:[[51],256],120826:[[52],256],120827:[[53],256],120828:[[54],256],120829:[[55],256],120830:[[56],256],120831:[[57],256]},
59392:{125136:[,220],125137:[,220],125138:[,220],125139:[,220],125140:[,220],125141:[,220],125142:[,220]},
60928:{126464:[[1575],256],126465:[[1576],256],126466:[[1580],256],126467:[[1583],256],126469:[[1608],256],126470:[[1586],256],126471:[[1581],256],126472:[[1591],256],126473:[[1610],256],126474:[[1603],256],126475:[[1604],256],126476:[[1605],256],126477:[[1606],256],126478:[[1587],256],126479:[[1593],256],126480:[[1601],256],126481:[[1589],256],126482:[[1602],256],126483:[[1585],256],126484:[[1588],256],126485:[[1578],256],126486:[[1579],256],126487:[[1582],256],126488:[[1584],256],126489:[[1590],256],126490:[[1592],256],126491:[[1594],256],126492:[[1646],256],126493:[[1722],256],126494:[[1697],256],126495:[[1647],256],126497:[[1576],256],126498:[[1580],256],126500:[[1607],256],126503:[[1581],256],126505:[[1610],256],126506:[[1603],256],126507:[[1604],256],126508:[[1605],256],126509:[[1606],256],126510:[[1587],256],126511:[[1593],256],126512:[[1601],256],126513:[[1589],256],126514:[[1602],256],126516:[[1588],256],126517:[[1578],256],126518:[[1579],256],126519:[[1582],256],126521:[[1590],256],126523:[[1594],256],126530:[[1580],256],126535:[[1581],256],126537:[[1610],256],126539:[[1604],256],126541:[[1606],256],126542:[[1587],256],126543:[[1593],256],126545:[[1589],256],126546:[[1602],256],126548:[[1588],256],126551:[[1582],256],126553:[[1590],256],126555:[[1594],256],126557:[[1722],256],126559:[[1647],256],126561:[[1576],256],126562:[[1580],256],126564:[[1607],256],126567:[[1581],256],126568:[[1591],256],126569:[[1610],256],126570:[[1603],256],126572:[[1605],256],126573:[[1606],256],126574:[[1587],256],126575:[[1593],256],126576:[[1601],256],126577:[[1589],256],126578:[[1602],256],126580:[[1588],256],126581:[[1578],256],126582:[[1579],256],126583:[[1582],256],126585:[[1590],256],126586:[[1592],256],126587:[[1594],256],126588:[[1646],256],126590:[[1697],256],126592:[[1575],256],126593:[[1576],256],126594:[[1580],256],126595:[[1583],256],126596:[[1607],256],126597:[[1608],256],126598:[[1586],256],126599:[[1581],256],126600:[[1591],256],126601:[[1610],256],126603:[[1604],256],126604:[[1605],256],126605:[[1606],256],126606:[[1587],256],126607:[[1593],256],126608:[[1601],256],126609:[[1589],256],126610:[[1602],256],126611:[[1585],256],126612:[[1588],256],126613:[[1578],256],126614:[[1579],256],126615:[[1582],256],126616:[[1584],256],126617:[[1590],256],126618:[[1592],256],126619:[[1594],256],126625:[[1576],256],126626:[[1580],256],126627:[[1583],256],126629:[[1608],256],126630:[[1586],256],126631:[[1581],256],126632:[[1591],256],126633:[[1610],256],126635:[[1604],256],126636:[[1605],256],126637:[[1606],256],126638:[[1587],256],126639:[[1593],256],126640:[[1601],256],126641:[[1589],256],126642:[[1602],256],126643:[[1585],256],126644:[[1588],256],126645:[[1578],256],126646:[[1579],256],126647:[[1582],256],126648:[[1584],256],126649:[[1590],256],126650:[[1592],256],126651:[[1594],256]},
61696:{127232:[[48,46],256],127233:[[48,44],256],127234:[[49,44],256],127235:[[50,44],256],127236:[[51,44],256],127237:[[52,44],256],127238:[[53,44],256],127239:[[54,44],256],127240:[[55,44],256],127241:[[56,44],256],127242:[[57,44],256],127248:[[40,65,41],256],127249:[[40,66,41],256],127250:[[40,67,41],256],127251:[[40,68,41],256],127252:[[40,69,41],256],127253:[[40,70,41],256],127254:[[40,71,41],256],127255:[[40,72,41],256],127256:[[40,73,41],256],127257:[[40,74,41],256],127258:[[40,75,41],256],127259:[[40,76,41],256],127260:[[40,77,41],256],127261:[[40,78,41],256],127262:[[40,79,41],256],127263:[[40,80,41],256],127264:[[40,81,41],256],127265:[[40,82,41],256],127266:[[40,83,41],256],127267:[[40,84,41],256],127268:[[40,85,41],256],127269:[[40,86,41],256],127270:[[40,87,41],256],127271:[[40,88,41],256],127272:[[40,89,41],256],127273:[[40,90,41],256],127274:[[12308,83,12309],256],127275:[[67],256],127276:[[82],256],127277:[[67,68],256],127278:[[87,90],256],127280:[[65],256],127281:[[66],256],127282:[[67],256],127283:[[68],256],127284:[[69],256],127285:[[70],256],127286:[[71],256],127287:[[72],256],127288:[[73],256],127289:[[74],256],127290:[[75],256],127291:[[76],256],127292:[[77],256],127293:[[78],256],127294:[[79],256],127295:[[80],256],127296:[[81],256],127297:[[82],256],127298:[[83],256],127299:[[84],256],127300:[[85],256],127301:[[86],256],127302:[[87],256],127303:[[88],256],127304:[[89],256],127305:[[90],256],127306:[[72,86],256],127307:[[77,86],256],127308:[[83,68],256],127309:[[83,83],256],127310:[[80,80,86],256],127311:[[87,67],256],127338:[[77,67],256],127339:[[77,68],256],127376:[[68,74],256]},
61952:{127488:[[12411,12363],256],127489:[[12467,12467],256],127490:[[12469],256],127504:[[25163],256],127505:[[23383],256],127506:[[21452],256],127507:[[12487],256],127508:[[20108],256],127509:[[22810],256],127510:[[35299],256],127511:[[22825],256],127512:[[20132],256],127513:[[26144],256],127514:[[28961],256],127515:[[26009],256],127516:[[21069],256],127517:[[24460],256],127518:[[20877],256],127519:[[26032],256],127520:[[21021],256],127521:[[32066],256],127522:[[29983],256],127523:[[36009],256],127524:[[22768],256],127525:[[21561],256],127526:[[28436],256],127527:[[25237],256],127528:[[25429],256],127529:[[19968],256],127530:[[19977],256],127531:[[36938],256],127532:[[24038],256],127533:[[20013],256],127534:[[21491],256],127535:[[25351],256],127536:[[36208],256],127537:[[25171],256],127538:[[31105],256],127539:[[31354],256],127540:[[21512],256],127541:[[28288],256],127542:[[26377],256],127543:[[26376],256],127544:[[30003],256],127545:[[21106],256],127546:[[21942],256],127552:[[12308,26412,12309],256],127553:[[12308,19977,12309],256],127554:[[12308,20108,12309],256],127555:[[12308,23433,12309],256],127556:[[12308,28857,12309],256],127557:[[12308,25171,12309],256],127558:[[12308,30423,12309],256],127559:[[12308,21213,12309],256],127560:[[12308,25943,12309],256],127568:[[24471],256],127569:[[21487],256]},
63488:{194560:[[20029]],194561:[[20024]],194562:[[20033]],194563:[[131362]],194564:[[20320]],194565:[[20398]],194566:[[20411]],194567:[[20482]],194568:[[20602]],194569:[[20633]],194570:[[20711]],194571:[[20687]],194572:[[13470]],194573:[[132666]],194574:[[20813]],194575:[[20820]],194576:[[20836]],194577:[[20855]],194578:[[132380]],194579:[[13497]],194580:[[20839]],194581:[[20877]],194582:[[132427]],194583:[[20887]],194584:[[20900]],194585:[[20172]],194586:[[20908]],194587:[[20917]],194588:[[168415]],194589:[[20981]],194590:[[20995]],194591:[[13535]],194592:[[21051]],194593:[[21062]],194594:[[21106]],194595:[[21111]],194596:[[13589]],194597:[[21191]],194598:[[21193]],194599:[[21220]],194600:[[21242]],194601:[[21253]],194602:[[21254]],194603:[[21271]],194604:[[21321]],194605:[[21329]],194606:[[21338]],194607:[[21363]],194608:[[21373]],194609:[[21375]],194610:[[21375]],194611:[[21375]],194612:[[133676]],194613:[[28784]],194614:[[21450]],194615:[[21471]],194616:[[133987]],194617:[[21483]],194618:[[21489]],194619:[[21510]],194620:[[21662]],194621:[[21560]],194622:[[21576]],194623:[[21608]],194624:[[21666]],194625:[[21750]],194626:[[21776]],194627:[[21843]],194628:[[21859]],194629:[[21892]],194630:[[21892]],194631:[[21913]],194632:[[21931]],194633:[[21939]],194634:[[21954]],194635:[[22294]],194636:[[22022]],194637:[[22295]],194638:[[22097]],194639:[[22132]],194640:[[20999]],194641:[[22766]],194642:[[22478]],194643:[[22516]],194644:[[22541]],194645:[[22411]],194646:[[22578]],194647:[[22577]],194648:[[22700]],194649:[[136420]],194650:[[22770]],194651:[[22775]],194652:[[22790]],194653:[[22810]],194654:[[22818]],194655:[[22882]],194656:[[136872]],194657:[[136938]],194658:[[23020]],194659:[[23067]],194660:[[23079]],194661:[[23000]],194662:[[23142]],194663:[[14062]],194664:[[14076]],194665:[[23304]],194666:[[23358]],194667:[[23358]],194668:[[137672]],194669:[[23491]],194670:[[23512]],194671:[[23527]],194672:[[23539]],194673:[[138008]],194674:[[23551]],194675:[[23558]],194676:[[24403]],194677:[[23586]],194678:[[14209]],194679:[[23648]],194680:[[23662]],194681:[[23744]],194682:[[23693]],194683:[[138724]],194684:[[23875]],194685:[[138726]],194686:[[23918]],194687:[[23915]],194688:[[23932]],194689:[[24033]],194690:[[24034]],194691:[[14383]],194692:[[24061]],194693:[[24104]],194694:[[24125]],194695:[[24169]],194696:[[14434]],194697:[[139651]],194698:[[14460]],194699:[[24240]],194700:[[24243]],194701:[[24246]],194702:[[24266]],194703:[[172946]],194704:[[24318]],194705:[[140081]],194706:[[140081]],194707:[[33281]],194708:[[24354]],194709:[[24354]],194710:[[14535]],194711:[[144056]],194712:[[156122]],194713:[[24418]],194714:[[24427]],194715:[[14563]],194716:[[24474]],194717:[[24525]],194718:[[24535]],194719:[[24569]],194720:[[24705]],194721:[[14650]],194722:[[14620]],194723:[[24724]],194724:[[141012]],194725:[[24775]],194726:[[24904]],194727:[[24908]],194728:[[24910]],194729:[[24908]],194730:[[24954]],194731:[[24974]],194732:[[25010]],194733:[[24996]],194734:[[25007]],194735:[[25054]],194736:[[25074]],194737:[[25078]],194738:[[25104]],194739:[[25115]],194740:[[25181]],194741:[[25265]],194742:[[25300]],194743:[[25424]],194744:[[142092]],194745:[[25405]],194746:[[25340]],194747:[[25448]],194748:[[25475]],194749:[[25572]],194750:[[142321]],194751:[[25634]],194752:[[25541]],194753:[[25513]],194754:[[14894]],194755:[[25705]],194756:[[25726]],194757:[[25757]],194758:[[25719]],194759:[[14956]],194760:[[25935]],194761:[[25964]],194762:[[143370]],194763:[[26083]],194764:[[26360]],194765:[[26185]],194766:[[15129]],194767:[[26257]],194768:[[15112]],194769:[[15076]],194770:[[20882]],194771:[[20885]],194772:[[26368]],194773:[[26268]],194774:[[32941]],194775:[[17369]],194776:[[26391]],194777:[[26395]],194778:[[26401]],194779:[[26462]],194780:[[26451]],194781:[[144323]],194782:[[15177]],194783:[[26618]],194784:[[26501]],194785:[[26706]],194786:[[26757]],194787:[[144493]],194788:[[26766]],194789:[[26655]],194790:[[26900]],194791:[[15261]],194792:[[26946]],194793:[[27043]],194794:[[27114]],194795:[[27304]],194796:[[145059]],194797:[[27355]],194798:[[15384]],194799:[[27425]],194800:[[145575]],194801:[[27476]],194802:[[15438]],194803:[[27506]],194804:[[27551]],194805:[[27578]],194806:[[27579]],194807:[[146061]],194808:[[138507]],194809:[[146170]],194810:[[27726]],194811:[[146620]],194812:[[27839]],194813:[[27853]],194814:[[27751]],194815:[[27926]]},
63744:{63744:[[35912]],63745:[[26356]],63746:[[36554]],63747:[[36040]],63748:[[28369]],63749:[[20018]],63750:[[21477]],63751:[[40860]],63752:[[40860]],63753:[[22865]],63754:[[37329]],63755:[[21895]],63756:[[22856]],63757:[[25078]],63758:[[30313]],63759:[[32645]],63760:[[34367]],63761:[[34746]],63762:[[35064]],63763:[[37007]],63764:[[27138]],63765:[[27931]],63766:[[28889]],63767:[[29662]],63768:[[33853]],63769:[[37226]],63770:[[39409]],63771:[[20098]],63772:[[21365]],63773:[[27396]],63774:[[29211]],63775:[[34349]],63776:[[40478]],63777:[[23888]],63778:[[28651]],63779:[[34253]],63780:[[35172]],63781:[[25289]],63782:[[33240]],63783:[[34847]],63784:[[24266]],63785:[[26391]],63786:[[28010]],63787:[[29436]],63788:[[37070]],63789:[[20358]],63790:[[20919]],63791:[[21214]],63792:[[25796]],63793:[[27347]],63794:[[29200]],63795:[[30439]],63796:[[32769]],63797:[[34310]],63798:[[34396]],63799:[[36335]],63800:[[38706]],63801:[[39791]],63802:[[40442]],63803:[[30860]],63804:[[31103]],63805:[[32160]],63806:[[33737]],63807:[[37636]],63808:[[40575]],63809:[[35542]],63810:[[22751]],63811:[[24324]],63812:[[31840]],63813:[[32894]],63814:[[29282]],63815:[[30922]],63816:[[36034]],63817:[[38647]],63818:[[22744]],63819:[[23650]],63820:[[27155]],63821:[[28122]],63822:[[28431]],63823:[[32047]],63824:[[32311]],63825:[[38475]],63826:[[21202]],63827:[[32907]],63828:[[20956]],63829:[[20940]],63830:[[31260]],63831:[[32190]],63832:[[33777]],63833:[[38517]],63834:[[35712]],63835:[[25295]],63836:[[27138]],63837:[[35582]],63838:[[20025]],63839:[[23527]],63840:[[24594]],63841:[[29575]],63842:[[30064]],63843:[[21271]],63844:[[30971]],63845:[[20415]],63846:[[24489]],63847:[[19981]],63848:[[27852]],63849:[[25976]],63850:[[32034]],63851:[[21443]],63852:[[22622]],63853:[[30465]],63854:[[33865]],63855:[[35498]],63856:[[27578]],63857:[[36784]],63858:[[27784]],63859:[[25342]],63860:[[33509]],63861:[[25504]],63862:[[30053]],63863:[[20142]],63864:[[20841]],63865:[[20937]],63866:[[26753]],63867:[[31975]],63868:[[33391]],63869:[[35538]],63870:[[37327]],63871:[[21237]],63872:[[21570]],63873:[[22899]],63874:[[24300]],63875:[[26053]],63876:[[28670]],63877:[[31018]],63878:[[38317]],63879:[[39530]],63880:[[40599]],63881:[[40654]],63882:[[21147]],63883:[[26310]],63884:[[27511]],63885:[[36706]],63886:[[24180]],63887:[[24976]],63888:[[25088]],63889:[[25754]],63890:[[28451]],63891:[[29001]],63892:[[29833]],63893:[[31178]],63894:[[32244]],63895:[[32879]],63896:[[36646]],63897:[[34030]],63898:[[36899]],63899:[[37706]],63900:[[21015]],63901:[[21155]],63902:[[21693]],63903:[[28872]],63904:[[35010]],63905:[[35498]],63906:[[24265]],63907:[[24565]],63908:[[25467]],63909:[[27566]],63910:[[31806]],63911:[[29557]],63912:[[20196]],63913:[[22265]],63914:[[23527]],63915:[[23994]],63916:[[24604]],63917:[[29618]],63918:[[29801]],63919:[[32666]],63920:[[32838]],63921:[[37428]],63922:[[38646]],63923:[[38728]],63924:[[38936]],63925:[[20363]],63926:[[31150]],63927:[[37300]],63928:[[38584]],63929:[[24801]],63930:[[20102]],63931:[[20698]],63932:[[23534]],63933:[[23615]],63934:[[26009]],63935:[[27138]],63936:[[29134]],63937:[[30274]],63938:[[34044]],63939:[[36988]],63940:[[40845]],63941:[[26248]],63942:[[38446]],63943:[[21129]],63944:[[26491]],63945:[[26611]],63946:[[27969]],63947:[[28316]],63948:[[29705]],63949:[[30041]],63950:[[30827]],63951:[[32016]],63952:[[39006]],63953:[[20845]],63954:[[25134]],63955:[[38520]],63956:[[20523]],63957:[[23833]],63958:[[28138]],63959:[[36650]],63960:[[24459]],63961:[[24900]],63962:[[26647]],63963:[[29575]],63964:[[38534]],63965:[[21033]],63966:[[21519]],63967:[[23653]],63968:[[26131]],63969:[[26446]],63970:[[26792]],63971:[[27877]],63972:[[29702]],63973:[[30178]],63974:[[32633]],63975:[[35023]],63976:[[35041]],63977:[[37324]],63978:[[38626]],63979:[[21311]],63980:[[28346]],63981:[[21533]],63982:[[29136]],63983:[[29848]],63984:[[34298]],63985:[[38563]],63986:[[40023]],63987:[[40607]],63988:[[26519]],63989:[[28107]],63990:[[33256]],63991:[[31435]],63992:[[31520]],63993:[[31890]],63994:[[29376]],63995:[[28825]],63996:[[35672]],63997:[[20160]],63998:[[33590]],63999:[[21050]],194816:[[27966]],194817:[[28023]],194818:[[27969]],194819:[[28009]],194820:[[28024]],194821:[[28037]],194822:[[146718]],194823:[[27956]],194824:[[28207]],194825:[[28270]],194826:[[15667]],194827:[[28363]],194828:[[28359]],194829:[[147153]],194830:[[28153]],194831:[[28526]],194832:[[147294]],194833:[[147342]],194834:[[28614]],194835:[[28729]],194836:[[28702]],194837:[[28699]],194838:[[15766]],194839:[[28746]],194840:[[28797]],194841:[[28791]],194842:[[28845]],194843:[[132389]],194844:[[28997]],194845:[[148067]],194846:[[29084]],194847:[[148395]],194848:[[29224]],194849:[[29237]],194850:[[29264]],194851:[[149000]],194852:[[29312]],194853:[[29333]],194854:[[149301]],194855:[[149524]],194856:[[29562]],194857:[[29579]],194858:[[16044]],194859:[[29605]],194860:[[16056]],194861:[[16056]],194862:[[29767]],194863:[[29788]],194864:[[29809]],194865:[[29829]],194866:[[29898]],194867:[[16155]],194868:[[29988]],194869:[[150582]],194870:[[30014]],194871:[[150674]],194872:[[30064]],194873:[[139679]],194874:[[30224]],194875:[[151457]],194876:[[151480]],194877:[[151620]],194878:[[16380]],194879:[[16392]],194880:[[30452]],194881:[[151795]],194882:[[151794]],194883:[[151833]],194884:[[151859]],194885:[[30494]],194886:[[30495]],194887:[[30495]],194888:[[30538]],194889:[[16441]],194890:[[30603]],194891:[[16454]],194892:[[16534]],194893:[[152605]],194894:[[30798]],194895:[[30860]],194896:[[30924]],194897:[[16611]],194898:[[153126]],194899:[[31062]],194900:[[153242]],194901:[[153285]],194902:[[31119]],194903:[[31211]],194904:[[16687]],194905:[[31296]],194906:[[31306]],194907:[[31311]],194908:[[153980]],194909:[[154279]],194910:[[154279]],194911:[[31470]],194912:[[16898]],194913:[[154539]],194914:[[31686]],194915:[[31689]],194916:[[16935]],194917:[[154752]],194918:[[31954]],194919:[[17056]],194920:[[31976]],194921:[[31971]],194922:[[32000]],194923:[[155526]],194924:[[32099]],194925:[[17153]],194926:[[32199]],194927:[[32258]],194928:[[32325]],194929:[[17204]],194930:[[156200]],194931:[[156231]],194932:[[17241]],194933:[[156377]],194934:[[32634]],194935:[[156478]],194936:[[32661]],194937:[[32762]],194938:[[32773]],194939:[[156890]],194940:[[156963]],194941:[[32864]],194942:[[157096]],194943:[[32880]],194944:[[144223]],194945:[[17365]],194946:[[32946]],194947:[[33027]],194948:[[17419]],194949:[[33086]],194950:[[23221]],194951:[[157607]],194952:[[157621]],194953:[[144275]],194954:[[144284]],194955:[[33281]],194956:[[33284]],194957:[[36766]],194958:[[17515]],194959:[[33425]],194960:[[33419]],194961:[[33437]],194962:[[21171]],194963:[[33457]],194964:[[33459]],194965:[[33469]],194966:[[33510]],194967:[[158524]],194968:[[33509]],194969:[[33565]],194970:[[33635]],194971:[[33709]],194972:[[33571]],194973:[[33725]],194974:[[33767]],194975:[[33879]],194976:[[33619]],194977:[[33738]],194978:[[33740]],194979:[[33756]],194980:[[158774]],194981:[[159083]],194982:[[158933]],194983:[[17707]],194984:[[34033]],194985:[[34035]],194986:[[34070]],194987:[[160714]],194988:[[34148]],194989:[[159532]],194990:[[17757]],194991:[[17761]],194992:[[159665]],194993:[[159954]],194994:[[17771]],194995:[[34384]],194996:[[34396]],194997:[[34407]],194998:[[34409]],194999:[[34473]],195000:[[34440]],195001:[[34574]],195002:[[34530]],195003:[[34681]],195004:[[34600]],195005:[[34667]],195006:[[34694]],195007:[[17879]],195008:[[34785]],195009:[[34817]],195010:[[17913]],195011:[[34912]],195012:[[34915]],195013:[[161383]],195014:[[35031]],195015:[[35038]],195016:[[17973]],195017:[[35066]],195018:[[13499]],195019:[[161966]],195020:[[162150]],195021:[[18110]],195022:[[18119]],195023:[[35488]],195024:[[35565]],195025:[[35722]],195026:[[35925]],195027:[[162984]],195028:[[36011]],195029:[[36033]],195030:[[36123]],195031:[[36215]],195032:[[163631]],195033:[[133124]],195034:[[36299]],195035:[[36284]],195036:[[36336]],195037:[[133342]],195038:[[36564]],195039:[[36664]],195040:[[165330]],195041:[[165357]],195042:[[37012]],195043:[[37105]],195044:[[37137]],195045:[[165678]],195046:[[37147]],195047:[[37432]],195048:[[37591]],195049:[[37592]],195050:[[37500]],195051:[[37881]],195052:[[37909]],195053:[[166906]],195054:[[38283]],195055:[[18837]],195056:[[38327]],195057:[[167287]],195058:[[18918]],195059:[[38595]],195060:[[23986]],195061:[[38691]],195062:[[168261]],195063:[[168474]],195064:[[19054]],195065:[[19062]],195066:[[38880]],195067:[[168970]],195068:[[19122]],195069:[[169110]],195070:[[38923]],195071:[[38923]]},
64000:{64000:[[20999]],64001:[[24230]],64002:[[25299]],64003:[[31958]],64004:[[23429]],64005:[[27934]],64006:[[26292]],64007:[[36667]],64008:[[34892]],64009:[[38477]],64010:[[35211]],64011:[[24275]],64012:[[20800]],64013:[[21952]],64016:[[22618]],64018:[[26228]],64021:[[20958]],64022:[[29482]],64023:[[30410]],64024:[[31036]],64025:[[31070]],64026:[[31077]],64027:[[31119]],64028:[[38742]],64029:[[31934]],64030:[[32701]],64032:[[34322]],64034:[[35576]],64037:[[36920]],64038:[[37117]],64042:[[39151]],64043:[[39164]],64044:[[39208]],64045:[[40372]],64046:[[37086]],64047:[[38583]],64048:[[20398]],64049:[[20711]],64050:[[20813]],64051:[[21193]],64052:[[21220]],64053:[[21329]],64054:[[21917]],64055:[[22022]],64056:[[22120]],64057:[[22592]],64058:[[22696]],64059:[[23652]],64060:[[23662]],64061:[[24724]],64062:[[24936]],64063:[[24974]],64064:[[25074]],64065:[[25935]],64066:[[26082]],64067:[[26257]],64068:[[26757]],64069:[[28023]],64070:[[28186]],64071:[[28450]],64072:[[29038]],64073:[[29227]],64074:[[29730]],64075:[[30865]],64076:[[31038]],64077:[[31049]],64078:[[31048]],64079:[[31056]],64080:[[31062]],64081:[[31069]],64082:[[31117]],64083:[[31118]],64084:[[31296]],64085:[[31361]],64086:[[31680]],64087:[[32244]],64088:[[32265]],64089:[[32321]],64090:[[32626]],64091:[[32773]],64092:[[33261]],64093:[[33401]],64094:[[33401]],64095:[[33879]],64096:[[35088]],64097:[[35222]],64098:[[35585]],64099:[[35641]],64100:[[36051]],64101:[[36104]],64102:[[36790]],64103:[[36920]],64104:[[38627]],64105:[[38911]],64106:[[38971]],64107:[[24693]],64108:[[148206]],64109:[[33304]],64112:[[20006]],64113:[[20917]],64114:[[20840]],64115:[[20352]],64116:[[20805]],64117:[[20864]],64118:[[21191]],64119:[[21242]],64120:[[21917]],64121:[[21845]],64122:[[21913]],64123:[[21986]],64124:[[22618]],64125:[[22707]],64126:[[22852]],64127:[[22868]],64128:[[23138]],64129:[[23336]],64130:[[24274]],64131:[[24281]],64132:[[24425]],64133:[[24493]],64134:[[24792]],64135:[[24910]],64136:[[24840]],64137:[[24974]],64138:[[24928]],64139:[[25074]],64140:[[25140]],64141:[[25540]],64142:[[25628]],64143:[[25682]],64144:[[25942]],64145:[[26228]],64146:[[26391]],64147:[[26395]],64148:[[26454]],64149:[[27513]],64150:[[27578]],64151:[[27969]],64152:[[28379]],64153:[[28363]],64154:[[28450]],64155:[[28702]],64156:[[29038]],64157:[[30631]],64158:[[29237]],64159:[[29359]],64160:[[29482]],64161:[[29809]],64162:[[29958]],64163:[[30011]],64164:[[30237]],64165:[[30239]],64166:[[30410]],64167:[[30427]],64168:[[30452]],64169:[[30538]],64170:[[30528]],64171:[[30924]],64172:[[31409]],64173:[[31680]],64174:[[31867]],64175:[[32091]],64176:[[32244]],64177:[[32574]],64178:[[32773]],64179:[[33618]],64180:[[33775]],64181:[[34681]],64182:[[35137]],64183:[[35206]],64184:[[35222]],64185:[[35519]],64186:[[35576]],64187:[[35531]],64188:[[35585]],64189:[[35582]],64190:[[35565]],64191:[[35641]],64192:[[35722]],64193:[[36104]],64194:[[36664]],64195:[[36978]],64196:[[37273]],64197:[[37494]],64198:[[38524]],64199:[[38627]],64200:[[38742]],64201:[[38875]],64202:[[38911]],64203:[[38923]],64204:[[38971]],64205:[[39698]],64206:[[40860]],64207:[[141386]],64208:[[141380]],64209:[[144341]],64210:[[15261]],64211:[[16408]],64212:[[16441]],64213:[[152137]],64214:[[154832]],64215:[[163539]],64216:[[40771]],64217:[[40846]],195072:[[38953]],195073:[[169398]],195074:[[39138]],195075:[[19251]],195076:[[39209]],195077:[[39335]],195078:[[39362]],195079:[[39422]],195080:[[19406]],195081:[[170800]],195082:[[39698]],195083:[[40000]],195084:[[40189]],195085:[[19662]],195086:[[19693]],195087:[[40295]],195088:[[172238]],195089:[[19704]],195090:[[172293]],195091:[[172558]],195092:[[172689]],195093:[[40635]],195094:[[19798]],195095:[[40697]],195096:[[40702]],195097:[[40709]],195098:[[40719]],195099:[[40726]],195100:[[40763]],195101:[[173568]]},
64256:{64256:[[102,102],256],64257:[[102,105],256],64258:[[102,108],256],64259:[[102,102,105],256],64260:[[102,102,108],256],64261:[[383,116],256],64262:[[115,116],256],64275:[[1396,1398],256],64276:[[1396,1381],256],64277:[[1396,1387],256],64278:[[1406,1398],256],64279:[[1396,1389],256],64285:[[1497,1460],512],64286:[,26],64287:[[1522,1463],512],64288:[[1506],256],64289:[[1488],256],64290:[[1491],256],64291:[[1492],256],64292:[[1499],256],64293:[[1500],256],64294:[[1501],256],64295:[[1512],256],64296:[[1514],256],64297:[[43],256],64298:[[1513,1473],512],64299:[[1513,1474],512],64300:[[64329,1473],512],64301:[[64329,1474],512],64302:[[1488,1463],512],64303:[[1488,1464],512],64304:[[1488,1468],512],64305:[[1489,1468],512],64306:[[1490,1468],512],64307:[[1491,1468],512],64308:[[1492,1468],512],64309:[[1493,1468],512],64310:[[1494,1468],512],64312:[[1496,1468],512],64313:[[1497,1468],512],64314:[[1498,1468],512],64315:[[1499,1468],512],64316:[[1500,1468],512],64318:[[1502,1468],512],64320:[[1504,1468],512],64321:[[1505,1468],512],64323:[[1507,1468],512],64324:[[1508,1468],512],64326:[[1510,1468],512],64327:[[1511,1468],512],64328:[[1512,1468],512],64329:[[1513,1468],512],64330:[[1514,1468],512],64331:[[1493,1465],512],64332:[[1489,1471],512],64333:[[1499,1471],512],64334:[[1508,1471],512],64335:[[1488,1500],256],64336:[[1649],256],64337:[[1649],256],64338:[[1659],256],64339:[[1659],256],64340:[[1659],256],64341:[[1659],256],64342:[[1662],256],64343:[[1662],256],64344:[[1662],256],64345:[[1662],256],64346:[[1664],256],64347:[[1664],256],64348:[[1664],256],64349:[[1664],256],64350:[[1658],256],64351:[[1658],256],64352:[[1658],256],64353:[[1658],256],64354:[[1663],256],64355:[[1663],256],64356:[[1663],256],64357:[[1663],256],64358:[[1657],256],64359:[[1657],256],64360:[[1657],256],64361:[[1657],256],64362:[[1700],256],64363:[[1700],256],64364:[[1700],256],64365:[[1700],256],64366:[[1702],256],64367:[[1702],256],64368:[[1702],256],64369:[[1702],256],64370:[[1668],256],64371:[[1668],256],64372:[[1668],256],64373:[[1668],256],64374:[[1667],256],64375:[[1667],256],64376:[[1667],256],64377:[[1667],256],64378:[[1670],256],64379:[[1670],256],64380:[[1670],256],64381:[[1670],256],64382:[[1671],256],64383:[[1671],256],64384:[[1671],256],64385:[[1671],256],64386:[[1677],256],64387:[[1677],256],64388:[[1676],256],64389:[[1676],256],64390:[[1678],256],64391:[[1678],256],64392:[[1672],256],64393:[[1672],256],64394:[[1688],256],64395:[[1688],256],64396:[[1681],256],64397:[[1681],256],64398:[[1705],256],64399:[[1705],256],64400:[[1705],256],64401:[[1705],256],64402:[[1711],256],64403:[[1711],256],64404:[[1711],256],64405:[[1711],256],64406:[[1715],256],64407:[[1715],256],64408:[[1715],256],64409:[[1715],256],64410:[[1713],256],64411:[[1713],256],64412:[[1713],256],64413:[[1713],256],64414:[[1722],256],64415:[[1722],256],64416:[[1723],256],64417:[[1723],256],64418:[[1723],256],64419:[[1723],256],64420:[[1728],256],64421:[[1728],256],64422:[[1729],256],64423:[[1729],256],64424:[[1729],256],64425:[[1729],256],64426:[[1726],256],64427:[[1726],256],64428:[[1726],256],64429:[[1726],256],64430:[[1746],256],64431:[[1746],256],64432:[[1747],256],64433:[[1747],256],64467:[[1709],256],64468:[[1709],256],64469:[[1709],256],64470:[[1709],256],64471:[[1735],256],64472:[[1735],256],64473:[[1734],256],64474:[[1734],256],64475:[[1736],256],64476:[[1736],256],64477:[[1655],256],64478:[[1739],256],64479:[[1739],256],64480:[[1733],256],64481:[[1733],256],64482:[[1737],256],64483:[[1737],256],64484:[[1744],256],64485:[[1744],256],64486:[[1744],256],64487:[[1744],256],64488:[[1609],256],64489:[[1609],256],64490:[[1574,1575],256],64491:[[1574,1575],256],64492:[[1574,1749],256],64493:[[1574,1749],256],64494:[[1574,1608],256],64495:[[1574,1608],256],64496:[[1574,1735],256],64497:[[1574,1735],256],64498:[[1574,1734],256],64499:[[1574,1734],256],64500:[[1574,1736],256],64501:[[1574,1736],256],64502:[[1574,1744],256],64503:[[1574,1744],256],64504:[[1574,1744],256],64505:[[1574,1609],256],64506:[[1574,1609],256],64507:[[1574,1609],256],64508:[[1740],256],64509:[[1740],256],64510:[[1740],256],64511:[[1740],256]},
64512:{64512:[[1574,1580],256],64513:[[1574,1581],256],64514:[[1574,1605],256],64515:[[1574,1609],256],64516:[[1574,1610],256],64517:[[1576,1580],256],64518:[[1576,1581],256],64519:[[1576,1582],256],64520:[[1576,1605],256],64521:[[1576,1609],256],64522:[[1576,1610],256],64523:[[1578,1580],256],64524:[[1578,1581],256],64525:[[1578,1582],256],64526:[[1578,1605],256],64527:[[1578,1609],256],64528:[[1578,1610],256],64529:[[1579,1580],256],64530:[[1579,1605],256],64531:[[1579,1609],256],64532:[[1579,1610],256],64533:[[1580,1581],256],64534:[[1580,1605],256],64535:[[1581,1580],256],64536:[[1581,1605],256],64537:[[1582,1580],256],64538:[[1582,1581],256],64539:[[1582,1605],256],64540:[[1587,1580],256],64541:[[1587,1581],256],64542:[[1587,1582],256],64543:[[1587,1605],256],64544:[[1589,1581],256],64545:[[1589,1605],256],64546:[[1590,1580],256],64547:[[1590,1581],256],64548:[[1590,1582],256],64549:[[1590,1605],256],64550:[[1591,1581],256],64551:[[1591,1605],256],64552:[[1592,1605],256],64553:[[1593,1580],256],64554:[[1593,1605],256],64555:[[1594,1580],256],64556:[[1594,1605],256],64557:[[1601,1580],256],64558:[[1601,1581],256],64559:[[1601,1582],256],64560:[[1601,1605],256],64561:[[1601,1609],256],64562:[[1601,1610],256],64563:[[1602,1581],256],64564:[[1602,1605],256],64565:[[1602,1609],256],64566:[[1602,1610],256],64567:[[1603,1575],256],64568:[[1603,1580],256],64569:[[1603,1581],256],64570:[[1603,1582],256],64571:[[1603,1604],256],64572:[[1603,1605],256],64573:[[1603,1609],256],64574:[[1603,1610],256],64575:[[1604,1580],256],64576:[[1604,1581],256],64577:[[1604,1582],256],64578:[[1604,1605],256],64579:[[1604,1609],256],64580:[[1604,1610],256],64581:[[1605,1580],256],64582:[[1605,1581],256],64583:[[1605,1582],256],64584:[[1605,1605],256],64585:[[1605,1609],256],64586:[[1605,1610],256],64587:[[1606,1580],256],64588:[[1606,1581],256],64589:[[1606,1582],256],64590:[[1606,1605],256],64591:[[1606,1609],256],64592:[[1606,1610],256],64593:[[1607,1580],256],64594:[[1607,1605],256],64595:[[1607,1609],256],64596:[[1607,1610],256],64597:[[1610,1580],256],64598:[[1610,1581],256],64599:[[1610,1582],256],64600:[[1610,1605],256],64601:[[1610,1609],256],64602:[[1610,1610],256],64603:[[1584,1648],256],64604:[[1585,1648],256],64605:[[1609,1648],256],64606:[[32,1612,1617],256],64607:[[32,1613,1617],256],64608:[[32,1614,1617],256],64609:[[32,1615,1617],256],64610:[[32,1616,1617],256],64611:[[32,1617,1648],256],64612:[[1574,1585],256],64613:[[1574,1586],256],64614:[[1574,1605],256],64615:[[1574,1606],256],64616:[[1574,1609],256],64617:[[1574,1610],256],64618:[[1576,1585],256],64619:[[1576,1586],256],64620:[[1576,1605],256],64621:[[1576,1606],256],64622:[[1576,1609],256],64623:[[1576,1610],256],64624:[[1578,1585],256],64625:[[1578,1586],256],64626:[[1578,1605],256],64627:[[1578,1606],256],64628:[[1578,1609],256],64629:[[1578,1610],256],64630:[[1579,1585],256],64631:[[1579,1586],256],64632:[[1579,1605],256],64633:[[1579,1606],256],64634:[[1579,1609],256],64635:[[1579,1610],256],64636:[[1601,1609],256],64637:[[1601,1610],256],64638:[[1602,1609],256],64639:[[1602,1610],256],64640:[[1603,1575],256],64641:[[1603,1604],256],64642:[[1603,1605],256],64643:[[1603,1609],256],64644:[[1603,1610],256],64645:[[1604,1605],256],64646:[[1604,1609],256],64647:[[1604,1610],256],64648:[[1605,1575],256],64649:[[1605,1605],256],64650:[[1606,1585],256],64651:[[1606,1586],256],64652:[[1606,1605],256],64653:[[1606,1606],256],64654:[[1606,1609],256],64655:[[1606,1610],256],64656:[[1609,1648],256],64657:[[1610,1585],256],64658:[[1610,1586],256],64659:[[1610,1605],256],64660:[[1610,1606],256],64661:[[1610,1609],256],64662:[[1610,1610],256],64663:[[1574,1580],256],64664:[[1574,1581],256],64665:[[1574,1582],256],64666:[[1574,1605],256],64667:[[1574,1607],256],64668:[[1576,1580],256],64669:[[1576,1581],256],64670:[[1576,1582],256],64671:[[1576,1605],256],64672:[[1576,1607],256],64673:[[1578,1580],256],64674:[[1578,1581],256],64675:[[1578,1582],256],64676:[[1578,1605],256],64677:[[1578,1607],256],64678:[[1579,1605],256],64679:[[1580,1581],256],64680:[[1580,1605],256],64681:[[1581,1580],256],64682:[[1581,1605],256],64683:[[1582,1580],256],64684:[[1582,1605],256],64685:[[1587,1580],256],64686:[[1587,1581],256],64687:[[1587,1582],256],64688:[[1587,1605],256],64689:[[1589,1581],256],64690:[[1589,1582],256],64691:[[1589,1605],256],64692:[[1590,1580],256],64693:[[1590,1581],256],64694:[[1590,1582],256],64695:[[1590,1605],256],64696:[[1591,1581],256],64697:[[1592,1605],256],64698:[[1593,1580],256],64699:[[1593,1605],256],64700:[[1594,1580],256],64701:[[1594,1605],256],64702:[[1601,1580],256],64703:[[1601,1581],256],64704:[[1601,1582],256],64705:[[1601,1605],256],64706:[[1602,1581],256],64707:[[1602,1605],256],64708:[[1603,1580],256],64709:[[1603,1581],256],64710:[[1603,1582],256],64711:[[1603,1604],256],64712:[[1603,1605],256],64713:[[1604,1580],256],64714:[[1604,1581],256],64715:[[1604,1582],256],64716:[[1604,1605],256],64717:[[1604,1607],256],64718:[[1605,1580],256],64719:[[1605,1581],256],64720:[[1605,1582],256],64721:[[1605,1605],256],64722:[[1606,1580],256],64723:[[1606,1581],256],64724:[[1606,1582],256],64725:[[1606,1605],256],64726:[[1606,1607],256],64727:[[1607,1580],256],64728:[[1607,1605],256],64729:[[1607,1648],256],64730:[[1610,1580],256],64731:[[1610,1581],256],64732:[[1610,1582],256],64733:[[1610,1605],256],64734:[[1610,1607],256],64735:[[1574,1605],256],64736:[[1574,1607],256],64737:[[1576,1605],256],64738:[[1576,1607],256],64739:[[1578,1605],256],64740:[[1578,1607],256],64741:[[1579,1605],256],64742:[[1579,1607],256],64743:[[1587,1605],256],64744:[[1587,1607],256],64745:[[1588,1605],256],64746:[[1588,1607],256],64747:[[1603,1604],256],64748:[[1603,1605],256],64749:[[1604,1605],256],64750:[[1606,1605],256],64751:[[1606,1607],256],64752:[[1610,1605],256],64753:[[1610,1607],256],64754:[[1600,1614,1617],256],64755:[[1600,1615,1617],256],64756:[[1600,1616,1617],256],64757:[[1591,1609],256],64758:[[1591,1610],256],64759:[[1593,1609],256],64760:[[1593,1610],256],64761:[[1594,1609],256],64762:[[1594,1610],256],64763:[[1587,1609],256],64764:[[1587,1610],256],64765:[[1588,1609],256],64766:[[1588,1610],256],64767:[[1581,1609],256]},
64768:{64768:[[1581,1610],256],64769:[[1580,1609],256],64770:[[1580,1610],256],64771:[[1582,1609],256],64772:[[1582,1610],256],64773:[[1589,1609],256],64774:[[1589,1610],256],64775:[[1590,1609],256],64776:[[1590,1610],256],64777:[[1588,1580],256],64778:[[1588,1581],256],64779:[[1588,1582],256],64780:[[1588,1605],256],64781:[[1588,1585],256],64782:[[1587,1585],256],64783:[[1589,1585],256],64784:[[1590,1585],256],64785:[[1591,1609],256],64786:[[1591,1610],256],64787:[[1593,1609],256],64788:[[1593,1610],256],64789:[[1594,1609],256],64790:[[1594,1610],256],64791:[[1587,1609],256],64792:[[1587,1610],256],64793:[[1588,1609],256],64794:[[1588,1610],256],64795:[[1581,1609],256],64796:[[1581,1610],256],64797:[[1580,1609],256],64798:[[1580,1610],256],64799:[[1582,1609],256],64800:[[1582,1610],256],64801:[[1589,1609],256],64802:[[1589,1610],256],64803:[[1590,1609],256],64804:[[1590,1610],256],64805:[[1588,1580],256],64806:[[1588,1581],256],64807:[[1588,1582],256],64808:[[1588,1605],256],64809:[[1588,1585],256],64810:[[1587,1585],256],64811:[[1589,1585],256],64812:[[1590,1585],256],64813:[[1588,1580],256],64814:[[1588,1581],256],64815:[[1588,1582],256],64816:[[1588,1605],256],64817:[[1587,1607],256],64818:[[1588,1607],256],64819:[[1591,1605],256],64820:[[1587,1580],256],64821:[[1587,1581],256],64822:[[1587,1582],256],64823:[[1588,1580],256],64824:[[1588,1581],256],64825:[[1588,1582],256],64826:[[1591,1605],256],64827:[[1592,1605],256],64828:[[1575,1611],256],64829:[[1575,1611],256],64848:[[1578,1580,1605],256],64849:[[1578,1581,1580],256],64850:[[1578,1581,1580],256],64851:[[1578,1581,1605],256],64852:[[1578,1582,1605],256],64853:[[1578,1605,1580],256],64854:[[1578,1605,1581],256],64855:[[1578,1605,1582],256],64856:[[1580,1605,1581],256],64857:[[1580,1605,1581],256],64858:[[1581,1605,1610],256],64859:[[1581,1605,1609],256],64860:[[1587,1581,1580],256],64861:[[1587,1580,1581],256],64862:[[1587,1580,1609],256],64863:[[1587,1605,1581],256],64864:[[1587,1605,1581],256],64865:[[1587,1605,1580],256],64866:[[1587,1605,1605],256],64867:[[1587,1605,1605],256],64868:[[1589,1581,1581],256],64869:[[1589,1581,1581],256],64870:[[1589,1605,1605],256],64871:[[1588,1581,1605],256],64872:[[1588,1581,1605],256],64873:[[1588,1580,1610],256],64874:[[1588,1605,1582],256],64875:[[1588,1605,1582],256],64876:[[1588,1605,1605],256],64877:[[1588,1605,1605],256],64878:[[1590,1581,1609],256],64879:[[1590,1582,1605],256],64880:[[1590,1582,1605],256],64881:[[1591,1605,1581],256],64882:[[1591,1605,1581],256],64883:[[1591,1605,1605],256],64884:[[1591,1605,1610],256],64885:[[1593,1580,1605],256],64886:[[1593,1605,1605],256],64887:[[1593,1605,1605],256],64888:[[1593,1605,1609],256],64889:[[1594,1605,1605],256],64890:[[1594,1605,1610],256],64891:[[1594,1605,1609],256],64892:[[1601,1582,1605],256],64893:[[1601,1582,1605],256],64894:[[1602,1605,1581],256],64895:[[1602,1605,1605],256],64896:[[1604,1581,1605],256],64897:[[1604,1581,1610],256],64898:[[1604,1581,1609],256],64899:[[1604,1580,1580],256],64900:[[1604,1580,1580],256],64901:[[1604,1582,1605],256],64902:[[1604,1582,1605],256],64903:[[1604,1605,1581],256],64904:[[1604,1605,1581],256],64905:[[1605,1581,1580],256],64906:[[1605,1581,1605],256],64907:[[1605,1581,1610],256],64908:[[1605,1580,1581],256],64909:[[1605,1580,1605],256],64910:[[1605,1582,1580],256],64911:[[1605,1582,1605],256],64914:[[1605,1580,1582],256],64915:[[1607,1605,1580],256],64916:[[1607,1605,1605],256],64917:[[1606,1581,1605],256],64918:[[1606,1581,1609],256],64919:[[1606,1580,1605],256],64920:[[1606,1580,1605],256],64921:[[1606,1580,1609],256],64922:[[1606,1605,1610],256],64923:[[1606,1605,1609],256],64924:[[1610,1605,1605],256],64925:[[1610,1605,1605],256],64926:[[1576,1582,1610],256],64927:[[1578,1580,1610],256],64928:[[1578,1580,1609],256],64929:[[1578,1582,1610],256],64930:[[1578,1582,1609],256],64931:[[1578,1605,1610],256],64932:[[1578,1605,1609],256],64933:[[1580,1605,1610],256],64934:[[1580,1581,1609],256],64935:[[1580,1605,1609],256],64936:[[1587,1582,1609],256],64937:[[1589,1581,1610],256],64938:[[1588,1581,1610],256],64939:[[1590,1581,1610],256],64940:[[1604,1580,1610],256],64941:[[1604,1605,1610],256],64942:[[1610,1581,1610],256],64943:[[1610,1580,1610],256],64944:[[1610,1605,1610],256],64945:[[1605,1605,1610],256],64946:[[1602,1605,1610],256],64947:[[1606,1581,1610],256],64948:[[1602,1605,1581],256],64949:[[1604,1581,1605],256],64950:[[1593,1605,1610],256],64951:[[1603,1605,1610],256],64952:[[1606,1580,1581],256],64953:[[1605,1582,1610],256],64954:[[1604,1580,1605],256],64955:[[1603,1605,1605],256],64956:[[1604,1580,1605],256],64957:[[1606,1580,1581],256],64958:[[1580,1581,1610],256],64959:[[1581,1580,1610],256],64960:[[1605,1580,1610],256],64961:[[1601,1605,1610],256],64962:[[1576,1581,1610],256],64963:[[1603,1605,1605],256],64964:[[1593,1580,1605],256],64965:[[1589,1605,1605],256],64966:[[1587,1582,1610],256],64967:[[1606,1580,1610],256],65008:[[1589,1604,1746],256],65009:[[1602,1604,1746],256],65010:[[1575,1604,1604,1607],256],65011:[[1575,1603,1576,1585],256],65012:[[1605,1581,1605,1583],256],65013:[[1589,1604,1593,1605],256],65014:[[1585,1587,1608,1604],256],65015:[[1593,1604,1610,1607],256],65016:[[1608,1587,1604,1605],256],65017:[[1589,1604,1609],256],65018:[[1589,1604,1609,32,1575,1604,1604,1607,32,1593,1604,1610,1607,32,1608,1587,1604,1605],256],65019:[[1580,1604,32,1580,1604,1575,1604,1607],256],65020:[[1585,1740,1575,1604],256]},
65024:{65040:[[44],256],65041:[[12289],256],65042:[[12290],256],65043:[[58],256],65044:[[59],256],65045:[[33],256],65046:[[63],256],65047:[[12310],256],65048:[[12311],256],65049:[[8230],256],65056:[,230],65057:[,230],65058:[,230],65059:[,230],65060:[,230],65061:[,230],65062:[,230],65063:[,220],65064:[,220],65065:[,220],65066:[,220],65067:[,220],65068:[,220],65069:[,220],65072:[[8229],256],65073:[[8212],256],65074:[[8211],256],65075:[[95],256],65076:[[95],256],65077:[[40],256],65078:[[41],256],65079:[[123],256],65080:[[125],256],65081:[[12308],256],65082:[[12309],256],65083:[[12304],256],65084:[[12305],256],65085:[[12298],256],65086:[[12299],256],65087:[[12296],256],65088:[[12297],256],65089:[[12300],256],65090:[[12301],256],65091:[[12302],256],65092:[[12303],256],65095:[[91],256],65096:[[93],256],65097:[[8254],256],65098:[[8254],256],65099:[[8254],256],65100:[[8254],256],65101:[[95],256],65102:[[95],256],65103:[[95],256],65104:[[44],256],65105:[[12289],256],65106:[[46],256],65108:[[59],256],65109:[[58],256],65110:[[63],256],65111:[[33],256],65112:[[8212],256],65113:[[40],256],65114:[[41],256],65115:[[123],256],65116:[[125],256],65117:[[12308],256],65118:[[12309],256],65119:[[35],256],65120:[[38],256],65121:[[42],256],65122:[[43],256],65123:[[45],256],65124:[[60],256],65125:[[62],256],65126:[[61],256],65128:[[92],256],65129:[[36],256],65130:[[37],256],65131:[[64],256],65136:[[32,1611],256],65137:[[1600,1611],256],65138:[[32,1612],256],65140:[[32,1613],256],65142:[[32,1614],256],65143:[[1600,1614],256],65144:[[32,1615],256],65145:[[1600,1615],256],65146:[[32,1616],256],65147:[[1600,1616],256],65148:[[32,1617],256],65149:[[1600,1617],256],65150:[[32,1618],256],65151:[[1600,1618],256],65152:[[1569],256],65153:[[1570],256],65154:[[1570],256],65155:[[1571],256],65156:[[1571],256],65157:[[1572],256],65158:[[1572],256],65159:[[1573],256],65160:[[1573],256],65161:[[1574],256],65162:[[1574],256],65163:[[1574],256],65164:[[1574],256],65165:[[1575],256],65166:[[1575],256],65167:[[1576],256],65168:[[1576],256],65169:[[1576],256],65170:[[1576],256],65171:[[1577],256],65172:[[1577],256],65173:[[1578],256],65174:[[1578],256],65175:[[1578],256],65176:[[1578],256],65177:[[1579],256],65178:[[1579],256],65179:[[1579],256],65180:[[1579],256],65181:[[1580],256],65182:[[1580],256],65183:[[1580],256],65184:[[1580],256],65185:[[1581],256],65186:[[1581],256],65187:[[1581],256],65188:[[1581],256],65189:[[1582],256],65190:[[1582],256],65191:[[1582],256],65192:[[1582],256],65193:[[1583],256],65194:[[1583],256],65195:[[1584],256],65196:[[1584],256],65197:[[1585],256],65198:[[1585],256],65199:[[1586],256],65200:[[1586],256],65201:[[1587],256],65202:[[1587],256],65203:[[1587],256],65204:[[1587],256],65205:[[1588],256],65206:[[1588],256],65207:[[1588],256],65208:[[1588],256],65209:[[1589],256],65210:[[1589],256],65211:[[1589],256],65212:[[1589],256],65213:[[1590],256],65214:[[1590],256],65215:[[1590],256],65216:[[1590],256],65217:[[1591],256],65218:[[1591],256],65219:[[1591],256],65220:[[1591],256],65221:[[1592],256],65222:[[1592],256],65223:[[1592],256],65224:[[1592],256],65225:[[1593],256],65226:[[1593],256],65227:[[1593],256],65228:[[1593],256],65229:[[1594],256],65230:[[1594],256],65231:[[1594],256],65232:[[1594],256],65233:[[1601],256],65234:[[1601],256],65235:[[1601],256],65236:[[1601],256],65237:[[1602],256],65238:[[1602],256],65239:[[1602],256],65240:[[1602],256],65241:[[1603],256],65242:[[1603],256],65243:[[1603],256],65244:[[1603],256],65245:[[1604],256],65246:[[1604],256],65247:[[1604],256],65248:[[1604],256],65249:[[1605],256],65250:[[1605],256],65251:[[1605],256],65252:[[1605],256],65253:[[1606],256],65254:[[1606],256],65255:[[1606],256],65256:[[1606],256],65257:[[1607],256],65258:[[1607],256],65259:[[1607],256],65260:[[1607],256],65261:[[1608],256],65262:[[1608],256],65263:[[1609],256],65264:[[1609],256],65265:[[1610],256],65266:[[1610],256],65267:[[1610],256],65268:[[1610],256],65269:[[1604,1570],256],65270:[[1604,1570],256],65271:[[1604,1571],256],65272:[[1604,1571],256],65273:[[1604,1573],256],65274:[[1604,1573],256],65275:[[1604,1575],256],65276:[[1604,1575],256]},
65280:{65281:[[33],256],65282:[[34],256],65283:[[35],256],65284:[[36],256],65285:[[37],256],65286:[[38],256],65287:[[39],256],65288:[[40],256],65289:[[41],256],65290:[[42],256],65291:[[43],256],65292:[[44],256],65293:[[45],256],65294:[[46],256],65295:[[47],256],65296:[[48],256],65297:[[49],256],65298:[[50],256],65299:[[51],256],65300:[[52],256],65301:[[53],256],65302:[[54],256],65303:[[55],256],65304:[[56],256],65305:[[57],256],65306:[[58],256],65307:[[59],256],65308:[[60],256],65309:[[61],256],65310:[[62],256],65311:[[63],256],65312:[[64],256],65313:[[65],256],65314:[[66],256],65315:[[67],256],65316:[[68],256],65317:[[69],256],65318:[[70],256],65319:[[71],256],65320:[[72],256],65321:[[73],256],65322:[[74],256],65323:[[75],256],65324:[[76],256],65325:[[77],256],65326:[[78],256],65327:[[79],256],65328:[[80],256],65329:[[81],256],65330:[[82],256],65331:[[83],256],65332:[[84],256],65333:[[85],256],65334:[[86],256],65335:[[87],256],65336:[[88],256],65337:[[89],256],65338:[[90],256],65339:[[91],256],65340:[[92],256],65341:[[93],256],65342:[[94],256],65343:[[95],256],65344:[[96],256],65345:[[97],256],65346:[[98],256],65347:[[99],256],65348:[[100],256],65349:[[101],256],65350:[[102],256],65351:[[103],256],65352:[[104],256],65353:[[105],256],65354:[[106],256],65355:[[107],256],65356:[[108],256],65357:[[109],256],65358:[[110],256],65359:[[111],256],65360:[[112],256],65361:[[113],256],65362:[[114],256],65363:[[115],256],65364:[[116],256],65365:[[117],256],65366:[[118],256],65367:[[119],256],65368:[[120],256],65369:[[121],256],65370:[[122],256],65371:[[123],256],65372:[[124],256],65373:[[125],256],65374:[[126],256],65375:[[10629],256],65376:[[10630],256],65377:[[12290],256],65378:[[12300],256],65379:[[12301],256],65380:[[12289],256],65381:[[12539],256],65382:[[12530],256],65383:[[12449],256],65384:[[12451],256],65385:[[12453],256],65386:[[12455],256],65387:[[12457],256],65388:[[12515],256],65389:[[12517],256],65390:[[12519],256],65391:[[12483],256],65392:[[12540],256],65393:[[12450],256],65394:[[12452],256],65395:[[12454],256],65396:[[12456],256],65397:[[12458],256],65398:[[12459],256],65399:[[12461],256],65400:[[12463],256],65401:[[12465],256],65402:[[12467],256],65403:[[12469],256],65404:[[12471],256],65405:[[12473],256],65406:[[12475],256],65407:[[12477],256],65408:[[12479],256],65409:[[12481],256],65410:[[12484],256],65411:[[12486],256],65412:[[12488],256],65413:[[12490],256],65414:[[12491],256],65415:[[12492],256],65416:[[12493],256],65417:[[12494],256],65418:[[12495],256],65419:[[12498],256],65420:[[12501],256],65421:[[12504],256],65422:[[12507],256],65423:[[12510],256],65424:[[12511],256],65425:[[12512],256],65426:[[12513],256],65427:[[12514],256],65428:[[12516],256],65429:[[12518],256],65430:[[12520],256],65431:[[12521],256],65432:[[12522],256],65433:[[12523],256],65434:[[12524],256],65435:[[12525],256],65436:[[12527],256],65437:[[12531],256],65438:[[12441],256],65439:[[12442],256],65440:[[12644],256],65441:[[12593],256],65442:[[12594],256],65443:[[12595],256],65444:[[12596],256],65445:[[12597],256],65446:[[12598],256],65447:[[12599],256],65448:[[12600],256],65449:[[12601],256],65450:[[12602],256],65451:[[12603],256],65452:[[12604],256],65453:[[12605],256],65454:[[12606],256],65455:[[12607],256],65456:[[12608],256],65457:[[12609],256],65458:[[12610],256],65459:[[12611],256],65460:[[12612],256],65461:[[12613],256],65462:[[12614],256],65463:[[12615],256],65464:[[12616],256],65465:[[12617],256],65466:[[12618],256],65467:[[12619],256],65468:[[12620],256],65469:[[12621],256],65470:[[12622],256],65474:[[12623],256],65475:[[12624],256],65476:[[12625],256],65477:[[12626],256],65478:[[12627],256],65479:[[12628],256],65482:[[12629],256],65483:[[12630],256],65484:[[12631],256],65485:[[12632],256],65486:[[12633],256],65487:[[12634],256],65490:[[12635],256],65491:[[12636],256],65492:[[12637],256],65493:[[12638],256],65494:[[12639],256],65495:[[12640],256],65498:[[12641],256],65499:[[12642],256],65500:[[12643],256],65504:[[162],256],65505:[[163],256],65506:[[172],256],65507:[[175],256],65508:[[166],256],65509:[[165],256],65510:[[8361],256],65512:[[9474],256],65513:[[8592],256],65514:[[8593],256],65515:[[8594],256],65516:[[8595],256],65517:[[9632],256],65518:[[9675],256]}

};

   /***** Module to export */
   var unorm = {
      nfc: nfc,
      nfd: nfd,
      nfkc: nfkc,
      nfkd: nfkd
   };

   /*globals module:true,define:true*/

   // CommonJS
   if (true) {
      module.exports = unorm;

   // AMD
   } else {}

   /***** Export as shim for String::normalize method *****/
   /*
      http://wiki.ecmascript.org/doku.php?id=harmony:specification_drafts#november_8_2013_draft_rev_21

      21.1.3.12 String.prototype.normalize(form="NFC")
      When the normalize method is called with one argument form, the following steps are taken:

      1. Let O be CheckObjectCoercible(this value).
      2. Let S be ToString(O).
      3. ReturnIfAbrupt(S).
      4. If form is not provided or undefined let form be "NFC".
      5. Let f be ToString(form).
      6. ReturnIfAbrupt(f).
      7. If f is not one of "NFC", "NFD", "NFKC", or "NFKD", then throw a RangeError Exception.
      8. Let ns be the String value is the result of normalizing S into the normalization form named by f as specified in Unicode Standard Annex #15, UnicodeNormalizatoin Forms.
      9. Return ns.

      The length property of the normalize method is 0.

      *NOTE* The normalize function is intentionally generic; it does not require that its this value be a String object. Therefore it can be transferred to other kinds of objects for use as a method.
   */
    unorm.shimApplied = false;

   if (!String.prototype.normalize) {
      Object.defineProperty(String.prototype, "normalize", {
         enumerable: false,
         configurable: true,
         writable: true,
         value: function normalize (/*form*/) {
            
            var str = "" + this;
            var form = arguments[0] === undefined ? "NFC" : arguments[0];

            if (this === null || this === undefined) {
               throw new TypeError("Cannot call method on " + Object.prototype.toString.call(this));
            }

            if (form === "NFC") {
               return unorm.nfc(str);
            } else if (form === "NFD") {
               return unorm.nfd(str);
            } else if (form === "NFKC") {
               return unorm.nfkc(str);
            } else if (form === "NFKD") {
               return unorm.nfkd(str);
            } else {
               throw new RangeError("Invalid normalization form: " + form);
            }
         }
      });

      unorm.shimApplied = true;
   }
}(this));


/***/ }),

/***/ 1120:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const encoding_1 = __webpack_require__(86);
const types_1 = __webpack_require__(183);
function unmarshalTx(data) {
    const decoded = JSON.parse(encoding_1.Encoding.fromUtf8(data));
    if (!types_1.isStdTx(decoded)) {
        throw new Error("Must be json encoded StdTx");
    }
    return decoded;
}
exports.unmarshalTx = unmarshalTx;
//# sourceMappingURL=decoding.js.map

/***/ }),

/***/ 1130:
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process, Buffer) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!function(globals){
'use strict'

//*** UMD BEGIN
if (true) { //require.js / AMD
  !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {
    return secureRandom
  }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
} else {}
//*** UMD END

//options.type is the only valid option
function secureRandom(count, options) {
  options = options || {type: 'Array'}
  //we check for process.pid to prevent browserify from tricking us
  if (
    typeof process != 'undefined'
    && typeof process.pid == 'number'
    && process.versions
    && process.versions.node
  ) {
    return nodeRandom(count, options)
  } else {
    var crypto = window.crypto || window.msCrypto
    if (!crypto) throw new Error("Your browser does not support window.crypto.")
    return browserRandom(count, options)
  }
}

function nodeRandom(count, options) {
  var crypto = __webpack_require__(1131)
  var buf = crypto.randomBytes(count)

  switch (options.type) {
    case 'Array':
      return [].slice.call(buf)
    case 'Buffer':
      return buf
    case 'Uint8Array':
      var arr = new Uint8Array(count)
      for (var i = 0; i < count; ++i) { arr[i] = buf.readUInt8(i) }
      return arr
    default:
      throw new Error(options.type + " is unsupported.")
  }
}

function browserRandom(count, options) {
  var nativeArr = new Uint8Array(count)
  var crypto = window.crypto || window.msCrypto
  crypto.getRandomValues(nativeArr)

  switch (options.type) {
    case 'Array':
      return [].slice.call(nativeArr)
    case 'Buffer':
      try { var b = new Buffer(1) } catch(e) { throw new Error('Buffer not supported in this environment. Use Node.js or Browserify for browser support.')}
      return new Buffer(nativeArr)
    case 'Uint8Array':
      return nativeArr
    default:
      throw new Error(options.type + " is unsupported.")
  }
}

secureRandom.randomArray = function(byteCount) {
  return secureRandom(byteCount, {type: 'Array'})
}

secureRandom.randomUint8Array = function(byteCount) {
  return secureRandom(byteCount, {type: 'Uint8Array'})
}

secureRandom.randomBuffer = function(byteCount) {
  return secureRandom(byteCount, {type: 'Buffer'})
}


}(this);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(28), __webpack_require__(4).Buffer))

/***/ }),

/***/ 1144:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
Object.defineProperty(exports,"__esModule",{value:true});exports["default"]=exports.SHAKE=exports.SHA3Hash=exports.SHA3=exports.Keccak=void 0;var _buffer=__webpack_require__(4);var _sponge=_interopRequireDefault(__webpack_require__(1145));function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{"default":obj}}var createHash=function createHash(_ref){var allowedSizes=_ref.allowedSizes,padding=_ref.padding;return function Hash(){var _this=this;var size=arguments.length>0&&arguments[0]!==undefined?arguments[0]:512;if(!this||this.constructor!==Hash){return new Hash(size)}if(allowedSizes&&!allowedSizes.includes(size)){throw new Error("Unsupported hash length")}var sponge=new _sponge["default"]({capacity:size});this.update=function(input){var encoding=arguments.length>1&&arguments[1]!==undefined?arguments[1]:"utf8";if(_buffer.Buffer.isBuffer(input)){sponge.absorb(input);return _this}if(typeof input==="string"){return _this.update(_buffer.Buffer.from(input,encoding))}throw new TypeError("Not a string or buffer")};this.digest=function(){var formatOrOptions=arguments.length>0&&arguments[0]!==undefined?arguments[0]:"binary";var options=typeof formatOrOptions==="string"?{format:formatOrOptions}:formatOrOptions;var buffer=sponge.squeeze({buffer:options.buffer,padding:options.padding||padding});if(options.format&&options.format!=="binary"){return buffer.toString(options.format)}return buffer};this.reset=function(){sponge.reset();return _this};return this}};var Keccak=createHash({allowedSizes:[224,256,384,512],padding:1});exports.Keccak=Keccak;var SHA3=createHash({allowedSizes:[224,256,384,512],padding:6});exports.SHA3=SHA3;var SHAKE=createHash({allowedSizes:[128,256],padding:31});exports.SHAKE=SHAKE;var SHA3Hash=Keccak;exports.SHA3Hash=SHA3Hash;SHA3.SHA3Hash=SHA3Hash;var _default=SHA3;exports["default"]=_default;

/***/ }),

/***/ 1145:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
Object.defineProperty(exports,"__esModule",{value:true});exports["default"]=void 0;var _buffer=__webpack_require__(4);var _permute=_interopRequireDefault(__webpack_require__(1146));function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{"default":obj}}var xorWords=function xorWords(I,O){for(var i=0;i<I.length;i+=8){var o=i/4;O[o]^=I[i+7]<<24|I[i+6]<<16|I[i+5]<<8|I[i+4];O[o+1]^=I[i+3]<<24|I[i+2]<<16|I[i+1]<<8|I[i]}return O};var readWords=function readWords(I,O){for(var o=0;o<O.length;o+=8){var i=o/4;O[o]=I[i+1];O[o+1]=I[i+1]>>>8;O[o+2]=I[i+1]>>>16;O[o+3]=I[i+1]>>>24;O[o+4]=I[i];O[o+5]=I[i]>>>8;O[o+6]=I[i]>>>16;O[o+7]=I[i]>>>24}return O};var Sponge=function Sponge(_ref){var _this=this;var capacity=_ref.capacity,padding=_ref.padding;var keccak=(0,_permute["default"])();var stateSize=200;var blockSize=capacity/8;var queueSize=stateSize-capacity/4;var queueOffset=0;var state=new Uint32Array(stateSize/4);var queue=_buffer.Buffer.allocUnsafe(queueSize);this.absorb=function(buffer){for(var i=0;i<buffer.length;i++){queue[queueOffset]=buffer[i];queueOffset+=1;if(queueOffset>=queueSize){xorWords(queue,state);keccak(state);queueOffset=0}}return _this};this.squeeze=function(){var options=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};var output={buffer:options.buffer||_buffer.Buffer.allocUnsafe(blockSize),padding:options.padding||padding,queue:_buffer.Buffer.allocUnsafe(queue.length),state:new Uint32Array(state.length)};queue.copy(output.queue);for(var i=0;i<state.length;i++){output.state[i]=state[i]}output.queue.fill(0,queueOffset);output.queue[queueOffset]|=output.padding;output.queue[queueSize-1]|=128;xorWords(output.queue,output.state);for(var offset=0;offset<output.buffer.length;offset+=queueSize){keccak(output.state);readWords(output.state,output.buffer.slice(offset,offset+queueSize))}return output.buffer};this.reset=function(){queue.fill(0);state.fill(0);queueOffset=0;return _this};return this};var _default=Sponge;exports["default"]=_default;

/***/ }),

/***/ 1146:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
Object.defineProperty(exports,"__esModule",{value:true});exports["default"]=void 0;var _chi=_interopRequireDefault(__webpack_require__(1147));var _iota=_interopRequireDefault(__webpack_require__(1148));var _rhoPi=_interopRequireDefault(__webpack_require__(1150));var _theta=_interopRequireDefault(__webpack_require__(1153));function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{"default":obj}}var permute=function permute(){var C=new Uint32Array(10);var D=new Uint32Array(10);var W=new Uint32Array(2);return function(A){for(var roundIndex=0;roundIndex<24;roundIndex++){(0,_theta["default"])({A:A,C:C,D:D,W:W});(0,_rhoPi["default"])({A:A,C:C,W:W});(0,_chi["default"])({A:A,C:C});(0,_iota["default"])({A:A,roundIndex:roundIndex})}C.fill(0);D.fill(0);W.fill(0)}};var _default=permute;exports["default"]=_default;

/***/ }),

/***/ 1147:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
Object.defineProperty(exports,"__esModule",{value:true});exports["default"]=void 0;var _copy=_interopRequireDefault(__webpack_require__(356));function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{"default":obj}}var chi=function chi(_ref){var A=_ref.A,C=_ref.C;for(var y=0;y<25;y+=5){for(var x=0;x<5;x++){(0,_copy["default"])(A,y+x)(C,x)}for(var _x=0;_x<5;_x++){var xy=(y+_x)*2;var x1=(_x+1)%5*2;var x2=(_x+2)%5*2;A[xy]^=~C[x1]&C[x2];A[xy+1]^=~C[x1+1]&C[x2+1]}}};var _default=chi;exports["default"]=_default;

/***/ }),

/***/ 1148:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
Object.defineProperty(exports,"__esModule",{value:true});exports["default"]=void 0;var _roundConstants=_interopRequireDefault(__webpack_require__(1149));function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{"default":obj}}var iota=function iota(_ref){var A=_ref.A,roundIndex=_ref.roundIndex;var i=roundIndex*2;A[0]^=_roundConstants["default"][i];A[1]^=_roundConstants["default"][i+1]};var _default=iota;exports["default"]=_default;

/***/ }),

/***/ 1149:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
Object.defineProperty(exports,"__esModule",{value:true});exports["default"]=void 0;var ROUND_CONSTANTS=new Uint32Array([0,1,0,32898,2147483648,32906,2147483648,2147516416,0,32907,0,2147483649,2147483648,2147516545,2147483648,32777,0,138,0,136,0,2147516425,0,2147483658,0,2147516555,2147483648,139,2147483648,32905,2147483648,32771,2147483648,32770,2147483648,128,0,32778,2147483648,2147483658,2147483648,2147516545,2147483648,32896,0,2147483649,2147483648,2147516424]);var _default=ROUND_CONSTANTS;exports["default"]=_default;

/***/ }),

/***/ 1150:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
Object.defineProperty(exports,"__esModule",{value:true});exports["default"]=void 0;var _piShuffles=_interopRequireDefault(__webpack_require__(1151));var _rhoOffsets=_interopRequireDefault(__webpack_require__(1152));var _copy=_interopRequireDefault(__webpack_require__(356));function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{"default":obj}}var rhoPi=function rhoPi(_ref){var A=_ref.A,C=_ref.C,W=_ref.W;(0,_copy["default"])(A,1)(W,0);var H=0;var L=0;var Wi=0;var ri=32;for(var i=0;i<24;i++){var j=_piShuffles["default"][i];var r=_rhoOffsets["default"][i];(0,_copy["default"])(A,j)(C,0);H=W[0];L=W[1];ri=32-r;Wi=r<32?0:1;W[Wi]=H<<r|L>>>ri;W[(Wi+1)%2]=L<<r|H>>>ri;(0,_copy["default"])(W,0)(A,j);(0,_copy["default"])(C,0)(W,0)}};var _default=rhoPi;exports["default"]=_default;

/***/ }),

/***/ 1151:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
Object.defineProperty(exports,"__esModule",{value:true});exports["default"]=void 0;var PI_SHUFFLES=[10,7,11,17,18,3,5,16,8,21,24,4,15,23,19,13,12,2,20,14,22,9,6,1];var _default=PI_SHUFFLES;exports["default"]=_default;

/***/ }),

/***/ 1152:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
Object.defineProperty(exports,"__esModule",{value:true});exports["default"]=void 0;var RHO_OFFSETS=[1,3,6,10,15,21,28,36,45,55,2,14,27,41,56,8,25,43,62,18,39,61,20,44];var _default=RHO_OFFSETS;exports["default"]=_default;

/***/ }),

/***/ 1153:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
Object.defineProperty(exports,"__esModule",{value:true});exports["default"]=void 0;var _copy=_interopRequireDefault(__webpack_require__(356));function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{"default":obj}}var theta=function theta(_ref){var A=_ref.A,C=_ref.C,D=_ref.D,W=_ref.W;var H=0;var L=0;for(var x=0;x<5;x++){var x20=x*2;var x21=(x+5)*2;var x22=(x+10)*2;var x23=(x+15)*2;var x24=(x+20)*2;C[x20]=A[x20]^A[x21]^A[x22]^A[x23]^A[x24];C[x20+1]=A[x20+1]^A[x21+1]^A[x22+1]^A[x23+1]^A[x24+1]}for(var _x=0;_x<5;_x++){(0,_copy["default"])(C,(_x+1)%5)(W,0);H=W[0];L=W[1];W[0]=H<<1|L>>>31;W[1]=L<<1|H>>>31;D[_x*2]=C[(_x+4)%5*2]^W[0];D[_x*2+1]=C[(_x+4)%5*2+1]^W[1];for(var y=0;y<25;y+=5){A[(y+_x)*2]^=D[_x*2];A[(y+_x)*2+1]^=D[_x*2+1]}}};var _default=theta;exports["default"]=_default;

/***/ }),

/***/ 1158:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const ProtoDefs_js_1 = __webpack_require__(1159);
// todo: dynamically create this type from protobuf
class MsgData {
    constructor(msgType, data) {
        this.msgType = msgType;
        this.data = data;
    }
}
exports.MsgData = MsgData;
function decodeTxData(data) {
    const message = ProtoDefs_js_1.cosmos.base.abci.v1beta1.TxMsgData.decode(data);
    const object = ProtoDefs_js_1.cosmos.base.abci.v1beta1.TxMsgData.toObject(message, {
        longs: String,
        enums: String,
        bytes: String,
    });
    return object["data"].map((item) => {
        var _a;
        return new MsgData(item.msgType, (_a = item) === null || _a === void 0 ? void 0 : _a.data);
    });
}
exports.decodeTxData = decodeTxData;
//# sourceMappingURL=ProtoEncoding.js.map

/***/ }),

/***/ 1159:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* 
Generated by:
npx pbjs -t static-module  ../../../third_party/proto/tendermint/abci/types.proto ../../../third_party/proto/cosmos/base/abci/v1beta1/abci.proto ../../../third_party/proto/gogoproto/gogo.proto /home/assafmo/workspace/SecretNetwork/third_party/proto/google/protobuf/any.proto /home/assafmo/workspace/SecretNetwork/third_party/proto/google/protobuf/timestamp.proto ../../../third_party/proto/tendermint/types/* ../../../third_party/proto/tendermint/crypto/* ../../../third_party/proto/tendermint/version/* > src/ProtoDefs.js
*/

/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
(function (global, factory) {
  /* global define, require, module */

  /* AMD */ if (true) !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(9)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  /* CommonJS */ else {}
})(this, function ($protobuf) {
  "use strict";

  // Common aliases
  var $Reader = $protobuf.Reader,
    $Writer = $protobuf.Writer,
    $util = $protobuf.util;

  // Exported root namespace
  var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

  $root.tendermint = (function () {
    /**
     * Namespace tendermint.
     * @exports tendermint
     * @namespace
     */
    var tendermint = {};

    tendermint.abci = (function () {
      /**
       * Namespace abci.
       * @memberof tendermint
       * @namespace
       */
      var abci = {};

      abci.Request = (function () {
        /**
         * Properties of a Request.
         * @memberof tendermint.abci
         * @interface IRequest
         * @property {tendermint.abci.IRequestEcho|null} [echo] Request echo
         * @property {tendermint.abci.IRequestFlush|null} [flush] Request flush
         * @property {tendermint.abci.IRequestInfo|null} [info] Request info
         * @property {tendermint.abci.IRequestSetOption|null} [setOption] Request setOption
         * @property {tendermint.abci.IRequestInitChain|null} [initChain] Request initChain
         * @property {tendermint.abci.IRequestQuery|null} [query] Request query
         * @property {tendermint.abci.IRequestBeginBlock|null} [beginBlock] Request beginBlock
         * @property {tendermint.abci.IRequestCheckTx|null} [checkTx] Request checkTx
         * @property {tendermint.abci.IRequestDeliverTx|null} [deliverTx] Request deliverTx
         * @property {tendermint.abci.IRequestEndBlock|null} [endBlock] Request endBlock
         * @property {tendermint.abci.IRequestCommit|null} [commit] Request commit
         * @property {tendermint.abci.IRequestListSnapshots|null} [listSnapshots] Request listSnapshots
         * @property {tendermint.abci.IRequestOfferSnapshot|null} [offerSnapshot] Request offerSnapshot
         * @property {tendermint.abci.IRequestLoadSnapshotChunk|null} [loadSnapshotChunk] Request loadSnapshotChunk
         * @property {tendermint.abci.IRequestApplySnapshotChunk|null} [applySnapshotChunk] Request applySnapshotChunk
         */

        /**
         * Constructs a new Request.
         * @memberof tendermint.abci
         * @classdesc Represents a Request.
         * @implements IRequest
         * @constructor
         * @param {tendermint.abci.IRequest=} [properties] Properties to set
         */
        function Request(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * Request echo.
         * @member {tendermint.abci.IRequestEcho|null|undefined} echo
         * @memberof tendermint.abci.Request
         * @instance
         */
        Request.prototype.echo = null;

        /**
         * Request flush.
         * @member {tendermint.abci.IRequestFlush|null|undefined} flush
         * @memberof tendermint.abci.Request
         * @instance
         */
        Request.prototype.flush = null;

        /**
         * Request info.
         * @member {tendermint.abci.IRequestInfo|null|undefined} info
         * @memberof tendermint.abci.Request
         * @instance
         */
        Request.prototype.info = null;

        /**
         * Request setOption.
         * @member {tendermint.abci.IRequestSetOption|null|undefined} setOption
         * @memberof tendermint.abci.Request
         * @instance
         */
        Request.prototype.setOption = null;

        /**
         * Request initChain.
         * @member {tendermint.abci.IRequestInitChain|null|undefined} initChain
         * @memberof tendermint.abci.Request
         * @instance
         */
        Request.prototype.initChain = null;

        /**
         * Request query.
         * @member {tendermint.abci.IRequestQuery|null|undefined} query
         * @memberof tendermint.abci.Request
         * @instance
         */
        Request.prototype.query = null;

        /**
         * Request beginBlock.
         * @member {tendermint.abci.IRequestBeginBlock|null|undefined} beginBlock
         * @memberof tendermint.abci.Request
         * @instance
         */
        Request.prototype.beginBlock = null;

        /**
         * Request checkTx.
         * @member {tendermint.abci.IRequestCheckTx|null|undefined} checkTx
         * @memberof tendermint.abci.Request
         * @instance
         */
        Request.prototype.checkTx = null;

        /**
         * Request deliverTx.
         * @member {tendermint.abci.IRequestDeliverTx|null|undefined} deliverTx
         * @memberof tendermint.abci.Request
         * @instance
         */
        Request.prototype.deliverTx = null;

        /**
         * Request endBlock.
         * @member {tendermint.abci.IRequestEndBlock|null|undefined} endBlock
         * @memberof tendermint.abci.Request
         * @instance
         */
        Request.prototype.endBlock = null;

        /**
         * Request commit.
         * @member {tendermint.abci.IRequestCommit|null|undefined} commit
         * @memberof tendermint.abci.Request
         * @instance
         */
        Request.prototype.commit = null;

        /**
         * Request listSnapshots.
         * @member {tendermint.abci.IRequestListSnapshots|null|undefined} listSnapshots
         * @memberof tendermint.abci.Request
         * @instance
         */
        Request.prototype.listSnapshots = null;

        /**
         * Request offerSnapshot.
         * @member {tendermint.abci.IRequestOfferSnapshot|null|undefined} offerSnapshot
         * @memberof tendermint.abci.Request
         * @instance
         */
        Request.prototype.offerSnapshot = null;

        /**
         * Request loadSnapshotChunk.
         * @member {tendermint.abci.IRequestLoadSnapshotChunk|null|undefined} loadSnapshotChunk
         * @memberof tendermint.abci.Request
         * @instance
         */
        Request.prototype.loadSnapshotChunk = null;

        /**
         * Request applySnapshotChunk.
         * @member {tendermint.abci.IRequestApplySnapshotChunk|null|undefined} applySnapshotChunk
         * @memberof tendermint.abci.Request
         * @instance
         */
        Request.prototype.applySnapshotChunk = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * Request value.
         * @member {"echo"|"flush"|"info"|"setOption"|"initChain"|"query"|"beginBlock"|"checkTx"|"deliverTx"|"endBlock"|"commit"|"listSnapshots"|"offerSnapshot"|"loadSnapshotChunk"|"applySnapshotChunk"|undefined} value
         * @memberof tendermint.abci.Request
         * @instance
         */
        Object.defineProperty(Request.prototype, "value", {
          get: $util.oneOfGetter(
            ($oneOfFields = [
              "echo",
              "flush",
              "info",
              "setOption",
              "initChain",
              "query",
              "beginBlock",
              "checkTx",
              "deliverTx",
              "endBlock",
              "commit",
              "listSnapshots",
              "offerSnapshot",
              "loadSnapshotChunk",
              "applySnapshotChunk",
            ]),
          ),
          set: $util.oneOfSetter($oneOfFields),
        });

        /**
         * Creates a new Request instance using the specified properties.
         * @function create
         * @memberof tendermint.abci.Request
         * @static
         * @param {tendermint.abci.IRequest=} [properties] Properties to set
         * @returns {tendermint.abci.Request} Request instance
         */
        Request.create = function create(properties) {
          return new Request(properties);
        };

        /**
         * Encodes the specified Request message. Does not implicitly {@link tendermint.abci.Request.verify|verify} messages.
         * @function encode
         * @memberof tendermint.abci.Request
         * @static
         * @param {tendermint.abci.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.echo != null && Object.hasOwnProperty.call(message, "echo"))
            $root.tendermint.abci.RequestEcho.encode(
              message.echo,
              writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
            ).ldelim();
          if (message.flush != null && Object.hasOwnProperty.call(message, "flush"))
            $root.tendermint.abci.RequestFlush.encode(
              message.flush,
              writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
            ).ldelim();
          if (message.info != null && Object.hasOwnProperty.call(message, "info"))
            $root.tendermint.abci.RequestInfo.encode(
              message.info,
              writer.uint32(/* id 3, wireType 2 =*/ 26).fork(),
            ).ldelim();
          if (message.setOption != null && Object.hasOwnProperty.call(message, "setOption"))
            $root.tendermint.abci.RequestSetOption.encode(
              message.setOption,
              writer.uint32(/* id 4, wireType 2 =*/ 34).fork(),
            ).ldelim();
          if (message.initChain != null && Object.hasOwnProperty.call(message, "initChain"))
            $root.tendermint.abci.RequestInitChain.encode(
              message.initChain,
              writer.uint32(/* id 5, wireType 2 =*/ 42).fork(),
            ).ldelim();
          if (message.query != null && Object.hasOwnProperty.call(message, "query"))
            $root.tendermint.abci.RequestQuery.encode(
              message.query,
              writer.uint32(/* id 6, wireType 2 =*/ 50).fork(),
            ).ldelim();
          if (message.beginBlock != null && Object.hasOwnProperty.call(message, "beginBlock"))
            $root.tendermint.abci.RequestBeginBlock.encode(
              message.beginBlock,
              writer.uint32(/* id 7, wireType 2 =*/ 58).fork(),
            ).ldelim();
          if (message.checkTx != null && Object.hasOwnProperty.call(message, "checkTx"))
            $root.tendermint.abci.RequestCheckTx.encode(
              message.checkTx,
              writer.uint32(/* id 8, wireType 2 =*/ 66).fork(),
            ).ldelim();
          if (message.deliverTx != null && Object.hasOwnProperty.call(message, "deliverTx"))
            $root.tendermint.abci.RequestDeliverTx.encode(
              message.deliverTx,
              writer.uint32(/* id 9, wireType 2 =*/ 74).fork(),
            ).ldelim();
          if (message.endBlock != null && Object.hasOwnProperty.call(message, "endBlock"))
            $root.tendermint.abci.RequestEndBlock.encode(
              message.endBlock,
              writer.uint32(/* id 10, wireType 2 =*/ 82).fork(),
            ).ldelim();
          if (message.commit != null && Object.hasOwnProperty.call(message, "commit"))
            $root.tendermint.abci.RequestCommit.encode(
              message.commit,
              writer.uint32(/* id 11, wireType 2 =*/ 90).fork(),
            ).ldelim();
          if (message.listSnapshots != null && Object.hasOwnProperty.call(message, "listSnapshots"))
            $root.tendermint.abci.RequestListSnapshots.encode(
              message.listSnapshots,
              writer.uint32(/* id 12, wireType 2 =*/ 98).fork(),
            ).ldelim();
          if (message.offerSnapshot != null && Object.hasOwnProperty.call(message, "offerSnapshot"))
            $root.tendermint.abci.RequestOfferSnapshot.encode(
              message.offerSnapshot,
              writer.uint32(/* id 13, wireType 2 =*/ 106).fork(),
            ).ldelim();
          if (message.loadSnapshotChunk != null && Object.hasOwnProperty.call(message, "loadSnapshotChunk"))
            $root.tendermint.abci.RequestLoadSnapshotChunk.encode(
              message.loadSnapshotChunk,
              writer.uint32(/* id 14, wireType 2 =*/ 114).fork(),
            ).ldelim();
          if (message.applySnapshotChunk != null && Object.hasOwnProperty.call(message, "applySnapshotChunk"))
            $root.tendermint.abci.RequestApplySnapshotChunk.encode(
              message.applySnapshotChunk,
              writer.uint32(/* id 15, wireType 2 =*/ 122).fork(),
            ).ldelim();
          return writer;
        };

        /**
         * Encodes the specified Request message, length delimited. Does not implicitly {@link tendermint.abci.Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tendermint.abci.Request
         * @static
         * @param {tendermint.abci.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Request message from the specified reader or buffer.
         * @function decode
         * @memberof tendermint.abci.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tendermint.abci.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.tendermint.abci.Request();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.echo = $root.tendermint.abci.RequestEcho.decode(reader, reader.uint32());
                break;
              case 2:
                message.flush = $root.tendermint.abci.RequestFlush.decode(reader, reader.uint32());
                break;
              case 3:
                message.info = $root.tendermint.abci.RequestInfo.decode(reader, reader.uint32());
                break;
              case 4:
                message.setOption = $root.tendermint.abci.RequestSetOption.decode(reader, reader.uint32());
                break;
              case 5:
                message.initChain = $root.tendermint.abci.RequestInitChain.decode(reader, reader.uint32());
                break;
              case 6:
                message.query = $root.tendermint.abci.RequestQuery.decode(reader, reader.uint32());
                break;
              case 7:
                message.beginBlock = $root.tendermint.abci.RequestBeginBlock.decode(reader, reader.uint32());
                break;
              case 8:
                message.checkTx = $root.tendermint.abci.RequestCheckTx.decode(reader, reader.uint32());
                break;
              case 9:
                message.deliverTx = $root.tendermint.abci.RequestDeliverTx.decode(reader, reader.uint32());
                break;
              case 10:
                message.endBlock = $root.tendermint.abci.RequestEndBlock.decode(reader, reader.uint32());
                break;
              case 11:
                message.commit = $root.tendermint.abci.RequestCommit.decode(reader, reader.uint32());
                break;
              case 12:
                message.listSnapshots = $root.tendermint.abci.RequestListSnapshots.decode(
                  reader,
                  reader.uint32(),
                );
                break;
              case 13:
                message.offerSnapshot = $root.tendermint.abci.RequestOfferSnapshot.decode(
                  reader,
                  reader.uint32(),
                );
                break;
              case 14:
                message.loadSnapshotChunk = $root.tendermint.abci.RequestLoadSnapshotChunk.decode(
                  reader,
                  reader.uint32(),
                );
                break;
              case 15:
                message.applySnapshotChunk = $root.tendermint.abci.RequestApplySnapshotChunk.decode(
                  reader,
                  reader.uint32(),
                );
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tendermint.abci.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tendermint.abci.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Request message.
         * @function verify
         * @memberof tendermint.abci.Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Request.verify = function verify(message) {
          if (typeof message !== "object" || message === null) return "object expected";
          var properties = {};
          if (message.echo != null && message.hasOwnProperty("echo")) {
            properties.value = 1;
            {
              var error = $root.tendermint.abci.RequestEcho.verify(message.echo);
              if (error) return "echo." + error;
            }
          }
          if (message.flush != null && message.hasOwnProperty("flush")) {
            if (properties.value === 1) return "value: multiple values";
            properties.value = 1;
            {
              var error = $root.tendermint.abci.RequestFlush.verify(message.flush);
              if (error) return "flush." + error;
            }
          }
          if (message.info != null && message.hasOwnProperty("info")) {
            if (properties.value === 1) return "value: multiple values";
            properties.value = 1;
            {
              var error = $root.tendermint.abci.RequestInfo.verify(message.info);
              if (error) return "info." + error;
            }
          }
          if (message.setOption != null && message.hasOwnProperty("setOption")) {
            if (properties.value === 1) return "value: multiple values";
            properties.value = 1;
            {
              var error = $root.tendermint.abci.RequestSetOption.verify(message.setOption);
              if (error) return "setOption." + error;
            }
          }
          if (message.initChain != null && message.hasOwnProperty("initChain")) {
            if (properties.value === 1) return "value: multiple values";
            properties.value = 1;
            {
              var error = $root.tendermint.abci.RequestInitChain.verify(message.initChain);
              if (error) return "initChain." + error;
            }
          }
          if (message.query != null && message.hasOwnProperty("query")) {
            if (properties.value === 1) return "value: multiple values";
            properties.value = 1;
            {
              var error = $root.tendermint.abci.RequestQuery.verify(message.query);
              if (error) return "query." + error;
            }
          }
          if (message.beginBlock != null && message.hasOwnProperty("beginBlock")) {
            if (properties.value === 1) return "value: multiple values";
            properties.value = 1;
            {
              var error = $root.tendermint.abci.RequestBeginBlock.verify(message.beginBlock);
              if (error) return "beginBlock." + error;
            }
          }
          if (message.checkTx != null && message.hasOwnProperty("checkTx")) {
            if (properties.value === 1) return "value: multiple values";
            properties.value = 1;
            {
              var error = $root.tendermint.abci.RequestCheckTx.verify(message.checkTx);
              if (error) return "checkTx." + error;
            }
          }
          if (message.deliverTx != null && message.hasOwnProperty("deliverTx")) {
            if (properties.value === 1) return "value: multiple values";
            properties.value = 1;
            {
              var error = $root.tendermint.abci.RequestDeliverTx.verify(message.deliverTx);
              if (error) return "deliverTx." + error;
            }
          }
          if (message.endBlock != null && message.hasOwnProperty("endBlock")) {
            if (properties.value === 1) return "value: multiple values";
            properties.value = 1;
            {
              var error = $root.tendermint.abci.RequestEndBlock.verify(message.endBlock);
              if (error) return "endBlock." + error;
            }
          }
          if (message.commit != null && message.hasOwnProperty("commit")) {
            if (properties.value === 1) return "value: multiple values";
            properties.value = 1;
            {
              var error = $root.tendermint.abci.RequestCommit.verify(message.commit);
              if (error) return "commit." + error;
            }
          }
          if (message.listSnapshots != null && message.hasOwnProperty("listSnapshots")) {
            if (properties.value === 1) return "value: multiple values";
            properties.value = 1;
            {
              var error = $root.tendermint.abci.RequestListSnapshots.verify(message.listSnapshots);
              if (error) return "listSnapshots." + error;
            }
          }
          if (message.offerSnapshot != null && message.hasOwnProperty("offerSnapshot")) {
            if (properties.value === 1) return "value: multiple values";
            properties.value = 1;
            {
              var error = $root.tendermint.abci.RequestOfferSnapshot.verify(message.offerSnapshot);
              if (error) return "offerSnapshot." + error;
            }
          }
          if (message.loadSnapshotChunk != null && message.hasOwnProperty("loadSnapshotChunk")) {
            if (properties.value === 1) return "value: multiple values";
            properties.value = 1;
            {
              var error = $root.tendermint.abci.RequestLoadSnapshotChunk.verify(message.loadSnapshotChunk);
              if (error) return "loadSnapshotChunk." + error;
            }
          }
          if (message.applySnapshotChunk != null && message.hasOwnProperty("applySnapshotChunk")) {
            if (properties.value === 1) return "value: multiple values";
            properties.value = 1;
            {
              var error = $root.tendermint.abci.RequestApplySnapshotChunk.verify(message.applySnapshotChunk);
              if (error) return "applySnapshotChunk." + error;
            }
          }
          return null;
        };

        /**
         * Creates a Request message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tendermint.abci.Request
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tendermint.abci.Request} Request
         */
        Request.fromObject = function fromObject(object) {
          if (object instanceof $root.tendermint.abci.Request) return object;
          var message = new $root.tendermint.abci.Request();
          if (object.echo != null) {
            if (typeof object.echo !== "object")
              throw TypeError(".tendermint.abci.Request.echo: object expected");
            message.echo = $root.tendermint.abci.RequestEcho.fromObject(object.echo);
          }
          if (object.flush != null) {
            if (typeof object.flush !== "object")
              throw TypeError(".tendermint.abci.Request.flush: object expected");
            message.flush = $root.tendermint.abci.RequestFlush.fromObject(object.flush);
          }
          if (object.info != null) {
            if (typeof object.info !== "object")
              throw TypeError(".tendermint.abci.Request.info: object expected");
            message.info = $root.tendermint.abci.RequestInfo.fromObject(object.info);
          }
          if (object.setOption != null) {
            if (typeof object.setOption !== "object")
              throw TypeError(".tendermint.abci.Request.setOption: object expected");
            message.setOption = $root.tendermint.abci.RequestSetOption.fromObject(object.setOption);
          }
          if (object.initChain != null) {
            if (typeof object.initChain !== "object")
              throw TypeError(".tendermint.abci.Request.initChain: object expected");
            message.initChain = $root.tendermint.abci.RequestInitChain.fromObject(object.initChain);
          }
          if (object.query != null) {
            if (typeof object.query !== "object")
              throw TypeError(".tendermint.abci.Request.query: object expected");
            message.query = $root.tendermint.abci.RequestQuery.fromObject(object.query);
          }
          if (object.beginBlock != null) {
            if (typeof object.beginBlock !== "object")
              throw TypeError(".tendermint.abci.Request.beginBlock: object expected");
            message.beginBlock = $root.tendermint.abci.RequestBeginBlock.fromObject(object.beginBlock);
          }
          if (object.checkTx != null) {
            if (typeof object.checkTx !== "object")
              throw TypeError(".tendermint.abci.Request.checkTx: object expected");
            message.checkTx = $root.tendermint.abci.RequestCheckTx.fromObject(object.checkTx);
          }
          if (object.deliverTx != null) {
            if (typeof object.deliverTx !== "object")
              throw TypeError(".tendermint.abci.Request.deliverTx: object expected");
            message.deliverTx = $root.tendermint.abci.RequestDeliverTx.fromObject(object.deliverTx);
          }
          if (object.endBlock != null) {
            if (typeof object.endBlock !== "object")
              throw TypeError(".tendermint.abci.Request.endBlock: object expected");
            message.endBlock = $root.tendermint.abci.RequestEndBlock.fromObject(object.endBlock);
          }
          if (object.commit != null) {
            if (typeof object.commit !== "object")
              throw TypeError(".tendermint.abci.Request.commit: object expected");
            message.commit = $root.tendermint.abci.RequestCommit.fromObject(object.commit);
          }
          if (object.listSnapshots != null) {
            if (typeof object.listSnapshots !== "object")
              throw TypeError(".tendermint.abci.Request.listSnapshots: object expected");
            message.listSnapshots = $root.tendermint.abci.RequestListSnapshots.fromObject(
              object.listSnapshots,
            );
          }
          if (object.offerSnapshot != null) {
            if (typeof object.offerSnapshot !== "object")
              throw TypeError(".tendermint.abci.Request.offerSnapshot: object expected");
            message.offerSnapshot = $root.tendermint.abci.RequestOfferSnapshot.fromObject(
              object.offerSnapshot,
            );
          }
          if (object.loadSnapshotChunk != null) {
            if (typeof object.loadSnapshotChunk !== "object")
              throw TypeError(".tendermint.abci.Request.loadSnapshotChunk: object expected");
            message.loadSnapshotChunk = $root.tendermint.abci.RequestLoadSnapshotChunk.fromObject(
              object.loadSnapshotChunk,
            );
          }
          if (object.applySnapshotChunk != null) {
            if (typeof object.applySnapshotChunk !== "object")
              throw TypeError(".tendermint.abci.Request.applySnapshotChunk: object expected");
            message.applySnapshotChunk = $root.tendermint.abci.RequestApplySnapshotChunk.fromObject(
              object.applySnapshotChunk,
            );
          }
          return message;
        };

        /**
         * Creates a plain object from a Request message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tendermint.abci.Request
         * @static
         * @param {tendermint.abci.Request} message Request
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Request.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (message.echo != null && message.hasOwnProperty("echo")) {
            object.echo = $root.tendermint.abci.RequestEcho.toObject(message.echo, options);
            if (options.oneofs) object.value = "echo";
          }
          if (message.flush != null && message.hasOwnProperty("flush")) {
            object.flush = $root.tendermint.abci.RequestFlush.toObject(message.flush, options);
            if (options.oneofs) object.value = "flush";
          }
          if (message.info != null && message.hasOwnProperty("info")) {
            object.info = $root.tendermint.abci.RequestInfo.toObject(message.info, options);
            if (options.oneofs) object.value = "info";
          }
          if (message.setOption != null && message.hasOwnProperty("setOption")) {
            object.setOption = $root.tendermint.abci.RequestSetOption.toObject(message.setOption, options);
            if (options.oneofs) object.value = "setOption";
          }
          if (message.initChain != null && message.hasOwnProperty("initChain")) {
            object.initChain = $root.tendermint.abci.RequestInitChain.toObject(message.initChain, options);
            if (options.oneofs) object.value = "initChain";
          }
          if (message.query != null && message.hasOwnProperty("query")) {
            object.query = $root.tendermint.abci.RequestQuery.toObject(message.query, options);
            if (options.oneofs) object.value = "query";
          }
          if (message.beginBlock != null && message.hasOwnProperty("beginBlock")) {
            object.beginBlock = $root.tendermint.abci.RequestBeginBlock.toObject(message.beginBlock, options);
            if (options.oneofs) object.value = "beginBlock";
          }
          if (message.checkTx != null && message.hasOwnProperty("checkTx")) {
            object.checkTx = $root.tendermint.abci.RequestCheckTx.toObject(message.checkTx, options);
            if (options.oneofs) object.value = "checkTx";
          }
          if (message.deliverTx != null && message.hasOwnProperty("deliverTx")) {
            object.deliverTx = $root.tendermint.abci.RequestDeliverTx.toObject(message.deliverTx, options);
            if (options.oneofs) object.value = "deliverTx";
          }
          if (message.endBlock != null && message.hasOwnProperty("endBlock")) {
            object.endBlock = $root.tendermint.abci.RequestEndBlock.toObject(message.endBlock, options);
            if (options.oneofs) object.value = "endBlock";
          }
          if (message.commit != null && message.hasOwnProperty("commit")) {
            object.commit = $root.tendermint.abci.RequestCommit.toObject(message.commit, options);
            if (options.oneofs) object.value = "commit";
          }
          if (message.listSnapshots != null && message.hasOwnProperty("listSnapshots")) {
            object.listSnapshots = $root.tendermint.abci.RequestListSnapshots.toObject(
              message.listSnapshots,
              options,
            );
            if (options.oneofs) object.value = "listSnapshots";
          }
          if (message.offerSnapshot != null && message.hasOwnProperty("offerSnapshot")) {
            object.offerSnapshot = $root.tendermint.abci.RequestOfferSnapshot.toObject(
              message.offerSnapshot,
              options,
            );
            if (options.oneofs) object.value = "offerSnapshot";
          }
          if (message.loadSnapshotChunk != null && message.hasOwnProperty("loadSnapshotChunk")) {
            object.loadSnapshotChunk = $root.tendermint.abci.RequestLoadSnapshotChunk.toObject(
              message.loadSnapshotChunk,
              options,
            );
            if (options.oneofs) object.value = "loadSnapshotChunk";
          }
          if (message.applySnapshotChunk != null && message.hasOwnProperty("applySnapshotChunk")) {
            object.applySnapshotChunk = $root.tendermint.abci.RequestApplySnapshotChunk.toObject(
              message.applySnapshotChunk,
              options,
            );
            if (options.oneofs) object.value = "applySnapshotChunk";
          }
          return object;
        };

        /**
         * Converts this Request to JSON.
         * @function toJSON
         * @memberof tendermint.abci.Request
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Request.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Request;
      })();

      abci.RequestEcho = (function () {
        /**
         * Properties of a RequestEcho.
         * @memberof tendermint.abci
         * @interface IRequestEcho
         * @property {string|null} [message] RequestEcho message
         */

        /**
         * Constructs a new RequestEcho.
         * @memberof tendermint.abci
         * @classdesc Represents a RequestEcho.
         * @implements IRequestEcho
         * @constructor
         * @param {tendermint.abci.IRequestEcho=} [properties] Properties to set
         */
        function RequestEcho(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * RequestEcho message.
         * @member {string} message
         * @memberof tendermint.abci.RequestEcho
         * @instance
         */
        RequestEcho.prototype.message = "";

        /**
         * Creates a new RequestEcho instance using the specified properties.
         * @function create
         * @memberof tendermint.abci.RequestEcho
         * @static
         * @param {tendermint.abci.IRequestEcho=} [properties] Properties to set
         * @returns {tendermint.abci.RequestEcho} RequestEcho instance
         */
        RequestEcho.create = function create(properties) {
          return new RequestEcho(properties);
        };

        /**
         * Encodes the specified RequestEcho message. Does not implicitly {@link tendermint.abci.RequestEcho.verify|verify} messages.
         * @function encode
         * @memberof tendermint.abci.RequestEcho
         * @static
         * @param {tendermint.abci.IRequestEcho} message RequestEcho message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RequestEcho.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.message != null && Object.hasOwnProperty.call(message, "message"))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.message);
          return writer;
        };

        /**
         * Encodes the specified RequestEcho message, length delimited. Does not implicitly {@link tendermint.abci.RequestEcho.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tendermint.abci.RequestEcho
         * @static
         * @param {tendermint.abci.IRequestEcho} message RequestEcho message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RequestEcho.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RequestEcho message from the specified reader or buffer.
         * @function decode
         * @memberof tendermint.abci.RequestEcho
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tendermint.abci.RequestEcho} RequestEcho
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RequestEcho.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.tendermint.abci.RequestEcho();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.message = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a RequestEcho message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tendermint.abci.RequestEcho
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tendermint.abci.RequestEcho} RequestEcho
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RequestEcho.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RequestEcho message.
         * @function verify
         * @memberof tendermint.abci.RequestEcho
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RequestEcho.verify = function verify(message) {
          if (typeof message !== "object" || message === null) return "object expected";
          if (message.message != null && message.hasOwnProperty("message"))
            if (!$util.isString(message.message)) return "message: string expected";
          return null;
        };

        /**
         * Creates a RequestEcho message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tendermint.abci.RequestEcho
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tendermint.abci.RequestEcho} RequestEcho
         */
        RequestEcho.fromObject = function fromObject(object) {
          if (object instanceof $root.tendermint.abci.RequestEcho) return object;
          var message = new $root.tendermint.abci.RequestEcho();
          if (object.message != null) message.message = String(object.message);
          return message;
        };

        /**
         * Creates a plain object from a RequestEcho message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tendermint.abci.RequestEcho
         * @static
         * @param {tendermint.abci.RequestEcho} message RequestEcho
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RequestEcho.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) object.message = "";
          if (message.message != null && message.hasOwnProperty("message")) object.message = message.message;
          return object;
        };

        /**
         * Converts this RequestEcho to JSON.
         * @function toJSON
         * @memberof tendermint.abci.RequestEcho
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RequestEcho.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RequestEcho;
      })();

      abci.RequestFlush = (function () {
        /**
         * Properties of a RequestFlush.
         * @memberof tendermint.abci
         * @interface IRequestFlush
         */

        /**
         * Constructs a new RequestFlush.
         * @memberof tendermint.abci
         * @classdesc Represents a RequestFlush.
         * @implements IRequestFlush
         * @constructor
         * @param {tendermint.abci.IRequestFlush=} [properties] Properties to set
         */
        function RequestFlush(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new RequestFlush instance using the specified properties.
         * @function create
         * @memberof tendermint.abci.RequestFlush
         * @static
         * @param {tendermint.abci.IRequestFlush=} [properties] Properties to set
         * @returns {tendermint.abci.RequestFlush} RequestFlush instance
         */
        RequestFlush.create = function create(properties) {
          return new RequestFlush(properties);
        };

        /**
         * Encodes the specified RequestFlush message. Does not implicitly {@link tendermint.abci.RequestFlush.verify|verify} messages.
         * @function encode
         * @memberof tendermint.abci.RequestFlush
         * @static
         * @param {tendermint.abci.IRequestFlush} message RequestFlush message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RequestFlush.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          return writer;
        };

        /**
         * Encodes the specified RequestFlush message, length delimited. Does not implicitly {@link tendermint.abci.RequestFlush.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tendermint.abci.RequestFlush
         * @static
         * @param {tendermint.abci.IRequestFlush} message RequestFlush message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RequestFlush.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RequestFlush message from the specified reader or buffer.
         * @function decode
         * @memberof tendermint.abci.RequestFlush
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tendermint.abci.RequestFlush} RequestFlush
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RequestFlush.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.tendermint.abci.RequestFlush();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a RequestFlush message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tendermint.abci.RequestFlush
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tendermint.abci.RequestFlush} RequestFlush
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RequestFlush.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RequestFlush message.
         * @function verify
         * @memberof tendermint.abci.RequestFlush
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RequestFlush.verify = function verify(message) {
          if (typeof message !== "object" || message === null) return "object expected";
          return null;
        };

        /**
         * Creates a RequestFlush message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tendermint.abci.RequestFlush
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tendermint.abci.RequestFlush} RequestFlush
         */
        RequestFlush.fromObject = function fromObject(object) {
          if (object instanceof $root.tendermint.abci.RequestFlush) return object;
          return new $root.tendermint.abci.RequestFlush();
        };

        /**
         * Creates a plain object from a RequestFlush message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tendermint.abci.RequestFlush
         * @static
         * @param {tendermint.abci.RequestFlush} message RequestFlush
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RequestFlush.toObject = function toObject() {
          return {};
        };

        /**
         * Converts this RequestFlush to JSON.
         * @function toJSON
         * @memberof tendermint.abci.RequestFlush
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RequestFlush.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RequestFlush;
      })();

      abci.RequestInfo = (function () {
        /**
         * Properties of a RequestInfo.
         * @memberof tendermint.abci
         * @interface IRequestInfo
         * @property {string|null} [version] RequestInfo version
         * @property {number|Long|null} [blockVersion] RequestInfo blockVersion
         * @property {number|Long|null} [p2pVersion] RequestInfo p2pVersion
         */

        /**
         * Constructs a new RequestInfo.
         * @memberof tendermint.abci
         * @classdesc Represents a RequestInfo.
         * @implements IRequestInfo
         * @constructor
         * @param {tendermint.abci.IRequestInfo=} [properties] Properties to set
         */
        function RequestInfo(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * RequestInfo version.
         * @member {string} version
         * @memberof tendermint.abci.RequestInfo
         * @instance
         */
        RequestInfo.prototype.version = "";

        /**
         * RequestInfo blockVersion.
         * @member {number|Long} blockVersion
         * @memberof tendermint.abci.RequestInfo
         * @instance
         */
        RequestInfo.prototype.blockVersion = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

        /**
         * RequestInfo p2pVersion.
         * @member {number|Long} p2pVersion
         * @memberof tendermint.abci.RequestInfo
         * @instance
         */
        RequestInfo.prototype.p2pVersion = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

        /**
         * Creates a new RequestInfo instance using the specified properties.
         * @function create
         * @memberof tendermint.abci.RequestInfo
         * @static
         * @param {tendermint.abci.IRequestInfo=} [properties] Properties to set
         * @returns {tendermint.abci.RequestInfo} RequestInfo instance
         */
        RequestInfo.create = function create(properties) {
          return new RequestInfo(properties);
        };

        /**
         * Encodes the specified RequestInfo message. Does not implicitly {@link tendermint.abci.RequestInfo.verify|verify} messages.
         * @function encode
         * @memberof tendermint.abci.RequestInfo
         * @static
         * @param {tendermint.abci.IRequestInfo} message RequestInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RequestInfo.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.version != null && Object.hasOwnProperty.call(message, "version"))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.version);
          if (message.blockVersion != null && Object.hasOwnProperty.call(message, "blockVersion"))
            writer.uint32(/* id 2, wireType 0 =*/ 16).uint64(message.blockVersion);
          if (message.p2pVersion != null && Object.hasOwnProperty.call(message, "p2pVersion"))
            writer.uint32(/* id 3, wireType 0 =*/ 24).uint64(message.p2pVersion);
          return writer;
        };

        /**
         * Encodes the specified RequestInfo message, length delimited. Does not implicitly {@link tendermint.abci.RequestInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tendermint.abci.RequestInfo
         * @static
         * @param {tendermint.abci.IRequestInfo} message RequestInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RequestInfo.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RequestInfo message from the specified reader or buffer.
         * @function decode
         * @memberof tendermint.abci.RequestInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tendermint.abci.RequestInfo} RequestInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RequestInfo.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.tendermint.abci.RequestInfo();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.version = reader.string();
                break;
              case 2:
                message.blockVersion = reader.uint64();
                break;
              case 3:
                message.p2pVersion = reader.uint64();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a RequestInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tendermint.abci.RequestInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tendermint.abci.RequestInfo} RequestInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RequestInfo.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RequestInfo message.
         * @function verify
         * @memberof tendermint.abci.RequestInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RequestInfo.verify = function verify(message) {
          if (typeof message !== "object" || message === null) return "object expected";
          if (message.version != null && message.hasOwnProperty("version"))
            if (!$util.isString(message.version)) return "version: string expected";
          if (message.blockVersion != null && message.hasOwnProperty("blockVersion"))
            if (
              !$util.isInteger(message.blockVersion) &&
              !(
                message.blockVersion &&
                $util.isInteger(message.blockVersion.low) &&
                $util.isInteger(message.blockVersion.high)
              )
            )
              return "blockVersion: integer|Long expected";
          if (message.p2pVersion != null && message.hasOwnProperty("p2pVersion"))
            if (
              !$util.isInteger(message.p2pVersion) &&
              !(
                message.p2pVersion &&
                $util.isInteger(message.p2pVersion.low) &&
                $util.isInteger(message.p2pVersion.high)
              )
            )
              return "p2pVersion: integer|Long expected";
          return null;
        };

        /**
         * Creates a RequestInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tendermint.abci.RequestInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tendermint.abci.RequestInfo} RequestInfo
         */
        RequestInfo.fromObject = function fromObject(object) {
          if (object instanceof $root.tendermint.abci.RequestInfo) return object;
          var message = new $root.tendermint.abci.RequestInfo();
          if (object.version != null) message.version = String(object.version);
          if (object.blockVersion != null)
            if ($util.Long)
              (message.blockVersion = $util.Long.fromValue(object.blockVersion)).unsigned = true;
            else if (typeof object.blockVersion === "string")
              message.blockVersion = parseInt(object.blockVersion, 10);
            else if (typeof object.blockVersion === "number") message.blockVersion = object.blockVersion;
            else if (typeof object.blockVersion === "object")
              message.blockVersion = new $util.LongBits(
                object.blockVersion.low >>> 0,
                object.blockVersion.high >>> 0,
              ).toNumber(true);
          if (object.p2pVersion != null)
            if ($util.Long) (message.p2pVersion = $util.Long.fromValue(object.p2pVersion)).unsigned = true;
            else if (typeof object.p2pVersion === "string")
              message.p2pVersion = parseInt(object.p2pVersion, 10);
            else if (typeof object.p2pVersion === "number") message.p2pVersion = object.p2pVersion;
            else if (typeof object.p2pVersion === "object")
              message.p2pVersion = new $util.LongBits(
                object.p2pVersion.low >>> 0,
                object.p2pVersion.high >>> 0,
              ).toNumber(true);
          return message;
        };

        /**
         * Creates a plain object from a RequestInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tendermint.abci.RequestInfo
         * @static
         * @param {tendermint.abci.RequestInfo} message RequestInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RequestInfo.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.version = "";
            if ($util.Long) {
              var long = new $util.Long(0, 0, true);
              object.blockVersion =
                options.longs === String
                  ? long.toString()
                  : options.longs === Number
                  ? long.toNumber()
                  : long;
            } else object.blockVersion = options.longs === String ? "0" : 0;
            if ($util.Long) {
              var long = new $util.Long(0, 0, true);
              object.p2pVersion =
                options.longs === String
                  ? long.toString()
                  : options.longs === Number
                  ? long.toNumber()
                  : long;
            } else object.p2pVersion = options.longs === String ? "0" : 0;
          }
          if (message.version != null && message.hasOwnProperty("version")) object.version = message.version;
          if (message.blockVersion != null && message.hasOwnProperty("blockVersion"))
            if (typeof message.blockVersion === "number")
              object.blockVersion =
                options.longs === String ? String(message.blockVersion) : message.blockVersion;
            else
              object.blockVersion =
                options.longs === String
                  ? $util.Long.prototype.toString.call(message.blockVersion)
                  : options.longs === Number
                  ? new $util.LongBits(
                      message.blockVersion.low >>> 0,
                      message.blockVersion.high >>> 0,
                    ).toNumber(true)
                  : message.blockVersion;
          if (message.p2pVersion != null && message.hasOwnProperty("p2pVersion"))
            if (typeof message.p2pVersion === "number")
              object.p2pVersion = options.longs === String ? String(message.p2pVersion) : message.p2pVersion;
            else
              object.p2pVersion =
                options.longs === String
                  ? $util.Long.prototype.toString.call(message.p2pVersion)
                  : options.longs === Number
                  ? new $util.LongBits(message.p2pVersion.low >>> 0, message.p2pVersion.high >>> 0).toNumber(
                      true,
                    )
                  : message.p2pVersion;
          return object;
        };

        /**
         * Converts this RequestInfo to JSON.
         * @function toJSON
         * @memberof tendermint.abci.RequestInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RequestInfo.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RequestInfo;
      })();

      abci.RequestSetOption = (function () {
        /**
         * Properties of a RequestSetOption.
         * @memberof tendermint.abci
         * @interface IRequestSetOption
         * @property {string|null} [key] RequestSetOption key
         * @property {string|null} [value] RequestSetOption value
         */

        /**
         * Constructs a new RequestSetOption.
         * @memberof tendermint.abci
         * @classdesc Represents a RequestSetOption.
         * @implements IRequestSetOption
         * @constructor
         * @param {tendermint.abci.IRequestSetOption=} [properties] Properties to set
         */
        function RequestSetOption(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * RequestSetOption key.
         * @member {string} key
         * @memberof tendermint.abci.RequestSetOption
         * @instance
         */
        RequestSetOption.prototype.key = "";

        /**
         * RequestSetOption value.
         * @member {string} value
         * @memberof tendermint.abci.RequestSetOption
         * @instance
         */
        RequestSetOption.prototype.value = "";

        /**
         * Creates a new RequestSetOption instance using the specified properties.
         * @function create
         * @memberof tendermint.abci.RequestSetOption
         * @static
         * @param {tendermint.abci.IRequestSetOption=} [properties] Properties to set
         * @returns {tendermint.abci.RequestSetOption} RequestSetOption instance
         */
        RequestSetOption.create = function create(properties) {
          return new RequestSetOption(properties);
        };

        /**
         * Encodes the specified RequestSetOption message. Does not implicitly {@link tendermint.abci.RequestSetOption.verify|verify} messages.
         * @function encode
         * @memberof tendermint.abci.RequestSetOption
         * @static
         * @param {tendermint.abci.IRequestSetOption} message RequestSetOption message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RequestSetOption.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.key != null && Object.hasOwnProperty.call(message, "key"))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.key);
          if (message.value != null && Object.hasOwnProperty.call(message, "value"))
            writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.value);
          return writer;
        };

        /**
         * Encodes the specified RequestSetOption message, length delimited. Does not implicitly {@link tendermint.abci.RequestSetOption.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tendermint.abci.RequestSetOption
         * @static
         * @param {tendermint.abci.IRequestSetOption} message RequestSetOption message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RequestSetOption.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RequestSetOption message from the specified reader or buffer.
         * @function decode
         * @memberof tendermint.abci.RequestSetOption
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tendermint.abci.RequestSetOption} RequestSetOption
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RequestSetOption.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.tendermint.abci.RequestSetOption();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.key = reader.string();
                break;
              case 2:
                message.value = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a RequestSetOption message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tendermint.abci.RequestSetOption
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tendermint.abci.RequestSetOption} RequestSetOption
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RequestSetOption.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RequestSetOption message.
         * @function verify
         * @memberof tendermint.abci.RequestSetOption
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RequestSetOption.verify = function verify(message) {
          if (typeof message !== "object" || message === null) return "object expected";
          if (message.key != null && message.hasOwnProperty("key"))
            if (!$util.isString(message.key)) return "key: string expected";
          if (message.value != null && message.hasOwnProperty("value"))
            if (!$util.isString(message.value)) return "value: string expected";
          return null;
        };

        /**
         * Creates a RequestSetOption message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tendermint.abci.RequestSetOption
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tendermint.abci.RequestSetOption} RequestSetOption
         */
        RequestSetOption.fromObject = function fromObject(object) {
          if (object instanceof $root.tendermint.abci.RequestSetOption) return object;
          var message = new $root.tendermint.abci.RequestSetOption();
          if (object.key != null) message.key = String(object.key);
          if (object.value != null) message.value = String(object.value);
          return message;
        };

        /**
         * Creates a plain object from a RequestSetOption message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tendermint.abci.RequestSetOption
         * @static
         * @param {tendermint.abci.RequestSetOption} message RequestSetOption
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RequestSetOption.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.key = "";
            object.value = "";
          }
          if (message.key != null && message.hasOwnProperty("key")) object.key = message.key;
          if (message.value != null && message.hasOwnProperty("value")) object.value = message.value;
          return object;
        };

        /**
         * Converts this RequestSetOption to JSON.
         * @function toJSON
         * @memberof tendermint.abci.RequestSetOption
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RequestSetOption.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RequestSetOption;
      })();

      abci.RequestInitChain = (function () {
        /**
         * Properties of a RequestInitChain.
         * @memberof tendermint.abci
         * @interface IRequestInitChain
         * @property {google.protobuf.ITimestamp|null} [time] RequestInitChain time
         * @property {string|null} [chainId] RequestInitChain chainId
         * @property {tendermint.abci.IConsensusParams|null} [consensusParams] RequestInitChain consensusParams
         * @property {Array.<tendermint.abci.IValidatorUpdate>|null} [validators] RequestInitChain validators
         * @property {Uint8Array|null} [appStateBytes] RequestInitChain appStateBytes
         * @property {number|Long|null} [initialHeight] RequestInitChain initialHeight
         */

        /**
         * Constructs a new RequestInitChain.
         * @memberof tendermint.abci
         * @classdesc Represents a RequestInitChain.
         * @implements IRequestInitChain
         * @constructor
         * @param {tendermint.abci.IRequestInitChain=} [properties] Properties to set
         */
        function RequestInitChain(properties) {
          this.validators = [];
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * RequestInitChain time.
         * @member {google.protobuf.ITimestamp|null|undefined} time
         * @memberof tendermint.abci.RequestInitChain
         * @instance
         */
        RequestInitChain.prototype.time = null;

        /**
         * RequestInitChain chainId.
         * @member {string} chainId
         * @memberof tendermint.abci.RequestInitChain
         * @instance
         */
        RequestInitChain.prototype.chainId = "";

        /**
         * RequestInitChain consensusParams.
         * @member {tendermint.abci.IConsensusParams|null|undefined} consensusParams
         * @memberof tendermint.abci.RequestInitChain
         * @instance
         */
        RequestInitChain.prototype.consensusParams = null;

        /**
         * RequestInitChain validators.
         * @member {Array.<tendermint.abci.IValidatorUpdate>} validators
         * @memberof tendermint.abci.RequestInitChain
         * @instance
         */
        RequestInitChain.prototype.validators = $util.emptyArray;

        /**
         * RequestInitChain appStateBytes.
         * @member {Uint8Array} appStateBytes
         * @memberof tendermint.abci.RequestInitChain
         * @instance
         */
        RequestInitChain.prototype.appStateBytes = $util.newBuffer([]);

        /**
         * RequestInitChain initialHeight.
         * @member {number|Long} initialHeight
         * @memberof tendermint.abci.RequestInitChain
         * @instance
         */
        RequestInitChain.prototype.initialHeight = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * Creates a new RequestInitChain instance using the specified properties.
         * @function create
         * @memberof tendermint.abci.RequestInitChain
         * @static
         * @param {tendermint.abci.IRequestInitChain=} [properties] Properties to set
         * @returns {tendermint.abci.RequestInitChain} RequestInitChain instance
         */
        RequestInitChain.create = function create(properties) {
          return new RequestInitChain(properties);
        };

        /**
         * Encodes the specified RequestInitChain message. Does not implicitly {@link tendermint.abci.RequestInitChain.verify|verify} messages.
         * @function encode
         * @memberof tendermint.abci.RequestInitChain
         * @static
         * @param {tendermint.abci.IRequestInitChain} message RequestInitChain message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RequestInitChain.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.time != null && Object.hasOwnProperty.call(message, "time"))
            $root.google.protobuf.Timestamp.encode(
              message.time,
              writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
            ).ldelim();
          if (message.chainId != null && Object.hasOwnProperty.call(message, "chainId"))
            writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.chainId);
          if (message.consensusParams != null && Object.hasOwnProperty.call(message, "consensusParams"))
            $root.tendermint.abci.ConsensusParams.encode(
              message.consensusParams,
              writer.uint32(/* id 3, wireType 2 =*/ 26).fork(),
            ).ldelim();
          if (message.validators != null && message.validators.length)
            for (var i = 0; i < message.validators.length; ++i)
              $root.tendermint.abci.ValidatorUpdate.encode(
                message.validators[i],
                writer.uint32(/* id 4, wireType 2 =*/ 34).fork(),
              ).ldelim();
          if (message.appStateBytes != null && Object.hasOwnProperty.call(message, "appStateBytes"))
            writer.uint32(/* id 5, wireType 2 =*/ 42).bytes(message.appStateBytes);
          if (message.initialHeight != null && Object.hasOwnProperty.call(message, "initialHeight"))
            writer.uint32(/* id 6, wireType 0 =*/ 48).int64(message.initialHeight);
          return writer;
        };

        /**
         * Encodes the specified RequestInitChain message, length delimited. Does not implicitly {@link tendermint.abci.RequestInitChain.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tendermint.abci.RequestInitChain
         * @static
         * @param {tendermint.abci.IRequestInitChain} message RequestInitChain message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RequestInitChain.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RequestInitChain message from the specified reader or buffer.
         * @function decode
         * @memberof tendermint.abci.RequestInitChain
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tendermint.abci.RequestInitChain} RequestInitChain
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RequestInitChain.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.tendermint.abci.RequestInitChain();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.time = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                break;
              case 2:
                message.chainId = reader.string();
                break;
              case 3:
                message.consensusParams = $root.tendermint.abci.ConsensusParams.decode(
                  reader,
                  reader.uint32(),
                );
                break;
              case 4:
                if (!(message.validators && message.validators.length)) message.validators = [];
                message.validators.push(
                  $root.tendermint.abci.ValidatorUpdate.decode(reader, reader.uint32()),
                );
                break;
              case 5:
                message.appStateBytes = reader.bytes();
                break;
              case 6:
                message.initialHeight = reader.int64();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a RequestInitChain message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tendermint.abci.RequestInitChain
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tendermint.abci.RequestInitChain} RequestInitChain
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RequestInitChain.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RequestInitChain message.
         * @function verify
         * @memberof tendermint.abci.RequestInitChain
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RequestInitChain.verify = function verify(message) {
          if (typeof message !== "object" || message === null) return "object expected";
          if (message.time != null && message.hasOwnProperty("time")) {
            var error = $root.google.protobuf.Timestamp.verify(message.time);
            if (error) return "time." + error;
          }
          if (message.chainId != null && message.hasOwnProperty("chainId"))
            if (!$util.isString(message.chainId)) return "chainId: string expected";
          if (message.consensusParams != null && message.hasOwnProperty("consensusParams")) {
            var error = $root.tendermint.abci.ConsensusParams.verify(message.consensusParams);
            if (error) return "consensusParams." + error;
          }
          if (message.validators != null && message.hasOwnProperty("validators")) {
            if (!Array.isArray(message.validators)) return "validators: array expected";
            for (var i = 0; i < message.validators.length; ++i) {
              var error = $root.tendermint.abci.ValidatorUpdate.verify(message.validators[i]);
              if (error) return "validators." + error;
            }
          }
          if (message.appStateBytes != null && message.hasOwnProperty("appStateBytes"))
            if (
              !(
                (message.appStateBytes && typeof message.appStateBytes.length === "number") ||
                $util.isString(message.appStateBytes)
              )
            )
              return "appStateBytes: buffer expected";
          if (message.initialHeight != null && message.hasOwnProperty("initialHeight"))
            if (
              !$util.isInteger(message.initialHeight) &&
              !(
                message.initialHeight &&
                $util.isInteger(message.initialHeight.low) &&
                $util.isInteger(message.initialHeight.high)
              )
            )
              return "initialHeight: integer|Long expected";
          return null;
        };

        /**
         * Creates a RequestInitChain message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tendermint.abci.RequestInitChain
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tendermint.abci.RequestInitChain} RequestInitChain
         */
        RequestInitChain.fromObject = function fromObject(object) {
          if (object instanceof $root.tendermint.abci.RequestInitChain) return object;
          var message = new $root.tendermint.abci.RequestInitChain();
          if (object.time != null) {
            if (typeof object.time !== "object")
              throw TypeError(".tendermint.abci.RequestInitChain.time: object expected");
            message.time = $root.google.protobuf.Timestamp.fromObject(object.time);
          }
          if (object.chainId != null) message.chainId = String(object.chainId);
          if (object.consensusParams != null) {
            if (typeof object.consensusParams !== "object")
              throw TypeError(".tendermint.abci.RequestInitChain.consensusParams: object expected");
            message.consensusParams = $root.tendermint.abci.ConsensusParams.fromObject(
              object.consensusParams,
            );
          }
          if (object.validators) {
            if (!Array.isArray(object.validators))
              throw TypeError(".tendermint.abci.RequestInitChain.validators: array expected");
            message.validators = [];
            for (var i = 0; i < object.validators.length; ++i) {
              if (typeof object.validators[i] !== "object")
                throw TypeError(".tendermint.abci.RequestInitChain.validators: object expected");
              message.validators[i] = $root.tendermint.abci.ValidatorUpdate.fromObject(object.validators[i]);
            }
          }
          if (object.appStateBytes != null)
            if (typeof object.appStateBytes === "string")
              $util.base64.decode(
                object.appStateBytes,
                (message.appStateBytes = $util.newBuffer($util.base64.length(object.appStateBytes))),
                0,
              );
            else if (object.appStateBytes.length) message.appStateBytes = object.appStateBytes;
          if (object.initialHeight != null)
            if ($util.Long)
              (message.initialHeight = $util.Long.fromValue(object.initialHeight)).unsigned = false;
            else if (typeof object.initialHeight === "string")
              message.initialHeight = parseInt(object.initialHeight, 10);
            else if (typeof object.initialHeight === "number") message.initialHeight = object.initialHeight;
            else if (typeof object.initialHeight === "object")
              message.initialHeight = new $util.LongBits(
                object.initialHeight.low >>> 0,
                object.initialHeight.high >>> 0,
              ).toNumber();
          return message;
        };

        /**
         * Creates a plain object from a RequestInitChain message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tendermint.abci.RequestInitChain
         * @static
         * @param {tendermint.abci.RequestInitChain} message RequestInitChain
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RequestInitChain.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.arrays || options.defaults) object.validators = [];
          if (options.defaults) {
            object.time = null;
            object.chainId = "";
            object.consensusParams = null;
            if (options.bytes === String) object.appStateBytes = "";
            else {
              object.appStateBytes = [];
              if (options.bytes !== Array) object.appStateBytes = $util.newBuffer(object.appStateBytes);
            }
            if ($util.Long) {
              var long = new $util.Long(0, 0, false);
              object.initialHeight =
                options.longs === String
                  ? long.toString()
                  : options.longs === Number
                  ? long.toNumber()
                  : long;
            } else object.initialHeight = options.longs === String ? "0" : 0;
          }
          if (message.time != null && message.hasOwnProperty("time"))
            object.time = $root.google.protobuf.Timestamp.toObject(message.time, options);
          if (message.chainId != null && message.hasOwnProperty("chainId")) object.chainId = message.chainId;
          if (message.consensusParams != null && message.hasOwnProperty("consensusParams"))
            object.consensusParams = $root.tendermint.abci.ConsensusParams.toObject(
              message.consensusParams,
              options,
            );
          if (message.validators && message.validators.length) {
            object.validators = [];
            for (var j = 0; j < message.validators.length; ++j)
              object.validators[j] = $root.tendermint.abci.ValidatorUpdate.toObject(
                message.validators[j],
                options,
              );
          }
          if (message.appStateBytes != null && message.hasOwnProperty("appStateBytes"))
            object.appStateBytes =
              options.bytes === String
                ? $util.base64.encode(message.appStateBytes, 0, message.appStateBytes.length)
                : options.bytes === Array
                ? Array.prototype.slice.call(message.appStateBytes)
                : message.appStateBytes;
          if (message.initialHeight != null && message.hasOwnProperty("initialHeight"))
            if (typeof message.initialHeight === "number")
              object.initialHeight =
                options.longs === String ? String(message.initialHeight) : message.initialHeight;
            else
              object.initialHeight =
                options.longs === String
                  ? $util.Long.prototype.toString.call(message.initialHeight)
                  : options.longs === Number
                  ? new $util.LongBits(
                      message.initialHeight.low >>> 0,
                      message.initialHeight.high >>> 0,
                    ).toNumber()
                  : message.initialHeight;
          return object;
        };

        /**
         * Converts this RequestInitChain to JSON.
         * @function toJSON
         * @memberof tendermint.abci.RequestInitChain
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RequestInitChain.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RequestInitChain;
      })();

      abci.RequestQuery = (function () {
        /**
         * Properties of a RequestQuery.
         * @memberof tendermint.abci
         * @interface IRequestQuery
         * @property {Uint8Array|null} [data] RequestQuery data
         * @property {string|null} [path] RequestQuery path
         * @property {number|Long|null} [height] RequestQuery height
         * @property {boolean|null} [prove] RequestQuery prove
         */

        /**
         * Constructs a new RequestQuery.
         * @memberof tendermint.abci
         * @classdesc Represents a RequestQuery.
         * @implements IRequestQuery
         * @constructor
         * @param {tendermint.abci.IRequestQuery=} [properties] Properties to set
         */
        function RequestQuery(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * RequestQuery data.
         * @member {Uint8Array} data
         * @memberof tendermint.abci.RequestQuery
         * @instance
         */
        RequestQuery.prototype.data = $util.newBuffer([]);

        /**
         * RequestQuery path.
         * @member {string} path
         * @memberof tendermint.abci.RequestQuery
         * @instance
         */
        RequestQuery.prototype.path = "";

        /**
         * RequestQuery height.
         * @member {number|Long} height
         * @memberof tendermint.abci.RequestQuery
         * @instance
         */
        RequestQuery.prototype.height = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * RequestQuery prove.
         * @member {boolean} prove
         * @memberof tendermint.abci.RequestQuery
         * @instance
         */
        RequestQuery.prototype.prove = false;

        /**
         * Creates a new RequestQuery instance using the specified properties.
         * @function create
         * @memberof tendermint.abci.RequestQuery
         * @static
         * @param {tendermint.abci.IRequestQuery=} [properties] Properties to set
         * @returns {tendermint.abci.RequestQuery} RequestQuery instance
         */
        RequestQuery.create = function create(properties) {
          return new RequestQuery(properties);
        };

        /**
         * Encodes the specified RequestQuery message. Does not implicitly {@link tendermint.abci.RequestQuery.verify|verify} messages.
         * @function encode
         * @memberof tendermint.abci.RequestQuery
         * @static
         * @param {tendermint.abci.IRequestQuery} message RequestQuery message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RequestQuery.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.data != null && Object.hasOwnProperty.call(message, "data"))
            writer.uint32(/* id 1, wireType 2 =*/ 10).bytes(message.data);
          if (message.path != null && Object.hasOwnProperty.call(message, "path"))
            writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.path);
          if (message.height != null && Object.hasOwnProperty.call(message, "height"))
            writer.uint32(/* id 3, wireType 0 =*/ 24).int64(message.height);
          if (message.prove != null && Object.hasOwnProperty.call(message, "prove"))
            writer.uint32(/* id 4, wireType 0 =*/ 32).bool(message.prove);
          return writer;
        };

        /**
         * Encodes the specified RequestQuery message, length delimited. Does not implicitly {@link tendermint.abci.RequestQuery.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tendermint.abci.RequestQuery
         * @static
         * @param {tendermint.abci.IRequestQuery} message RequestQuery message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RequestQuery.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RequestQuery message from the specified reader or buffer.
         * @function decode
         * @memberof tendermint.abci.RequestQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tendermint.abci.RequestQuery} RequestQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RequestQuery.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.tendermint.abci.RequestQuery();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.data = reader.bytes();
                break;
              case 2:
                message.path = reader.string();
                break;
              case 3:
                message.height = reader.int64();
                break;
              case 4:
                message.prove = reader.bool();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a RequestQuery message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tendermint.abci.RequestQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tendermint.abci.RequestQuery} RequestQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RequestQuery.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RequestQuery message.
         * @function verify
         * @memberof tendermint.abci.RequestQuery
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RequestQuery.verify = function verify(message) {
          if (typeof message !== "object" || message === null) return "object expected";
          if (message.data != null && message.hasOwnProperty("data"))
            if (!((message.data && typeof message.data.length === "number") || $util.isString(message.data)))
              return "data: buffer expected";
          if (message.path != null && message.hasOwnProperty("path"))
            if (!$util.isString(message.path)) return "path: string expected";
          if (message.height != null && message.hasOwnProperty("height"))
            if (
              !$util.isInteger(message.height) &&
              !(message.height && $util.isInteger(message.height.low) && $util.isInteger(message.height.high))
            )
              return "height: integer|Long expected";
          if (message.prove != null && message.hasOwnProperty("prove"))
            if (typeof message.prove !== "boolean") return "prove: boolean expected";
          return null;
        };

        /**
         * Creates a RequestQuery message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tendermint.abci.RequestQuery
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tendermint.abci.RequestQuery} RequestQuery
         */
        RequestQuery.fromObject = function fromObject(object) {
          if (object instanceof $root.tendermint.abci.RequestQuery) return object;
          var message = new $root.tendermint.abci.RequestQuery();
          if (object.data != null)
            if (typeof object.data === "string")
              $util.base64.decode(
                object.data,
                (message.data = $util.newBuffer($util.base64.length(object.data))),
                0,
              );
            else if (object.data.length) message.data = object.data;
          if (object.path != null) message.path = String(object.path);
          if (object.height != null)
            if ($util.Long) (message.height = $util.Long.fromValue(object.height)).unsigned = false;
            else if (typeof object.height === "string") message.height = parseInt(object.height, 10);
            else if (typeof object.height === "number") message.height = object.height;
            else if (typeof object.height === "object")
              message.height = new $util.LongBits(
                object.height.low >>> 0,
                object.height.high >>> 0,
              ).toNumber();
          if (object.prove != null) message.prove = Boolean(object.prove);
          return message;
        };

        /**
         * Creates a plain object from a RequestQuery message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tendermint.abci.RequestQuery
         * @static
         * @param {tendermint.abci.RequestQuery} message RequestQuery
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RequestQuery.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            if (options.bytes === String) object.data = "";
            else {
              object.data = [];
              if (options.bytes !== Array) object.data = $util.newBuffer(object.data);
            }
            object.path = "";
            if ($util.Long) {
              var long = new $util.Long(0, 0, false);
              object.height =
                options.longs === String
                  ? long.toString()
                  : options.longs === Number
                  ? long.toNumber()
                  : long;
            } else object.height = options.longs === String ? "0" : 0;
            object.prove = false;
          }
          if (message.data != null && message.hasOwnProperty("data"))
            object.data =
              options.bytes === String
                ? $util.base64.encode(message.data, 0, message.data.length)
                : options.bytes === Array
                ? Array.prototype.slice.call(message.data)
                : message.data;
          if (message.path != null && message.hasOwnProperty("path")) object.path = message.path;
          if (message.height != null && message.hasOwnProperty("height"))
            if (typeof message.height === "number")
              object.height = options.longs === String ? String(message.height) : message.height;
            else
              object.height =
                options.longs === String
                  ? $util.Long.prototype.toString.call(message.height)
                  : options.longs === Number
                  ? new $util.LongBits(message.height.low >>> 0, message.height.high >>> 0).toNumber()
                  : message.height;
          if (message.prove != null && message.hasOwnProperty("prove")) object.prove = message.prove;
          return object;
        };

        /**
         * Converts this RequestQuery to JSON.
         * @function toJSON
         * @memberof tendermint.abci.RequestQuery
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RequestQuery.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RequestQuery;
      })();

      abci.RequestBeginBlock = (function () {
        /**
         * Properties of a RequestBeginBlock.
         * @memberof tendermint.abci
         * @interface IRequestBeginBlock
         * @property {Uint8Array|null} [hash] RequestBeginBlock hash
         * @property {tendermint.types.IHeader|null} [header] RequestBeginBlock header
         * @property {tendermint.abci.ILastCommitInfo|null} [lastCommitInfo] RequestBeginBlock lastCommitInfo
         * @property {Array.<tendermint.abci.IEvidence>|null} [byzantineValidators] RequestBeginBlock byzantineValidators
         */

        /**
         * Constructs a new RequestBeginBlock.
         * @memberof tendermint.abci
         * @classdesc Represents a RequestBeginBlock.
         * @implements IRequestBeginBlock
         * @constructor
         * @param {tendermint.abci.IRequestBeginBlock=} [properties] Properties to set
         */
        function RequestBeginBlock(properties) {
          this.byzantineValidators = [];
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * RequestBeginBlock hash.
         * @member {Uint8Array} hash
         * @memberof tendermint.abci.RequestBeginBlock
         * @instance
         */
        RequestBeginBlock.prototype.hash = $util.newBuffer([]);

        /**
         * RequestBeginBlock header.
         * @member {tendermint.types.IHeader|null|undefined} header
         * @memberof tendermint.abci.RequestBeginBlock
         * @instance
         */
        RequestBeginBlock.prototype.header = null;

        /**
         * RequestBeginBlock lastCommitInfo.
         * @member {tendermint.abci.ILastCommitInfo|null|undefined} lastCommitInfo
         * @memberof tendermint.abci.RequestBeginBlock
         * @instance
         */
        RequestBeginBlock.prototype.lastCommitInfo = null;

        /**
         * RequestBeginBlock byzantineValidators.
         * @member {Array.<tendermint.abci.IEvidence>} byzantineValidators
         * @memberof tendermint.abci.RequestBeginBlock
         * @instance
         */
        RequestBeginBlock.prototype.byzantineValidators = $util.emptyArray;

        /**
         * Creates a new RequestBeginBlock instance using the specified properties.
         * @function create
         * @memberof tendermint.abci.RequestBeginBlock
         * @static
         * @param {tendermint.abci.IRequestBeginBlock=} [properties] Properties to set
         * @returns {tendermint.abci.RequestBeginBlock} RequestBeginBlock instance
         */
        RequestBeginBlock.create = function create(properties) {
          return new RequestBeginBlock(properties);
        };

        /**
         * Encodes the specified RequestBeginBlock message. Does not implicitly {@link tendermint.abci.RequestBeginBlock.verify|verify} messages.
         * @function encode
         * @memberof tendermint.abci.RequestBeginBlock
         * @static
         * @param {tendermint.abci.IRequestBeginBlock} message RequestBeginBlock message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RequestBeginBlock.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.hash != null && Object.hasOwnProperty.call(message, "hash"))
            writer.uint32(/* id 1, wireType 2 =*/ 10).bytes(message.hash);
          if (message.header != null && Object.hasOwnProperty.call(message, "header"))
            $root.tendermint.types.Header.encode(
              message.header,
              writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
            ).ldelim();
          if (message.lastCommitInfo != null && Object.hasOwnProperty.call(message, "lastCommitInfo"))
            $root.tendermint.abci.LastCommitInfo.encode(
              message.lastCommitInfo,
              writer.uint32(/* id 3, wireType 2 =*/ 26).fork(),
            ).ldelim();
          if (message.byzantineValidators != null && message.byzantineValidators.length)
            for (var i = 0; i < message.byzantineValidators.length; ++i)
              $root.tendermint.abci.Evidence.encode(
                message.byzantineValidators[i],
                writer.uint32(/* id 4, wireType 2 =*/ 34).fork(),
              ).ldelim();
          return writer;
        };

        /**
         * Encodes the specified RequestBeginBlock message, length delimited. Does not implicitly {@link tendermint.abci.RequestBeginBlock.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tendermint.abci.RequestBeginBlock
         * @static
         * @param {tendermint.abci.IRequestBeginBlock} message RequestBeginBlock message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RequestBeginBlock.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RequestBeginBlock message from the specified reader or buffer.
         * @function decode
         * @memberof tendermint.abci.RequestBeginBlock
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tendermint.abci.RequestBeginBlock} RequestBeginBlock
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RequestBeginBlock.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.tendermint.abci.RequestBeginBlock();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.hash = reader.bytes();
                break;
              case 2:
                message.header = $root.tendermint.types.Header.decode(reader, reader.uint32());
                break;
              case 3:
                message.lastCommitInfo = $root.tendermint.abci.LastCommitInfo.decode(reader, reader.uint32());
                break;
              case 4:
                if (!(message.byzantineValidators && message.byzantineValidators.length))
                  message.byzantineValidators = [];
                message.byzantineValidators.push(
                  $root.tendermint.abci.Evidence.decode(reader, reader.uint32()),
                );
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a RequestBeginBlock message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tendermint.abci.RequestBeginBlock
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tendermint.abci.RequestBeginBlock} RequestBeginBlock
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RequestBeginBlock.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RequestBeginBlock message.
         * @function verify
         * @memberof tendermint.abci.RequestBeginBlock
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RequestBeginBlock.verify = function verify(message) {
          if (typeof message !== "object" || message === null) return "object expected";
          if (message.hash != null && message.hasOwnProperty("hash"))
            if (!((message.hash && typeof message.hash.length === "number") || $util.isString(message.hash)))
              return "hash: buffer expected";
          if (message.header != null && message.hasOwnProperty("header")) {
            var error = $root.tendermint.types.Header.verify(message.header);
            if (error) return "header." + error;
          }
          if (message.lastCommitInfo != null && message.hasOwnProperty("lastCommitInfo")) {
            var error = $root.tendermint.abci.LastCommitInfo.verify(message.lastCommitInfo);
            if (error) return "lastCommitInfo." + error;
          }
          if (message.byzantineValidators != null && message.hasOwnProperty("byzantineValidators")) {
            if (!Array.isArray(message.byzantineValidators)) return "byzantineValidators: array expected";
            for (var i = 0; i < message.byzantineValidators.length; ++i) {
              var error = $root.tendermint.abci.Evidence.verify(message.byzantineValidators[i]);
              if (error) return "byzantineValidators." + error;
            }
          }
          return null;
        };

        /**
         * Creates a RequestBeginBlock message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tendermint.abci.RequestBeginBlock
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tendermint.abci.RequestBeginBlock} RequestBeginBlock
         */
        RequestBeginBlock.fromObject = function fromObject(object) {
          if (object instanceof $root.tendermint.abci.RequestBeginBlock) return object;
          var message = new $root.tendermint.abci.RequestBeginBlock();
          if (object.hash != null)
            if (typeof object.hash === "string")
              $util.base64.decode(
                object.hash,
                (message.hash = $util.newBuffer($util.base64.length(object.hash))),
                0,
              );
            else if (object.hash.length) message.hash = object.hash;
          if (object.header != null) {
            if (typeof object.header !== "object")
              throw TypeError(".tendermint.abci.RequestBeginBlock.header: object expected");
            message.header = $root.tendermint.types.Header.fromObject(object.header);
          }
          if (object.lastCommitInfo != null) {
            if (typeof object.lastCommitInfo !== "object")
              throw TypeError(".tendermint.abci.RequestBeginBlock.lastCommitInfo: object expected");
            message.lastCommitInfo = $root.tendermint.abci.LastCommitInfo.fromObject(object.lastCommitInfo);
          }
          if (object.byzantineValidators) {
            if (!Array.isArray(object.byzantineValidators))
              throw TypeError(".tendermint.abci.RequestBeginBlock.byzantineValidators: array expected");
            message.byzantineValidators = [];
            for (var i = 0; i < object.byzantineValidators.length; ++i) {
              if (typeof object.byzantineValidators[i] !== "object")
                throw TypeError(".tendermint.abci.RequestBeginBlock.byzantineValidators: object expected");
              message.byzantineValidators[i] = $root.tendermint.abci.Evidence.fromObject(
                object.byzantineValidators[i],
              );
            }
          }
          return message;
        };

        /**
         * Creates a plain object from a RequestBeginBlock message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tendermint.abci.RequestBeginBlock
         * @static
         * @param {tendermint.abci.RequestBeginBlock} message RequestBeginBlock
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RequestBeginBlock.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.arrays || options.defaults) object.byzantineValidators = [];
          if (options.defaults) {
            if (options.bytes === String) object.hash = "";
            else {
              object.hash = [];
              if (options.bytes !== Array) object.hash = $util.newBuffer(object.hash);
            }
            object.header = null;
            object.lastCommitInfo = null;
          }
          if (message.hash != null && message.hasOwnProperty("hash"))
            object.hash =
              options.bytes === String
                ? $util.base64.encode(message.hash, 0, message.hash.length)
                : options.bytes === Array
                ? Array.prototype.slice.call(message.hash)
                : message.hash;
          if (message.header != null && message.hasOwnProperty("header"))
            object.header = $root.tendermint.types.Header.toObject(message.header, options);
          if (message.lastCommitInfo != null && message.hasOwnProperty("lastCommitInfo"))
            object.lastCommitInfo = $root.tendermint.abci.LastCommitInfo.toObject(
              message.lastCommitInfo,
              options,
            );
          if (message.byzantineValidators && message.byzantineValidators.length) {
            object.byzantineValidators = [];
            for (var j = 0; j < message.byzantineValidators.length; ++j)
              object.byzantineValidators[j] = $root.tendermint.abci.Evidence.toObject(
                message.byzantineValidators[j],
                options,
              );
          }
          return object;
        };

        /**
         * Converts this RequestBeginBlock to JSON.
         * @function toJSON
         * @memberof tendermint.abci.RequestBeginBlock
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RequestBeginBlock.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RequestBeginBlock;
      })();

      /**
       * CheckTxType enum.
       * @name tendermint.abci.CheckTxType
       * @enum {number}
       * @property {number} NEW=0 NEW value
       * @property {number} RECHECK=1 RECHECK value
       */
      abci.CheckTxType = (function () {
        var valuesById = {},
          values = Object.create(valuesById);
        values[(valuesById[0] = "NEW")] = 0;
        values[(valuesById[1] = "RECHECK")] = 1;
        return values;
      })();

      abci.RequestCheckTx = (function () {
        /**
         * Properties of a RequestCheckTx.
         * @memberof tendermint.abci
         * @interface IRequestCheckTx
         * @property {Uint8Array|null} [tx] RequestCheckTx tx
         * @property {tendermint.abci.CheckTxType|null} [type] RequestCheckTx type
         */

        /**
         * Constructs a new RequestCheckTx.
         * @memberof tendermint.abci
         * @classdesc Represents a RequestCheckTx.
         * @implements IRequestCheckTx
         * @constructor
         * @param {tendermint.abci.IRequestCheckTx=} [properties] Properties to set
         */
        function RequestCheckTx(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * RequestCheckTx tx.
         * @member {Uint8Array} tx
         * @memberof tendermint.abci.RequestCheckTx
         * @instance
         */
        RequestCheckTx.prototype.tx = $util.newBuffer([]);

        /**
         * RequestCheckTx type.
         * @member {tendermint.abci.CheckTxType} type
         * @memberof tendermint.abci.RequestCheckTx
         * @instance
         */
        RequestCheckTx.prototype.type = 0;

        /**
         * Creates a new RequestCheckTx instance using the specified properties.
         * @function create
         * @memberof tendermint.abci.RequestCheckTx
         * @static
         * @param {tendermint.abci.IRequestCheckTx=} [properties] Properties to set
         * @returns {tendermint.abci.RequestCheckTx} RequestCheckTx instance
         */
        RequestCheckTx.create = function create(properties) {
          return new RequestCheckTx(properties);
        };

        /**
         * Encodes the specified RequestCheckTx message. Does not implicitly {@link tendermint.abci.RequestCheckTx.verify|verify} messages.
         * @function encode
         * @memberof tendermint.abci.RequestCheckTx
         * @static
         * @param {tendermint.abci.IRequestCheckTx} message RequestCheckTx message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RequestCheckTx.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.tx != null && Object.hasOwnProperty.call(message, "tx"))
            writer.uint32(/* id 1, wireType 2 =*/ 10).bytes(message.tx);
          if (message.type != null && Object.hasOwnProperty.call(message, "type"))
            writer.uint32(/* id 2, wireType 0 =*/ 16).int32(message.type);
          return writer;
        };

        /**
         * Encodes the specified RequestCheckTx message, length delimited. Does not implicitly {@link tendermint.abci.RequestCheckTx.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tendermint.abci.RequestCheckTx
         * @static
         * @param {tendermint.abci.IRequestCheckTx} message RequestCheckTx message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RequestCheckTx.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RequestCheckTx message from the specified reader or buffer.
         * @function decode
         * @memberof tendermint.abci.RequestCheckTx
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tendermint.abci.RequestCheckTx} RequestCheckTx
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RequestCheckTx.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.tendermint.abci.RequestCheckTx();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.tx = reader.bytes();
                break;
              case 2:
                message.type = reader.int32();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a RequestCheckTx message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tendermint.abci.RequestCheckTx
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tendermint.abci.RequestCheckTx} RequestCheckTx
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RequestCheckTx.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RequestCheckTx message.
         * @function verify
         * @memberof tendermint.abci.RequestCheckTx
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RequestCheckTx.verify = function verify(message) {
          if (typeof message !== "object" || message === null) return "object expected";
          if (message.tx != null && message.hasOwnProperty("tx"))
            if (!((message.tx && typeof message.tx.length === "number") || $util.isString(message.tx)))
              return "tx: buffer expected";
          if (message.type != null && message.hasOwnProperty("type"))
            switch (message.type) {
              default:
                return "type: enum value expected";
              case 0:
              case 1:
                break;
            }
          return null;
        };

        /**
         * Creates a RequestCheckTx message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tendermint.abci.RequestCheckTx
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tendermint.abci.RequestCheckTx} RequestCheckTx
         */
        RequestCheckTx.fromObject = function fromObject(object) {
          if (object instanceof $root.tendermint.abci.RequestCheckTx) return object;
          var message = new $root.tendermint.abci.RequestCheckTx();
          if (object.tx != null)
            if (typeof object.tx === "string")
              $util.base64.decode(
                object.tx,
                (message.tx = $util.newBuffer($util.base64.length(object.tx))),
                0,
              );
            else if (object.tx.length) message.tx = object.tx;
          switch (object.type) {
            case "NEW":
            case 0:
              message.type = 0;
              break;
            case "RECHECK":
            case 1:
              message.type = 1;
              break;
          }
          return message;
        };

        /**
         * Creates a plain object from a RequestCheckTx message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tendermint.abci.RequestCheckTx
         * @static
         * @param {tendermint.abci.RequestCheckTx} message RequestCheckTx
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RequestCheckTx.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            if (options.bytes === String) object.tx = "";
            else {
              object.tx = [];
              if (options.bytes !== Array) object.tx = $util.newBuffer(object.tx);
            }
            object.type = options.enums === String ? "NEW" : 0;
          }
          if (message.tx != null && message.hasOwnProperty("tx"))
            object.tx =
              options.bytes === String
                ? $util.base64.encode(message.tx, 0, message.tx.length)
                : options.bytes === Array
                ? Array.prototype.slice.call(message.tx)
                : message.tx;
          if (message.type != null && message.hasOwnProperty("type"))
            object.type =
              options.enums === String ? $root.tendermint.abci.CheckTxType[message.type] : message.type;
          return object;
        };

        /**
         * Converts this RequestCheckTx to JSON.
         * @function toJSON
         * @memberof tendermint.abci.RequestCheckTx
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RequestCheckTx.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RequestCheckTx;
      })();

      abci.RequestDeliverTx = (function () {
        /**
         * Properties of a RequestDeliverTx.
         * @memberof tendermint.abci
         * @interface IRequestDeliverTx
         * @property {Uint8Array|null} [tx] RequestDeliverTx tx
         */

        /**
         * Constructs a new RequestDeliverTx.
         * @memberof tendermint.abci
         * @classdesc Represents a RequestDeliverTx.
         * @implements IRequestDeliverTx
         * @constructor
         * @param {tendermint.abci.IRequestDeliverTx=} [properties] Properties to set
         */
        function RequestDeliverTx(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * RequestDeliverTx tx.
         * @member {Uint8Array} tx
         * @memberof tendermint.abci.RequestDeliverTx
         * @instance
         */
        RequestDeliverTx.prototype.tx = $util.newBuffer([]);

        /**
         * Creates a new RequestDeliverTx instance using the specified properties.
         * @function create
         * @memberof tendermint.abci.RequestDeliverTx
         * @static
         * @param {tendermint.abci.IRequestDeliverTx=} [properties] Properties to set
         * @returns {tendermint.abci.RequestDeliverTx} RequestDeliverTx instance
         */
        RequestDeliverTx.create = function create(properties) {
          return new RequestDeliverTx(properties);
        };

        /**
         * Encodes the specified RequestDeliverTx message. Does not implicitly {@link tendermint.abci.RequestDeliverTx.verify|verify} messages.
         * @function encode
         * @memberof tendermint.abci.RequestDeliverTx
         * @static
         * @param {tendermint.abci.IRequestDeliverTx} message RequestDeliverTx message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RequestDeliverTx.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.tx != null && Object.hasOwnProperty.call(message, "tx"))
            writer.uint32(/* id 1, wireType 2 =*/ 10).bytes(message.tx);
          return writer;
        };

        /**
         * Encodes the specified RequestDeliverTx message, length delimited. Does not implicitly {@link tendermint.abci.RequestDeliverTx.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tendermint.abci.RequestDeliverTx
         * @static
         * @param {tendermint.abci.IRequestDeliverTx} message RequestDeliverTx message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RequestDeliverTx.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RequestDeliverTx message from the specified reader or buffer.
         * @function decode
         * @memberof tendermint.abci.RequestDeliverTx
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tendermint.abci.RequestDeliverTx} RequestDeliverTx
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RequestDeliverTx.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.tendermint.abci.RequestDeliverTx();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.tx = reader.bytes();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a RequestDeliverTx message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tendermint.abci.RequestDeliverTx
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tendermint.abci.RequestDeliverTx} RequestDeliverTx
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RequestDeliverTx.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RequestDeliverTx message.
         * @function verify
         * @memberof tendermint.abci.RequestDeliverTx
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RequestDeliverTx.verify = function verify(message) {
          if (typeof message !== "object" || message === null) return "object expected";
          if (message.tx != null && message.hasOwnProperty("tx"))
            if (!((message.tx && typeof message.tx.length === "number") || $util.isString(message.tx)))
              return "tx: buffer expected";
          return null;
        };

        /**
         * Creates a RequestDeliverTx message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tendermint.abci.RequestDeliverTx
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tendermint.abci.RequestDeliverTx} RequestDeliverTx
         */
        RequestDeliverTx.fromObject = function fromObject(object) {
          if (object instanceof $root.tendermint.abci.RequestDeliverTx) return object;
          var message = new $root.tendermint.abci.RequestDeliverTx();
          if (object.tx != null)
            if (typeof object.tx === "string")
              $util.base64.decode(
                object.tx,
                (message.tx = $util.newBuffer($util.base64.length(object.tx))),
                0,
              );
            else if (object.tx.length) message.tx = object.tx;
          return message;
        };

        /**
         * Creates a plain object from a RequestDeliverTx message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tendermint.abci.RequestDeliverTx
         * @static
         * @param {tendermint.abci.RequestDeliverTx} message RequestDeliverTx
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RequestDeliverTx.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults)
            if (options.bytes === String) object.tx = "";
            else {
              object.tx = [];
              if (options.bytes !== Array) object.tx = $util.newBuffer(object.tx);
            }
          if (message.tx != null && message.hasOwnProperty("tx"))
            object.tx =
              options.bytes === String
                ? $util.base64.encode(message.tx, 0, message.tx.length)
                : options.bytes === Array
                ? Array.prototype.slice.call(message.tx)
                : message.tx;
          return object;
        };

        /**
         * Converts this RequestDeliverTx to JSON.
         * @function toJSON
         * @memberof tendermint.abci.RequestDeliverTx
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RequestDeliverTx.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RequestDeliverTx;
      })();

      abci.RequestEndBlock = (function () {
        /**
         * Properties of a RequestEndBlock.
         * @memberof tendermint.abci
         * @interface IRequestEndBlock
         * @property {number|Long|null} [height] RequestEndBlock height
         */

        /**
         * Constructs a new RequestEndBlock.
         * @memberof tendermint.abci
         * @classdesc Represents a RequestEndBlock.
         * @implements IRequestEndBlock
         * @constructor
         * @param {tendermint.abci.IRequestEndBlock=} [properties] Properties to set
         */
        function RequestEndBlock(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * RequestEndBlock height.
         * @member {number|Long} height
         * @memberof tendermint.abci.RequestEndBlock
         * @instance
         */
        RequestEndBlock.prototype.height = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * Creates a new RequestEndBlock instance using the specified properties.
         * @function create
         * @memberof tendermint.abci.RequestEndBlock
         * @static
         * @param {tendermint.abci.IRequestEndBlock=} [properties] Properties to set
         * @returns {tendermint.abci.RequestEndBlock} RequestEndBlock instance
         */
        RequestEndBlock.create = function create(properties) {
          return new RequestEndBlock(properties);
        };

        /**
         * Encodes the specified RequestEndBlock message. Does not implicitly {@link tendermint.abci.RequestEndBlock.verify|verify} messages.
         * @function encode
         * @memberof tendermint.abci.RequestEndBlock
         * @static
         * @param {tendermint.abci.IRequestEndBlock} message RequestEndBlock message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RequestEndBlock.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.height != null && Object.hasOwnProperty.call(message, "height"))
            writer.uint32(/* id 1, wireType 0 =*/ 8).int64(message.height);
          return writer;
        };

        /**
         * Encodes the specified RequestEndBlock message, length delimited. Does not implicitly {@link tendermint.abci.RequestEndBlock.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tendermint.abci.RequestEndBlock
         * @static
         * @param {tendermint.abci.IRequestEndBlock} message RequestEndBlock message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RequestEndBlock.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RequestEndBlock message from the specified reader or buffer.
         * @function decode
         * @memberof tendermint.abci.RequestEndBlock
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tendermint.abci.RequestEndBlock} RequestEndBlock
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RequestEndBlock.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.tendermint.abci.RequestEndBlock();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.height = reader.int64();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a RequestEndBlock message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tendermint.abci.RequestEndBlock
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tendermint.abci.RequestEndBlock} RequestEndBlock
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RequestEndBlock.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RequestEndBlock message.
         * @function verify
         * @memberof tendermint.abci.RequestEndBlock
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RequestEndBlock.verify = function verify(message) {
          if (typeof message !== "object" || message === null) return "object expected";
          if (message.height != null && message.hasOwnProperty("height"))
            if (
              !$util.isInteger(message.height) &&
              !(message.height && $util.isInteger(message.height.low) && $util.isInteger(message.height.high))
            )
              return "height: integer|Long expected";
          return null;
        };

        /**
         * Creates a RequestEndBlock message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tendermint.abci.RequestEndBlock
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tendermint.abci.RequestEndBlock} RequestEndBlock
         */
        RequestEndBlock.fromObject = function fromObject(object) {
          if (object instanceof $root.tendermint.abci.RequestEndBlock) return object;
          var message = new $root.tendermint.abci.RequestEndBlock();
          if (object.height != null)
            if ($util.Long) (message.height = $util.Long.fromValue(object.height)).unsigned = false;
            else if (typeof object.height === "string") message.height = parseInt(object.height, 10);
            else if (typeof object.height === "number") message.height = object.height;
            else if (typeof object.height === "object")
              message.height = new $util.LongBits(
                object.height.low >>> 0,
                object.height.high >>> 0,
              ).toNumber();
          return message;
        };

        /**
         * Creates a plain object from a RequestEndBlock message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tendermint.abci.RequestEndBlock
         * @static
         * @param {tendermint.abci.RequestEndBlock} message RequestEndBlock
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RequestEndBlock.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults)
            if ($util.Long) {
              var long = new $util.Long(0, 0, false);
              object.height =
                options.longs === String
                  ? long.toString()
                  : options.longs === Number
                  ? long.toNumber()
                  : long;
            } else object.height = options.longs === String ? "0" : 0;
          if (message.height != null && message.hasOwnProperty("height"))
            if (typeof message.height === "number")
              object.height = options.longs === String ? String(message.height) : message.height;
            else
              object.height =
                options.longs === String
                  ? $util.Long.prototype.toString.call(message.height)
                  : options.longs === Number
                  ? new $util.LongBits(message.height.low >>> 0, message.height.high >>> 0).toNumber()
                  : message.height;
          return object;
        };

        /**
         * Converts this RequestEndBlock to JSON.
         * @function toJSON
         * @memberof tendermint.abci.RequestEndBlock
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RequestEndBlock.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RequestEndBlock;
      })();

      abci.RequestCommit = (function () {
        /**
         * Properties of a RequestCommit.
         * @memberof tendermint.abci
         * @interface IRequestCommit
         */

        /**
         * Constructs a new RequestCommit.
         * @memberof tendermint.abci
         * @classdesc Represents a RequestCommit.
         * @implements IRequestCommit
         * @constructor
         * @param {tendermint.abci.IRequestCommit=} [properties] Properties to set
         */
        function RequestCommit(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new RequestCommit instance using the specified properties.
         * @function create
         * @memberof tendermint.abci.RequestCommit
         * @static
         * @param {tendermint.abci.IRequestCommit=} [properties] Properties to set
         * @returns {tendermint.abci.RequestCommit} RequestCommit instance
         */
        RequestCommit.create = function create(properties) {
          return new RequestCommit(properties);
        };

        /**
         * Encodes the specified RequestCommit message. Does not implicitly {@link tendermint.abci.RequestCommit.verify|verify} messages.
         * @function encode
         * @memberof tendermint.abci.RequestCommit
         * @static
         * @param {tendermint.abci.IRequestCommit} message RequestCommit message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RequestCommit.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          return writer;
        };

        /**
         * Encodes the specified RequestCommit message, length delimited. Does not implicitly {@link tendermint.abci.RequestCommit.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tendermint.abci.RequestCommit
         * @static
         * @param {tendermint.abci.IRequestCommit} message RequestCommit message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RequestCommit.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RequestCommit message from the specified reader or buffer.
         * @function decode
         * @memberof tendermint.abci.RequestCommit
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tendermint.abci.RequestCommit} RequestCommit
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RequestCommit.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.tendermint.abci.RequestCommit();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a RequestCommit message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tendermint.abci.RequestCommit
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tendermint.abci.RequestCommit} RequestCommit
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RequestCommit.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RequestCommit message.
         * @function verify
         * @memberof tendermint.abci.RequestCommit
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RequestCommit.verify = function verify(message) {
          if (typeof message !== "object" || message === null) return "object expected";
          return null;
        };

        /**
         * Creates a RequestCommit message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tendermint.abci.RequestCommit
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tendermint.abci.RequestCommit} RequestCommit
         */
        RequestCommit.fromObject = function fromObject(object) {
          if (object instanceof $root.tendermint.abci.RequestCommit) return object;
          return new $root.tendermint.abci.RequestCommit();
        };

        /**
         * Creates a plain object from a RequestCommit message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tendermint.abci.RequestCommit
         * @static
         * @param {tendermint.abci.RequestCommit} message RequestCommit
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RequestCommit.toObject = function toObject() {
          return {};
        };

        /**
         * Converts this RequestCommit to JSON.
         * @function toJSON
         * @memberof tendermint.abci.RequestCommit
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RequestCommit.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RequestCommit;
      })();

      abci.RequestListSnapshots = (function () {
        /**
         * Properties of a RequestListSnapshots.
         * @memberof tendermint.abci
         * @interface IRequestListSnapshots
         */

        /**
         * Constructs a new RequestListSnapshots.
         * @memberof tendermint.abci
         * @classdesc Represents a RequestListSnapshots.
         * @implements IRequestListSnapshots
         * @constructor
         * @param {tendermint.abci.IRequestListSnapshots=} [properties] Properties to set
         */
        function RequestListSnapshots(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new RequestListSnapshots instance using the specified properties.
         * @function create
         * @memberof tendermint.abci.RequestListSnapshots
         * @static
         * @param {tendermint.abci.IRequestListSnapshots=} [properties] Properties to set
         * @returns {tendermint.abci.RequestListSnapshots} RequestListSnapshots instance
         */
        RequestListSnapshots.create = function create(properties) {
          return new RequestListSnapshots(properties);
        };

        /**
         * Encodes the specified RequestListSnapshots message. Does not implicitly {@link tendermint.abci.RequestListSnapshots.verify|verify} messages.
         * @function encode
         * @memberof tendermint.abci.RequestListSnapshots
         * @static
         * @param {tendermint.abci.IRequestListSnapshots} message RequestListSnapshots message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RequestListSnapshots.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          return writer;
        };

        /**
         * Encodes the specified RequestListSnapshots message, length delimited. Does not implicitly {@link tendermint.abci.RequestListSnapshots.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tendermint.abci.RequestListSnapshots
         * @static
         * @param {tendermint.abci.IRequestListSnapshots} message RequestListSnapshots message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RequestListSnapshots.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RequestListSnapshots message from the specified reader or buffer.
         * @function decode
         * @memberof tendermint.abci.RequestListSnapshots
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tendermint.abci.RequestListSnapshots} RequestListSnapshots
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RequestListSnapshots.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.tendermint.abci.RequestListSnapshots();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a RequestListSnapshots message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tendermint.abci.RequestListSnapshots
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tendermint.abci.RequestListSnapshots} RequestListSnapshots
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RequestListSnapshots.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RequestListSnapshots message.
         * @function verify
         * @memberof tendermint.abci.RequestListSnapshots
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RequestListSnapshots.verify = function verify(message) {
          if (typeof message !== "object" || message === null) return "object expected";
          return null;
        };

        /**
         * Creates a RequestListSnapshots message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tendermint.abci.RequestListSnapshots
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tendermint.abci.RequestListSnapshots} RequestListSnapshots
         */
        RequestListSnapshots.fromObject = function fromObject(object) {
          if (object instanceof $root.tendermint.abci.RequestListSnapshots) return object;
          return new $root.tendermint.abci.RequestListSnapshots();
        };

        /**
         * Creates a plain object from a RequestListSnapshots message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tendermint.abci.RequestListSnapshots
         * @static
         * @param {tendermint.abci.RequestListSnapshots} message RequestListSnapshots
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RequestListSnapshots.toObject = function toObject() {
          return {};
        };

        /**
         * Converts this RequestListSnapshots to JSON.
         * @function toJSON
         * @memberof tendermint.abci.RequestListSnapshots
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RequestListSnapshots.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RequestListSnapshots;
      })();

      abci.RequestOfferSnapshot = (function () {
        /**
         * Properties of a RequestOfferSnapshot.
         * @memberof tendermint.abci
         * @interface IRequestOfferSnapshot
         * @property {tendermint.abci.ISnapshot|null} [snapshot] RequestOfferSnapshot snapshot
         * @property {Uint8Array|null} [appHash] RequestOfferSnapshot appHash
         */

        /**
         * Constructs a new RequestOfferSnapshot.
         * @memberof tendermint.abci
         * @classdesc Represents a RequestOfferSnapshot.
         * @implements IRequestOfferSnapshot
         * @constructor
         * @param {tendermint.abci.IRequestOfferSnapshot=} [properties] Properties to set
         */
        function RequestOfferSnapshot(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * RequestOfferSnapshot snapshot.
         * @member {tendermint.abci.ISnapshot|null|undefined} snapshot
         * @memberof tendermint.abci.RequestOfferSnapshot
         * @instance
         */
        RequestOfferSnapshot.prototype.snapshot = null;

        /**
         * RequestOfferSnapshot appHash.
         * @member {Uint8Array} appHash
         * @memberof tendermint.abci.RequestOfferSnapshot
         * @instance
         */
        RequestOfferSnapshot.prototype.appHash = $util.newBuffer([]);

        /**
         * Creates a new RequestOfferSnapshot instance using the specified properties.
         * @function create
         * @memberof tendermint.abci.RequestOfferSnapshot
         * @static
         * @param {tendermint.abci.IRequestOfferSnapshot=} [properties] Properties to set
         * @returns {tendermint.abci.RequestOfferSnapshot} RequestOfferSnapshot instance
         */
        RequestOfferSnapshot.create = function create(properties) {
          return new RequestOfferSnapshot(properties);
        };

        /**
         * Encodes the specified RequestOfferSnapshot message. Does not implicitly {@link tendermint.abci.RequestOfferSnapshot.verify|verify} messages.
         * @function encode
         * @memberof tendermint.abci.RequestOfferSnapshot
         * @static
         * @param {tendermint.abci.IRequestOfferSnapshot} message RequestOfferSnapshot message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RequestOfferSnapshot.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.snapshot != null && Object.hasOwnProperty.call(message, "snapshot"))
            $root.tendermint.abci.Snapshot.encode(
              message.snapshot,
              writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
            ).ldelim();
          if (message.appHash != null && Object.hasOwnProperty.call(message, "appHash"))
            writer.uint32(/* id 2, wireType 2 =*/ 18).bytes(message.appHash);
          return writer;
        };

        /**
         * Encodes the specified RequestOfferSnapshot message, length delimited. Does not implicitly {@link tendermint.abci.RequestOfferSnapshot.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tendermint.abci.RequestOfferSnapshot
         * @static
         * @param {tendermint.abci.IRequestOfferSnapshot} message RequestOfferSnapshot message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RequestOfferSnapshot.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RequestOfferSnapshot message from the specified reader or buffer.
         * @function decode
         * @memberof tendermint.abci.RequestOfferSnapshot
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tendermint.abci.RequestOfferSnapshot} RequestOfferSnapshot
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RequestOfferSnapshot.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.tendermint.abci.RequestOfferSnapshot();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.snapshot = $root.tendermint.abci.Snapshot.decode(reader, reader.uint32());
                break;
              case 2:
                message.appHash = reader.bytes();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a RequestOfferSnapshot message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tendermint.abci.RequestOfferSnapshot
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tendermint.abci.RequestOfferSnapshot} RequestOfferSnapshot
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RequestOfferSnapshot.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RequestOfferSnapshot message.
         * @function verify
         * @memberof tendermint.abci.RequestOfferSnapshot
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RequestOfferSnapshot.verify = function verify(message) {
          if (typeof message !== "object" || message === null) return "object expected";
          if (message.snapshot != null && message.hasOwnProperty("snapshot")) {
            var error = $root.tendermint.abci.Snapshot.verify(message.snapshot);
            if (error) return "snapshot." + error;
          }
          if (message.appHash != null && message.hasOwnProperty("appHash"))
            if (
              !(
                (message.appHash && typeof message.appHash.length === "number") ||
                $util.isString(message.appHash)
              )
            )
              return "appHash: buffer expected";
          return null;
        };

        /**
         * Creates a RequestOfferSnapshot message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tendermint.abci.RequestOfferSnapshot
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tendermint.abci.RequestOfferSnapshot} RequestOfferSnapshot
         */
        RequestOfferSnapshot.fromObject = function fromObject(object) {
          if (object instanceof $root.tendermint.abci.RequestOfferSnapshot) return object;
          var message = new $root.tendermint.abci.RequestOfferSnapshot();
          if (object.snapshot != null) {
            if (typeof object.snapshot !== "object")
              throw TypeError(".tendermint.abci.RequestOfferSnapshot.snapshot: object expected");
            message.snapshot = $root.tendermint.abci.Snapshot.fromObject(object.snapshot);
          }
          if (object.appHash != null)
            if (typeof object.appHash === "string")
              $util.base64.decode(
                object.appHash,
                (message.appHash = $util.newBuffer($util.base64.length(object.appHash))),
                0,
              );
            else if (object.appHash.length) message.appHash = object.appHash;
          return message;
        };

        /**
         * Creates a plain object from a RequestOfferSnapshot message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tendermint.abci.RequestOfferSnapshot
         * @static
         * @param {tendermint.abci.RequestOfferSnapshot} message RequestOfferSnapshot
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RequestOfferSnapshot.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.snapshot = null;
            if (options.bytes === String) object.appHash = "";
            else {
              object.appHash = [];
              if (options.bytes !== Array) object.appHash = $util.newBuffer(object.appHash);
            }
          }
          if (message.snapshot != null && message.hasOwnProperty("snapshot"))
            object.snapshot = $root.tendermint.abci.Snapshot.toObject(message.snapshot, options);
          if (message.appHash != null && message.hasOwnProperty("appHash"))
            object.appHash =
              options.bytes === String
                ? $util.base64.encode(message.appHash, 0, message.appHash.length)
                : options.bytes === Array
                ? Array.prototype.slice.call(message.appHash)
                : message.appHash;
          return object;
        };

        /**
         * Converts this RequestOfferSnapshot to JSON.
         * @function toJSON
         * @memberof tendermint.abci.RequestOfferSnapshot
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RequestOfferSnapshot.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RequestOfferSnapshot;
      })();

      abci.RequestLoadSnapshotChunk = (function () {
        /**
         * Properties of a RequestLoadSnapshotChunk.
         * @memberof tendermint.abci
         * @interface IRequestLoadSnapshotChunk
         * @property {number|Long|null} [height] RequestLoadSnapshotChunk height
         * @property {number|null} [format] RequestLoadSnapshotChunk format
         * @property {number|null} [chunk] RequestLoadSnapshotChunk chunk
         */

        /**
         * Constructs a new RequestLoadSnapshotChunk.
         * @memberof tendermint.abci
         * @classdesc Represents a RequestLoadSnapshotChunk.
         * @implements IRequestLoadSnapshotChunk
         * @constructor
         * @param {tendermint.abci.IRequestLoadSnapshotChunk=} [properties] Properties to set
         */
        function RequestLoadSnapshotChunk(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * RequestLoadSnapshotChunk height.
         * @member {number|Long} height
         * @memberof tendermint.abci.RequestLoadSnapshotChunk
         * @instance
         */
        RequestLoadSnapshotChunk.prototype.height = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

        /**
         * RequestLoadSnapshotChunk format.
         * @member {number} format
         * @memberof tendermint.abci.RequestLoadSnapshotChunk
         * @instance
         */
        RequestLoadSnapshotChunk.prototype.format = 0;

        /**
         * RequestLoadSnapshotChunk chunk.
         * @member {number} chunk
         * @memberof tendermint.abci.RequestLoadSnapshotChunk
         * @instance
         */
        RequestLoadSnapshotChunk.prototype.chunk = 0;

        /**
         * Creates a new RequestLoadSnapshotChunk instance using the specified properties.
         * @function create
         * @memberof tendermint.abci.RequestLoadSnapshotChunk
         * @static
         * @param {tendermint.abci.IRequestLoadSnapshotChunk=} [properties] Properties to set
         * @returns {tendermint.abci.RequestLoadSnapshotChunk} RequestLoadSnapshotChunk instance
         */
        RequestLoadSnapshotChunk.create = function create(properties) {
          return new RequestLoadSnapshotChunk(properties);
        };

        /**
         * Encodes the specified RequestLoadSnapshotChunk message. Does not implicitly {@link tendermint.abci.RequestLoadSnapshotChunk.verify|verify} messages.
         * @function encode
         * @memberof tendermint.abci.RequestLoadSnapshotChunk
         * @static
         * @param {tendermint.abci.IRequestLoadSnapshotChunk} message RequestLoadSnapshotChunk message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RequestLoadSnapshotChunk.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.height != null && Object.hasOwnProperty.call(message, "height"))
            writer.uint32(/* id 1, wireType 0 =*/ 8).uint64(message.height);
          if (message.format != null && Object.hasOwnProperty.call(message, "format"))
            writer.uint32(/* id 2, wireType 0 =*/ 16).uint32(message.format);
          if (message.chunk != null && Object.hasOwnProperty.call(message, "chunk"))
            writer.uint32(/* id 3, wireType 0 =*/ 24).uint32(message.chunk);
          return writer;
        };

        /**
         * Encodes the specified RequestLoadSnapshotChunk message, length delimited. Does not implicitly {@link tendermint.abci.RequestLoadSnapshotChunk.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tendermint.abci.RequestLoadSnapshotChunk
         * @static
         * @param {tendermint.abci.IRequestLoadSnapshotChunk} message RequestLoadSnapshotChunk message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RequestLoadSnapshotChunk.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RequestLoadSnapshotChunk message from the specified reader or buffer.
         * @function decode
         * @memberof tendermint.abci.RequestLoadSnapshotChunk
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tendermint.abci.RequestLoadSnapshotChunk} RequestLoadSnapshotChunk
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RequestLoadSnapshotChunk.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.tendermint.abci.RequestLoadSnapshotChunk();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.height = reader.uint64();
                break;
              case 2:
                message.format = reader.uint32();
                break;
              case 3:
                message.chunk = reader.uint32();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a RequestLoadSnapshotChunk message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tendermint.abci.RequestLoadSnapshotChunk
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tendermint.abci.RequestLoadSnapshotChunk} RequestLoadSnapshotChunk
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RequestLoadSnapshotChunk.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RequestLoadSnapshotChunk message.
         * @function verify
         * @memberof tendermint.abci.RequestLoadSnapshotChunk
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RequestLoadSnapshotChunk.verify = function verify(message) {
          if (typeof message !== "object" || message === null) return "object expected";
          if (message.height != null && message.hasOwnProperty("height"))
            if (
              !$util.isInteger(message.height) &&
              !(message.height && $util.isInteger(message.height.low) && $util.isInteger(message.height.high))
            )
              return "height: integer|Long expected";
          if (message.format != null && message.hasOwnProperty("format"))
            if (!$util.isInteger(message.format)) return "format: integer expected";
          if (message.chunk != null && message.hasOwnProperty("chunk"))
            if (!$util.isInteger(message.chunk)) return "chunk: integer expected";
          return null;
        };

        /**
         * Creates a RequestLoadSnapshotChunk message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tendermint.abci.RequestLoadSnapshotChunk
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tendermint.abci.RequestLoadSnapshotChunk} RequestLoadSnapshotChunk
         */
        RequestLoadSnapshotChunk.fromObject = function fromObject(object) {
          if (object instanceof $root.tendermint.abci.RequestLoadSnapshotChunk) return object;
          var message = new $root.tendermint.abci.RequestLoadSnapshotChunk();
          if (object.height != null)
            if ($util.Long) (message.height = $util.Long.fromValue(object.height)).unsigned = true;
            else if (typeof object.height === "string") message.height = parseInt(object.height, 10);
            else if (typeof object.height === "number") message.height = object.height;
            else if (typeof object.height === "object")
              message.height = new $util.LongBits(object.height.low >>> 0, object.height.high >>> 0).toNumber(
                true,
              );
          if (object.format != null) message.format = object.format >>> 0;
          if (object.chunk != null) message.chunk = object.chunk >>> 0;
          return message;
        };

        /**
         * Creates a plain object from a RequestLoadSnapshotChunk message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tendermint.abci.RequestLoadSnapshotChunk
         * @static
         * @param {tendermint.abci.RequestLoadSnapshotChunk} message RequestLoadSnapshotChunk
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RequestLoadSnapshotChunk.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            if ($util.Long) {
              var long = new $util.Long(0, 0, true);
              object.height =
                options.longs === String
                  ? long.toString()
                  : options.longs === Number
                  ? long.toNumber()
                  : long;
            } else object.height = options.longs === String ? "0" : 0;
            object.format = 0;
            object.chunk = 0;
          }
          if (message.height != null && message.hasOwnProperty("height"))
            if (typeof message.height === "number")
              object.height = options.longs === String ? String(message.height) : message.height;
            else
              object.height =
                options.longs === String
                  ? $util.Long.prototype.toString.call(message.height)
                  : options.longs === Number
                  ? new $util.LongBits(message.height.low >>> 0, message.height.high >>> 0).toNumber(true)
                  : message.height;
          if (message.format != null && message.hasOwnProperty("format")) object.format = message.format;
          if (message.chunk != null && message.hasOwnProperty("chunk")) object.chunk = message.chunk;
          return object;
        };

        /**
         * Converts this RequestLoadSnapshotChunk to JSON.
         * @function toJSON
         * @memberof tendermint.abci.RequestLoadSnapshotChunk
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RequestLoadSnapshotChunk.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RequestLoadSnapshotChunk;
      })();

      abci.RequestApplySnapshotChunk = (function () {
        /**
         * Properties of a RequestApplySnapshotChunk.
         * @memberof tendermint.abci
         * @interface IRequestApplySnapshotChunk
         * @property {number|null} [index] RequestApplySnapshotChunk index
         * @property {Uint8Array|null} [chunk] RequestApplySnapshotChunk chunk
         * @property {string|null} [sender] RequestApplySnapshotChunk sender
         */

        /**
         * Constructs a new RequestApplySnapshotChunk.
         * @memberof tendermint.abci
         * @classdesc Represents a RequestApplySnapshotChunk.
         * @implements IRequestApplySnapshotChunk
         * @constructor
         * @param {tendermint.abci.IRequestApplySnapshotChunk=} [properties] Properties to set
         */
        function RequestApplySnapshotChunk(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * RequestApplySnapshotChunk index.
         * @member {number} index
         * @memberof tendermint.abci.RequestApplySnapshotChunk
         * @instance
         */
        RequestApplySnapshotChunk.prototype.index = 0;

        /**
         * RequestApplySnapshotChunk chunk.
         * @member {Uint8Array} chunk
         * @memberof tendermint.abci.RequestApplySnapshotChunk
         * @instance
         */
        RequestApplySnapshotChunk.prototype.chunk = $util.newBuffer([]);

        /**
         * RequestApplySnapshotChunk sender.
         * @member {string} sender
         * @memberof tendermint.abci.RequestApplySnapshotChunk
         * @instance
         */
        RequestApplySnapshotChunk.prototype.sender = "";

        /**
         * Creates a new RequestApplySnapshotChunk instance using the specified properties.
         * @function create
         * @memberof tendermint.abci.RequestApplySnapshotChunk
         * @static
         * @param {tendermint.abci.IRequestApplySnapshotChunk=} [properties] Properties to set
         * @returns {tendermint.abci.RequestApplySnapshotChunk} RequestApplySnapshotChunk instance
         */
        RequestApplySnapshotChunk.create = function create(properties) {
          return new RequestApplySnapshotChunk(properties);
        };

        /**
         * Encodes the specified RequestApplySnapshotChunk message. Does not implicitly {@link tendermint.abci.RequestApplySnapshotChunk.verify|verify} messages.
         * @function encode
         * @memberof tendermint.abci.RequestApplySnapshotChunk
         * @static
         * @param {tendermint.abci.IRequestApplySnapshotChunk} message RequestApplySnapshotChunk message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RequestApplySnapshotChunk.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.index != null && Object.hasOwnProperty.call(message, "index"))
            writer.uint32(/* id 1, wireType 0 =*/ 8).uint32(message.index);
          if (message.chunk != null && Object.hasOwnProperty.call(message, "chunk"))
            writer.uint32(/* id 2, wireType 2 =*/ 18).bytes(message.chunk);
          if (message.sender != null && Object.hasOwnProperty.call(message, "sender"))
            writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.sender);
          return writer;
        };

        /**
         * Encodes the specified RequestApplySnapshotChunk message, length delimited. Does not implicitly {@link tendermint.abci.RequestApplySnapshotChunk.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tendermint.abci.RequestApplySnapshotChunk
         * @static
         * @param {tendermint.abci.IRequestApplySnapshotChunk} message RequestApplySnapshotChunk message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RequestApplySnapshotChunk.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RequestApplySnapshotChunk message from the specified reader or buffer.
         * @function decode
         * @memberof tendermint.abci.RequestApplySnapshotChunk
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tendermint.abci.RequestApplySnapshotChunk} RequestApplySnapshotChunk
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RequestApplySnapshotChunk.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.tendermint.abci.RequestApplySnapshotChunk();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.index = reader.uint32();
                break;
              case 2:
                message.chunk = reader.bytes();
                break;
              case 3:
                message.sender = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a RequestApplySnapshotChunk message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tendermint.abci.RequestApplySnapshotChunk
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tendermint.abci.RequestApplySnapshotChunk} RequestApplySnapshotChunk
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RequestApplySnapshotChunk.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RequestApplySnapshotChunk message.
         * @function verify
         * @memberof tendermint.abci.RequestApplySnapshotChunk
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RequestApplySnapshotChunk.verify = function verify(message) {
          if (typeof message !== "object" || message === null) return "object expected";
          if (message.index != null && message.hasOwnProperty("index"))
            if (!$util.isInteger(message.index)) return "index: integer expected";
          if (message.chunk != null && message.hasOwnProperty("chunk"))
            if (
              !((message.chunk && typeof message.chunk.length === "number") || $util.isString(message.chunk))
            )
              return "chunk: buffer expected";
          if (message.sender != null && message.hasOwnProperty("sender"))
            if (!$util.isString(message.sender)) return "sender: string expected";
          return null;
        };

        /**
         * Creates a RequestApplySnapshotChunk message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tendermint.abci.RequestApplySnapshotChunk
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tendermint.abci.RequestApplySnapshotChunk} RequestApplySnapshotChunk
         */
        RequestApplySnapshotChunk.fromObject = function fromObject(object) {
          if (object instanceof $root.tendermint.abci.RequestApplySnapshotChunk) return object;
          var message = new $root.tendermint.abci.RequestApplySnapshotChunk();
          if (object.index != null) message.index = object.index >>> 0;
          if (object.chunk != null)
            if (typeof object.chunk === "string")
              $util.base64.decode(
                object.chunk,
                (message.chunk = $util.newBuffer($util.base64.length(object.chunk))),
                0,
              );
            else if (object.chunk.length) message.chunk = object.chunk;
          if (object.sender != null) message.sender = String(object.sender);
          return message;
        };

        /**
         * Creates a plain object from a RequestApplySnapshotChunk message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tendermint.abci.RequestApplySnapshotChunk
         * @static
         * @param {tendermint.abci.RequestApplySnapshotChunk} message RequestApplySnapshotChunk
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RequestApplySnapshotChunk.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.index = 0;
            if (options.bytes === String) object.chunk = "";
            else {
              object.chunk = [];
              if (options.bytes !== Array) object.chunk = $util.newBuffer(object.chunk);
            }
            object.sender = "";
          }
          if (message.index != null && message.hasOwnProperty("index")) object.index = message.index;
          if (message.chunk != null && message.hasOwnProperty("chunk"))
            object.chunk =
              options.bytes === String
                ? $util.base64.encode(message.chunk, 0, message.chunk.length)
                : options.bytes === Array
                ? Array.prototype.slice.call(message.chunk)
                : message.chunk;
          if (message.sender != null && message.hasOwnProperty("sender")) object.sender = message.sender;
          return object;
        };

        /**
         * Converts this RequestApplySnapshotChunk to JSON.
         * @function toJSON
         * @memberof tendermint.abci.RequestApplySnapshotChunk
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RequestApplySnapshotChunk.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RequestApplySnapshotChunk;
      })();

      abci.Response = (function () {
        /**
         * Properties of a Response.
         * @memberof tendermint.abci
         * @interface IResponse
         * @property {tendermint.abci.IResponseException|null} [exception] Response exception
         * @property {tendermint.abci.IResponseEcho|null} [echo] Response echo
         * @property {tendermint.abci.IResponseFlush|null} [flush] Response flush
         * @property {tendermint.abci.IResponseInfo|null} [info] Response info
         * @property {tendermint.abci.IResponseSetOption|null} [setOption] Response setOption
         * @property {tendermint.abci.IResponseInitChain|null} [initChain] Response initChain
         * @property {tendermint.abci.IResponseQuery|null} [query] Response query
         * @property {tendermint.abci.IResponseBeginBlock|null} [beginBlock] Response beginBlock
         * @property {tendermint.abci.IResponseCheckTx|null} [checkTx] Response checkTx
         * @property {tendermint.abci.IResponseDeliverTx|null} [deliverTx] Response deliverTx
         * @property {tendermint.abci.IResponseEndBlock|null} [endBlock] Response endBlock
         * @property {tendermint.abci.IResponseCommit|null} [commit] Response commit
         * @property {tendermint.abci.IResponseListSnapshots|null} [listSnapshots] Response listSnapshots
         * @property {tendermint.abci.IResponseOfferSnapshot|null} [offerSnapshot] Response offerSnapshot
         * @property {tendermint.abci.IResponseLoadSnapshotChunk|null} [loadSnapshotChunk] Response loadSnapshotChunk
         * @property {tendermint.abci.IResponseApplySnapshotChunk|null} [applySnapshotChunk] Response applySnapshotChunk
         */

        /**
         * Constructs a new Response.
         * @memberof tendermint.abci
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {tendermint.abci.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response exception.
         * @member {tendermint.abci.IResponseException|null|undefined} exception
         * @memberof tendermint.abci.Response
         * @instance
         */
        Response.prototype.exception = null;

        /**
         * Response echo.
         * @member {tendermint.abci.IResponseEcho|null|undefined} echo
         * @memberof tendermint.abci.Response
         * @instance
         */
        Response.prototype.echo = null;

        /**
         * Response flush.
         * @member {tendermint.abci.IResponseFlush|null|undefined} flush
         * @memberof tendermint.abci.Response
         * @instance
         */
        Response.prototype.flush = null;

        /**
         * Response info.
         * @member {tendermint.abci.IResponseInfo|null|undefined} info
         * @memberof tendermint.abci.Response
         * @instance
         */
        Response.prototype.info = null;

        /**
         * Response setOption.
         * @member {tendermint.abci.IResponseSetOption|null|undefined} setOption
         * @memberof tendermint.abci.Response
         * @instance
         */
        Response.prototype.setOption = null;

        /**
         * Response initChain.
         * @member {tendermint.abci.IResponseInitChain|null|undefined} initChain
         * @memberof tendermint.abci.Response
         * @instance
         */
        Response.prototype.initChain = null;

        /**
         * Response query.
         * @member {tendermint.abci.IResponseQuery|null|undefined} query
         * @memberof tendermint.abci.Response
         * @instance
         */
        Response.prototype.query = null;

        /**
         * Response beginBlock.
         * @member {tendermint.abci.IResponseBeginBlock|null|undefined} beginBlock
         * @memberof tendermint.abci.Response
         * @instance
         */
        Response.prototype.beginBlock = null;

        /**
         * Response checkTx.
         * @member {tendermint.abci.IResponseCheckTx|null|undefined} checkTx
         * @memberof tendermint.abci.Response
         * @instance
         */
        Response.prototype.checkTx = null;

        /**
         * Response deliverTx.
         * @member {tendermint.abci.IResponseDeliverTx|null|undefined} deliverTx
         * @memberof tendermint.abci.Response
         * @instance
         */
        Response.prototype.deliverTx = null;

        /**
         * Response endBlock.
         * @member {tendermint.abci.IResponseEndBlock|null|undefined} endBlock
         * @memberof tendermint.abci.Response
         * @instance
         */
        Response.prototype.endBlock = null;

        /**
         * Response commit.
         * @member {tendermint.abci.IResponseCommit|null|undefined} commit
         * @memberof tendermint.abci.Response
         * @instance
         */
        Response.prototype.commit = null;

        /**
         * Response listSnapshots.
         * @member {tendermint.abci.IResponseListSnapshots|null|undefined} listSnapshots
         * @memberof tendermint.abci.Response
         * @instance
         */
        Response.prototype.listSnapshots = null;

        /**
         * Response offerSnapshot.
         * @member {tendermint.abci.IResponseOfferSnapshot|null|undefined} offerSnapshot
         * @memberof tendermint.abci.Response
         * @instance
         */
        Response.prototype.offerSnapshot = null;

        /**
         * Response loadSnapshotChunk.
         * @member {tendermint.abci.IResponseLoadSnapshotChunk|null|undefined} loadSnapshotChunk
         * @memberof tendermint.abci.Response
         * @instance
         */
        Response.prototype.loadSnapshotChunk = null;

        /**
         * Response applySnapshotChunk.
         * @member {tendermint.abci.IResponseApplySnapshotChunk|null|undefined} applySnapshotChunk
         * @memberof tendermint.abci.Response
         * @instance
         */
        Response.prototype.applySnapshotChunk = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * Response value.
         * @member {"exception"|"echo"|"flush"|"info"|"setOption"|"initChain"|"query"|"beginBlock"|"checkTx"|"deliverTx"|"endBlock"|"commit"|"listSnapshots"|"offerSnapshot"|"loadSnapshotChunk"|"applySnapshotChunk"|undefined} value
         * @memberof tendermint.abci.Response
         * @instance
         */
        Object.defineProperty(Response.prototype, "value", {
          get: $util.oneOfGetter(
            ($oneOfFields = [
              "exception",
              "echo",
              "flush",
              "info",
              "setOption",
              "initChain",
              "query",
              "beginBlock",
              "checkTx",
              "deliverTx",
              "endBlock",
              "commit",
              "listSnapshots",
              "offerSnapshot",
              "loadSnapshotChunk",
              "applySnapshotChunk",
            ]),
          ),
          set: $util.oneOfSetter($oneOfFields),
        });

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof tendermint.abci.Response
         * @static
         * @param {tendermint.abci.IResponse=} [properties] Properties to set
         * @returns {tendermint.abci.Response} Response instance
         */
        Response.create = function create(properties) {
          return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link tendermint.abci.Response.verify|verify} messages.
         * @function encode
         * @memberof tendermint.abci.Response
         * @static
         * @param {tendermint.abci.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.exception != null && Object.hasOwnProperty.call(message, "exception"))
            $root.tendermint.abci.ResponseException.encode(
              message.exception,
              writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
            ).ldelim();
          if (message.echo != null && Object.hasOwnProperty.call(message, "echo"))
            $root.tendermint.abci.ResponseEcho.encode(
              message.echo,
              writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
            ).ldelim();
          if (message.flush != null && Object.hasOwnProperty.call(message, "flush"))
            $root.tendermint.abci.ResponseFlush.encode(
              message.flush,
              writer.uint32(/* id 3, wireType 2 =*/ 26).fork(),
            ).ldelim();
          if (message.info != null && Object.hasOwnProperty.call(message, "info"))
            $root.tendermint.abci.ResponseInfo.encode(
              message.info,
              writer.uint32(/* id 4, wireType 2 =*/ 34).fork(),
            ).ldelim();
          if (message.setOption != null && Object.hasOwnProperty.call(message, "setOption"))
            $root.tendermint.abci.ResponseSetOption.encode(
              message.setOption,
              writer.uint32(/* id 5, wireType 2 =*/ 42).fork(),
            ).ldelim();
          if (message.initChain != null && Object.hasOwnProperty.call(message, "initChain"))
            $root.tendermint.abci.ResponseInitChain.encode(
              message.initChain,
              writer.uint32(/* id 6, wireType 2 =*/ 50).fork(),
            ).ldelim();
          if (message.query != null && Object.hasOwnProperty.call(message, "query"))
            $root.tendermint.abci.ResponseQuery.encode(
              message.query,
              writer.uint32(/* id 7, wireType 2 =*/ 58).fork(),
            ).ldelim();
          if (message.beginBlock != null && Object.hasOwnProperty.call(message, "beginBlock"))
            $root.tendermint.abci.ResponseBeginBlock.encode(
              message.beginBlock,
              writer.uint32(/* id 8, wireType 2 =*/ 66).fork(),
            ).ldelim();
          if (message.checkTx != null && Object.hasOwnProperty.call(message, "checkTx"))
            $root.tendermint.abci.ResponseCheckTx.encode(
              message.checkTx,
              writer.uint32(/* id 9, wireType 2 =*/ 74).fork(),
            ).ldelim();
          if (message.deliverTx != null && Object.hasOwnProperty.call(message, "deliverTx"))
            $root.tendermint.abci.ResponseDeliverTx.encode(
              message.deliverTx,
              writer.uint32(/* id 10, wireType 2 =*/ 82).fork(),
            ).ldelim();
          if (message.endBlock != null && Object.hasOwnProperty.call(message, "endBlock"))
            $root.tendermint.abci.ResponseEndBlock.encode(
              message.endBlock,
              writer.uint32(/* id 11, wireType 2 =*/ 90).fork(),
            ).ldelim();
          if (message.commit != null && Object.hasOwnProperty.call(message, "commit"))
            $root.tendermint.abci.ResponseCommit.encode(
              message.commit,
              writer.uint32(/* id 12, wireType 2 =*/ 98).fork(),
            ).ldelim();
          if (message.listSnapshots != null && Object.hasOwnProperty.call(message, "listSnapshots"))
            $root.tendermint.abci.ResponseListSnapshots.encode(
              message.listSnapshots,
              writer.uint32(/* id 13, wireType 2 =*/ 106).fork(),
            ).ldelim();
          if (message.offerSnapshot != null && Object.hasOwnProperty.call(message, "offerSnapshot"))
            $root.tendermint.abci.ResponseOfferSnapshot.encode(
              message.offerSnapshot,
              writer.uint32(/* id 14, wireType 2 =*/ 114).fork(),
            ).ldelim();
          if (message.loadSnapshotChunk != null && Object.hasOwnProperty.call(message, "loadSnapshotChunk"))
            $root.tendermint.abci.ResponseLoadSnapshotChunk.encode(
              message.loadSnapshotChunk,
              writer.uint32(/* id 15, wireType 2 =*/ 122).fork(),
            ).ldelim();
          if (message.applySnapshotChunk != null && Object.hasOwnProperty.call(message, "applySnapshotChunk"))
            $root.tendermint.abci.ResponseApplySnapshotChunk.encode(
              message.applySnapshotChunk,
              writer.uint32(/* id 16, wireType 2 =*/ 130).fork(),
            ).ldelim();
          return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link tendermint.abci.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tendermint.abci.Response
         * @static
         * @param {tendermint.abci.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof tendermint.abci.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tendermint.abci.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.tendermint.abci.Response();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.exception = $root.tendermint.abci.ResponseException.decode(reader, reader.uint32());
                break;
              case 2:
                message.echo = $root.tendermint.abci.ResponseEcho.decode(reader, reader.uint32());
                break;
              case 3:
                message.flush = $root.tendermint.abci.ResponseFlush.decode(reader, reader.uint32());
                break;
              case 4:
                message.info = $root.tendermint.abci.ResponseInfo.decode(reader, reader.uint32());
                break;
              case 5:
                message.setOption = $root.tendermint.abci.ResponseSetOption.decode(reader, reader.uint32());
                break;
              case 6:
                message.initChain = $root.tendermint.abci.ResponseInitChain.decode(reader, reader.uint32());
                break;
              case 7:
                message.query = $root.tendermint.abci.ResponseQuery.decode(reader, reader.uint32());
                break;
              case 8:
                message.beginBlock = $root.tendermint.abci.ResponseBeginBlock.decode(reader, reader.uint32());
                break;
              case 9:
                message.checkTx = $root.tendermint.abci.ResponseCheckTx.decode(reader, reader.uint32());
                break;
              case 10:
                message.deliverTx = $root.tendermint.abci.ResponseDeliverTx.decode(reader, reader.uint32());
                break;
              case 11:
                message.endBlock = $root.tendermint.abci.ResponseEndBlock.decode(reader, reader.uint32());
                break;
              case 12:
                message.commit = $root.tendermint.abci.ResponseCommit.decode(reader, reader.uint32());
                break;
              case 13:
                message.listSnapshots = $root.tendermint.abci.ResponseListSnapshots.decode(
                  reader,
                  reader.uint32(),
                );
                break;
              case 14:
                message.offerSnapshot = $root.tendermint.abci.ResponseOfferSnapshot.decode(
                  reader,
                  reader.uint32(),
                );
                break;
              case 15:
                message.loadSnapshotChunk = $root.tendermint.abci.ResponseLoadSnapshotChunk.decode(
                  reader,
                  reader.uint32(),
                );
                break;
              case 16:
                message.applySnapshotChunk = $root.tendermint.abci.ResponseApplySnapshotChunk.decode(
                  reader,
                  reader.uint32(),
                );
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tendermint.abci.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tendermint.abci.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof tendermint.abci.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
          if (typeof message !== "object" || message === null) return "object expected";
          var properties = {};
          if (message.exception != null && message.hasOwnProperty("exception")) {
            properties.value = 1;
            {
              var error = $root.tendermint.abci.ResponseException.verify(message.exception);
              if (error) return "exception." + error;
            }
          }
          if (message.echo != null && message.hasOwnProperty("echo")) {
            if (properties.value === 1) return "value: multiple values";
            properties.value = 1;
            {
              var error = $root.tendermint.abci.ResponseEcho.verify(message.echo);
              if (error) return "echo." + error;
            }
          }
          if (message.flush != null && message.hasOwnProperty("flush")) {
            if (properties.value === 1) return "value: multiple values";
            properties.value = 1;
            {
              var error = $root.tendermint.abci.ResponseFlush.verify(message.flush);
              if (error) return "flush." + error;
            }
          }
          if (message.info != null && message.hasOwnProperty("info")) {
            if (properties.value === 1) return "value: multiple values";
            properties.value = 1;
            {
              var error = $root.tendermint.abci.ResponseInfo.verify(message.info);
              if (error) return "info." + error;
            }
          }
          if (message.setOption != null && message.hasOwnProperty("setOption")) {
            if (properties.value === 1) return "value: multiple values";
            properties.value = 1;
            {
              var error = $root.tendermint.abci.ResponseSetOption.verify(message.setOption);
              if (error) return "setOption." + error;
            }
          }
          if (message.initChain != null && message.hasOwnProperty("initChain")) {
            if (properties.value === 1) return "value: multiple values";
            properties.value = 1;
            {
              var error = $root.tendermint.abci.ResponseInitChain.verify(message.initChain);
              if (error) return "initChain." + error;
            }
          }
          if (message.query != null && message.hasOwnProperty("query")) {
            if (properties.value === 1) return "value: multiple values";
            properties.value = 1;
            {
              var error = $root.tendermint.abci.ResponseQuery.verify(message.query);
              if (error) return "query." + error;
            }
          }
          if (message.beginBlock != null && message.hasOwnProperty("beginBlock")) {
            if (properties.value === 1) return "value: multiple values";
            properties.value = 1;
            {
              var error = $root.tendermint.abci.ResponseBeginBlock.verify(message.beginBlock);
              if (error) return "beginBlock." + error;
            }
          }
          if (message.checkTx != null && message.hasOwnProperty("checkTx")) {
            if (properties.value === 1) return "value: multiple values";
            properties.value = 1;
            {
              var error = $root.tendermint.abci.ResponseCheckTx.verify(message.checkTx);
              if (error) return "checkTx." + error;
            }
          }
          if (message.deliverTx != null && message.hasOwnProperty("deliverTx")) {
            if (properties.value === 1) return "value: multiple values";
            properties.value = 1;
            {
              var error = $root.tendermint.abci.ResponseDeliverTx.verify(message.deliverTx);
              if (error) return "deliverTx." + error;
            }
          }
          if (message.endBlock != null && message.hasOwnProperty("endBlock")) {
            if (properties.value === 1) return "value: multiple values";
            properties.value = 1;
            {
              var error = $root.tendermint.abci.ResponseEndBlock.verify(message.endBlock);
              if (error) return "endBlock." + error;
            }
          }
          if (message.commit != null && message.hasOwnProperty("commit")) {
            if (properties.value === 1) return "value: multiple values";
            properties.value = 1;
            {
              var error = $root.tendermint.abci.ResponseCommit.verify(message.commit);
              if (error) return "commit." + error;
            }
          }
          if (message.listSnapshots != null && message.hasOwnProperty("listSnapshots")) {
            if (properties.value === 1) return "value: multiple values";
            properties.value = 1;
            {
              var error = $root.tendermint.abci.ResponseListSnapshots.verify(message.listSnapshots);
              if (error) return "listSnapshots." + error;
            }
          }
          if (message.offerSnapshot != null && message.hasOwnProperty("offerSnapshot")) {
            if (properties.value === 1) return "value: multiple values";
            properties.value = 1;
            {
              var error = $root.tendermint.abci.ResponseOfferSnapshot.verify(message.offerSnapshot);
              if (error) return "offerSnapshot." + error;
            }
          }
          if (message.loadSnapshotChunk != null && message.hasOwnProperty("loadSnapshotChunk")) {
            if (properties.value === 1) return "value: multiple values";
            properties.value = 1;
            {
              var error = $root.tendermint.abci.ResponseLoadSnapshotChunk.verify(message.loadSnapshotChunk);
              if (error) return "loadSnapshotChunk." + error;
            }
          }
          if (message.applySnapshotChunk != null && message.hasOwnProperty("applySnapshotChunk")) {
            if (properties.value === 1) return "value: multiple values";
            properties.value = 1;
            {
              var error = $root.tendermint.abci.ResponseApplySnapshotChunk.verify(message.applySnapshotChunk);
              if (error) return "applySnapshotChunk." + error;
            }
          }
          return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tendermint.abci.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tendermint.abci.Response} Response
         */
        Response.fromObject = function fromObject(object) {
          if (object instanceof $root.tendermint.abci.Response) return object;
          var message = new $root.tendermint.abci.Response();
          if (object.exception != null) {
            if (typeof object.exception !== "object")
              throw TypeError(".tendermint.abci.Response.exception: object expected");
            message.exception = $root.tendermint.abci.ResponseException.fromObject(object.exception);
          }
          if (object.echo != null) {
            if (typeof object.echo !== "object")
              throw TypeError(".tendermint.abci.Response.echo: object expected");
            message.echo = $root.tendermint.abci.ResponseEcho.fromObject(object.echo);
          }
          if (object.flush != null) {
            if (typeof object.flush !== "object")
              throw TypeError(".tendermint.abci.Response.flush: object expected");
            message.flush = $root.tendermint.abci.ResponseFlush.fromObject(object.flush);
          }
          if (object.info != null) {
            if (typeof object.info !== "object")
              throw TypeError(".tendermint.abci.Response.info: object expected");
            message.info = $root.tendermint.abci.ResponseInfo.fromObject(object.info);
          }
          if (object.setOption != null) {
            if (typeof object.setOption !== "object")
              throw TypeError(".tendermint.abci.Response.setOption: object expected");
            message.setOption = $root.tendermint.abci.ResponseSetOption.fromObject(object.setOption);
          }
          if (object.initChain != null) {
            if (typeof object.initChain !== "object")
              throw TypeError(".tendermint.abci.Response.initChain: object expected");
            message.initChain = $root.tendermint.abci.ResponseInitChain.fromObject(object.initChain);
          }
          if (object.query != null) {
            if (typeof object.query !== "object")
              throw TypeError(".tendermint.abci.Response.query: object expected");
            message.query = $root.tendermint.abci.ResponseQuery.fromObject(object.query);
          }
          if (object.beginBlock != null) {
            if (typeof object.beginBlock !== "object")
              throw TypeError(".tendermint.abci.Response.beginBlock: object expected");
            message.beginBlock = $root.tendermint.abci.ResponseBeginBlock.fromObject(object.beginBlock);
          }
          if (object.checkTx != null) {
            if (typeof object.checkTx !== "object")
              throw TypeError(".tendermint.abci.Response.checkTx: object expected");
            message.checkTx = $root.tendermint.abci.ResponseCheckTx.fromObject(object.checkTx);
          }
          if (object.deliverTx != null) {
            if (typeof object.deliverTx !== "object")
              throw TypeError(".tendermint.abci.Response.deliverTx: object expected");
            message.deliverTx = $root.tendermint.abci.ResponseDeliverTx.fromObject(object.deliverTx);
          }
          if (object.endBlock != null) {
            if (typeof object.endBlock !== "object")
              throw TypeError(".tendermint.abci.Response.endBlock: object expected");
            message.endBlock = $root.tendermint.abci.ResponseEndBlock.fromObject(object.endBlock);
          }
          if (object.commit != null) {
            if (typeof object.commit !== "object")
              throw TypeError(".tendermint.abci.Response.commit: object expected");
            message.commit = $root.tendermint.abci.ResponseCommit.fromObject(object.commit);
          }
          if (object.listSnapshots != null) {
            if (typeof object.listSnapshots !== "object")
              throw TypeError(".tendermint.abci.Response.listSnapshots: object expected");
            message.listSnapshots = $root.tendermint.abci.ResponseListSnapshots.fromObject(
              object.listSnapshots,
            );
          }
          if (object.offerSnapshot != null) {
            if (typeof object.offerSnapshot !== "object")
              throw TypeError(".tendermint.abci.Response.offerSnapshot: object expected");
            message.offerSnapshot = $root.tendermint.abci.ResponseOfferSnapshot.fromObject(
              object.offerSnapshot,
            );
          }
          if (object.loadSnapshotChunk != null) {
            if (typeof object.loadSnapshotChunk !== "object")
              throw TypeError(".tendermint.abci.Response.loadSnapshotChunk: object expected");
            message.loadSnapshotChunk = $root.tendermint.abci.ResponseLoadSnapshotChunk.fromObject(
              object.loadSnapshotChunk,
            );
          }
          if (object.applySnapshotChunk != null) {
            if (typeof object.applySnapshotChunk !== "object")
              throw TypeError(".tendermint.abci.Response.applySnapshotChunk: object expected");
            message.applySnapshotChunk = $root.tendermint.abci.ResponseApplySnapshotChunk.fromObject(
              object.applySnapshotChunk,
            );
          }
          return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tendermint.abci.Response
         * @static
         * @param {tendermint.abci.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (message.exception != null && message.hasOwnProperty("exception")) {
            object.exception = $root.tendermint.abci.ResponseException.toObject(message.exception, options);
            if (options.oneofs) object.value = "exception";
          }
          if (message.echo != null && message.hasOwnProperty("echo")) {
            object.echo = $root.tendermint.abci.ResponseEcho.toObject(message.echo, options);
            if (options.oneofs) object.value = "echo";
          }
          if (message.flush != null && message.hasOwnProperty("flush")) {
            object.flush = $root.tendermint.abci.ResponseFlush.toObject(message.flush, options);
            if (options.oneofs) object.value = "flush";
          }
          if (message.info != null && message.hasOwnProperty("info")) {
            object.info = $root.tendermint.abci.ResponseInfo.toObject(message.info, options);
            if (options.oneofs) object.value = "info";
          }
          if (message.setOption != null && message.hasOwnProperty("setOption")) {
            object.setOption = $root.tendermint.abci.ResponseSetOption.toObject(message.setOption, options);
            if (options.oneofs) object.value = "setOption";
          }
          if (message.initChain != null && message.hasOwnProperty("initChain")) {
            object.initChain = $root.tendermint.abci.ResponseInitChain.toObject(message.initChain, options);
            if (options.oneofs) object.value = "initChain";
          }
          if (message.query != null && message.hasOwnProperty("query")) {
            object.query = $root.tendermint.abci.ResponseQuery.toObject(message.query, options);
            if (options.oneofs) object.value = "query";
          }
          if (message.beginBlock != null && message.hasOwnProperty("beginBlock")) {
            object.beginBlock = $root.tendermint.abci.ResponseBeginBlock.toObject(
              message.beginBlock,
              options,
            );
            if (options.oneofs) object.value = "beginBlock";
          }
          if (message.checkTx != null && message.hasOwnProperty("checkTx")) {
            object.checkTx = $root.tendermint.abci.ResponseCheckTx.toObject(message.checkTx, options);
            if (options.oneofs) object.value = "checkTx";
          }
          if (message.deliverTx != null && message.hasOwnProperty("deliverTx")) {
            object.deliverTx = $root.tendermint.abci.ResponseDeliverTx.toObject(message.deliverTx, options);
            if (options.oneofs) object.value = "deliverTx";
          }
          if (message.endBlock != null && message.hasOwnProperty("endBlock")) {
            object.endBlock = $root.tendermint.abci.ResponseEndBlock.toObject(message.endBlock, options);
            if (options.oneofs) object.value = "endBlock";
          }
          if (message.commit != null && message.hasOwnProperty("commit")) {
            object.commit = $root.tendermint.abci.ResponseCommit.toObject(message.commit, options);
            if (options.oneofs) object.value = "commit";
          }
          if (message.listSnapshots != null && message.hasOwnProperty("listSnapshots")) {
            object.listSnapshots = $root.tendermint.abci.ResponseListSnapshots.toObject(
              message.listSnapshots,
              options,
            );
            if (options.oneofs) object.value = "listSnapshots";
          }
          if (message.offerSnapshot != null && message.hasOwnProperty("offerSnapshot")) {
            object.offerSnapshot = $root.tendermint.abci.ResponseOfferSnapshot.toObject(
              message.offerSnapshot,
              options,
            );
            if (options.oneofs) object.value = "offerSnapshot";
          }
          if (message.loadSnapshotChunk != null && message.hasOwnProperty("loadSnapshotChunk")) {
            object.loadSnapshotChunk = $root.tendermint.abci.ResponseLoadSnapshotChunk.toObject(
              message.loadSnapshotChunk,
              options,
            );
            if (options.oneofs) object.value = "loadSnapshotChunk";
          }
          if (message.applySnapshotChunk != null && message.hasOwnProperty("applySnapshotChunk")) {
            object.applySnapshotChunk = $root.tendermint.abci.ResponseApplySnapshotChunk.toObject(
              message.applySnapshotChunk,
              options,
            );
            if (options.oneofs) object.value = "applySnapshotChunk";
          }
          return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof tendermint.abci.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
      })();

      abci.ResponseException = (function () {
        /**
         * Properties of a ResponseException.
         * @memberof tendermint.abci
         * @interface IResponseException
         * @property {string|null} [error] ResponseException error
         */

        /**
         * Constructs a new ResponseException.
         * @memberof tendermint.abci
         * @classdesc Represents a ResponseException.
         * @implements IResponseException
         * @constructor
         * @param {tendermint.abci.IResponseException=} [properties] Properties to set
         */
        function ResponseException(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * ResponseException error.
         * @member {string} error
         * @memberof tendermint.abci.ResponseException
         * @instance
         */
        ResponseException.prototype.error = "";

        /**
         * Creates a new ResponseException instance using the specified properties.
         * @function create
         * @memberof tendermint.abci.ResponseException
         * @static
         * @param {tendermint.abci.IResponseException=} [properties] Properties to set
         * @returns {tendermint.abci.ResponseException} ResponseException instance
         */
        ResponseException.create = function create(properties) {
          return new ResponseException(properties);
        };

        /**
         * Encodes the specified ResponseException message. Does not implicitly {@link tendermint.abci.ResponseException.verify|verify} messages.
         * @function encode
         * @memberof tendermint.abci.ResponseException
         * @static
         * @param {tendermint.abci.IResponseException} message ResponseException message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResponseException.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.error != null && Object.hasOwnProperty.call(message, "error"))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.error);
          return writer;
        };

        /**
         * Encodes the specified ResponseException message, length delimited. Does not implicitly {@link tendermint.abci.ResponseException.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tendermint.abci.ResponseException
         * @static
         * @param {tendermint.abci.IResponseException} message ResponseException message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResponseException.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ResponseException message from the specified reader or buffer.
         * @function decode
         * @memberof tendermint.abci.ResponseException
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tendermint.abci.ResponseException} ResponseException
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResponseException.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.tendermint.abci.ResponseException();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.error = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a ResponseException message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tendermint.abci.ResponseException
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tendermint.abci.ResponseException} ResponseException
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResponseException.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ResponseException message.
         * @function verify
         * @memberof tendermint.abci.ResponseException
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ResponseException.verify = function verify(message) {
          if (typeof message !== "object" || message === null) return "object expected";
          if (message.error != null && message.hasOwnProperty("error"))
            if (!$util.isString(message.error)) return "error: string expected";
          return null;
        };

        /**
         * Creates a ResponseException message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tendermint.abci.ResponseException
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tendermint.abci.ResponseException} ResponseException
         */
        ResponseException.fromObject = function fromObject(object) {
          if (object instanceof $root.tendermint.abci.ResponseException) return object;
          var message = new $root.tendermint.abci.ResponseException();
          if (object.error != null) message.error = String(object.error);
          return message;
        };

        /**
         * Creates a plain object from a ResponseException message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tendermint.abci.ResponseException
         * @static
         * @param {tendermint.abci.ResponseException} message ResponseException
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ResponseException.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) object.error = "";
          if (message.error != null && message.hasOwnProperty("error")) object.error = message.error;
          return object;
        };

        /**
         * Converts this ResponseException to JSON.
         * @function toJSON
         * @memberof tendermint.abci.ResponseException
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ResponseException.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ResponseException;
      })();

      abci.ResponseEcho = (function () {
        /**
         * Properties of a ResponseEcho.
         * @memberof tendermint.abci
         * @interface IResponseEcho
         * @property {string|null} [message] ResponseEcho message
         */

        /**
         * Constructs a new ResponseEcho.
         * @memberof tendermint.abci
         * @classdesc Represents a ResponseEcho.
         * @implements IResponseEcho
         * @constructor
         * @param {tendermint.abci.IResponseEcho=} [properties] Properties to set
         */
        function ResponseEcho(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * ResponseEcho message.
         * @member {string} message
         * @memberof tendermint.abci.ResponseEcho
         * @instance
         */
        ResponseEcho.prototype.message = "";

        /**
         * Creates a new ResponseEcho instance using the specified properties.
         * @function create
         * @memberof tendermint.abci.ResponseEcho
         * @static
         * @param {tendermint.abci.IResponseEcho=} [properties] Properties to set
         * @returns {tendermint.abci.ResponseEcho} ResponseEcho instance
         */
        ResponseEcho.create = function create(properties) {
          return new ResponseEcho(properties);
        };

        /**
         * Encodes the specified ResponseEcho message. Does not implicitly {@link tendermint.abci.ResponseEcho.verify|verify} messages.
         * @function encode
         * @memberof tendermint.abci.ResponseEcho
         * @static
         * @param {tendermint.abci.IResponseEcho} message ResponseEcho message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResponseEcho.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.message != null && Object.hasOwnProperty.call(message, "message"))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.message);
          return writer;
        };

        /**
         * Encodes the specified ResponseEcho message, length delimited. Does not implicitly {@link tendermint.abci.ResponseEcho.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tendermint.abci.ResponseEcho
         * @static
         * @param {tendermint.abci.IResponseEcho} message ResponseEcho message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResponseEcho.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ResponseEcho message from the specified reader or buffer.
         * @function decode
         * @memberof tendermint.abci.ResponseEcho
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tendermint.abci.ResponseEcho} ResponseEcho
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResponseEcho.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.tendermint.abci.ResponseEcho();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.message = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a ResponseEcho message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tendermint.abci.ResponseEcho
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tendermint.abci.ResponseEcho} ResponseEcho
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResponseEcho.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ResponseEcho message.
         * @function verify
         * @memberof tendermint.abci.ResponseEcho
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ResponseEcho.verify = function verify(message) {
          if (typeof message !== "object" || message === null) return "object expected";
          if (message.message != null && message.hasOwnProperty("message"))
            if (!$util.isString(message.message)) return "message: string expected";
          return null;
        };

        /**
         * Creates a ResponseEcho message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tendermint.abci.ResponseEcho
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tendermint.abci.ResponseEcho} ResponseEcho
         */
        ResponseEcho.fromObject = function fromObject(object) {
          if (object instanceof $root.tendermint.abci.ResponseEcho) return object;
          var message = new $root.tendermint.abci.ResponseEcho();
          if (object.message != null) message.message = String(object.message);
          return message;
        };

        /**
         * Creates a plain object from a ResponseEcho message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tendermint.abci.ResponseEcho
         * @static
         * @param {tendermint.abci.ResponseEcho} message ResponseEcho
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ResponseEcho.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) object.message = "";
          if (message.message != null && message.hasOwnProperty("message")) object.message = message.message;
          return object;
        };

        /**
         * Converts this ResponseEcho to JSON.
         * @function toJSON
         * @memberof tendermint.abci.ResponseEcho
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ResponseEcho.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ResponseEcho;
      })();

      abci.ResponseFlush = (function () {
        /**
         * Properties of a ResponseFlush.
         * @memberof tendermint.abci
         * @interface IResponseFlush
         */

        /**
         * Constructs a new ResponseFlush.
         * @memberof tendermint.abci
         * @classdesc Represents a ResponseFlush.
         * @implements IResponseFlush
         * @constructor
         * @param {tendermint.abci.IResponseFlush=} [properties] Properties to set
         */
        function ResponseFlush(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new ResponseFlush instance using the specified properties.
         * @function create
         * @memberof tendermint.abci.ResponseFlush
         * @static
         * @param {tendermint.abci.IResponseFlush=} [properties] Properties to set
         * @returns {tendermint.abci.ResponseFlush} ResponseFlush instance
         */
        ResponseFlush.create = function create(properties) {
          return new ResponseFlush(properties);
        };

        /**
         * Encodes the specified ResponseFlush message. Does not implicitly {@link tendermint.abci.ResponseFlush.verify|verify} messages.
         * @function encode
         * @memberof tendermint.abci.ResponseFlush
         * @static
         * @param {tendermint.abci.IResponseFlush} message ResponseFlush message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResponseFlush.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          return writer;
        };

        /**
         * Encodes the specified ResponseFlush message, length delimited. Does not implicitly {@link tendermint.abci.ResponseFlush.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tendermint.abci.ResponseFlush
         * @static
         * @param {tendermint.abci.IResponseFlush} message ResponseFlush message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResponseFlush.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ResponseFlush message from the specified reader or buffer.
         * @function decode
         * @memberof tendermint.abci.ResponseFlush
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tendermint.abci.ResponseFlush} ResponseFlush
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResponseFlush.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.tendermint.abci.ResponseFlush();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a ResponseFlush message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tendermint.abci.ResponseFlush
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tendermint.abci.ResponseFlush} ResponseFlush
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResponseFlush.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ResponseFlush message.
         * @function verify
         * @memberof tendermint.abci.ResponseFlush
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ResponseFlush.verify = function verify(message) {
          if (typeof message !== "object" || message === null) return "object expected";
          return null;
        };

        /**
         * Creates a ResponseFlush message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tendermint.abci.ResponseFlush
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tendermint.abci.ResponseFlush} ResponseFlush
         */
        ResponseFlush.fromObject = function fromObject(object) {
          if (object instanceof $root.tendermint.abci.ResponseFlush) return object;
          return new $root.tendermint.abci.ResponseFlush();
        };

        /**
         * Creates a plain object from a ResponseFlush message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tendermint.abci.ResponseFlush
         * @static
         * @param {tendermint.abci.ResponseFlush} message ResponseFlush
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ResponseFlush.toObject = function toObject() {
          return {};
        };

        /**
         * Converts this ResponseFlush to JSON.
         * @function toJSON
         * @memberof tendermint.abci.ResponseFlush
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ResponseFlush.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ResponseFlush;
      })();

      abci.ResponseInfo = (function () {
        /**
         * Properties of a ResponseInfo.
         * @memberof tendermint.abci
         * @interface IResponseInfo
         * @property {string|null} [data] ResponseInfo data
         * @property {string|null} [version] ResponseInfo version
         * @property {number|Long|null} [appVersion] ResponseInfo appVersion
         * @property {number|Long|null} [lastBlockHeight] ResponseInfo lastBlockHeight
         * @property {Uint8Array|null} [lastBlockAppHash] ResponseInfo lastBlockAppHash
         */

        /**
         * Constructs a new ResponseInfo.
         * @memberof tendermint.abci
         * @classdesc Represents a ResponseInfo.
         * @implements IResponseInfo
         * @constructor
         * @param {tendermint.abci.IResponseInfo=} [properties] Properties to set
         */
        function ResponseInfo(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * ResponseInfo data.
         * @member {string} data
         * @memberof tendermint.abci.ResponseInfo
         * @instance
         */
        ResponseInfo.prototype.data = "";

        /**
         * ResponseInfo version.
         * @member {string} version
         * @memberof tendermint.abci.ResponseInfo
         * @instance
         */
        ResponseInfo.prototype.version = "";

        /**
         * ResponseInfo appVersion.
         * @member {number|Long} appVersion
         * @memberof tendermint.abci.ResponseInfo
         * @instance
         */
        ResponseInfo.prototype.appVersion = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

        /**
         * ResponseInfo lastBlockHeight.
         * @member {number|Long} lastBlockHeight
         * @memberof tendermint.abci.ResponseInfo
         * @instance
         */
        ResponseInfo.prototype.lastBlockHeight = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * ResponseInfo lastBlockAppHash.
         * @member {Uint8Array} lastBlockAppHash
         * @memberof tendermint.abci.ResponseInfo
         * @instance
         */
        ResponseInfo.prototype.lastBlockAppHash = $util.newBuffer([]);

        /**
         * Creates a new ResponseInfo instance using the specified properties.
         * @function create
         * @memberof tendermint.abci.ResponseInfo
         * @static
         * @param {tendermint.abci.IResponseInfo=} [properties] Properties to set
         * @returns {tendermint.abci.ResponseInfo} ResponseInfo instance
         */
        ResponseInfo.create = function create(properties) {
          return new ResponseInfo(properties);
        };

        /**
         * Encodes the specified ResponseInfo message. Does not implicitly {@link tendermint.abci.ResponseInfo.verify|verify} messages.
         * @function encode
         * @memberof tendermint.abci.ResponseInfo
         * @static
         * @param {tendermint.abci.IResponseInfo} message ResponseInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResponseInfo.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.data != null && Object.hasOwnProperty.call(message, "data"))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.data);
          if (message.version != null && Object.hasOwnProperty.call(message, "version"))
            writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.version);
          if (message.appVersion != null && Object.hasOwnProperty.call(message, "appVersion"))
            writer.uint32(/* id 3, wireType 0 =*/ 24).uint64(message.appVersion);
          if (message.lastBlockHeight != null && Object.hasOwnProperty.call(message, "lastBlockHeight"))
            writer.uint32(/* id 4, wireType 0 =*/ 32).int64(message.lastBlockHeight);
          if (message.lastBlockAppHash != null && Object.hasOwnProperty.call(message, "lastBlockAppHash"))
            writer.uint32(/* id 5, wireType 2 =*/ 42).bytes(message.lastBlockAppHash);
          return writer;
        };

        /**
         * Encodes the specified ResponseInfo message, length delimited. Does not implicitly {@link tendermint.abci.ResponseInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tendermint.abci.ResponseInfo
         * @static
         * @param {tendermint.abci.IResponseInfo} message ResponseInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResponseInfo.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ResponseInfo message from the specified reader or buffer.
         * @function decode
         * @memberof tendermint.abci.ResponseInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tendermint.abci.ResponseInfo} ResponseInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResponseInfo.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.tendermint.abci.ResponseInfo();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.data = reader.string();
                break;
              case 2:
                message.version = reader.string();
                break;
              case 3:
                message.appVersion = reader.uint64();
                break;
              case 4:
                message.lastBlockHeight = reader.int64();
                break;
              case 5:
                message.lastBlockAppHash = reader.bytes();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a ResponseInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tendermint.abci.ResponseInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tendermint.abci.ResponseInfo} ResponseInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResponseInfo.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ResponseInfo message.
         * @function verify
         * @memberof tendermint.abci.ResponseInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ResponseInfo.verify = function verify(message) {
          if (typeof message !== "object" || message === null) return "object expected";
          if (message.data != null && message.hasOwnProperty("data"))
            if (!$util.isString(message.data)) return "data: string expected";
          if (message.version != null && message.hasOwnProperty("version"))
            if (!$util.isString(message.version)) return "version: string expected";
          if (message.appVersion != null && message.hasOwnProperty("appVersion"))
            if (
              !$util.isInteger(message.appVersion) &&
              !(
                message.appVersion &&
                $util.isInteger(message.appVersion.low) &&
                $util.isInteger(message.appVersion.high)
              )
            )
              return "appVersion: integer|Long expected";
          if (message.lastBlockHeight != null && message.hasOwnProperty("lastBlockHeight"))
            if (
              !$util.isInteger(message.lastBlockHeight) &&
              !(
                message.lastBlockHeight &&
                $util.isInteger(message.lastBlockHeight.low) &&
                $util.isInteger(message.lastBlockHeight.high)
              )
            )
              return "lastBlockHeight: integer|Long expected";
          if (message.lastBlockAppHash != null && message.hasOwnProperty("lastBlockAppHash"))
            if (
              !(
                (message.lastBlockAppHash && typeof message.lastBlockAppHash.length === "number") ||
                $util.isString(message.lastBlockAppHash)
              )
            )
              return "lastBlockAppHash: buffer expected";
          return null;
        };

        /**
         * Creates a ResponseInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tendermint.abci.ResponseInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tendermint.abci.ResponseInfo} ResponseInfo
         */
        ResponseInfo.fromObject = function fromObject(object) {
          if (object instanceof $root.tendermint.abci.ResponseInfo) return object;
          var message = new $root.tendermint.abci.ResponseInfo();
          if (object.data != null) message.data = String(object.data);
          if (object.version != null) message.version = String(object.version);
          if (object.appVersion != null)
            if ($util.Long) (message.appVersion = $util.Long.fromValue(object.appVersion)).unsigned = true;
            else if (typeof object.appVersion === "string")
              message.appVersion = parseInt(object.appVersion, 10);
            else if (typeof object.appVersion === "number") message.appVersion = object.appVersion;
            else if (typeof object.appVersion === "object")
              message.appVersion = new $util.LongBits(
                object.appVersion.low >>> 0,
                object.appVersion.high >>> 0,
              ).toNumber(true);
          if (object.lastBlockHeight != null)
            if ($util.Long)
              (message.lastBlockHeight = $util.Long.fromValue(object.lastBlockHeight)).unsigned = false;
            else if (typeof object.lastBlockHeight === "string")
              message.lastBlockHeight = parseInt(object.lastBlockHeight, 10);
            else if (typeof object.lastBlockHeight === "number")
              message.lastBlockHeight = object.lastBlockHeight;
            else if (typeof object.lastBlockHeight === "object")
              message.lastBlockHeight = new $util.LongBits(
                object.lastBlockHeight.low >>> 0,
                object.lastBlockHeight.high >>> 0,
              ).toNumber();
          if (object.lastBlockAppHash != null)
            if (typeof object.lastBlockAppHash === "string")
              $util.base64.decode(
                object.lastBlockAppHash,
                (message.lastBlockAppHash = $util.newBuffer($util.base64.length(object.lastBlockAppHash))),
                0,
              );
            else if (object.lastBlockAppHash.length) message.lastBlockAppHash = object.lastBlockAppHash;
          return message;
        };

        /**
         * Creates a plain object from a ResponseInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tendermint.abci.ResponseInfo
         * @static
         * @param {tendermint.abci.ResponseInfo} message ResponseInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ResponseInfo.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.data = "";
            object.version = "";
            if ($util.Long) {
              var long = new $util.Long(0, 0, true);
              object.appVersion =
                options.longs === String
                  ? long.toString()
                  : options.longs === Number
                  ? long.toNumber()
                  : long;
            } else object.appVersion = options.longs === String ? "0" : 0;
            if ($util.Long) {
              var long = new $util.Long(0, 0, false);
              object.lastBlockHeight =
                options.longs === String
                  ? long.toString()
                  : options.longs === Number
                  ? long.toNumber()
                  : long;
            } else object.lastBlockHeight = options.longs === String ? "0" : 0;
            if (options.bytes === String) object.lastBlockAppHash = "";
            else {
              object.lastBlockAppHash = [];
              if (options.bytes !== Array) object.lastBlockAppHash = $util.newBuffer(object.lastBlockAppHash);
            }
          }
          if (message.data != null && message.hasOwnProperty("data")) object.data = message.data;
          if (message.version != null && message.hasOwnProperty("version")) object.version = message.version;
          if (message.appVersion != null && message.hasOwnProperty("appVersion"))
            if (typeof message.appVersion === "number")
              object.appVersion = options.longs === String ? String(message.appVersion) : message.appVersion;
            else
              object.appVersion =
                options.longs === String
                  ? $util.Long.prototype.toString.call(message.appVersion)
                  : options.longs === Number
                  ? new $util.LongBits(message.appVersion.low >>> 0, message.appVersion.high >>> 0).toNumber(
                      true,
                    )
                  : message.appVersion;
          if (message.lastBlockHeight != null && message.hasOwnProperty("lastBlockHeight"))
            if (typeof message.lastBlockHeight === "number")
              object.lastBlockHeight =
                options.longs === String ? String(message.lastBlockHeight) : message.lastBlockHeight;
            else
              object.lastBlockHeight =
                options.longs === String
                  ? $util.Long.prototype.toString.call(message.lastBlockHeight)
                  : options.longs === Number
                  ? new $util.LongBits(
                      message.lastBlockHeight.low >>> 0,
                      message.lastBlockHeight.high >>> 0,
                    ).toNumber()
                  : message.lastBlockHeight;
          if (message.lastBlockAppHash != null && message.hasOwnProperty("lastBlockAppHash"))
            object.lastBlockAppHash =
              options.bytes === String
                ? $util.base64.encode(message.lastBlockAppHash, 0, message.lastBlockAppHash.length)
                : options.bytes === Array
                ? Array.prototype.slice.call(message.lastBlockAppHash)
                : message.lastBlockAppHash;
          return object;
        };

        /**
         * Converts this ResponseInfo to JSON.
         * @function toJSON
         * @memberof tendermint.abci.ResponseInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ResponseInfo.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ResponseInfo;
      })();

      abci.ResponseSetOption = (function () {
        /**
         * Properties of a ResponseSetOption.
         * @memberof tendermint.abci
         * @interface IResponseSetOption
         * @property {number|null} [code] ResponseSetOption code
         * @property {string|null} [log] ResponseSetOption log
         * @property {string|null} [info] ResponseSetOption info
         */

        /**
         * Constructs a new ResponseSetOption.
         * @memberof tendermint.abci
         * @classdesc Represents a ResponseSetOption.
         * @implements IResponseSetOption
         * @constructor
         * @param {tendermint.abci.IResponseSetOption=} [properties] Properties to set
         */
        function ResponseSetOption(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * ResponseSetOption code.
         * @member {number} code
         * @memberof tendermint.abci.ResponseSetOption
         * @instance
         */
        ResponseSetOption.prototype.code = 0;

        /**
         * ResponseSetOption log.
         * @member {string} log
         * @memberof tendermint.abci.ResponseSetOption
         * @instance
         */
        ResponseSetOption.prototype.log = "";

        /**
         * ResponseSetOption info.
         * @member {string} info
         * @memberof tendermint.abci.ResponseSetOption
         * @instance
         */
        ResponseSetOption.prototype.info = "";

        /**
         * Creates a new ResponseSetOption instance using the specified properties.
         * @function create
         * @memberof tendermint.abci.ResponseSetOption
         * @static
         * @param {tendermint.abci.IResponseSetOption=} [properties] Properties to set
         * @returns {tendermint.abci.ResponseSetOption} ResponseSetOption instance
         */
        ResponseSetOption.create = function create(properties) {
          return new ResponseSetOption(properties);
        };

        /**
         * Encodes the specified ResponseSetOption message. Does not implicitly {@link tendermint.abci.ResponseSetOption.verify|verify} messages.
         * @function encode
         * @memberof tendermint.abci.ResponseSetOption
         * @static
         * @param {tendermint.abci.IResponseSetOption} message ResponseSetOption message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResponseSetOption.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.code != null && Object.hasOwnProperty.call(message, "code"))
            writer.uint32(/* id 1, wireType 0 =*/ 8).uint32(message.code);
          if (message.log != null && Object.hasOwnProperty.call(message, "log"))
            writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.log);
          if (message.info != null && Object.hasOwnProperty.call(message, "info"))
            writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.info);
          return writer;
        };

        /**
         * Encodes the specified ResponseSetOption message, length delimited. Does not implicitly {@link tendermint.abci.ResponseSetOption.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tendermint.abci.ResponseSetOption
         * @static
         * @param {tendermint.abci.IResponseSetOption} message ResponseSetOption message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResponseSetOption.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ResponseSetOption message from the specified reader or buffer.
         * @function decode
         * @memberof tendermint.abci.ResponseSetOption
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tendermint.abci.ResponseSetOption} ResponseSetOption
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResponseSetOption.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.tendermint.abci.ResponseSetOption();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.code = reader.uint32();
                break;
              case 3:
                message.log = reader.string();
                break;
              case 4:
                message.info = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a ResponseSetOption message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tendermint.abci.ResponseSetOption
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tendermint.abci.ResponseSetOption} ResponseSetOption
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResponseSetOption.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ResponseSetOption message.
         * @function verify
         * @memberof tendermint.abci.ResponseSetOption
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ResponseSetOption.verify = function verify(message) {
          if (typeof message !== "object" || message === null) return "object expected";
          if (message.code != null && message.hasOwnProperty("code"))
            if (!$util.isInteger(message.code)) return "code: integer expected";
          if (message.log != null && message.hasOwnProperty("log"))
            if (!$util.isString(message.log)) return "log: string expected";
          if (message.info != null && message.hasOwnProperty("info"))
            if (!$util.isString(message.info)) return "info: string expected";
          return null;
        };

        /**
         * Creates a ResponseSetOption message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tendermint.abci.ResponseSetOption
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tendermint.abci.ResponseSetOption} ResponseSetOption
         */
        ResponseSetOption.fromObject = function fromObject(object) {
          if (object instanceof $root.tendermint.abci.ResponseSetOption) return object;
          var message = new $root.tendermint.abci.ResponseSetOption();
          if (object.code != null) message.code = object.code >>> 0;
          if (object.log != null) message.log = String(object.log);
          if (object.info != null) message.info = String(object.info);
          return message;
        };

        /**
         * Creates a plain object from a ResponseSetOption message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tendermint.abci.ResponseSetOption
         * @static
         * @param {tendermint.abci.ResponseSetOption} message ResponseSetOption
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ResponseSetOption.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.code = 0;
            object.log = "";
            object.info = "";
          }
          if (message.code != null && message.hasOwnProperty("code")) object.code = message.code;
          if (message.log != null && message.hasOwnProperty("log")) object.log = message.log;
          if (message.info != null && message.hasOwnProperty("info")) object.info = message.info;
          return object;
        };

        /**
         * Converts this ResponseSetOption to JSON.
         * @function toJSON
         * @memberof tendermint.abci.ResponseSetOption
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ResponseSetOption.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ResponseSetOption;
      })();

      abci.ResponseInitChain = (function () {
        /**
         * Properties of a ResponseInitChain.
         * @memberof tendermint.abci
         * @interface IResponseInitChain
         * @property {tendermint.abci.IConsensusParams|null} [consensusParams] ResponseInitChain consensusParams
         * @property {Array.<tendermint.abci.IValidatorUpdate>|null} [validators] ResponseInitChain validators
         * @property {Uint8Array|null} [appHash] ResponseInitChain appHash
         */

        /**
         * Constructs a new ResponseInitChain.
         * @memberof tendermint.abci
         * @classdesc Represents a ResponseInitChain.
         * @implements IResponseInitChain
         * @constructor
         * @param {tendermint.abci.IResponseInitChain=} [properties] Properties to set
         */
        function ResponseInitChain(properties) {
          this.validators = [];
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * ResponseInitChain consensusParams.
         * @member {tendermint.abci.IConsensusParams|null|undefined} consensusParams
         * @memberof tendermint.abci.ResponseInitChain
         * @instance
         */
        ResponseInitChain.prototype.consensusParams = null;

        /**
         * ResponseInitChain validators.
         * @member {Array.<tendermint.abci.IValidatorUpdate>} validators
         * @memberof tendermint.abci.ResponseInitChain
         * @instance
         */
        ResponseInitChain.prototype.validators = $util.emptyArray;

        /**
         * ResponseInitChain appHash.
         * @member {Uint8Array} appHash
         * @memberof tendermint.abci.ResponseInitChain
         * @instance
         */
        ResponseInitChain.prototype.appHash = $util.newBuffer([]);

        /**
         * Creates a new ResponseInitChain instance using the specified properties.
         * @function create
         * @memberof tendermint.abci.ResponseInitChain
         * @static
         * @param {tendermint.abci.IResponseInitChain=} [properties] Properties to set
         * @returns {tendermint.abci.ResponseInitChain} ResponseInitChain instance
         */
        ResponseInitChain.create = function create(properties) {
          return new ResponseInitChain(properties);
        };

        /**
         * Encodes the specified ResponseInitChain message. Does not implicitly {@link tendermint.abci.ResponseInitChain.verify|verify} messages.
         * @function encode
         * @memberof tendermint.abci.ResponseInitChain
         * @static
         * @param {tendermint.abci.IResponseInitChain} message ResponseInitChain message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResponseInitChain.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.consensusParams != null && Object.hasOwnProperty.call(message, "consensusParams"))
            $root.tendermint.abci.ConsensusParams.encode(
              message.consensusParams,
              writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
            ).ldelim();
          if (message.validators != null && message.validators.length)
            for (var i = 0; i < message.validators.length; ++i)
              $root.tendermint.abci.ValidatorUpdate.encode(
                message.validators[i],
                writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
              ).ldelim();
          if (message.appHash != null && Object.hasOwnProperty.call(message, "appHash"))
            writer.uint32(/* id 3, wireType 2 =*/ 26).bytes(message.appHash);
          return writer;
        };

        /**
         * Encodes the specified ResponseInitChain message, length delimited. Does not implicitly {@link tendermint.abci.ResponseInitChain.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tendermint.abci.ResponseInitChain
         * @static
         * @param {tendermint.abci.IResponseInitChain} message ResponseInitChain message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResponseInitChain.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ResponseInitChain message from the specified reader or buffer.
         * @function decode
         * @memberof tendermint.abci.ResponseInitChain
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tendermint.abci.ResponseInitChain} ResponseInitChain
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResponseInitChain.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.tendermint.abci.ResponseInitChain();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.consensusParams = $root.tendermint.abci.ConsensusParams.decode(
                  reader,
                  reader.uint32(),
                );
                break;
              case 2:
                if (!(message.validators && message.validators.length)) message.validators = [];
                message.validators.push(
                  $root.tendermint.abci.ValidatorUpdate.decode(reader, reader.uint32()),
                );
                break;
              case 3:
                message.appHash = reader.bytes();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a ResponseInitChain message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tendermint.abci.ResponseInitChain
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tendermint.abci.ResponseInitChain} ResponseInitChain
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResponseInitChain.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ResponseInitChain message.
         * @function verify
         * @memberof tendermint.abci.ResponseInitChain
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ResponseInitChain.verify = function verify(message) {
          if (typeof message !== "object" || message === null) return "object expected";
          if (message.consensusParams != null && message.hasOwnProperty("consensusParams")) {
            var error = $root.tendermint.abci.ConsensusParams.verify(message.consensusParams);
            if (error) return "consensusParams." + error;
          }
          if (message.validators != null && message.hasOwnProperty("validators")) {
            if (!Array.isArray(message.validators)) return "validators: array expected";
            for (var i = 0; i < message.validators.length; ++i) {
              var error = $root.tendermint.abci.ValidatorUpdate.verify(message.validators[i]);
              if (error) return "validators." + error;
            }
          }
          if (message.appHash != null && message.hasOwnProperty("appHash"))
            if (
              !(
                (message.appHash && typeof message.appHash.length === "number") ||
                $util.isString(message.appHash)
              )
            )
              return "appHash: buffer expected";
          return null;
        };

        /**
         * Creates a ResponseInitChain message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tendermint.abci.ResponseInitChain
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tendermint.abci.ResponseInitChain} ResponseInitChain
         */
        ResponseInitChain.fromObject = function fromObject(object) {
          if (object instanceof $root.tendermint.abci.ResponseInitChain) return object;
          var message = new $root.tendermint.abci.ResponseInitChain();
          if (object.consensusParams != null) {
            if (typeof object.consensusParams !== "object")
              throw TypeError(".tendermint.abci.ResponseInitChain.consensusParams: object expected");
            message.consensusParams = $root.tendermint.abci.ConsensusParams.fromObject(
              object.consensusParams,
            );
          }
          if (object.validators) {
            if (!Array.isArray(object.validators))
              throw TypeError(".tendermint.abci.ResponseInitChain.validators: array expected");
            message.validators = [];
            for (var i = 0; i < object.validators.length; ++i) {
              if (typeof object.validators[i] !== "object")
                throw TypeError(".tendermint.abci.ResponseInitChain.validators: object expected");
              message.validators[i] = $root.tendermint.abci.ValidatorUpdate.fromObject(object.validators[i]);
            }
          }
          if (object.appHash != null)
            if (typeof object.appHash === "string")
              $util.base64.decode(
                object.appHash,
                (message.appHash = $util.newBuffer($util.base64.length(object.appHash))),
                0,
              );
            else if (object.appHash.length) message.appHash = object.appHash;
          return message;
        };

        /**
         * Creates a plain object from a ResponseInitChain message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tendermint.abci.ResponseInitChain
         * @static
         * @param {tendermint.abci.ResponseInitChain} message ResponseInitChain
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ResponseInitChain.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.arrays || options.defaults) object.validators = [];
          if (options.defaults) {
            object.consensusParams = null;
            if (options.bytes === String) object.appHash = "";
            else {
              object.appHash = [];
              if (options.bytes !== Array) object.appHash = $util.newBuffer(object.appHash);
            }
          }
          if (message.consensusParams != null && message.hasOwnProperty("consensusParams"))
            object.consensusParams = $root.tendermint.abci.ConsensusParams.toObject(
              message.consensusParams,
              options,
            );
          if (message.validators && message.validators.length) {
            object.validators = [];
            for (var j = 0; j < message.validators.length; ++j)
              object.validators[j] = $root.tendermint.abci.ValidatorUpdate.toObject(
                message.validators[j],
                options,
              );
          }
          if (message.appHash != null && message.hasOwnProperty("appHash"))
            object.appHash =
              options.bytes === String
                ? $util.base64.encode(message.appHash, 0, message.appHash.length)
                : options.bytes === Array
                ? Array.prototype.slice.call(message.appHash)
                : message.appHash;
          return object;
        };

        /**
         * Converts this ResponseInitChain to JSON.
         * @function toJSON
         * @memberof tendermint.abci.ResponseInitChain
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ResponseInitChain.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ResponseInitChain;
      })();

      abci.ResponseQuery = (function () {
        /**
         * Properties of a ResponseQuery.
         * @memberof tendermint.abci
         * @interface IResponseQuery
         * @property {number|null} [code] ResponseQuery code
         * @property {string|null} [log] ResponseQuery log
         * @property {string|null} [info] ResponseQuery info
         * @property {number|Long|null} [index] ResponseQuery index
         * @property {Uint8Array|null} [key] ResponseQuery key
         * @property {Uint8Array|null} [value] ResponseQuery value
         * @property {tendermint.crypto.IProofOps|null} [proofOps] ResponseQuery proofOps
         * @property {number|Long|null} [height] ResponseQuery height
         * @property {string|null} [codespace] ResponseQuery codespace
         */

        /**
         * Constructs a new ResponseQuery.
         * @memberof tendermint.abci
         * @classdesc Represents a ResponseQuery.
         * @implements IResponseQuery
         * @constructor
         * @param {tendermint.abci.IResponseQuery=} [properties] Properties to set
         */
        function ResponseQuery(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * ResponseQuery code.
         * @member {number} code
         * @memberof tendermint.abci.ResponseQuery
         * @instance
         */
        ResponseQuery.prototype.code = 0;

        /**
         * ResponseQuery log.
         * @member {string} log
         * @memberof tendermint.abci.ResponseQuery
         * @instance
         */
        ResponseQuery.prototype.log = "";

        /**
         * ResponseQuery info.
         * @member {string} info
         * @memberof tendermint.abci.ResponseQuery
         * @instance
         */
        ResponseQuery.prototype.info = "";

        /**
         * ResponseQuery index.
         * @member {number|Long} index
         * @memberof tendermint.abci.ResponseQuery
         * @instance
         */
        ResponseQuery.prototype.index = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * ResponseQuery key.
         * @member {Uint8Array} key
         * @memberof tendermint.abci.ResponseQuery
         * @instance
         */
        ResponseQuery.prototype.key = $util.newBuffer([]);

        /**
         * ResponseQuery value.
         * @member {Uint8Array} value
         * @memberof tendermint.abci.ResponseQuery
         * @instance
         */
        ResponseQuery.prototype.value = $util.newBuffer([]);

        /**
         * ResponseQuery proofOps.
         * @member {tendermint.crypto.IProofOps|null|undefined} proofOps
         * @memberof tendermint.abci.ResponseQuery
         * @instance
         */
        ResponseQuery.prototype.proofOps = null;

        /**
         * ResponseQuery height.
         * @member {number|Long} height
         * @memberof tendermint.abci.ResponseQuery
         * @instance
         */
        ResponseQuery.prototype.height = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * ResponseQuery codespace.
         * @member {string} codespace
         * @memberof tendermint.abci.ResponseQuery
         * @instance
         */
        ResponseQuery.prototype.codespace = "";

        /**
         * Creates a new ResponseQuery instance using the specified properties.
         * @function create
         * @memberof tendermint.abci.ResponseQuery
         * @static
         * @param {tendermint.abci.IResponseQuery=} [properties] Properties to set
         * @returns {tendermint.abci.ResponseQuery} ResponseQuery instance
         */
        ResponseQuery.create = function create(properties) {
          return new ResponseQuery(properties);
        };

        /**
         * Encodes the specified ResponseQuery message. Does not implicitly {@link tendermint.abci.ResponseQuery.verify|verify} messages.
         * @function encode
         * @memberof tendermint.abci.ResponseQuery
         * @static
         * @param {tendermint.abci.IResponseQuery} message ResponseQuery message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResponseQuery.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.code != null && Object.hasOwnProperty.call(message, "code"))
            writer.uint32(/* id 1, wireType 0 =*/ 8).uint32(message.code);
          if (message.log != null && Object.hasOwnProperty.call(message, "log"))
            writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.log);
          if (message.info != null && Object.hasOwnProperty.call(message, "info"))
            writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.info);
          if (message.index != null && Object.hasOwnProperty.call(message, "index"))
            writer.uint32(/* id 5, wireType 0 =*/ 40).int64(message.index);
          if (message.key != null && Object.hasOwnProperty.call(message, "key"))
            writer.uint32(/* id 6, wireType 2 =*/ 50).bytes(message.key);
          if (message.value != null && Object.hasOwnProperty.call(message, "value"))
            writer.uint32(/* id 7, wireType 2 =*/ 58).bytes(message.value);
          if (message.proofOps != null && Object.hasOwnProperty.call(message, "proofOps"))
            $root.tendermint.crypto.ProofOps.encode(
              message.proofOps,
              writer.uint32(/* id 8, wireType 2 =*/ 66).fork(),
            ).ldelim();
          if (message.height != null && Object.hasOwnProperty.call(message, "height"))
            writer.uint32(/* id 9, wireType 0 =*/ 72).int64(message.height);
          if (message.codespace != null && Object.hasOwnProperty.call(message, "codespace"))
            writer.uint32(/* id 10, wireType 2 =*/ 82).string(message.codespace);
          return writer;
        };

        /**
         * Encodes the specified ResponseQuery message, length delimited. Does not implicitly {@link tendermint.abci.ResponseQuery.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tendermint.abci.ResponseQuery
         * @static
         * @param {tendermint.abci.IResponseQuery} message ResponseQuery message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResponseQuery.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ResponseQuery message from the specified reader or buffer.
         * @function decode
         * @memberof tendermint.abci.ResponseQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tendermint.abci.ResponseQuery} ResponseQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResponseQuery.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.tendermint.abci.ResponseQuery();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.code = reader.uint32();
                break;
              case 3:
                message.log = reader.string();
                break;
              case 4:
                message.info = reader.string();
                break;
              case 5:
                message.index = reader.int64();
                break;
              case 6:
                message.key = reader.bytes();
                break;
              case 7:
                message.value = reader.bytes();
                break;
              case 8:
                message.proofOps = $root.tendermint.crypto.ProofOps.decode(reader, reader.uint32());
                break;
              case 9:
                message.height = reader.int64();
                break;
              case 10:
                message.codespace = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a ResponseQuery message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tendermint.abci.ResponseQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tendermint.abci.ResponseQuery} ResponseQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResponseQuery.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ResponseQuery message.
         * @function verify
         * @memberof tendermint.abci.ResponseQuery
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ResponseQuery.verify = function verify(message) {
          if (typeof message !== "object" || message === null) return "object expected";
          if (message.code != null && message.hasOwnProperty("code"))
            if (!$util.isInteger(message.code)) return "code: integer expected";
          if (message.log != null && message.hasOwnProperty("log"))
            if (!$util.isString(message.log)) return "log: string expected";
          if (message.info != null && message.hasOwnProperty("info"))
            if (!$util.isString(message.info)) return "info: string expected";
          if (message.index != null && message.hasOwnProperty("index"))
            if (
              !$util.isInteger(message.index) &&
              !(message.index && $util.isInteger(message.index.low) && $util.isInteger(message.index.high))
            )
              return "index: integer|Long expected";
          if (message.key != null && message.hasOwnProperty("key"))
            if (!((message.key && typeof message.key.length === "number") || $util.isString(message.key)))
              return "key: buffer expected";
          if (message.value != null && message.hasOwnProperty("value"))
            if (
              !((message.value && typeof message.value.length === "number") || $util.isString(message.value))
            )
              return "value: buffer expected";
          if (message.proofOps != null && message.hasOwnProperty("proofOps")) {
            var error = $root.tendermint.crypto.ProofOps.verify(message.proofOps);
            if (error) return "proofOps." + error;
          }
          if (message.height != null && message.hasOwnProperty("height"))
            if (
              !$util.isInteger(message.height) &&
              !(message.height && $util.isInteger(message.height.low) && $util.isInteger(message.height.high))
            )
              return "height: integer|Long expected";
          if (message.codespace != null && message.hasOwnProperty("codespace"))
            if (!$util.isString(message.codespace)) return "codespace: string expected";
          return null;
        };

        /**
         * Creates a ResponseQuery message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tendermint.abci.ResponseQuery
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tendermint.abci.ResponseQuery} ResponseQuery
         */
        ResponseQuery.fromObject = function fromObject(object) {
          if (object instanceof $root.tendermint.abci.ResponseQuery) return object;
          var message = new $root.tendermint.abci.ResponseQuery();
          if (object.code != null) message.code = object.code >>> 0;
          if (object.log != null) message.log = String(object.log);
          if (object.info != null) message.info = String(object.info);
          if (object.index != null)
            if ($util.Long) (message.index = $util.Long.fromValue(object.index)).unsigned = false;
            else if (typeof object.index === "string") message.index = parseInt(object.index, 10);
            else if (typeof object.index === "number") message.index = object.index;
            else if (typeof object.index === "object")
              message.index = new $util.LongBits(object.index.low >>> 0, object.index.high >>> 0).toNumber();
          if (object.key != null)
            if (typeof object.key === "string")
              $util.base64.decode(
                object.key,
                (message.key = $util.newBuffer($util.base64.length(object.key))),
                0,
              );
            else if (object.key.length) message.key = object.key;
          if (object.value != null)
            if (typeof object.value === "string")
              $util.base64.decode(
                object.value,
                (message.value = $util.newBuffer($util.base64.length(object.value))),
                0,
              );
            else if (object.value.length) message.value = object.value;
          if (object.proofOps != null) {
            if (typeof object.proofOps !== "object")
              throw TypeError(".tendermint.abci.ResponseQuery.proofOps: object expected");
            message.proofOps = $root.tendermint.crypto.ProofOps.fromObject(object.proofOps);
          }
          if (object.height != null)
            if ($util.Long) (message.height = $util.Long.fromValue(object.height)).unsigned = false;
            else if (typeof object.height === "string") message.height = parseInt(object.height, 10);
            else if (typeof object.height === "number") message.height = object.height;
            else if (typeof object.height === "object")
              message.height = new $util.LongBits(
                object.height.low >>> 0,
                object.height.high >>> 0,
              ).toNumber();
          if (object.codespace != null) message.codespace = String(object.codespace);
          return message;
        };

        /**
         * Creates a plain object from a ResponseQuery message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tendermint.abci.ResponseQuery
         * @static
         * @param {tendermint.abci.ResponseQuery} message ResponseQuery
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ResponseQuery.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.code = 0;
            object.log = "";
            object.info = "";
            if ($util.Long) {
              var long = new $util.Long(0, 0, false);
              object.index =
                options.longs === String
                  ? long.toString()
                  : options.longs === Number
                  ? long.toNumber()
                  : long;
            } else object.index = options.longs === String ? "0" : 0;
            if (options.bytes === String) object.key = "";
            else {
              object.key = [];
              if (options.bytes !== Array) object.key = $util.newBuffer(object.key);
            }
            if (options.bytes === String) object.value = "";
            else {
              object.value = [];
              if (options.bytes !== Array) object.value = $util.newBuffer(object.value);
            }
            object.proofOps = null;
            if ($util.Long) {
              var long = new $util.Long(0, 0, false);
              object.height =
                options.longs === String
                  ? long.toString()
                  : options.longs === Number
                  ? long.toNumber()
                  : long;
            } else object.height = options.longs === String ? "0" : 0;
            object.codespace = "";
          }
          if (message.code != null && message.hasOwnProperty("code")) object.code = message.code;
          if (message.log != null && message.hasOwnProperty("log")) object.log = message.log;
          if (message.info != null && message.hasOwnProperty("info")) object.info = message.info;
          if (message.index != null && message.hasOwnProperty("index"))
            if (typeof message.index === "number")
              object.index = options.longs === String ? String(message.index) : message.index;
            else
              object.index =
                options.longs === String
                  ? $util.Long.prototype.toString.call(message.index)
                  : options.longs === Number
                  ? new $util.LongBits(message.index.low >>> 0, message.index.high >>> 0).toNumber()
                  : message.index;
          if (message.key != null && message.hasOwnProperty("key"))
            object.key =
              options.bytes === String
                ? $util.base64.encode(message.key, 0, message.key.length)
                : options.bytes === Array
                ? Array.prototype.slice.call(message.key)
                : message.key;
          if (message.value != null && message.hasOwnProperty("value"))
            object.value =
              options.bytes === String
                ? $util.base64.encode(message.value, 0, message.value.length)
                : options.bytes === Array
                ? Array.prototype.slice.call(message.value)
                : message.value;
          if (message.proofOps != null && message.hasOwnProperty("proofOps"))
            object.proofOps = $root.tendermint.crypto.ProofOps.toObject(message.proofOps, options);
          if (message.height != null && message.hasOwnProperty("height"))
            if (typeof message.height === "number")
              object.height = options.longs === String ? String(message.height) : message.height;
            else
              object.height =
                options.longs === String
                  ? $util.Long.prototype.toString.call(message.height)
                  : options.longs === Number
                  ? new $util.LongBits(message.height.low >>> 0, message.height.high >>> 0).toNumber()
                  : message.height;
          if (message.codespace != null && message.hasOwnProperty("codespace"))
            object.codespace = message.codespace;
          return object;
        };

        /**
         * Converts this ResponseQuery to JSON.
         * @function toJSON
         * @memberof tendermint.abci.ResponseQuery
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ResponseQuery.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ResponseQuery;
      })();

      abci.ResponseBeginBlock = (function () {
        /**
         * Properties of a ResponseBeginBlock.
         * @memberof tendermint.abci
         * @interface IResponseBeginBlock
         * @property {Array.<tendermint.abci.IEvent>|null} [events] ResponseBeginBlock events
         */

        /**
         * Constructs a new ResponseBeginBlock.
         * @memberof tendermint.abci
         * @classdesc Represents a ResponseBeginBlock.
         * @implements IResponseBeginBlock
         * @constructor
         * @param {tendermint.abci.IResponseBeginBlock=} [properties] Properties to set
         */
        function ResponseBeginBlock(properties) {
          this.events = [];
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * ResponseBeginBlock events.
         * @member {Array.<tendermint.abci.IEvent>} events
         * @memberof tendermint.abci.ResponseBeginBlock
         * @instance
         */
        ResponseBeginBlock.prototype.events = $util.emptyArray;

        /**
         * Creates a new ResponseBeginBlock instance using the specified properties.
         * @function create
         * @memberof tendermint.abci.ResponseBeginBlock
         * @static
         * @param {tendermint.abci.IResponseBeginBlock=} [properties] Properties to set
         * @returns {tendermint.abci.ResponseBeginBlock} ResponseBeginBlock instance
         */
        ResponseBeginBlock.create = function create(properties) {
          return new ResponseBeginBlock(properties);
        };

        /**
         * Encodes the specified ResponseBeginBlock message. Does not implicitly {@link tendermint.abci.ResponseBeginBlock.verify|verify} messages.
         * @function encode
         * @memberof tendermint.abci.ResponseBeginBlock
         * @static
         * @param {tendermint.abci.IResponseBeginBlock} message ResponseBeginBlock message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResponseBeginBlock.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.events != null && message.events.length)
            for (var i = 0; i < message.events.length; ++i)
              $root.tendermint.abci.Event.encode(
                message.events[i],
                writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
              ).ldelim();
          return writer;
        };

        /**
         * Encodes the specified ResponseBeginBlock message, length delimited. Does not implicitly {@link tendermint.abci.ResponseBeginBlock.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tendermint.abci.ResponseBeginBlock
         * @static
         * @param {tendermint.abci.IResponseBeginBlock} message ResponseBeginBlock message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResponseBeginBlock.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ResponseBeginBlock message from the specified reader or buffer.
         * @function decode
         * @memberof tendermint.abci.ResponseBeginBlock
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tendermint.abci.ResponseBeginBlock} ResponseBeginBlock
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResponseBeginBlock.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.tendermint.abci.ResponseBeginBlock();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                if (!(message.events && message.events.length)) message.events = [];
                message.events.push($root.tendermint.abci.Event.decode(reader, reader.uint32()));
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a ResponseBeginBlock message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tendermint.abci.ResponseBeginBlock
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tendermint.abci.ResponseBeginBlock} ResponseBeginBlock
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResponseBeginBlock.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ResponseBeginBlock message.
         * @function verify
         * @memberof tendermint.abci.ResponseBeginBlock
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ResponseBeginBlock.verify = function verify(message) {
          if (typeof message !== "object" || message === null) return "object expected";
          if (message.events != null && message.hasOwnProperty("events")) {
            if (!Array.isArray(message.events)) return "events: array expected";
            for (var i = 0; i < message.events.length; ++i) {
              var error = $root.tendermint.abci.Event.verify(message.events[i]);
              if (error) return "events." + error;
            }
          }
          return null;
        };

        /**
         * Creates a ResponseBeginBlock message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tendermint.abci.ResponseBeginBlock
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tendermint.abci.ResponseBeginBlock} ResponseBeginBlock
         */
        ResponseBeginBlock.fromObject = function fromObject(object) {
          if (object instanceof $root.tendermint.abci.ResponseBeginBlock) return object;
          var message = new $root.tendermint.abci.ResponseBeginBlock();
          if (object.events) {
            if (!Array.isArray(object.events))
              throw TypeError(".tendermint.abci.ResponseBeginBlock.events: array expected");
            message.events = [];
            for (var i = 0; i < object.events.length; ++i) {
              if (typeof object.events[i] !== "object")
                throw TypeError(".tendermint.abci.ResponseBeginBlock.events: object expected");
              message.events[i] = $root.tendermint.abci.Event.fromObject(object.events[i]);
            }
          }
          return message;
        };

        /**
         * Creates a plain object from a ResponseBeginBlock message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tendermint.abci.ResponseBeginBlock
         * @static
         * @param {tendermint.abci.ResponseBeginBlock} message ResponseBeginBlock
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ResponseBeginBlock.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.arrays || options.defaults) object.events = [];
          if (message.events && message.events.length) {
            object.events = [];
            for (var j = 0; j < message.events.length; ++j)
              object.events[j] = $root.tendermint.abci.Event.toObject(message.events[j], options);
          }
          return object;
        };

        /**
         * Converts this ResponseBeginBlock to JSON.
         * @function toJSON
         * @memberof tendermint.abci.ResponseBeginBlock
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ResponseBeginBlock.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ResponseBeginBlock;
      })();

      abci.ResponseCheckTx = (function () {
        /**
         * Properties of a ResponseCheckTx.
         * @memberof tendermint.abci
         * @interface IResponseCheckTx
         * @property {number|null} [code] ResponseCheckTx code
         * @property {Uint8Array|null} [data] ResponseCheckTx data
         * @property {string|null} [log] ResponseCheckTx log
         * @property {string|null} [info] ResponseCheckTx info
         * @property {number|Long|null} [gasWanted] ResponseCheckTx gasWanted
         * @property {number|Long|null} [gasUsed] ResponseCheckTx gasUsed
         * @property {Array.<tendermint.abci.IEvent>|null} [events] ResponseCheckTx events
         * @property {string|null} [codespace] ResponseCheckTx codespace
         */

        /**
         * Constructs a new ResponseCheckTx.
         * @memberof tendermint.abci
         * @classdesc Represents a ResponseCheckTx.
         * @implements IResponseCheckTx
         * @constructor
         * @param {tendermint.abci.IResponseCheckTx=} [properties] Properties to set
         */
        function ResponseCheckTx(properties) {
          this.events = [];
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * ResponseCheckTx code.
         * @member {number} code
         * @memberof tendermint.abci.ResponseCheckTx
         * @instance
         */
        ResponseCheckTx.prototype.code = 0;

        /**
         * ResponseCheckTx data.
         * @member {Uint8Array} data
         * @memberof tendermint.abci.ResponseCheckTx
         * @instance
         */
        ResponseCheckTx.prototype.data = $util.newBuffer([]);

        /**
         * ResponseCheckTx log.
         * @member {string} log
         * @memberof tendermint.abci.ResponseCheckTx
         * @instance
         */
        ResponseCheckTx.prototype.log = "";

        /**
         * ResponseCheckTx info.
         * @member {string} info
         * @memberof tendermint.abci.ResponseCheckTx
         * @instance
         */
        ResponseCheckTx.prototype.info = "";

        /**
         * ResponseCheckTx gasWanted.
         * @member {number|Long} gasWanted
         * @memberof tendermint.abci.ResponseCheckTx
         * @instance
         */
        ResponseCheckTx.prototype.gasWanted = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * ResponseCheckTx gasUsed.
         * @member {number|Long} gasUsed
         * @memberof tendermint.abci.ResponseCheckTx
         * @instance
         */
        ResponseCheckTx.prototype.gasUsed = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * ResponseCheckTx events.
         * @member {Array.<tendermint.abci.IEvent>} events
         * @memberof tendermint.abci.ResponseCheckTx
         * @instance
         */
        ResponseCheckTx.prototype.events = $util.emptyArray;

        /**
         * ResponseCheckTx codespace.
         * @member {string} codespace
         * @memberof tendermint.abci.ResponseCheckTx
         * @instance
         */
        ResponseCheckTx.prototype.codespace = "";

        /**
         * Creates a new ResponseCheckTx instance using the specified properties.
         * @function create
         * @memberof tendermint.abci.ResponseCheckTx
         * @static
         * @param {tendermint.abci.IResponseCheckTx=} [properties] Properties to set
         * @returns {tendermint.abci.ResponseCheckTx} ResponseCheckTx instance
         */
        ResponseCheckTx.create = function create(properties) {
          return new ResponseCheckTx(properties);
        };

        /**
         * Encodes the specified ResponseCheckTx message. Does not implicitly {@link tendermint.abci.ResponseCheckTx.verify|verify} messages.
         * @function encode
         * @memberof tendermint.abci.ResponseCheckTx
         * @static
         * @param {tendermint.abci.IResponseCheckTx} message ResponseCheckTx message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResponseCheckTx.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.code != null && Object.hasOwnProperty.call(message, "code"))
            writer.uint32(/* id 1, wireType 0 =*/ 8).uint32(message.code);
          if (message.data != null && Object.hasOwnProperty.call(message, "data"))
            writer.uint32(/* id 2, wireType 2 =*/ 18).bytes(message.data);
          if (message.log != null && Object.hasOwnProperty.call(message, "log"))
            writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.log);
          if (message.info != null && Object.hasOwnProperty.call(message, "info"))
            writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.info);
          if (message.gasWanted != null && Object.hasOwnProperty.call(message, "gasWanted"))
            writer.uint32(/* id 5, wireType 0 =*/ 40).int64(message.gasWanted);
          if (message.gasUsed != null && Object.hasOwnProperty.call(message, "gasUsed"))
            writer.uint32(/* id 6, wireType 0 =*/ 48).int64(message.gasUsed);
          if (message.events != null && message.events.length)
            for (var i = 0; i < message.events.length; ++i)
              $root.tendermint.abci.Event.encode(
                message.events[i],
                writer.uint32(/* id 7, wireType 2 =*/ 58).fork(),
              ).ldelim();
          if (message.codespace != null && Object.hasOwnProperty.call(message, "codespace"))
            writer.uint32(/* id 8, wireType 2 =*/ 66).string(message.codespace);
          return writer;
        };

        /**
         * Encodes the specified ResponseCheckTx message, length delimited. Does not implicitly {@link tendermint.abci.ResponseCheckTx.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tendermint.abci.ResponseCheckTx
         * @static
         * @param {tendermint.abci.IResponseCheckTx} message ResponseCheckTx message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResponseCheckTx.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ResponseCheckTx message from the specified reader or buffer.
         * @function decode
         * @memberof tendermint.abci.ResponseCheckTx
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tendermint.abci.ResponseCheckTx} ResponseCheckTx
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResponseCheckTx.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.tendermint.abci.ResponseCheckTx();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.code = reader.uint32();
                break;
              case 2:
                message.data = reader.bytes();
                break;
              case 3:
                message.log = reader.string();
                break;
              case 4:
                message.info = reader.string();
                break;
              case 5:
                message.gasWanted = reader.int64();
                break;
              case 6:
                message.gasUsed = reader.int64();
                break;
              case 7:
                if (!(message.events && message.events.length)) message.events = [];
                message.events.push($root.tendermint.abci.Event.decode(reader, reader.uint32()));
                break;
              case 8:
                message.codespace = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a ResponseCheckTx message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tendermint.abci.ResponseCheckTx
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tendermint.abci.ResponseCheckTx} ResponseCheckTx
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResponseCheckTx.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ResponseCheckTx message.
         * @function verify
         * @memberof tendermint.abci.ResponseCheckTx
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ResponseCheckTx.verify = function verify(message) {
          if (typeof message !== "object" || message === null) return "object expected";
          if (message.code != null && message.hasOwnProperty("code"))
            if (!$util.isInteger(message.code)) return "code: integer expected";
          if (message.data != null && message.hasOwnProperty("data"))
            if (!((message.data && typeof message.data.length === "number") || $util.isString(message.data)))
              return "data: buffer expected";
          if (message.log != null && message.hasOwnProperty("log"))
            if (!$util.isString(message.log)) return "log: string expected";
          if (message.info != null && message.hasOwnProperty("info"))
            if (!$util.isString(message.info)) return "info: string expected";
          if (message.gasWanted != null && message.hasOwnProperty("gasWanted"))
            if (
              !$util.isInteger(message.gasWanted) &&
              !(
                message.gasWanted &&
                $util.isInteger(message.gasWanted.low) &&
                $util.isInteger(message.gasWanted.high)
              )
            )
              return "gasWanted: integer|Long expected";
          if (message.gasUsed != null && message.hasOwnProperty("gasUsed"))
            if (
              !$util.isInteger(message.gasUsed) &&
              !(
                message.gasUsed &&
                $util.isInteger(message.gasUsed.low) &&
                $util.isInteger(message.gasUsed.high)
              )
            )
              return "gasUsed: integer|Long expected";
          if (message.events != null && message.hasOwnProperty("events")) {
            if (!Array.isArray(message.events)) return "events: array expected";
            for (var i = 0; i < message.events.length; ++i) {
              var error = $root.tendermint.abci.Event.verify(message.events[i]);
              if (error) return "events." + error;
            }
          }
          if (message.codespace != null && message.hasOwnProperty("codespace"))
            if (!$util.isString(message.codespace)) return "codespace: string expected";
          return null;
        };

        /**
         * Creates a ResponseCheckTx message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tendermint.abci.ResponseCheckTx
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tendermint.abci.ResponseCheckTx} ResponseCheckTx
         */
        ResponseCheckTx.fromObject = function fromObject(object) {
          if (object instanceof $root.tendermint.abci.ResponseCheckTx) return object;
          var message = new $root.tendermint.abci.ResponseCheckTx();
          if (object.code != null) message.code = object.code >>> 0;
          if (object.data != null)
            if (typeof object.data === "string")
              $util.base64.decode(
                object.data,
                (message.data = $util.newBuffer($util.base64.length(object.data))),
                0,
              );
            else if (object.data.length) message.data = object.data;
          if (object.log != null) message.log = String(object.log);
          if (object.info != null) message.info = String(object.info);
          if (object.gasWanted != null)
            if ($util.Long) (message.gasWanted = $util.Long.fromValue(object.gasWanted)).unsigned = false;
            else if (typeof object.gasWanted === "string") message.gasWanted = parseInt(object.gasWanted, 10);
            else if (typeof object.gasWanted === "number") message.gasWanted = object.gasWanted;
            else if (typeof object.gasWanted === "object")
              message.gasWanted = new $util.LongBits(
                object.gasWanted.low >>> 0,
                object.gasWanted.high >>> 0,
              ).toNumber();
          if (object.gasUsed != null)
            if ($util.Long) (message.gasUsed = $util.Long.fromValue(object.gasUsed)).unsigned = false;
            else if (typeof object.gasUsed === "string") message.gasUsed = parseInt(object.gasUsed, 10);
            else if (typeof object.gasUsed === "number") message.gasUsed = object.gasUsed;
            else if (typeof object.gasUsed === "object")
              message.gasUsed = new $util.LongBits(
                object.gasUsed.low >>> 0,
                object.gasUsed.high >>> 0,
              ).toNumber();
          if (object.events) {
            if (!Array.isArray(object.events))
              throw TypeError(".tendermint.abci.ResponseCheckTx.events: array expected");
            message.events = [];
            for (var i = 0; i < object.events.length; ++i) {
              if (typeof object.events[i] !== "object")
                throw TypeError(".tendermint.abci.ResponseCheckTx.events: object expected");
              message.events[i] = $root.tendermint.abci.Event.fromObject(object.events[i]);
            }
          }
          if (object.codespace != null) message.codespace = String(object.codespace);
          return message;
        };

        /**
         * Creates a plain object from a ResponseCheckTx message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tendermint.abci.ResponseCheckTx
         * @static
         * @param {tendermint.abci.ResponseCheckTx} message ResponseCheckTx
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ResponseCheckTx.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.arrays || options.defaults) object.events = [];
          if (options.defaults) {
            object.code = 0;
            if (options.bytes === String) object.data = "";
            else {
              object.data = [];
              if (options.bytes !== Array) object.data = $util.newBuffer(object.data);
            }
            object.log = "";
            object.info = "";
            if ($util.Long) {
              var long = new $util.Long(0, 0, false);
              object.gasWanted =
                options.longs === String
                  ? long.toString()
                  : options.longs === Number
                  ? long.toNumber()
                  : long;
            } else object.gasWanted = options.longs === String ? "0" : 0;
            if ($util.Long) {
              var long = new $util.Long(0, 0, false);
              object.gasUsed =
                options.longs === String
                  ? long.toString()
                  : options.longs === Number
                  ? long.toNumber()
                  : long;
            } else object.gasUsed = options.longs === String ? "0" : 0;
            object.codespace = "";
          }
          if (message.code != null && message.hasOwnProperty("code")) object.code = message.code;
          if (message.data != null && message.hasOwnProperty("data"))
            object.data =
              options.bytes === String
                ? $util.base64.encode(message.data, 0, message.data.length)
                : options.bytes === Array
                ? Array.prototype.slice.call(message.data)
                : message.data;
          if (message.log != null && message.hasOwnProperty("log")) object.log = message.log;
          if (message.info != null && message.hasOwnProperty("info")) object.info = message.info;
          if (message.gasWanted != null && message.hasOwnProperty("gasWanted"))
            if (typeof message.gasWanted === "number")
              object.gasWanted = options.longs === String ? String(message.gasWanted) : message.gasWanted;
            else
              object.gasWanted =
                options.longs === String
                  ? $util.Long.prototype.toString.call(message.gasWanted)
                  : options.longs === Number
                  ? new $util.LongBits(message.gasWanted.low >>> 0, message.gasWanted.high >>> 0).toNumber()
                  : message.gasWanted;
          if (message.gasUsed != null && message.hasOwnProperty("gasUsed"))
            if (typeof message.gasUsed === "number")
              object.gasUsed = options.longs === String ? String(message.gasUsed) : message.gasUsed;
            else
              object.gasUsed =
                options.longs === String
                  ? $util.Long.prototype.toString.call(message.gasUsed)
                  : options.longs === Number
                  ? new $util.LongBits(message.gasUsed.low >>> 0, message.gasUsed.high >>> 0).toNumber()
                  : message.gasUsed;
          if (message.events && message.events.length) {
            object.events = [];
            for (var j = 0; j < message.events.length; ++j)
              object.events[j] = $root.tendermint.abci.Event.toObject(message.events[j], options);
          }
          if (message.codespace != null && message.hasOwnProperty("codespace"))
            object.codespace = message.codespace;
          return object;
        };

        /**
         * Converts this ResponseCheckTx to JSON.
         * @function toJSON
         * @memberof tendermint.abci.ResponseCheckTx
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ResponseCheckTx.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ResponseCheckTx;
      })();

      abci.ResponseDeliverTx = (function () {
        /**
         * Properties of a ResponseDeliverTx.
         * @memberof tendermint.abci
         * @interface IResponseDeliverTx
         * @property {number|null} [code] ResponseDeliverTx code
         * @property {Uint8Array|null} [data] ResponseDeliverTx data
         * @property {string|null} [log] ResponseDeliverTx log
         * @property {string|null} [info] ResponseDeliverTx info
         * @property {number|Long|null} [gasWanted] ResponseDeliverTx gasWanted
         * @property {number|Long|null} [gasUsed] ResponseDeliverTx gasUsed
         * @property {Array.<tendermint.abci.IEvent>|null} [events] ResponseDeliverTx events
         * @property {string|null} [codespace] ResponseDeliverTx codespace
         */

        /**
         * Constructs a new ResponseDeliverTx.
         * @memberof tendermint.abci
         * @classdesc Represents a ResponseDeliverTx.
         * @implements IResponseDeliverTx
         * @constructor
         * @param {tendermint.abci.IResponseDeliverTx=} [properties] Properties to set
         */
        function ResponseDeliverTx(properties) {
          this.events = [];
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * ResponseDeliverTx code.
         * @member {number} code
         * @memberof tendermint.abci.ResponseDeliverTx
         * @instance
         */
        ResponseDeliverTx.prototype.code = 0;

        /**
         * ResponseDeliverTx data.
         * @member {Uint8Array} data
         * @memberof tendermint.abci.ResponseDeliverTx
         * @instance
         */
        ResponseDeliverTx.prototype.data = $util.newBuffer([]);

        /**
         * ResponseDeliverTx log.
         * @member {string} log
         * @memberof tendermint.abci.ResponseDeliverTx
         * @instance
         */
        ResponseDeliverTx.prototype.log = "";

        /**
         * ResponseDeliverTx info.
         * @member {string} info
         * @memberof tendermint.abci.ResponseDeliverTx
         * @instance
         */
        ResponseDeliverTx.prototype.info = "";

        /**
         * ResponseDeliverTx gasWanted.
         * @member {number|Long} gasWanted
         * @memberof tendermint.abci.ResponseDeliverTx
         * @instance
         */
        ResponseDeliverTx.prototype.gasWanted = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * ResponseDeliverTx gasUsed.
         * @member {number|Long} gasUsed
         * @memberof tendermint.abci.ResponseDeliverTx
         * @instance
         */
        ResponseDeliverTx.prototype.gasUsed = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * ResponseDeliverTx events.
         * @member {Array.<tendermint.abci.IEvent>} events
         * @memberof tendermint.abci.ResponseDeliverTx
         * @instance
         */
        ResponseDeliverTx.prototype.events = $util.emptyArray;

        /**
         * ResponseDeliverTx codespace.
         * @member {string} codespace
         * @memberof tendermint.abci.ResponseDeliverTx
         * @instance
         */
        ResponseDeliverTx.prototype.codespace = "";

        /**
         * Creates a new ResponseDeliverTx instance using the specified properties.
         * @function create
         * @memberof tendermint.abci.ResponseDeliverTx
         * @static
         * @param {tendermint.abci.IResponseDeliverTx=} [properties] Properties to set
         * @returns {tendermint.abci.ResponseDeliverTx} ResponseDeliverTx instance
         */
        ResponseDeliverTx.create = function create(properties) {
          return new ResponseDeliverTx(properties);
        };

        /**
         * Encodes the specified ResponseDeliverTx message. Does not implicitly {@link tendermint.abci.ResponseDeliverTx.verify|verify} messages.
         * @function encode
         * @memberof tendermint.abci.ResponseDeliverTx
         * @static
         * @param {tendermint.abci.IResponseDeliverTx} message ResponseDeliverTx message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResponseDeliverTx.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.code != null && Object.hasOwnProperty.call(message, "code"))
            writer.uint32(/* id 1, wireType 0 =*/ 8).uint32(message.code);
          if (message.data != null && Object.hasOwnProperty.call(message, "data"))
            writer.uint32(/* id 2, wireType 2 =*/ 18).bytes(message.data);
          if (message.log != null && Object.hasOwnProperty.call(message, "log"))
            writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.log);
          if (message.info != null && Object.hasOwnProperty.call(message, "info"))
            writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.info);
          if (message.gasWanted != null && Object.hasOwnProperty.call(message, "gasWanted"))
            writer.uint32(/* id 5, wireType 0 =*/ 40).int64(message.gasWanted);
          if (message.gasUsed != null && Object.hasOwnProperty.call(message, "gasUsed"))
            writer.uint32(/* id 6, wireType 0 =*/ 48).int64(message.gasUsed);
          if (message.events != null && message.events.length)
            for (var i = 0; i < message.events.length; ++i)
              $root.tendermint.abci.Event.encode(
                message.events[i],
                writer.uint32(/* id 7, wireType 2 =*/ 58).fork(),
              ).ldelim();
          if (message.codespace != null && Object.hasOwnProperty.call(message, "codespace"))
            writer.uint32(/* id 8, wireType 2 =*/ 66).string(message.codespace);
          return writer;
        };

        /**
         * Encodes the specified ResponseDeliverTx message, length delimited. Does not implicitly {@link tendermint.abci.ResponseDeliverTx.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tendermint.abci.ResponseDeliverTx
         * @static
         * @param {tendermint.abci.IResponseDeliverTx} message ResponseDeliverTx message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResponseDeliverTx.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ResponseDeliverTx message from the specified reader or buffer.
         * @function decode
         * @memberof tendermint.abci.ResponseDeliverTx
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tendermint.abci.ResponseDeliverTx} ResponseDeliverTx
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResponseDeliverTx.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.tendermint.abci.ResponseDeliverTx();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.code = reader.uint32();
                break;
              case 2:
                message.data = reader.bytes();
                break;
              case 3:
                message.log = reader.string();
                break;
              case 4:
                message.info = reader.string();
                break;
              case 5:
                message.gasWanted = reader.int64();
                break;
              case 6:
                message.gasUsed = reader.int64();
                break;
              case 7:
                if (!(message.events && message.events.length)) message.events = [];
                message.events.push($root.tendermint.abci.Event.decode(reader, reader.uint32()));
                break;
              case 8:
                message.codespace = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a ResponseDeliverTx message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tendermint.abci.ResponseDeliverTx
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tendermint.abci.ResponseDeliverTx} ResponseDeliverTx
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResponseDeliverTx.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ResponseDeliverTx message.
         * @function verify
         * @memberof tendermint.abci.ResponseDeliverTx
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ResponseDeliverTx.verify = function verify(message) {
          if (typeof message !== "object" || message === null) return "object expected";
          if (message.code != null && message.hasOwnProperty("code"))
            if (!$util.isInteger(message.code)) return "code: integer expected";
          if (message.data != null && message.hasOwnProperty("data"))
            if (!((message.data && typeof message.data.length === "number") || $util.isString(message.data)))
              return "data: buffer expected";
          if (message.log != null && message.hasOwnProperty("log"))
            if (!$util.isString(message.log)) return "log: string expected";
          if (message.info != null && message.hasOwnProperty("info"))
            if (!$util.isString(message.info)) return "info: string expected";
          if (message.gasWanted != null && message.hasOwnProperty("gasWanted"))
            if (
              !$util.isInteger(message.gasWanted) &&
              !(
                message.gasWanted &&
                $util.isInteger(message.gasWanted.low) &&
                $util.isInteger(message.gasWanted.high)
              )
            )
              return "gasWanted: integer|Long expected";
          if (message.gasUsed != null && message.hasOwnProperty("gasUsed"))
            if (
              !$util.isInteger(message.gasUsed) &&
              !(
                message.gasUsed &&
                $util.isInteger(message.gasUsed.low) &&
                $util.isInteger(message.gasUsed.high)
              )
            )
              return "gasUsed: integer|Long expected";
          if (message.events != null && message.hasOwnProperty("events")) {
            if (!Array.isArray(message.events)) return "events: array expected";
            for (var i = 0; i < message.events.length; ++i) {
              var error = $root.tendermint.abci.Event.verify(message.events[i]);
              if (error) return "events." + error;
            }
          }
          if (message.codespace != null && message.hasOwnProperty("codespace"))
            if (!$util.isString(message.codespace)) return "codespace: string expected";
          return null;
        };

        /**
         * Creates a ResponseDeliverTx message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tendermint.abci.ResponseDeliverTx
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tendermint.abci.ResponseDeliverTx} ResponseDeliverTx
         */
        ResponseDeliverTx.fromObject = function fromObject(object) {
          if (object instanceof $root.tendermint.abci.ResponseDeliverTx) return object;
          var message = new $root.tendermint.abci.ResponseDeliverTx();
          if (object.code != null) message.code = object.code >>> 0;
          if (object.data != null)
            if (typeof object.data === "string")
              $util.base64.decode(
                object.data,
                (message.data = $util.newBuffer($util.base64.length(object.data))),
                0,
              );
            else if (object.data.length) message.data = object.data;
          if (object.log != null) message.log = String(object.log);
          if (object.info != null) message.info = String(object.info);
          if (object.gasWanted != null)
            if ($util.Long) (message.gasWanted = $util.Long.fromValue(object.gasWanted)).unsigned = false;
            else if (typeof object.gasWanted === "string") message.gasWanted = parseInt(object.gasWanted, 10);
            else if (typeof object.gasWanted === "number") message.gasWanted = object.gasWanted;
            else if (typeof object.gasWanted === "object")
              message.gasWanted = new $util.LongBits(
                object.gasWanted.low >>> 0,
                object.gasWanted.high >>> 0,
              ).toNumber();
          if (object.gasUsed != null)
            if ($util.Long) (message.gasUsed = $util.Long.fromValue(object.gasUsed)).unsigned = false;
            else if (typeof object.gasUsed === "string") message.gasUsed = parseInt(object.gasUsed, 10);
            else if (typeof object.gasUsed === "number") message.gasUsed = object.gasUsed;
            else if (typeof object.gasUsed === "object")
              message.gasUsed = new $util.LongBits(
                object.gasUsed.low >>> 0,
                object.gasUsed.high >>> 0,
              ).toNumber();
          if (object.events) {
            if (!Array.isArray(object.events))
              throw TypeError(".tendermint.abci.ResponseDeliverTx.events: array expected");
            message.events = [];
            for (var i = 0; i < object.events.length; ++i) {
              if (typeof object.events[i] !== "object")
                throw TypeError(".tendermint.abci.ResponseDeliverTx.events: object expected");
              message.events[i] = $root.tendermint.abci.Event.fromObject(object.events[i]);
            }
          }
          if (object.codespace != null) message.codespace = String(object.codespace);
          return message;
        };

        /**
         * Creates a plain object from a ResponseDeliverTx message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tendermint.abci.ResponseDeliverTx
         * @static
         * @param {tendermint.abci.ResponseDeliverTx} message ResponseDeliverTx
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ResponseDeliverTx.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.arrays || options.defaults) object.events = [];
          if (options.defaults) {
            object.code = 0;
            if (options.bytes === String) object.data = "";
            else {
              object.data = [];
              if (options.bytes !== Array) object.data = $util.newBuffer(object.data);
            }
            object.log = "";
            object.info = "";
            if ($util.Long) {
              var long = new $util.Long(0, 0, false);
              object.gasWanted =
                options.longs === String
                  ? long.toString()
                  : options.longs === Number
                  ? long.toNumber()
                  : long;
            } else object.gasWanted = options.longs === String ? "0" : 0;
            if ($util.Long) {
              var long = new $util.Long(0, 0, false);
              object.gasUsed =
                options.longs === String
                  ? long.toString()
                  : options.longs === Number
                  ? long.toNumber()
                  : long;
            } else object.gasUsed = options.longs === String ? "0" : 0;
            object.codespace = "";
          }
          if (message.code != null && message.hasOwnProperty("code")) object.code = message.code;
          if (message.data != null && message.hasOwnProperty("data"))
            object.data =
              options.bytes === String
                ? $util.base64.encode(message.data, 0, message.data.length)
                : options.bytes === Array
                ? Array.prototype.slice.call(message.data)
                : message.data;
          if (message.log != null && message.hasOwnProperty("log")) object.log = message.log;
          if (message.info != null && message.hasOwnProperty("info")) object.info = message.info;
          if (message.gasWanted != null && message.hasOwnProperty("gasWanted"))
            if (typeof message.gasWanted === "number")
              object.gasWanted = options.longs === String ? String(message.gasWanted) : message.gasWanted;
            else
              object.gasWanted =
                options.longs === String
                  ? $util.Long.prototype.toString.call(message.gasWanted)
                  : options.longs === Number
                  ? new $util.LongBits(message.gasWanted.low >>> 0, message.gasWanted.high >>> 0).toNumber()
                  : message.gasWanted;
          if (message.gasUsed != null && message.hasOwnProperty("gasUsed"))
            if (typeof message.gasUsed === "number")
              object.gasUsed = options.longs === String ? String(message.gasUsed) : message.gasUsed;
            else
              object.gasUsed =
                options.longs === String
                  ? $util.Long.prototype.toString.call(message.gasUsed)
                  : options.longs === Number
                  ? new $util.LongBits(message.gasUsed.low >>> 0, message.gasUsed.high >>> 0).toNumber()
                  : message.gasUsed;
          if (message.events && message.events.length) {
            object.events = [];
            for (var j = 0; j < message.events.length; ++j)
              object.events[j] = $root.tendermint.abci.Event.toObject(message.events[j], options);
          }
          if (message.codespace != null && message.hasOwnProperty("codespace"))
            object.codespace = message.codespace;
          return object;
        };

        /**
         * Converts this ResponseDeliverTx to JSON.
         * @function toJSON
         * @memberof tendermint.abci.ResponseDeliverTx
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ResponseDeliverTx.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ResponseDeliverTx;
      })();

      abci.ResponseEndBlock = (function () {
        /**
         * Properties of a ResponseEndBlock.
         * @memberof tendermint.abci
         * @interface IResponseEndBlock
         * @property {Array.<tendermint.abci.IValidatorUpdate>|null} [validatorUpdates] ResponseEndBlock validatorUpdates
         * @property {tendermint.abci.IConsensusParams|null} [consensusParamUpdates] ResponseEndBlock consensusParamUpdates
         * @property {Array.<tendermint.abci.IEvent>|null} [events] ResponseEndBlock events
         */

        /**
         * Constructs a new ResponseEndBlock.
         * @memberof tendermint.abci
         * @classdesc Represents a ResponseEndBlock.
         * @implements IResponseEndBlock
         * @constructor
         * @param {tendermint.abci.IResponseEndBlock=} [properties] Properties to set
         */
        function ResponseEndBlock(properties) {
          this.validatorUpdates = [];
          this.events = [];
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * ResponseEndBlock validatorUpdates.
         * @member {Array.<tendermint.abci.IValidatorUpdate>} validatorUpdates
         * @memberof tendermint.abci.ResponseEndBlock
         * @instance
         */
        ResponseEndBlock.prototype.validatorUpdates = $util.emptyArray;

        /**
         * ResponseEndBlock consensusParamUpdates.
         * @member {tendermint.abci.IConsensusParams|null|undefined} consensusParamUpdates
         * @memberof tendermint.abci.ResponseEndBlock
         * @instance
         */
        ResponseEndBlock.prototype.consensusParamUpdates = null;

        /**
         * ResponseEndBlock events.
         * @member {Array.<tendermint.abci.IEvent>} events
         * @memberof tendermint.abci.ResponseEndBlock
         * @instance
         */
        ResponseEndBlock.prototype.events = $util.emptyArray;

        /**
         * Creates a new ResponseEndBlock instance using the specified properties.
         * @function create
         * @memberof tendermint.abci.ResponseEndBlock
         * @static
         * @param {tendermint.abci.IResponseEndBlock=} [properties] Properties to set
         * @returns {tendermint.abci.ResponseEndBlock} ResponseEndBlock instance
         */
        ResponseEndBlock.create = function create(properties) {
          return new ResponseEndBlock(properties);
        };

        /**
         * Encodes the specified ResponseEndBlock message. Does not implicitly {@link tendermint.abci.ResponseEndBlock.verify|verify} messages.
         * @function encode
         * @memberof tendermint.abci.ResponseEndBlock
         * @static
         * @param {tendermint.abci.IResponseEndBlock} message ResponseEndBlock message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResponseEndBlock.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.validatorUpdates != null && message.validatorUpdates.length)
            for (var i = 0; i < message.validatorUpdates.length; ++i)
              $root.tendermint.abci.ValidatorUpdate.encode(
                message.validatorUpdates[i],
                writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
              ).ldelim();
          if (
            message.consensusParamUpdates != null &&
            Object.hasOwnProperty.call(message, "consensusParamUpdates")
          )
            $root.tendermint.abci.ConsensusParams.encode(
              message.consensusParamUpdates,
              writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
            ).ldelim();
          if (message.events != null && message.events.length)
            for (var i = 0; i < message.events.length; ++i)
              $root.tendermint.abci.Event.encode(
                message.events[i],
                writer.uint32(/* id 3, wireType 2 =*/ 26).fork(),
              ).ldelim();
          return writer;
        };

        /**
         * Encodes the specified ResponseEndBlock message, length delimited. Does not implicitly {@link tendermint.abci.ResponseEndBlock.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tendermint.abci.ResponseEndBlock
         * @static
         * @param {tendermint.abci.IResponseEndBlock} message ResponseEndBlock message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResponseEndBlock.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ResponseEndBlock message from the specified reader or buffer.
         * @function decode
         * @memberof tendermint.abci.ResponseEndBlock
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tendermint.abci.ResponseEndBlock} ResponseEndBlock
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResponseEndBlock.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.tendermint.abci.ResponseEndBlock();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                if (!(message.validatorUpdates && message.validatorUpdates.length))
                  message.validatorUpdates = [];
                message.validatorUpdates.push(
                  $root.tendermint.abci.ValidatorUpdate.decode(reader, reader.uint32()),
                );
                break;
              case 2:
                message.consensusParamUpdates = $root.tendermint.abci.ConsensusParams.decode(
                  reader,
                  reader.uint32(),
                );
                break;
              case 3:
                if (!(message.events && message.events.length)) message.events = [];
                message.events.push($root.tendermint.abci.Event.decode(reader, reader.uint32()));
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a ResponseEndBlock message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tendermint.abci.ResponseEndBlock
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tendermint.abci.ResponseEndBlock} ResponseEndBlock
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResponseEndBlock.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ResponseEndBlock message.
         * @function verify
         * @memberof tendermint.abci.ResponseEndBlock
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ResponseEndBlock.verify = function verify(message) {
          if (typeof message !== "object" || message === null) return "object expected";
          if (message.validatorUpdates != null && message.hasOwnProperty("validatorUpdates")) {
            if (!Array.isArray(message.validatorUpdates)) return "validatorUpdates: array expected";
            for (var i = 0; i < message.validatorUpdates.length; ++i) {
              var error = $root.tendermint.abci.ValidatorUpdate.verify(message.validatorUpdates[i]);
              if (error) return "validatorUpdates." + error;
            }
          }
          if (message.consensusParamUpdates != null && message.hasOwnProperty("consensusParamUpdates")) {
            var error = $root.tendermint.abci.ConsensusParams.verify(message.consensusParamUpdates);
            if (error) return "consensusParamUpdates." + error;
          }
          if (message.events != null && message.hasOwnProperty("events")) {
            if (!Array.isArray(message.events)) return "events: array expected";
            for (var i = 0; i < message.events.length; ++i) {
              var error = $root.tendermint.abci.Event.verify(message.events[i]);
              if (error) return "events." + error;
            }
          }
          return null;
        };

        /**
         * Creates a ResponseEndBlock message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tendermint.abci.ResponseEndBlock
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tendermint.abci.ResponseEndBlock} ResponseEndBlock
         */
        ResponseEndBlock.fromObject = function fromObject(object) {
          if (object instanceof $root.tendermint.abci.ResponseEndBlock) return object;
          var message = new $root.tendermint.abci.ResponseEndBlock();
          if (object.validatorUpdates) {
            if (!Array.isArray(object.validatorUpdates))
              throw TypeError(".tendermint.abci.ResponseEndBlock.validatorUpdates: array expected");
            message.validatorUpdates = [];
            for (var i = 0; i < object.validatorUpdates.length; ++i) {
              if (typeof object.validatorUpdates[i] !== "object")
                throw TypeError(".tendermint.abci.ResponseEndBlock.validatorUpdates: object expected");
              message.validatorUpdates[i] = $root.tendermint.abci.ValidatorUpdate.fromObject(
                object.validatorUpdates[i],
              );
            }
          }
          if (object.consensusParamUpdates != null) {
            if (typeof object.consensusParamUpdates !== "object")
              throw TypeError(".tendermint.abci.ResponseEndBlock.consensusParamUpdates: object expected");
            message.consensusParamUpdates = $root.tendermint.abci.ConsensusParams.fromObject(
              object.consensusParamUpdates,
            );
          }
          if (object.events) {
            if (!Array.isArray(object.events))
              throw TypeError(".tendermint.abci.ResponseEndBlock.events: array expected");
            message.events = [];
            for (var i = 0; i < object.events.length; ++i) {
              if (typeof object.events[i] !== "object")
                throw TypeError(".tendermint.abci.ResponseEndBlock.events: object expected");
              message.events[i] = $root.tendermint.abci.Event.fromObject(object.events[i]);
            }
          }
          return message;
        };

        /**
         * Creates a plain object from a ResponseEndBlock message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tendermint.abci.ResponseEndBlock
         * @static
         * @param {tendermint.abci.ResponseEndBlock} message ResponseEndBlock
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ResponseEndBlock.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.arrays || options.defaults) {
            object.validatorUpdates = [];
            object.events = [];
          }
          if (options.defaults) object.consensusParamUpdates = null;
          if (message.validatorUpdates && message.validatorUpdates.length) {
            object.validatorUpdates = [];
            for (var j = 0; j < message.validatorUpdates.length; ++j)
              object.validatorUpdates[j] = $root.tendermint.abci.ValidatorUpdate.toObject(
                message.validatorUpdates[j],
                options,
              );
          }
          if (message.consensusParamUpdates != null && message.hasOwnProperty("consensusParamUpdates"))
            object.consensusParamUpdates = $root.tendermint.abci.ConsensusParams.toObject(
              message.consensusParamUpdates,
              options,
            );
          if (message.events && message.events.length) {
            object.events = [];
            for (var j = 0; j < message.events.length; ++j)
              object.events[j] = $root.tendermint.abci.Event.toObject(message.events[j], options);
          }
          return object;
        };

        /**
         * Converts this ResponseEndBlock to JSON.
         * @function toJSON
         * @memberof tendermint.abci.ResponseEndBlock
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ResponseEndBlock.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ResponseEndBlock;
      })();

      abci.ResponseCommit = (function () {
        /**
         * Properties of a ResponseCommit.
         * @memberof tendermint.abci
         * @interface IResponseCommit
         * @property {Uint8Array|null} [data] ResponseCommit data
         * @property {number|Long|null} [retainHeight] ResponseCommit retainHeight
         */

        /**
         * Constructs a new ResponseCommit.
         * @memberof tendermint.abci
         * @classdesc Represents a ResponseCommit.
         * @implements IResponseCommit
         * @constructor
         * @param {tendermint.abci.IResponseCommit=} [properties] Properties to set
         */
        function ResponseCommit(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * ResponseCommit data.
         * @member {Uint8Array} data
         * @memberof tendermint.abci.ResponseCommit
         * @instance
         */
        ResponseCommit.prototype.data = $util.newBuffer([]);

        /**
         * ResponseCommit retainHeight.
         * @member {number|Long} retainHeight
         * @memberof tendermint.abci.ResponseCommit
         * @instance
         */
        ResponseCommit.prototype.retainHeight = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * Creates a new ResponseCommit instance using the specified properties.
         * @function create
         * @memberof tendermint.abci.ResponseCommit
         * @static
         * @param {tendermint.abci.IResponseCommit=} [properties] Properties to set
         * @returns {tendermint.abci.ResponseCommit} ResponseCommit instance
         */
        ResponseCommit.create = function create(properties) {
          return new ResponseCommit(properties);
        };

        /**
         * Encodes the specified ResponseCommit message. Does not implicitly {@link tendermint.abci.ResponseCommit.verify|verify} messages.
         * @function encode
         * @memberof tendermint.abci.ResponseCommit
         * @static
         * @param {tendermint.abci.IResponseCommit} message ResponseCommit message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResponseCommit.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.data != null && Object.hasOwnProperty.call(message, "data"))
            writer.uint32(/* id 2, wireType 2 =*/ 18).bytes(message.data);
          if (message.retainHeight != null && Object.hasOwnProperty.call(message, "retainHeight"))
            writer.uint32(/* id 3, wireType 0 =*/ 24).int64(message.retainHeight);
          return writer;
        };

        /**
         * Encodes the specified ResponseCommit message, length delimited. Does not implicitly {@link tendermint.abci.ResponseCommit.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tendermint.abci.ResponseCommit
         * @static
         * @param {tendermint.abci.IResponseCommit} message ResponseCommit message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResponseCommit.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ResponseCommit message from the specified reader or buffer.
         * @function decode
         * @memberof tendermint.abci.ResponseCommit
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tendermint.abci.ResponseCommit} ResponseCommit
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResponseCommit.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.tendermint.abci.ResponseCommit();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 2:
                message.data = reader.bytes();
                break;
              case 3:
                message.retainHeight = reader.int64();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a ResponseCommit message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tendermint.abci.ResponseCommit
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tendermint.abci.ResponseCommit} ResponseCommit
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResponseCommit.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ResponseCommit message.
         * @function verify
         * @memberof tendermint.abci.ResponseCommit
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ResponseCommit.verify = function verify(message) {
          if (typeof message !== "object" || message === null) return "object expected";
          if (message.data != null && message.hasOwnProperty("data"))
            if (!((message.data && typeof message.data.length === "number") || $util.isString(message.data)))
              return "data: buffer expected";
          if (message.retainHeight != null && message.hasOwnProperty("retainHeight"))
            if (
              !$util.isInteger(message.retainHeight) &&
              !(
                message.retainHeight &&
                $util.isInteger(message.retainHeight.low) &&
                $util.isInteger(message.retainHeight.high)
              )
            )
              return "retainHeight: integer|Long expected";
          return null;
        };

        /**
         * Creates a ResponseCommit message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tendermint.abci.ResponseCommit
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tendermint.abci.ResponseCommit} ResponseCommit
         */
        ResponseCommit.fromObject = function fromObject(object) {
          if (object instanceof $root.tendermint.abci.ResponseCommit) return object;
          var message = new $root.tendermint.abci.ResponseCommit();
          if (object.data != null)
            if (typeof object.data === "string")
              $util.base64.decode(
                object.data,
                (message.data = $util.newBuffer($util.base64.length(object.data))),
                0,
              );
            else if (object.data.length) message.data = object.data;
          if (object.retainHeight != null)
            if ($util.Long)
              (message.retainHeight = $util.Long.fromValue(object.retainHeight)).unsigned = false;
            else if (typeof object.retainHeight === "string")
              message.retainHeight = parseInt(object.retainHeight, 10);
            else if (typeof object.retainHeight === "number") message.retainHeight = object.retainHeight;
            else if (typeof object.retainHeight === "object")
              message.retainHeight = new $util.LongBits(
                object.retainHeight.low >>> 0,
                object.retainHeight.high >>> 0,
              ).toNumber();
          return message;
        };

        /**
         * Creates a plain object from a ResponseCommit message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tendermint.abci.ResponseCommit
         * @static
         * @param {tendermint.abci.ResponseCommit} message ResponseCommit
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ResponseCommit.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            if (options.bytes === String) object.data = "";
            else {
              object.data = [];
              if (options.bytes !== Array) object.data = $util.newBuffer(object.data);
            }
            if ($util.Long) {
              var long = new $util.Long(0, 0, false);
              object.retainHeight =
                options.longs === String
                  ? long.toString()
                  : options.longs === Number
                  ? long.toNumber()
                  : long;
            } else object.retainHeight = options.longs === String ? "0" : 0;
          }
          if (message.data != null && message.hasOwnProperty("data"))
            object.data =
              options.bytes === String
                ? $util.base64.encode(message.data, 0, message.data.length)
                : options.bytes === Array
                ? Array.prototype.slice.call(message.data)
                : message.data;
          if (message.retainHeight != null && message.hasOwnProperty("retainHeight"))
            if (typeof message.retainHeight === "number")
              object.retainHeight =
                options.longs === String ? String(message.retainHeight) : message.retainHeight;
            else
              object.retainHeight =
                options.longs === String
                  ? $util.Long.prototype.toString.call(message.retainHeight)
                  : options.longs === Number
                  ? new $util.LongBits(
                      message.retainHeight.low >>> 0,
                      message.retainHeight.high >>> 0,
                    ).toNumber()
                  : message.retainHeight;
          return object;
        };

        /**
         * Converts this ResponseCommit to JSON.
         * @function toJSON
         * @memberof tendermint.abci.ResponseCommit
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ResponseCommit.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ResponseCommit;
      })();

      abci.ResponseListSnapshots = (function () {
        /**
         * Properties of a ResponseListSnapshots.
         * @memberof tendermint.abci
         * @interface IResponseListSnapshots
         * @property {Array.<tendermint.abci.ISnapshot>|null} [snapshots] ResponseListSnapshots snapshots
         */

        /**
         * Constructs a new ResponseListSnapshots.
         * @memberof tendermint.abci
         * @classdesc Represents a ResponseListSnapshots.
         * @implements IResponseListSnapshots
         * @constructor
         * @param {tendermint.abci.IResponseListSnapshots=} [properties] Properties to set
         */
        function ResponseListSnapshots(properties) {
          this.snapshots = [];
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * ResponseListSnapshots snapshots.
         * @member {Array.<tendermint.abci.ISnapshot>} snapshots
         * @memberof tendermint.abci.ResponseListSnapshots
         * @instance
         */
        ResponseListSnapshots.prototype.snapshots = $util.emptyArray;

        /**
         * Creates a new ResponseListSnapshots instance using the specified properties.
         * @function create
         * @memberof tendermint.abci.ResponseListSnapshots
         * @static
         * @param {tendermint.abci.IResponseListSnapshots=} [properties] Properties to set
         * @returns {tendermint.abci.ResponseListSnapshots} ResponseListSnapshots instance
         */
        ResponseListSnapshots.create = function create(properties) {
          return new ResponseListSnapshots(properties);
        };

        /**
         * Encodes the specified ResponseListSnapshots message. Does not implicitly {@link tendermint.abci.ResponseListSnapshots.verify|verify} messages.
         * @function encode
         * @memberof tendermint.abci.ResponseListSnapshots
         * @static
         * @param {tendermint.abci.IResponseListSnapshots} message ResponseListSnapshots message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResponseListSnapshots.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.snapshots != null && message.snapshots.length)
            for (var i = 0; i < message.snapshots.length; ++i)
              $root.tendermint.abci.Snapshot.encode(
                message.snapshots[i],
                writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
              ).ldelim();
          return writer;
        };

        /**
         * Encodes the specified ResponseListSnapshots message, length delimited. Does not implicitly {@link tendermint.abci.ResponseListSnapshots.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tendermint.abci.ResponseListSnapshots
         * @static
         * @param {tendermint.abci.IResponseListSnapshots} message ResponseListSnapshots message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResponseListSnapshots.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ResponseListSnapshots message from the specified reader or buffer.
         * @function decode
         * @memberof tendermint.abci.ResponseListSnapshots
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tendermint.abci.ResponseListSnapshots} ResponseListSnapshots
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResponseListSnapshots.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.tendermint.abci.ResponseListSnapshots();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                if (!(message.snapshots && message.snapshots.length)) message.snapshots = [];
                message.snapshots.push($root.tendermint.abci.Snapshot.decode(reader, reader.uint32()));
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a ResponseListSnapshots message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tendermint.abci.ResponseListSnapshots
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tendermint.abci.ResponseListSnapshots} ResponseListSnapshots
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResponseListSnapshots.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ResponseListSnapshots message.
         * @function verify
         * @memberof tendermint.abci.ResponseListSnapshots
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ResponseListSnapshots.verify = function verify(message) {
          if (typeof message !== "object" || message === null) return "object expected";
          if (message.snapshots != null && message.hasOwnProperty("snapshots")) {
            if (!Array.isArray(message.snapshots)) return "snapshots: array expected";
            for (var i = 0; i < message.snapshots.length; ++i) {
              var error = $root.tendermint.abci.Snapshot.verify(message.snapshots[i]);
              if (error) return "snapshots." + error;
            }
          }
          return null;
        };

        /**
         * Creates a ResponseListSnapshots message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tendermint.abci.ResponseListSnapshots
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tendermint.abci.ResponseListSnapshots} ResponseListSnapshots
         */
        ResponseListSnapshots.fromObject = function fromObject(object) {
          if (object instanceof $root.tendermint.abci.ResponseListSnapshots) return object;
          var message = new $root.tendermint.abci.ResponseListSnapshots();
          if (object.snapshots) {
            if (!Array.isArray(object.snapshots))
              throw TypeError(".tendermint.abci.ResponseListSnapshots.snapshots: array expected");
            message.snapshots = [];
            for (var i = 0; i < object.snapshots.length; ++i) {
              if (typeof object.snapshots[i] !== "object")
                throw TypeError(".tendermint.abci.ResponseListSnapshots.snapshots: object expected");
              message.snapshots[i] = $root.tendermint.abci.Snapshot.fromObject(object.snapshots[i]);
            }
          }
          return message;
        };

        /**
         * Creates a plain object from a ResponseListSnapshots message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tendermint.abci.ResponseListSnapshots
         * @static
         * @param {tendermint.abci.ResponseListSnapshots} message ResponseListSnapshots
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ResponseListSnapshots.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.arrays || options.defaults) object.snapshots = [];
          if (message.snapshots && message.snapshots.length) {
            object.snapshots = [];
            for (var j = 0; j < message.snapshots.length; ++j)
              object.snapshots[j] = $root.tendermint.abci.Snapshot.toObject(message.snapshots[j], options);
          }
          return object;
        };

        /**
         * Converts this ResponseListSnapshots to JSON.
         * @function toJSON
         * @memberof tendermint.abci.ResponseListSnapshots
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ResponseListSnapshots.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ResponseListSnapshots;
      })();

      abci.ResponseOfferSnapshot = (function () {
        /**
         * Properties of a ResponseOfferSnapshot.
         * @memberof tendermint.abci
         * @interface IResponseOfferSnapshot
         * @property {tendermint.abci.ResponseOfferSnapshot.Result|null} [result] ResponseOfferSnapshot result
         */

        /**
         * Constructs a new ResponseOfferSnapshot.
         * @memberof tendermint.abci
         * @classdesc Represents a ResponseOfferSnapshot.
         * @implements IResponseOfferSnapshot
         * @constructor
         * @param {tendermint.abci.IResponseOfferSnapshot=} [properties] Properties to set
         */
        function ResponseOfferSnapshot(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * ResponseOfferSnapshot result.
         * @member {tendermint.abci.ResponseOfferSnapshot.Result} result
         * @memberof tendermint.abci.ResponseOfferSnapshot
         * @instance
         */
        ResponseOfferSnapshot.prototype.result = 0;

        /**
         * Creates a new ResponseOfferSnapshot instance using the specified properties.
         * @function create
         * @memberof tendermint.abci.ResponseOfferSnapshot
         * @static
         * @param {tendermint.abci.IResponseOfferSnapshot=} [properties] Properties to set
         * @returns {tendermint.abci.ResponseOfferSnapshot} ResponseOfferSnapshot instance
         */
        ResponseOfferSnapshot.create = function create(properties) {
          return new ResponseOfferSnapshot(properties);
        };

        /**
         * Encodes the specified ResponseOfferSnapshot message. Does not implicitly {@link tendermint.abci.ResponseOfferSnapshot.verify|verify} messages.
         * @function encode
         * @memberof tendermint.abci.ResponseOfferSnapshot
         * @static
         * @param {tendermint.abci.IResponseOfferSnapshot} message ResponseOfferSnapshot message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResponseOfferSnapshot.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.result != null && Object.hasOwnProperty.call(message, "result"))
            writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.result);
          return writer;
        };

        /**
         * Encodes the specified ResponseOfferSnapshot message, length delimited. Does not implicitly {@link tendermint.abci.ResponseOfferSnapshot.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tendermint.abci.ResponseOfferSnapshot
         * @static
         * @param {tendermint.abci.IResponseOfferSnapshot} message ResponseOfferSnapshot message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResponseOfferSnapshot.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ResponseOfferSnapshot message from the specified reader or buffer.
         * @function decode
         * @memberof tendermint.abci.ResponseOfferSnapshot
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tendermint.abci.ResponseOfferSnapshot} ResponseOfferSnapshot
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResponseOfferSnapshot.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.tendermint.abci.ResponseOfferSnapshot();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.result = reader.int32();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a ResponseOfferSnapshot message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tendermint.abci.ResponseOfferSnapshot
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tendermint.abci.ResponseOfferSnapshot} ResponseOfferSnapshot
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResponseOfferSnapshot.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ResponseOfferSnapshot message.
         * @function verify
         * @memberof tendermint.abci.ResponseOfferSnapshot
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ResponseOfferSnapshot.verify = function verify(message) {
          if (typeof message !== "object" || message === null) return "object expected";
          if (message.result != null && message.hasOwnProperty("result"))
            switch (message.result) {
              default:
                return "result: enum value expected";
              case 0:
              case 1:
              case 2:
              case 3:
              case 4:
              case 5:
                break;
            }
          return null;
        };

        /**
         * Creates a ResponseOfferSnapshot message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tendermint.abci.ResponseOfferSnapshot
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tendermint.abci.ResponseOfferSnapshot} ResponseOfferSnapshot
         */
        ResponseOfferSnapshot.fromObject = function fromObject(object) {
          if (object instanceof $root.tendermint.abci.ResponseOfferSnapshot) return object;
          var message = new $root.tendermint.abci.ResponseOfferSnapshot();
          switch (object.result) {
            case "UNKNOWN":
            case 0:
              message.result = 0;
              break;
            case "ACCEPT":
            case 1:
              message.result = 1;
              break;
            case "ABORT":
            case 2:
              message.result = 2;
              break;
            case "REJECT":
            case 3:
              message.result = 3;
              break;
            case "REJECT_FORMAT":
            case 4:
              message.result = 4;
              break;
            case "REJECT_SENDER":
            case 5:
              message.result = 5;
              break;
          }
          return message;
        };

        /**
         * Creates a plain object from a ResponseOfferSnapshot message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tendermint.abci.ResponseOfferSnapshot
         * @static
         * @param {tendermint.abci.ResponseOfferSnapshot} message ResponseOfferSnapshot
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ResponseOfferSnapshot.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) object.result = options.enums === String ? "UNKNOWN" : 0;
          if (message.result != null && message.hasOwnProperty("result"))
            object.result =
              options.enums === String
                ? $root.tendermint.abci.ResponseOfferSnapshot.Result[message.result]
                : message.result;
          return object;
        };

        /**
         * Converts this ResponseOfferSnapshot to JSON.
         * @function toJSON
         * @memberof tendermint.abci.ResponseOfferSnapshot
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ResponseOfferSnapshot.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Result enum.
         * @name tendermint.abci.ResponseOfferSnapshot.Result
         * @enum {number}
         * @property {number} UNKNOWN=0 UNKNOWN value
         * @property {number} ACCEPT=1 ACCEPT value
         * @property {number} ABORT=2 ABORT value
         * @property {number} REJECT=3 REJECT value
         * @property {number} REJECT_FORMAT=4 REJECT_FORMAT value
         * @property {number} REJECT_SENDER=5 REJECT_SENDER value
         */
        ResponseOfferSnapshot.Result = (function () {
          var valuesById = {},
            values = Object.create(valuesById);
          values[(valuesById[0] = "UNKNOWN")] = 0;
          values[(valuesById[1] = "ACCEPT")] = 1;
          values[(valuesById[2] = "ABORT")] = 2;
          values[(valuesById[3] = "REJECT")] = 3;
          values[(valuesById[4] = "REJECT_FORMAT")] = 4;
          values[(valuesById[5] = "REJECT_SENDER")] = 5;
          return values;
        })();

        return ResponseOfferSnapshot;
      })();

      abci.ResponseLoadSnapshotChunk = (function () {
        /**
         * Properties of a ResponseLoadSnapshotChunk.
         * @memberof tendermint.abci
         * @interface IResponseLoadSnapshotChunk
         * @property {Uint8Array|null} [chunk] ResponseLoadSnapshotChunk chunk
         */

        /**
         * Constructs a new ResponseLoadSnapshotChunk.
         * @memberof tendermint.abci
         * @classdesc Represents a ResponseLoadSnapshotChunk.
         * @implements IResponseLoadSnapshotChunk
         * @constructor
         * @param {tendermint.abci.IResponseLoadSnapshotChunk=} [properties] Properties to set
         */
        function ResponseLoadSnapshotChunk(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * ResponseLoadSnapshotChunk chunk.
         * @member {Uint8Array} chunk
         * @memberof tendermint.abci.ResponseLoadSnapshotChunk
         * @instance
         */
        ResponseLoadSnapshotChunk.prototype.chunk = $util.newBuffer([]);

        /**
         * Creates a new ResponseLoadSnapshotChunk instance using the specified properties.
         * @function create
         * @memberof tendermint.abci.ResponseLoadSnapshotChunk
         * @static
         * @param {tendermint.abci.IResponseLoadSnapshotChunk=} [properties] Properties to set
         * @returns {tendermint.abci.ResponseLoadSnapshotChunk} ResponseLoadSnapshotChunk instance
         */
        ResponseLoadSnapshotChunk.create = function create(properties) {
          return new ResponseLoadSnapshotChunk(properties);
        };

        /**
         * Encodes the specified ResponseLoadSnapshotChunk message. Does not implicitly {@link tendermint.abci.ResponseLoadSnapshotChunk.verify|verify} messages.
         * @function encode
         * @memberof tendermint.abci.ResponseLoadSnapshotChunk
         * @static
         * @param {tendermint.abci.IResponseLoadSnapshotChunk} message ResponseLoadSnapshotChunk message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResponseLoadSnapshotChunk.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.chunk != null && Object.hasOwnProperty.call(message, "chunk"))
            writer.uint32(/* id 1, wireType 2 =*/ 10).bytes(message.chunk);
          return writer;
        };

        /**
         * Encodes the specified ResponseLoadSnapshotChunk message, length delimited. Does not implicitly {@link tendermint.abci.ResponseLoadSnapshotChunk.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tendermint.abci.ResponseLoadSnapshotChunk
         * @static
         * @param {tendermint.abci.IResponseLoadSnapshotChunk} message ResponseLoadSnapshotChunk message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResponseLoadSnapshotChunk.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ResponseLoadSnapshotChunk message from the specified reader or buffer.
         * @function decode
         * @memberof tendermint.abci.ResponseLoadSnapshotChunk
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tendermint.abci.ResponseLoadSnapshotChunk} ResponseLoadSnapshotChunk
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResponseLoadSnapshotChunk.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.tendermint.abci.ResponseLoadSnapshotChunk();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.chunk = reader.bytes();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a ResponseLoadSnapshotChunk message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tendermint.abci.ResponseLoadSnapshotChunk
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tendermint.abci.ResponseLoadSnapshotChunk} ResponseLoadSnapshotChunk
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResponseLoadSnapshotChunk.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ResponseLoadSnapshotChunk message.
         * @function verify
         * @memberof tendermint.abci.ResponseLoadSnapshotChunk
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ResponseLoadSnapshotChunk.verify = function verify(message) {
          if (typeof message !== "object" || message === null) return "object expected";
          if (message.chunk != null && message.hasOwnProperty("chunk"))
            if (
              !((message.chunk && typeof message.chunk.length === "number") || $util.isString(message.chunk))
            )
              return "chunk: buffer expected";
          return null;
        };

        /**
         * Creates a ResponseLoadSnapshotChunk message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tendermint.abci.ResponseLoadSnapshotChunk
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tendermint.abci.ResponseLoadSnapshotChunk} ResponseLoadSnapshotChunk
         */
        ResponseLoadSnapshotChunk.fromObject = function fromObject(object) {
          if (object instanceof $root.tendermint.abci.ResponseLoadSnapshotChunk) return object;
          var message = new $root.tendermint.abci.ResponseLoadSnapshotChunk();
          if (object.chunk != null)
            if (typeof object.chunk === "string")
              $util.base64.decode(
                object.chunk,
                (message.chunk = $util.newBuffer($util.base64.length(object.chunk))),
                0,
              );
            else if (object.chunk.length) message.chunk = object.chunk;
          return message;
        };

        /**
         * Creates a plain object from a ResponseLoadSnapshotChunk message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tendermint.abci.ResponseLoadSnapshotChunk
         * @static
         * @param {tendermint.abci.ResponseLoadSnapshotChunk} message ResponseLoadSnapshotChunk
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ResponseLoadSnapshotChunk.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults)
            if (options.bytes === String) object.chunk = "";
            else {
              object.chunk = [];
              if (options.bytes !== Array) object.chunk = $util.newBuffer(object.chunk);
            }
          if (message.chunk != null && message.hasOwnProperty("chunk"))
            object.chunk =
              options.bytes === String
                ? $util.base64.encode(message.chunk, 0, message.chunk.length)
                : options.bytes === Array
                ? Array.prototype.slice.call(message.chunk)
                : message.chunk;
          return object;
        };

        /**
         * Converts this ResponseLoadSnapshotChunk to JSON.
         * @function toJSON
         * @memberof tendermint.abci.ResponseLoadSnapshotChunk
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ResponseLoadSnapshotChunk.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ResponseLoadSnapshotChunk;
      })();

      abci.ResponseApplySnapshotChunk = (function () {
        /**
         * Properties of a ResponseApplySnapshotChunk.
         * @memberof tendermint.abci
         * @interface IResponseApplySnapshotChunk
         * @property {tendermint.abci.ResponseApplySnapshotChunk.Result|null} [result] ResponseApplySnapshotChunk result
         * @property {Array.<number>|null} [refetchChunks] ResponseApplySnapshotChunk refetchChunks
         * @property {Array.<string>|null} [rejectSenders] ResponseApplySnapshotChunk rejectSenders
         */

        /**
         * Constructs a new ResponseApplySnapshotChunk.
         * @memberof tendermint.abci
         * @classdesc Represents a ResponseApplySnapshotChunk.
         * @implements IResponseApplySnapshotChunk
         * @constructor
         * @param {tendermint.abci.IResponseApplySnapshotChunk=} [properties] Properties to set
         */
        function ResponseApplySnapshotChunk(properties) {
          this.refetchChunks = [];
          this.rejectSenders = [];
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * ResponseApplySnapshotChunk result.
         * @member {tendermint.abci.ResponseApplySnapshotChunk.Result} result
         * @memberof tendermint.abci.ResponseApplySnapshotChunk
         * @instance
         */
        ResponseApplySnapshotChunk.prototype.result = 0;

        /**
         * ResponseApplySnapshotChunk refetchChunks.
         * @member {Array.<number>} refetchChunks
         * @memberof tendermint.abci.ResponseApplySnapshotChunk
         * @instance
         */
        ResponseApplySnapshotChunk.prototype.refetchChunks = $util.emptyArray;

        /**
         * ResponseApplySnapshotChunk rejectSenders.
         * @member {Array.<string>} rejectSenders
         * @memberof tendermint.abci.ResponseApplySnapshotChunk
         * @instance
         */
        ResponseApplySnapshotChunk.prototype.rejectSenders = $util.emptyArray;

        /**
         * Creates a new ResponseApplySnapshotChunk instance using the specified properties.
         * @function create
         * @memberof tendermint.abci.ResponseApplySnapshotChunk
         * @static
         * @param {tendermint.abci.IResponseApplySnapshotChunk=} [properties] Properties to set
         * @returns {tendermint.abci.ResponseApplySnapshotChunk} ResponseApplySnapshotChunk instance
         */
        ResponseApplySnapshotChunk.create = function create(properties) {
          return new ResponseApplySnapshotChunk(properties);
        };

        /**
         * Encodes the specified ResponseApplySnapshotChunk message. Does not implicitly {@link tendermint.abci.ResponseApplySnapshotChunk.verify|verify} messages.
         * @function encode
         * @memberof tendermint.abci.ResponseApplySnapshotChunk
         * @static
         * @param {tendermint.abci.IResponseApplySnapshotChunk} message ResponseApplySnapshotChunk message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResponseApplySnapshotChunk.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.result != null && Object.hasOwnProperty.call(message, "result"))
            writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.result);
          if (message.refetchChunks != null && message.refetchChunks.length) {
            writer.uint32(/* id 2, wireType 2 =*/ 18).fork();
            for (var i = 0; i < message.refetchChunks.length; ++i) writer.uint32(message.refetchChunks[i]);
            writer.ldelim();
          }
          if (message.rejectSenders != null && message.rejectSenders.length)
            for (var i = 0; i < message.rejectSenders.length; ++i)
              writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.rejectSenders[i]);
          return writer;
        };

        /**
         * Encodes the specified ResponseApplySnapshotChunk message, length delimited. Does not implicitly {@link tendermint.abci.ResponseApplySnapshotChunk.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tendermint.abci.ResponseApplySnapshotChunk
         * @static
         * @param {tendermint.abci.IResponseApplySnapshotChunk} message ResponseApplySnapshotChunk message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResponseApplySnapshotChunk.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ResponseApplySnapshotChunk message from the specified reader or buffer.
         * @function decode
         * @memberof tendermint.abci.ResponseApplySnapshotChunk
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tendermint.abci.ResponseApplySnapshotChunk} ResponseApplySnapshotChunk
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResponseApplySnapshotChunk.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.tendermint.abci.ResponseApplySnapshotChunk();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.result = reader.int32();
                break;
              case 2:
                if (!(message.refetchChunks && message.refetchChunks.length)) message.refetchChunks = [];
                if ((tag & 7) === 2) {
                  var end2 = reader.uint32() + reader.pos;
                  while (reader.pos < end2) message.refetchChunks.push(reader.uint32());
                } else message.refetchChunks.push(reader.uint32());
                break;
              case 3:
                if (!(message.rejectSenders && message.rejectSenders.length)) message.rejectSenders = [];
                message.rejectSenders.push(reader.string());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a ResponseApplySnapshotChunk message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tendermint.abci.ResponseApplySnapshotChunk
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tendermint.abci.ResponseApplySnapshotChunk} ResponseApplySnapshotChunk
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResponseApplySnapshotChunk.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ResponseApplySnapshotChunk message.
         * @function verify
         * @memberof tendermint.abci.ResponseApplySnapshotChunk
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ResponseApplySnapshotChunk.verify = function verify(message) {
          if (typeof message !== "object" || message === null) return "object expected";
          if (message.result != null && message.hasOwnProperty("result"))
            switch (message.result) {
              default:
                return "result: enum value expected";
              case 0:
              case 1:
              case 2:
              case 3:
              case 4:
              case 5:
                break;
            }
          if (message.refetchChunks != null && message.hasOwnProperty("refetchChunks")) {
            if (!Array.isArray(message.refetchChunks)) return "refetchChunks: array expected";
            for (var i = 0; i < message.refetchChunks.length; ++i)
              if (!$util.isInteger(message.refetchChunks[i])) return "refetchChunks: integer[] expected";
          }
          if (message.rejectSenders != null && message.hasOwnProperty("rejectSenders")) {
            if (!Array.isArray(message.rejectSenders)) return "rejectSenders: array expected";
            for (var i = 0; i < message.rejectSenders.length; ++i)
              if (!$util.isString(message.rejectSenders[i])) return "rejectSenders: string[] expected";
          }
          return null;
        };

        /**
         * Creates a ResponseApplySnapshotChunk message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tendermint.abci.ResponseApplySnapshotChunk
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tendermint.abci.ResponseApplySnapshotChunk} ResponseApplySnapshotChunk
         */
        ResponseApplySnapshotChunk.fromObject = function fromObject(object) {
          if (object instanceof $root.tendermint.abci.ResponseApplySnapshotChunk) return object;
          var message = new $root.tendermint.abci.ResponseApplySnapshotChunk();
          switch (object.result) {
            case "UNKNOWN":
            case 0:
              message.result = 0;
              break;
            case "ACCEPT":
            case 1:
              message.result = 1;
              break;
            case "ABORT":
            case 2:
              message.result = 2;
              break;
            case "RETRY":
            case 3:
              message.result = 3;
              break;
            case "RETRY_SNAPSHOT":
            case 4:
              message.result = 4;
              break;
            case "REJECT_SNAPSHOT":
            case 5:
              message.result = 5;
              break;
          }
          if (object.refetchChunks) {
            if (!Array.isArray(object.refetchChunks))
              throw TypeError(".tendermint.abci.ResponseApplySnapshotChunk.refetchChunks: array expected");
            message.refetchChunks = [];
            for (var i = 0; i < object.refetchChunks.length; ++i)
              message.refetchChunks[i] = object.refetchChunks[i] >>> 0;
          }
          if (object.rejectSenders) {
            if (!Array.isArray(object.rejectSenders))
              throw TypeError(".tendermint.abci.ResponseApplySnapshotChunk.rejectSenders: array expected");
            message.rejectSenders = [];
            for (var i = 0; i < object.rejectSenders.length; ++i)
              message.rejectSenders[i] = String(object.rejectSenders[i]);
          }
          return message;
        };

        /**
         * Creates a plain object from a ResponseApplySnapshotChunk message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tendermint.abci.ResponseApplySnapshotChunk
         * @static
         * @param {tendermint.abci.ResponseApplySnapshotChunk} message ResponseApplySnapshotChunk
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ResponseApplySnapshotChunk.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.arrays || options.defaults) {
            object.refetchChunks = [];
            object.rejectSenders = [];
          }
          if (options.defaults) object.result = options.enums === String ? "UNKNOWN" : 0;
          if (message.result != null && message.hasOwnProperty("result"))
            object.result =
              options.enums === String
                ? $root.tendermint.abci.ResponseApplySnapshotChunk.Result[message.result]
                : message.result;
          if (message.refetchChunks && message.refetchChunks.length) {
            object.refetchChunks = [];
            for (var j = 0; j < message.refetchChunks.length; ++j)
              object.refetchChunks[j] = message.refetchChunks[j];
          }
          if (message.rejectSenders && message.rejectSenders.length) {
            object.rejectSenders = [];
            for (var j = 0; j < message.rejectSenders.length; ++j)
              object.rejectSenders[j] = message.rejectSenders[j];
          }
          return object;
        };

        /**
         * Converts this ResponseApplySnapshotChunk to JSON.
         * @function toJSON
         * @memberof tendermint.abci.ResponseApplySnapshotChunk
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ResponseApplySnapshotChunk.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Result enum.
         * @name tendermint.abci.ResponseApplySnapshotChunk.Result
         * @enum {number}
         * @property {number} UNKNOWN=0 UNKNOWN value
         * @property {number} ACCEPT=1 ACCEPT value
         * @property {number} ABORT=2 ABORT value
         * @property {number} RETRY=3 RETRY value
         * @property {number} RETRY_SNAPSHOT=4 RETRY_SNAPSHOT value
         * @property {number} REJECT_SNAPSHOT=5 REJECT_SNAPSHOT value
         */
        ResponseApplySnapshotChunk.Result = (function () {
          var valuesById = {},
            values = Object.create(valuesById);
          values[(valuesById[0] = "UNKNOWN")] = 0;
          values[(valuesById[1] = "ACCEPT")] = 1;
          values[(valuesById[2] = "ABORT")] = 2;
          values[(valuesById[3] = "RETRY")] = 3;
          values[(valuesById[4] = "RETRY_SNAPSHOT")] = 4;
          values[(valuesById[5] = "REJECT_SNAPSHOT")] = 5;
          return values;
        })();

        return ResponseApplySnapshotChunk;
      })();

      abci.ConsensusParams = (function () {
        /**
         * Properties of a ConsensusParams.
         * @memberof tendermint.abci
         * @interface IConsensusParams
         * @property {tendermint.abci.IBlockParams|null} [block] ConsensusParams block
         * @property {tendermint.types.IEvidenceParams|null} [evidence] ConsensusParams evidence
         * @property {tendermint.types.IValidatorParams|null} [validator] ConsensusParams validator
         * @property {tendermint.types.IVersionParams|null} [version] ConsensusParams version
         */

        /**
         * Constructs a new ConsensusParams.
         * @memberof tendermint.abci
         * @classdesc Represents a ConsensusParams.
         * @implements IConsensusParams
         * @constructor
         * @param {tendermint.abci.IConsensusParams=} [properties] Properties to set
         */
        function ConsensusParams(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * ConsensusParams block.
         * @member {tendermint.abci.IBlockParams|null|undefined} block
         * @memberof tendermint.abci.ConsensusParams
         * @instance
         */
        ConsensusParams.prototype.block = null;

        /**
         * ConsensusParams evidence.
         * @member {tendermint.types.IEvidenceParams|null|undefined} evidence
         * @memberof tendermint.abci.ConsensusParams
         * @instance
         */
        ConsensusParams.prototype.evidence = null;

        /**
         * ConsensusParams validator.
         * @member {tendermint.types.IValidatorParams|null|undefined} validator
         * @memberof tendermint.abci.ConsensusParams
         * @instance
         */
        ConsensusParams.prototype.validator = null;

        /**
         * ConsensusParams version.
         * @member {tendermint.types.IVersionParams|null|undefined} version
         * @memberof tendermint.abci.ConsensusParams
         * @instance
         */
        ConsensusParams.prototype.version = null;

        /**
         * Creates a new ConsensusParams instance using the specified properties.
         * @function create
         * @memberof tendermint.abci.ConsensusParams
         * @static
         * @param {tendermint.abci.IConsensusParams=} [properties] Properties to set
         * @returns {tendermint.abci.ConsensusParams} ConsensusParams instance
         */
        ConsensusParams.create = function create(properties) {
          return new ConsensusParams(properties);
        };

        /**
         * Encodes the specified ConsensusParams message. Does not implicitly {@link tendermint.abci.ConsensusParams.verify|verify} messages.
         * @function encode
         * @memberof tendermint.abci.ConsensusParams
         * @static
         * @param {tendermint.abci.IConsensusParams} message ConsensusParams message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ConsensusParams.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.block != null && Object.hasOwnProperty.call(message, "block"))
            $root.tendermint.abci.BlockParams.encode(
              message.block,
              writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
            ).ldelim();
          if (message.evidence != null && Object.hasOwnProperty.call(message, "evidence"))
            $root.tendermint.types.EvidenceParams.encode(
              message.evidence,
              writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
            ).ldelim();
          if (message.validator != null && Object.hasOwnProperty.call(message, "validator"))
            $root.tendermint.types.ValidatorParams.encode(
              message.validator,
              writer.uint32(/* id 3, wireType 2 =*/ 26).fork(),
            ).ldelim();
          if (message.version != null && Object.hasOwnProperty.call(message, "version"))
            $root.tendermint.types.VersionParams.encode(
              message.version,
              writer.uint32(/* id 4, wireType 2 =*/ 34).fork(),
            ).ldelim();
          return writer;
        };

        /**
         * Encodes the specified ConsensusParams message, length delimited. Does not implicitly {@link tendermint.abci.ConsensusParams.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tendermint.abci.ConsensusParams
         * @static
         * @param {tendermint.abci.IConsensusParams} message ConsensusParams message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ConsensusParams.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ConsensusParams message from the specified reader or buffer.
         * @function decode
         * @memberof tendermint.abci.ConsensusParams
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tendermint.abci.ConsensusParams} ConsensusParams
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ConsensusParams.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.tendermint.abci.ConsensusParams();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.block = $root.tendermint.abci.BlockParams.decode(reader, reader.uint32());
                break;
              case 2:
                message.evidence = $root.tendermint.types.EvidenceParams.decode(reader, reader.uint32());
                break;
              case 3:
                message.validator = $root.tendermint.types.ValidatorParams.decode(reader, reader.uint32());
                break;
              case 4:
                message.version = $root.tendermint.types.VersionParams.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a ConsensusParams message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tendermint.abci.ConsensusParams
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tendermint.abci.ConsensusParams} ConsensusParams
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ConsensusParams.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ConsensusParams message.
         * @function verify
         * @memberof tendermint.abci.ConsensusParams
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ConsensusParams.verify = function verify(message) {
          if (typeof message !== "object" || message === null) return "object expected";
          if (message.block != null && message.hasOwnProperty("block")) {
            var error = $root.tendermint.abci.BlockParams.verify(message.block);
            if (error) return "block." + error;
          }
          if (message.evidence != null && message.hasOwnProperty("evidence")) {
            var error = $root.tendermint.types.EvidenceParams.verify(message.evidence);
            if (error) return "evidence." + error;
          }
          if (message.validator != null && message.hasOwnProperty("validator")) {
            var error = $root.tendermint.types.ValidatorParams.verify(message.validator);
            if (error) return "validator." + error;
          }
          if (message.version != null && message.hasOwnProperty("version")) {
            var error = $root.tendermint.types.VersionParams.verify(message.version);
            if (error) return "version." + error;
          }
          return null;
        };

        /**
         * Creates a ConsensusParams message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tendermint.abci.ConsensusParams
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tendermint.abci.ConsensusParams} ConsensusParams
         */
        ConsensusParams.fromObject = function fromObject(object) {
          if (object instanceof $root.tendermint.abci.ConsensusParams) return object;
          var message = new $root.tendermint.abci.ConsensusParams();
          if (object.block != null) {
            if (typeof object.block !== "object")
              throw TypeError(".tendermint.abci.ConsensusParams.block: object expected");
            message.block = $root.tendermint.abci.BlockParams.fromObject(object.block);
          }
          if (object.evidence != null) {
            if (typeof object.evidence !== "object")
              throw TypeError(".tendermint.abci.ConsensusParams.evidence: object expected");
            message.evidence = $root.tendermint.types.EvidenceParams.fromObject(object.evidence);
          }
          if (object.validator != null) {
            if (typeof object.validator !== "object")
              throw TypeError(".tendermint.abci.ConsensusParams.validator: object expected");
            message.validator = $root.tendermint.types.ValidatorParams.fromObject(object.validator);
          }
          if (object.version != null) {
            if (typeof object.version !== "object")
              throw TypeError(".tendermint.abci.ConsensusParams.version: object expected");
            message.version = $root.tendermint.types.VersionParams.fromObject(object.version);
          }
          return message;
        };

        /**
         * Creates a plain object from a ConsensusParams message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tendermint.abci.ConsensusParams
         * @static
         * @param {tendermint.abci.ConsensusParams} message ConsensusParams
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ConsensusParams.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.block = null;
            object.evidence = null;
            object.validator = null;
            object.version = null;
          }
          if (message.block != null && message.hasOwnProperty("block"))
            object.block = $root.tendermint.abci.BlockParams.toObject(message.block, options);
          if (message.evidence != null && message.hasOwnProperty("evidence"))
            object.evidence = $root.tendermint.types.EvidenceParams.toObject(message.evidence, options);
          if (message.validator != null && message.hasOwnProperty("validator"))
            object.validator = $root.tendermint.types.ValidatorParams.toObject(message.validator, options);
          if (message.version != null && message.hasOwnProperty("version"))
            object.version = $root.tendermint.types.VersionParams.toObject(message.version, options);
          return object;
        };

        /**
         * Converts this ConsensusParams to JSON.
         * @function toJSON
         * @memberof tendermint.abci.ConsensusParams
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ConsensusParams.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ConsensusParams;
      })();

      abci.BlockParams = (function () {
        /**
         * Properties of a BlockParams.
         * @memberof tendermint.abci
         * @interface IBlockParams
         * @property {number|Long|null} [maxBytes] BlockParams maxBytes
         * @property {number|Long|null} [maxGas] BlockParams maxGas
         */

        /**
         * Constructs a new BlockParams.
         * @memberof tendermint.abci
         * @classdesc Represents a BlockParams.
         * @implements IBlockParams
         * @constructor
         * @param {tendermint.abci.IBlockParams=} [properties] Properties to set
         */
        function BlockParams(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * BlockParams maxBytes.
         * @member {number|Long} maxBytes
         * @memberof tendermint.abci.BlockParams
         * @instance
         */
        BlockParams.prototype.maxBytes = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * BlockParams maxGas.
         * @member {number|Long} maxGas
         * @memberof tendermint.abci.BlockParams
         * @instance
         */
        BlockParams.prototype.maxGas = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * Creates a new BlockParams instance using the specified properties.
         * @function create
         * @memberof tendermint.abci.BlockParams
         * @static
         * @param {tendermint.abci.IBlockParams=} [properties] Properties to set
         * @returns {tendermint.abci.BlockParams} BlockParams instance
         */
        BlockParams.create = function create(properties) {
          return new BlockParams(properties);
        };

        /**
         * Encodes the specified BlockParams message. Does not implicitly {@link tendermint.abci.BlockParams.verify|verify} messages.
         * @function encode
         * @memberof tendermint.abci.BlockParams
         * @static
         * @param {tendermint.abci.IBlockParams} message BlockParams message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BlockParams.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.maxBytes != null && Object.hasOwnProperty.call(message, "maxBytes"))
            writer.uint32(/* id 1, wireType 0 =*/ 8).int64(message.maxBytes);
          if (message.maxGas != null && Object.hasOwnProperty.call(message, "maxGas"))
            writer.uint32(/* id 2, wireType 0 =*/ 16).int64(message.maxGas);
          return writer;
        };

        /**
         * Encodes the specified BlockParams message, length delimited. Does not implicitly {@link tendermint.abci.BlockParams.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tendermint.abci.BlockParams
         * @static
         * @param {tendermint.abci.IBlockParams} message BlockParams message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BlockParams.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BlockParams message from the specified reader or buffer.
         * @function decode
         * @memberof tendermint.abci.BlockParams
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tendermint.abci.BlockParams} BlockParams
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BlockParams.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.tendermint.abci.BlockParams();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.maxBytes = reader.int64();
                break;
              case 2:
                message.maxGas = reader.int64();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a BlockParams message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tendermint.abci.BlockParams
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tendermint.abci.BlockParams} BlockParams
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BlockParams.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BlockParams message.
         * @function verify
         * @memberof tendermint.abci.BlockParams
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BlockParams.verify = function verify(message) {
          if (typeof message !== "object" || message === null) return "object expected";
          if (message.maxBytes != null && message.hasOwnProperty("maxBytes"))
            if (
              !$util.isInteger(message.maxBytes) &&
              !(
                message.maxBytes &&
                $util.isInteger(message.maxBytes.low) &&
                $util.isInteger(message.maxBytes.high)
              )
            )
              return "maxBytes: integer|Long expected";
          if (message.maxGas != null && message.hasOwnProperty("maxGas"))
            if (
              !$util.isInteger(message.maxGas) &&
              !(message.maxGas && $util.isInteger(message.maxGas.low) && $util.isInteger(message.maxGas.high))
            )
              return "maxGas: integer|Long expected";
          return null;
        };

        /**
         * Creates a BlockParams message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tendermint.abci.BlockParams
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tendermint.abci.BlockParams} BlockParams
         */
        BlockParams.fromObject = function fromObject(object) {
          if (object instanceof $root.tendermint.abci.BlockParams) return object;
          var message = new $root.tendermint.abci.BlockParams();
          if (object.maxBytes != null)
            if ($util.Long) (message.maxBytes = $util.Long.fromValue(object.maxBytes)).unsigned = false;
            else if (typeof object.maxBytes === "string") message.maxBytes = parseInt(object.maxBytes, 10);
            else if (typeof object.maxBytes === "number") message.maxBytes = object.maxBytes;
            else if (typeof object.maxBytes === "object")
              message.maxBytes = new $util.LongBits(
                object.maxBytes.low >>> 0,
                object.maxBytes.high >>> 0,
              ).toNumber();
          if (object.maxGas != null)
            if ($util.Long) (message.maxGas = $util.Long.fromValue(object.maxGas)).unsigned = false;
            else if (typeof object.maxGas === "string") message.maxGas = parseInt(object.maxGas, 10);
            else if (typeof object.maxGas === "number") message.maxGas = object.maxGas;
            else if (typeof object.maxGas === "object")
              message.maxGas = new $util.LongBits(
                object.maxGas.low >>> 0,
                object.maxGas.high >>> 0,
              ).toNumber();
          return message;
        };

        /**
         * Creates a plain object from a BlockParams message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tendermint.abci.BlockParams
         * @static
         * @param {tendermint.abci.BlockParams} message BlockParams
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BlockParams.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            if ($util.Long) {
              var long = new $util.Long(0, 0, false);
              object.maxBytes =
                options.longs === String
                  ? long.toString()
                  : options.longs === Number
                  ? long.toNumber()
                  : long;
            } else object.maxBytes = options.longs === String ? "0" : 0;
            if ($util.Long) {
              var long = new $util.Long(0, 0, false);
              object.maxGas =
                options.longs === String
                  ? long.toString()
                  : options.longs === Number
                  ? long.toNumber()
                  : long;
            } else object.maxGas = options.longs === String ? "0" : 0;
          }
          if (message.maxBytes != null && message.hasOwnProperty("maxBytes"))
            if (typeof message.maxBytes === "number")
              object.maxBytes = options.longs === String ? String(message.maxBytes) : message.maxBytes;
            else
              object.maxBytes =
                options.longs === String
                  ? $util.Long.prototype.toString.call(message.maxBytes)
                  : options.longs === Number
                  ? new $util.LongBits(message.maxBytes.low >>> 0, message.maxBytes.high >>> 0).toNumber()
                  : message.maxBytes;
          if (message.maxGas != null && message.hasOwnProperty("maxGas"))
            if (typeof message.maxGas === "number")
              object.maxGas = options.longs === String ? String(message.maxGas) : message.maxGas;
            else
              object.maxGas =
                options.longs === String
                  ? $util.Long.prototype.toString.call(message.maxGas)
                  : options.longs === Number
                  ? new $util.LongBits(message.maxGas.low >>> 0, message.maxGas.high >>> 0).toNumber()
                  : message.maxGas;
          return object;
        };

        /**
         * Converts this BlockParams to JSON.
         * @function toJSON
         * @memberof tendermint.abci.BlockParams
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BlockParams.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BlockParams;
      })();

      abci.LastCommitInfo = (function () {
        /**
         * Properties of a LastCommitInfo.
         * @memberof tendermint.abci
         * @interface ILastCommitInfo
         * @property {number|null} [round] LastCommitInfo round
         * @property {Array.<tendermint.abci.IVoteInfo>|null} [votes] LastCommitInfo votes
         */

        /**
         * Constructs a new LastCommitInfo.
         * @memberof tendermint.abci
         * @classdesc Represents a LastCommitInfo.
         * @implements ILastCommitInfo
         * @constructor
         * @param {tendermint.abci.ILastCommitInfo=} [properties] Properties to set
         */
        function LastCommitInfo(properties) {
          this.votes = [];
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * LastCommitInfo round.
         * @member {number} round
         * @memberof tendermint.abci.LastCommitInfo
         * @instance
         */
        LastCommitInfo.prototype.round = 0;

        /**
         * LastCommitInfo votes.
         * @member {Array.<tendermint.abci.IVoteInfo>} votes
         * @memberof tendermint.abci.LastCommitInfo
         * @instance
         */
        LastCommitInfo.prototype.votes = $util.emptyArray;

        /**
         * Creates a new LastCommitInfo instance using the specified properties.
         * @function create
         * @memberof tendermint.abci.LastCommitInfo
         * @static
         * @param {tendermint.abci.ILastCommitInfo=} [properties] Properties to set
         * @returns {tendermint.abci.LastCommitInfo} LastCommitInfo instance
         */
        LastCommitInfo.create = function create(properties) {
          return new LastCommitInfo(properties);
        };

        /**
         * Encodes the specified LastCommitInfo message. Does not implicitly {@link tendermint.abci.LastCommitInfo.verify|verify} messages.
         * @function encode
         * @memberof tendermint.abci.LastCommitInfo
         * @static
         * @param {tendermint.abci.ILastCommitInfo} message LastCommitInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LastCommitInfo.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.round != null && Object.hasOwnProperty.call(message, "round"))
            writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.round);
          if (message.votes != null && message.votes.length)
            for (var i = 0; i < message.votes.length; ++i)
              $root.tendermint.abci.VoteInfo.encode(
                message.votes[i],
                writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
              ).ldelim();
          return writer;
        };

        /**
         * Encodes the specified LastCommitInfo message, length delimited. Does not implicitly {@link tendermint.abci.LastCommitInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tendermint.abci.LastCommitInfo
         * @static
         * @param {tendermint.abci.ILastCommitInfo} message LastCommitInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LastCommitInfo.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LastCommitInfo message from the specified reader or buffer.
         * @function decode
         * @memberof tendermint.abci.LastCommitInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tendermint.abci.LastCommitInfo} LastCommitInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LastCommitInfo.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.tendermint.abci.LastCommitInfo();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.round = reader.int32();
                break;
              case 2:
                if (!(message.votes && message.votes.length)) message.votes = [];
                message.votes.push($root.tendermint.abci.VoteInfo.decode(reader, reader.uint32()));
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a LastCommitInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tendermint.abci.LastCommitInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tendermint.abci.LastCommitInfo} LastCommitInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LastCommitInfo.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LastCommitInfo message.
         * @function verify
         * @memberof tendermint.abci.LastCommitInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LastCommitInfo.verify = function verify(message) {
          if (typeof message !== "object" || message === null) return "object expected";
          if (message.round != null && message.hasOwnProperty("round"))
            if (!$util.isInteger(message.round)) return "round: integer expected";
          if (message.votes != null && message.hasOwnProperty("votes")) {
            if (!Array.isArray(message.votes)) return "votes: array expected";
            for (var i = 0; i < message.votes.length; ++i) {
              var error = $root.tendermint.abci.VoteInfo.verify(message.votes[i]);
              if (error) return "votes." + error;
            }
          }
          return null;
        };

        /**
         * Creates a LastCommitInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tendermint.abci.LastCommitInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tendermint.abci.LastCommitInfo} LastCommitInfo
         */
        LastCommitInfo.fromObject = function fromObject(object) {
          if (object instanceof $root.tendermint.abci.LastCommitInfo) return object;
          var message = new $root.tendermint.abci.LastCommitInfo();
          if (object.round != null) message.round = object.round | 0;
          if (object.votes) {
            if (!Array.isArray(object.votes))
              throw TypeError(".tendermint.abci.LastCommitInfo.votes: array expected");
            message.votes = [];
            for (var i = 0; i < object.votes.length; ++i) {
              if (typeof object.votes[i] !== "object")
                throw TypeError(".tendermint.abci.LastCommitInfo.votes: object expected");
              message.votes[i] = $root.tendermint.abci.VoteInfo.fromObject(object.votes[i]);
            }
          }
          return message;
        };

        /**
         * Creates a plain object from a LastCommitInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tendermint.abci.LastCommitInfo
         * @static
         * @param {tendermint.abci.LastCommitInfo} message LastCommitInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        LastCommitInfo.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.arrays || options.defaults) object.votes = [];
          if (options.defaults) object.round = 0;
          if (message.round != null && message.hasOwnProperty("round")) object.round = message.round;
          if (message.votes && message.votes.length) {
            object.votes = [];
            for (var j = 0; j < message.votes.length; ++j)
              object.votes[j] = $root.tendermint.abci.VoteInfo.toObject(message.votes[j], options);
          }
          return object;
        };

        /**
         * Converts this LastCommitInfo to JSON.
         * @function toJSON
         * @memberof tendermint.abci.LastCommitInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        LastCommitInfo.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return LastCommitInfo;
      })();

      abci.Event = (function () {
        /**
         * Properties of an Event.
         * @memberof tendermint.abci
         * @interface IEvent
         * @property {string|null} [type] Event type
         * @property {Array.<tendermint.abci.IEventAttribute>|null} [attributes] Event attributes
         */

        /**
         * Constructs a new Event.
         * @memberof tendermint.abci
         * @classdesc Represents an Event.
         * @implements IEvent
         * @constructor
         * @param {tendermint.abci.IEvent=} [properties] Properties to set
         */
        function Event(properties) {
          this.attributes = [];
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * Event type.
         * @member {string} type
         * @memberof tendermint.abci.Event
         * @instance
         */
        Event.prototype.type = "";

        /**
         * Event attributes.
         * @member {Array.<tendermint.abci.IEventAttribute>} attributes
         * @memberof tendermint.abci.Event
         * @instance
         */
        Event.prototype.attributes = $util.emptyArray;

        /**
         * Creates a new Event instance using the specified properties.
         * @function create
         * @memberof tendermint.abci.Event
         * @static
         * @param {tendermint.abci.IEvent=} [properties] Properties to set
         * @returns {tendermint.abci.Event} Event instance
         */
        Event.create = function create(properties) {
          return new Event(properties);
        };

        /**
         * Encodes the specified Event message. Does not implicitly {@link tendermint.abci.Event.verify|verify} messages.
         * @function encode
         * @memberof tendermint.abci.Event
         * @static
         * @param {tendermint.abci.IEvent} message Event message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Event.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.type != null && Object.hasOwnProperty.call(message, "type"))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.type);
          if (message.attributes != null && message.attributes.length)
            for (var i = 0; i < message.attributes.length; ++i)
              $root.tendermint.abci.EventAttribute.encode(
                message.attributes[i],
                writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
              ).ldelim();
          return writer;
        };

        /**
         * Encodes the specified Event message, length delimited. Does not implicitly {@link tendermint.abci.Event.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tendermint.abci.Event
         * @static
         * @param {tendermint.abci.IEvent} message Event message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Event.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Event message from the specified reader or buffer.
         * @function decode
         * @memberof tendermint.abci.Event
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tendermint.abci.Event} Event
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Event.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.tendermint.abci.Event();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.type = reader.string();
                break;
              case 2:
                if (!(message.attributes && message.attributes.length)) message.attributes = [];
                message.attributes.push($root.tendermint.abci.EventAttribute.decode(reader, reader.uint32()));
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes an Event message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tendermint.abci.Event
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tendermint.abci.Event} Event
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Event.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Event message.
         * @function verify
         * @memberof tendermint.abci.Event
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Event.verify = function verify(message) {
          if (typeof message !== "object" || message === null) return "object expected";
          if (message.type != null && message.hasOwnProperty("type"))
            if (!$util.isString(message.type)) return "type: string expected";
          if (message.attributes != null && message.hasOwnProperty("attributes")) {
            if (!Array.isArray(message.attributes)) return "attributes: array expected";
            for (var i = 0; i < message.attributes.length; ++i) {
              var error = $root.tendermint.abci.EventAttribute.verify(message.attributes[i]);
              if (error) return "attributes." + error;
            }
          }
          return null;
        };

        /**
         * Creates an Event message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tendermint.abci.Event
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tendermint.abci.Event} Event
         */
        Event.fromObject = function fromObject(object) {
          if (object instanceof $root.tendermint.abci.Event) return object;
          var message = new $root.tendermint.abci.Event();
          if (object.type != null) message.type = String(object.type);
          if (object.attributes) {
            if (!Array.isArray(object.attributes))
              throw TypeError(".tendermint.abci.Event.attributes: array expected");
            message.attributes = [];
            for (var i = 0; i < object.attributes.length; ++i) {
              if (typeof object.attributes[i] !== "object")
                throw TypeError(".tendermint.abci.Event.attributes: object expected");
              message.attributes[i] = $root.tendermint.abci.EventAttribute.fromObject(object.attributes[i]);
            }
          }
          return message;
        };

        /**
         * Creates a plain object from an Event message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tendermint.abci.Event
         * @static
         * @param {tendermint.abci.Event} message Event
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Event.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.arrays || options.defaults) object.attributes = [];
          if (options.defaults) object.type = "";
          if (message.type != null && message.hasOwnProperty("type")) object.type = message.type;
          if (message.attributes && message.attributes.length) {
            object.attributes = [];
            for (var j = 0; j < message.attributes.length; ++j)
              object.attributes[j] = $root.tendermint.abci.EventAttribute.toObject(
                message.attributes[j],
                options,
              );
          }
          return object;
        };

        /**
         * Converts this Event to JSON.
         * @function toJSON
         * @memberof tendermint.abci.Event
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Event.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Event;
      })();

      abci.EventAttribute = (function () {
        /**
         * Properties of an EventAttribute.
         * @memberof tendermint.abci
         * @interface IEventAttribute
         * @property {Uint8Array|null} [key] EventAttribute key
         * @property {Uint8Array|null} [value] EventAttribute value
         * @property {boolean|null} [index] EventAttribute index
         */

        /**
         * Constructs a new EventAttribute.
         * @memberof tendermint.abci
         * @classdesc Represents an EventAttribute.
         * @implements IEventAttribute
         * @constructor
         * @param {tendermint.abci.IEventAttribute=} [properties] Properties to set
         */
        function EventAttribute(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * EventAttribute key.
         * @member {Uint8Array} key
         * @memberof tendermint.abci.EventAttribute
         * @instance
         */
        EventAttribute.prototype.key = $util.newBuffer([]);

        /**
         * EventAttribute value.
         * @member {Uint8Array} value
         * @memberof tendermint.abci.EventAttribute
         * @instance
         */
        EventAttribute.prototype.value = $util.newBuffer([]);

        /**
         * EventAttribute index.
         * @member {boolean} index
         * @memberof tendermint.abci.EventAttribute
         * @instance
         */
        EventAttribute.prototype.index = false;

        /**
         * Creates a new EventAttribute instance using the specified properties.
         * @function create
         * @memberof tendermint.abci.EventAttribute
         * @static
         * @param {tendermint.abci.IEventAttribute=} [properties] Properties to set
         * @returns {tendermint.abci.EventAttribute} EventAttribute instance
         */
        EventAttribute.create = function create(properties) {
          return new EventAttribute(properties);
        };

        /**
         * Encodes the specified EventAttribute message. Does not implicitly {@link tendermint.abci.EventAttribute.verify|verify} messages.
         * @function encode
         * @memberof tendermint.abci.EventAttribute
         * @static
         * @param {tendermint.abci.IEventAttribute} message EventAttribute message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EventAttribute.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.key != null && Object.hasOwnProperty.call(message, "key"))
            writer.uint32(/* id 1, wireType 2 =*/ 10).bytes(message.key);
          if (message.value != null && Object.hasOwnProperty.call(message, "value"))
            writer.uint32(/* id 2, wireType 2 =*/ 18).bytes(message.value);
          if (message.index != null && Object.hasOwnProperty.call(message, "index"))
            writer.uint32(/* id 3, wireType 0 =*/ 24).bool(message.index);
          return writer;
        };

        /**
         * Encodes the specified EventAttribute message, length delimited. Does not implicitly {@link tendermint.abci.EventAttribute.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tendermint.abci.EventAttribute
         * @static
         * @param {tendermint.abci.IEventAttribute} message EventAttribute message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EventAttribute.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EventAttribute message from the specified reader or buffer.
         * @function decode
         * @memberof tendermint.abci.EventAttribute
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tendermint.abci.EventAttribute} EventAttribute
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EventAttribute.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.tendermint.abci.EventAttribute();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.key = reader.bytes();
                break;
              case 2:
                message.value = reader.bytes();
                break;
              case 3:
                message.index = reader.bool();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes an EventAttribute message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tendermint.abci.EventAttribute
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tendermint.abci.EventAttribute} EventAttribute
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EventAttribute.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EventAttribute message.
         * @function verify
         * @memberof tendermint.abci.EventAttribute
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EventAttribute.verify = function verify(message) {
          if (typeof message !== "object" || message === null) return "object expected";
          if (message.key != null && message.hasOwnProperty("key"))
            if (!((message.key && typeof message.key.length === "number") || $util.isString(message.key)))
              return "key: buffer expected";
          if (message.value != null && message.hasOwnProperty("value"))
            if (
              !((message.value && typeof message.value.length === "number") || $util.isString(message.value))
            )
              return "value: buffer expected";
          if (message.index != null && message.hasOwnProperty("index"))
            if (typeof message.index !== "boolean") return "index: boolean expected";
          return null;
        };

        /**
         * Creates an EventAttribute message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tendermint.abci.EventAttribute
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tendermint.abci.EventAttribute} EventAttribute
         */
        EventAttribute.fromObject = function fromObject(object) {
          if (object instanceof $root.tendermint.abci.EventAttribute) return object;
          var message = new $root.tendermint.abci.EventAttribute();
          if (object.key != null)
            if (typeof object.key === "string")
              $util.base64.decode(
                object.key,
                (message.key = $util.newBuffer($util.base64.length(object.key))),
                0,
              );
            else if (object.key.length) message.key = object.key;
          if (object.value != null)
            if (typeof object.value === "string")
              $util.base64.decode(
                object.value,
                (message.value = $util.newBuffer($util.base64.length(object.value))),
                0,
              );
            else if (object.value.length) message.value = object.value;
          if (object.index != null) message.index = Boolean(object.index);
          return message;
        };

        /**
         * Creates a plain object from an EventAttribute message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tendermint.abci.EventAttribute
         * @static
         * @param {tendermint.abci.EventAttribute} message EventAttribute
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EventAttribute.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            if (options.bytes === String) object.key = "";
            else {
              object.key = [];
              if (options.bytes !== Array) object.key = $util.newBuffer(object.key);
            }
            if (options.bytes === String) object.value = "";
            else {
              object.value = [];
              if (options.bytes !== Array) object.value = $util.newBuffer(object.value);
            }
            object.index = false;
          }
          if (message.key != null && message.hasOwnProperty("key"))
            object.key =
              options.bytes === String
                ? $util.base64.encode(message.key, 0, message.key.length)
                : options.bytes === Array
                ? Array.prototype.slice.call(message.key)
                : message.key;
          if (message.value != null && message.hasOwnProperty("value"))
            object.value =
              options.bytes === String
                ? $util.base64.encode(message.value, 0, message.value.length)
                : options.bytes === Array
                ? Array.prototype.slice.call(message.value)
                : message.value;
          if (message.index != null && message.hasOwnProperty("index")) object.index = message.index;
          return object;
        };

        /**
         * Converts this EventAttribute to JSON.
         * @function toJSON
         * @memberof tendermint.abci.EventAttribute
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EventAttribute.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return EventAttribute;
      })();

      abci.TxResult = (function () {
        /**
         * Properties of a TxResult.
         * @memberof tendermint.abci
         * @interface ITxResult
         * @property {number|Long|null} [height] TxResult height
         * @property {number|null} [index] TxResult index
         * @property {Uint8Array|null} [tx] TxResult tx
         * @property {tendermint.abci.IResponseDeliverTx|null} [result] TxResult result
         */

        /**
         * Constructs a new TxResult.
         * @memberof tendermint.abci
         * @classdesc Represents a TxResult.
         * @implements ITxResult
         * @constructor
         * @param {tendermint.abci.ITxResult=} [properties] Properties to set
         */
        function TxResult(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * TxResult height.
         * @member {number|Long} height
         * @memberof tendermint.abci.TxResult
         * @instance
         */
        TxResult.prototype.height = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * TxResult index.
         * @member {number} index
         * @memberof tendermint.abci.TxResult
         * @instance
         */
        TxResult.prototype.index = 0;

        /**
         * TxResult tx.
         * @member {Uint8Array} tx
         * @memberof tendermint.abci.TxResult
         * @instance
         */
        TxResult.prototype.tx = $util.newBuffer([]);

        /**
         * TxResult result.
         * @member {tendermint.abci.IResponseDeliverTx|null|undefined} result
         * @memberof tendermint.abci.TxResult
         * @instance
         */
        TxResult.prototype.result = null;

        /**
         * Creates a new TxResult instance using the specified properties.
         * @function create
         * @memberof tendermint.abci.TxResult
         * @static
         * @param {tendermint.abci.ITxResult=} [properties] Properties to set
         * @returns {tendermint.abci.TxResult} TxResult instance
         */
        TxResult.create = function create(properties) {
          return new TxResult(properties);
        };

        /**
         * Encodes the specified TxResult message. Does not implicitly {@link tendermint.abci.TxResult.verify|verify} messages.
         * @function encode
         * @memberof tendermint.abci.TxResult
         * @static
         * @param {tendermint.abci.ITxResult} message TxResult message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TxResult.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.height != null && Object.hasOwnProperty.call(message, "height"))
            writer.uint32(/* id 1, wireType 0 =*/ 8).int64(message.height);
          if (message.index != null && Object.hasOwnProperty.call(message, "index"))
            writer.uint32(/* id 2, wireType 0 =*/ 16).uint32(message.index);
          if (message.tx != null && Object.hasOwnProperty.call(message, "tx"))
            writer.uint32(/* id 3, wireType 2 =*/ 26).bytes(message.tx);
          if (message.result != null && Object.hasOwnProperty.call(message, "result"))
            $root.tendermint.abci.ResponseDeliverTx.encode(
              message.result,
              writer.uint32(/* id 4, wireType 2 =*/ 34).fork(),
            ).ldelim();
          return writer;
        };

        /**
         * Encodes the specified TxResult message, length delimited. Does not implicitly {@link tendermint.abci.TxResult.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tendermint.abci.TxResult
         * @static
         * @param {tendermint.abci.ITxResult} message TxResult message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TxResult.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TxResult message from the specified reader or buffer.
         * @function decode
         * @memberof tendermint.abci.TxResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tendermint.abci.TxResult} TxResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TxResult.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.tendermint.abci.TxResult();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.height = reader.int64();
                break;
              case 2:
                message.index = reader.uint32();
                break;
              case 3:
                message.tx = reader.bytes();
                break;
              case 4:
                message.result = $root.tendermint.abci.ResponseDeliverTx.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a TxResult message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tendermint.abci.TxResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tendermint.abci.TxResult} TxResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TxResult.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TxResult message.
         * @function verify
         * @memberof tendermint.abci.TxResult
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TxResult.verify = function verify(message) {
          if (typeof message !== "object" || message === null) return "object expected";
          if (message.height != null && message.hasOwnProperty("height"))
            if (
              !$util.isInteger(message.height) &&
              !(message.height && $util.isInteger(message.height.low) && $util.isInteger(message.height.high))
            )
              return "height: integer|Long expected";
          if (message.index != null && message.hasOwnProperty("index"))
            if (!$util.isInteger(message.index)) return "index: integer expected";
          if (message.tx != null && message.hasOwnProperty("tx"))
            if (!((message.tx && typeof message.tx.length === "number") || $util.isString(message.tx)))
              return "tx: buffer expected";
          if (message.result != null && message.hasOwnProperty("result")) {
            var error = $root.tendermint.abci.ResponseDeliverTx.verify(message.result);
            if (error) return "result." + error;
          }
          return null;
        };

        /**
         * Creates a TxResult message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tendermint.abci.TxResult
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tendermint.abci.TxResult} TxResult
         */
        TxResult.fromObject = function fromObject(object) {
          if (object instanceof $root.tendermint.abci.TxResult) return object;
          var message = new $root.tendermint.abci.TxResult();
          if (object.height != null)
            if ($util.Long) (message.height = $util.Long.fromValue(object.height)).unsigned = false;
            else if (typeof object.height === "string") message.height = parseInt(object.height, 10);
            else if (typeof object.height === "number") message.height = object.height;
            else if (typeof object.height === "object")
              message.height = new $util.LongBits(
                object.height.low >>> 0,
                object.height.high >>> 0,
              ).toNumber();
          if (object.index != null) message.index = object.index >>> 0;
          if (object.tx != null)
            if (typeof object.tx === "string")
              $util.base64.decode(
                object.tx,
                (message.tx = $util.newBuffer($util.base64.length(object.tx))),
                0,
              );
            else if (object.tx.length) message.tx = object.tx;
          if (object.result != null) {
            if (typeof object.result !== "object")
              throw TypeError(".tendermint.abci.TxResult.result: object expected");
            message.result = $root.tendermint.abci.ResponseDeliverTx.fromObject(object.result);
          }
          return message;
        };

        /**
         * Creates a plain object from a TxResult message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tendermint.abci.TxResult
         * @static
         * @param {tendermint.abci.TxResult} message TxResult
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TxResult.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            if ($util.Long) {
              var long = new $util.Long(0, 0, false);
              object.height =
                options.longs === String
                  ? long.toString()
                  : options.longs === Number
                  ? long.toNumber()
                  : long;
            } else object.height = options.longs === String ? "0" : 0;
            object.index = 0;
            if (options.bytes === String) object.tx = "";
            else {
              object.tx = [];
              if (options.bytes !== Array) object.tx = $util.newBuffer(object.tx);
            }
            object.result = null;
          }
          if (message.height != null && message.hasOwnProperty("height"))
            if (typeof message.height === "number")
              object.height = options.longs === String ? String(message.height) : message.height;
            else
              object.height =
                options.longs === String
                  ? $util.Long.prototype.toString.call(message.height)
                  : options.longs === Number
                  ? new $util.LongBits(message.height.low >>> 0, message.height.high >>> 0).toNumber()
                  : message.height;
          if (message.index != null && message.hasOwnProperty("index")) object.index = message.index;
          if (message.tx != null && message.hasOwnProperty("tx"))
            object.tx =
              options.bytes === String
                ? $util.base64.encode(message.tx, 0, message.tx.length)
                : options.bytes === Array
                ? Array.prototype.slice.call(message.tx)
                : message.tx;
          if (message.result != null && message.hasOwnProperty("result"))
            object.result = $root.tendermint.abci.ResponseDeliverTx.toObject(message.result, options);
          return object;
        };

        /**
         * Converts this TxResult to JSON.
         * @function toJSON
         * @memberof tendermint.abci.TxResult
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TxResult.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TxResult;
      })();

      abci.Validator = (function () {
        /**
         * Properties of a Validator.
         * @memberof tendermint.abci
         * @interface IValidator
         * @property {Uint8Array|null} [address] Validator address
         * @property {number|Long|null} [power] Validator power
         */

        /**
         * Constructs a new Validator.
         * @memberof tendermint.abci
         * @classdesc Represents a Validator.
         * @implements IValidator
         * @constructor
         * @param {tendermint.abci.IValidator=} [properties] Properties to set
         */
        function Validator(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * Validator address.
         * @member {Uint8Array} address
         * @memberof tendermint.abci.Validator
         * @instance
         */
        Validator.prototype.address = $util.newBuffer([]);

        /**
         * Validator power.
         * @member {number|Long} power
         * @memberof tendermint.abci.Validator
         * @instance
         */
        Validator.prototype.power = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * Creates a new Validator instance using the specified properties.
         * @function create
         * @memberof tendermint.abci.Validator
         * @static
         * @param {tendermint.abci.IValidator=} [properties] Properties to set
         * @returns {tendermint.abci.Validator} Validator instance
         */
        Validator.create = function create(properties) {
          return new Validator(properties);
        };

        /**
         * Encodes the specified Validator message. Does not implicitly {@link tendermint.abci.Validator.verify|verify} messages.
         * @function encode
         * @memberof tendermint.abci.Validator
         * @static
         * @param {tendermint.abci.IValidator} message Validator message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Validator.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.address != null && Object.hasOwnProperty.call(message, "address"))
            writer.uint32(/* id 1, wireType 2 =*/ 10).bytes(message.address);
          if (message.power != null && Object.hasOwnProperty.call(message, "power"))
            writer.uint32(/* id 3, wireType 0 =*/ 24).int64(message.power);
          return writer;
        };

        /**
         * Encodes the specified Validator message, length delimited. Does not implicitly {@link tendermint.abci.Validator.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tendermint.abci.Validator
         * @static
         * @param {tendermint.abci.IValidator} message Validator message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Validator.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Validator message from the specified reader or buffer.
         * @function decode
         * @memberof tendermint.abci.Validator
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tendermint.abci.Validator} Validator
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Validator.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.tendermint.abci.Validator();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.address = reader.bytes();
                break;
              case 3:
                message.power = reader.int64();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a Validator message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tendermint.abci.Validator
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tendermint.abci.Validator} Validator
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Validator.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Validator message.
         * @function verify
         * @memberof tendermint.abci.Validator
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Validator.verify = function verify(message) {
          if (typeof message !== "object" || message === null) return "object expected";
          if (message.address != null && message.hasOwnProperty("address"))
            if (
              !(
                (message.address && typeof message.address.length === "number") ||
                $util.isString(message.address)
              )
            )
              return "address: buffer expected";
          if (message.power != null && message.hasOwnProperty("power"))
            if (
              !$util.isInteger(message.power) &&
              !(message.power && $util.isInteger(message.power.low) && $util.isInteger(message.power.high))
            )
              return "power: integer|Long expected";
          return null;
        };

        /**
         * Creates a Validator message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tendermint.abci.Validator
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tendermint.abci.Validator} Validator
         */
        Validator.fromObject = function fromObject(object) {
          if (object instanceof $root.tendermint.abci.Validator) return object;
          var message = new $root.tendermint.abci.Validator();
          if (object.address != null)
            if (typeof object.address === "string")
              $util.base64.decode(
                object.address,
                (message.address = $util.newBuffer($util.base64.length(object.address))),
                0,
              );
            else if (object.address.length) message.address = object.address;
          if (object.power != null)
            if ($util.Long) (message.power = $util.Long.fromValue(object.power)).unsigned = false;
            else if (typeof object.power === "string") message.power = parseInt(object.power, 10);
            else if (typeof object.power === "number") message.power = object.power;
            else if (typeof object.power === "object")
              message.power = new $util.LongBits(object.power.low >>> 0, object.power.high >>> 0).toNumber();
          return message;
        };

        /**
         * Creates a plain object from a Validator message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tendermint.abci.Validator
         * @static
         * @param {tendermint.abci.Validator} message Validator
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Validator.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            if (options.bytes === String) object.address = "";
            else {
              object.address = [];
              if (options.bytes !== Array) object.address = $util.newBuffer(object.address);
            }
            if ($util.Long) {
              var long = new $util.Long(0, 0, false);
              object.power =
                options.longs === String
                  ? long.toString()
                  : options.longs === Number
                  ? long.toNumber()
                  : long;
            } else object.power = options.longs === String ? "0" : 0;
          }
          if (message.address != null && message.hasOwnProperty("address"))
            object.address =
              options.bytes === String
                ? $util.base64.encode(message.address, 0, message.address.length)
                : options.bytes === Array
                ? Array.prototype.slice.call(message.address)
                : message.address;
          if (message.power != null && message.hasOwnProperty("power"))
            if (typeof message.power === "number")
              object.power = options.longs === String ? String(message.power) : message.power;
            else
              object.power =
                options.longs === String
                  ? $util.Long.prototype.toString.call(message.power)
                  : options.longs === Number
                  ? new $util.LongBits(message.power.low >>> 0, message.power.high >>> 0).toNumber()
                  : message.power;
          return object;
        };

        /**
         * Converts this Validator to JSON.
         * @function toJSON
         * @memberof tendermint.abci.Validator
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Validator.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Validator;
      })();

      abci.ValidatorUpdate = (function () {
        /**
         * Properties of a ValidatorUpdate.
         * @memberof tendermint.abci
         * @interface IValidatorUpdate
         * @property {tendermint.crypto.IPublicKey|null} [pubKey] ValidatorUpdate pubKey
         * @property {number|Long|null} [power] ValidatorUpdate power
         */

        /**
         * Constructs a new ValidatorUpdate.
         * @memberof tendermint.abci
         * @classdesc Represents a ValidatorUpdate.
         * @implements IValidatorUpdate
         * @constructor
         * @param {tendermint.abci.IValidatorUpdate=} [properties] Properties to set
         */
        function ValidatorUpdate(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * ValidatorUpdate pubKey.
         * @member {tendermint.crypto.IPublicKey|null|undefined} pubKey
         * @memberof tendermint.abci.ValidatorUpdate
         * @instance
         */
        ValidatorUpdate.prototype.pubKey = null;

        /**
         * ValidatorUpdate power.
         * @member {number|Long} power
         * @memberof tendermint.abci.ValidatorUpdate
         * @instance
         */
        ValidatorUpdate.prototype.power = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * Creates a new ValidatorUpdate instance using the specified properties.
         * @function create
         * @memberof tendermint.abci.ValidatorUpdate
         * @static
         * @param {tendermint.abci.IValidatorUpdate=} [properties] Properties to set
         * @returns {tendermint.abci.ValidatorUpdate} ValidatorUpdate instance
         */
        ValidatorUpdate.create = function create(properties) {
          return new ValidatorUpdate(properties);
        };

        /**
         * Encodes the specified ValidatorUpdate message. Does not implicitly {@link tendermint.abci.ValidatorUpdate.verify|verify} messages.
         * @function encode
         * @memberof tendermint.abci.ValidatorUpdate
         * @static
         * @param {tendermint.abci.IValidatorUpdate} message ValidatorUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ValidatorUpdate.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.pubKey != null && Object.hasOwnProperty.call(message, "pubKey"))
            $root.tendermint.crypto.PublicKey.encode(
              message.pubKey,
              writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
            ).ldelim();
          if (message.power != null && Object.hasOwnProperty.call(message, "power"))
            writer.uint32(/* id 2, wireType 0 =*/ 16).int64(message.power);
          return writer;
        };

        /**
         * Encodes the specified ValidatorUpdate message, length delimited. Does not implicitly {@link tendermint.abci.ValidatorUpdate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tendermint.abci.ValidatorUpdate
         * @static
         * @param {tendermint.abci.IValidatorUpdate} message ValidatorUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ValidatorUpdate.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ValidatorUpdate message from the specified reader or buffer.
         * @function decode
         * @memberof tendermint.abci.ValidatorUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tendermint.abci.ValidatorUpdate} ValidatorUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ValidatorUpdate.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.tendermint.abci.ValidatorUpdate();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.pubKey = $root.tendermint.crypto.PublicKey.decode(reader, reader.uint32());
                break;
              case 2:
                message.power = reader.int64();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a ValidatorUpdate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tendermint.abci.ValidatorUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tendermint.abci.ValidatorUpdate} ValidatorUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ValidatorUpdate.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ValidatorUpdate message.
         * @function verify
         * @memberof tendermint.abci.ValidatorUpdate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ValidatorUpdate.verify = function verify(message) {
          if (typeof message !== "object" || message === null) return "object expected";
          if (message.pubKey != null && message.hasOwnProperty("pubKey")) {
            var error = $root.tendermint.crypto.PublicKey.verify(message.pubKey);
            if (error) return "pubKey." + error;
          }
          if (message.power != null && message.hasOwnProperty("power"))
            if (
              !$util.isInteger(message.power) &&
              !(message.power && $util.isInteger(message.power.low) && $util.isInteger(message.power.high))
            )
              return "power: integer|Long expected";
          return null;
        };

        /**
         * Creates a ValidatorUpdate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tendermint.abci.ValidatorUpdate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tendermint.abci.ValidatorUpdate} ValidatorUpdate
         */
        ValidatorUpdate.fromObject = function fromObject(object) {
          if (object instanceof $root.tendermint.abci.ValidatorUpdate) return object;
          var message = new $root.tendermint.abci.ValidatorUpdate();
          if (object.pubKey != null) {
            if (typeof object.pubKey !== "object")
              throw TypeError(".tendermint.abci.ValidatorUpdate.pubKey: object expected");
            message.pubKey = $root.tendermint.crypto.PublicKey.fromObject(object.pubKey);
          }
          if (object.power != null)
            if ($util.Long) (message.power = $util.Long.fromValue(object.power)).unsigned = false;
            else if (typeof object.power === "string") message.power = parseInt(object.power, 10);
            else if (typeof object.power === "number") message.power = object.power;
            else if (typeof object.power === "object")
              message.power = new $util.LongBits(object.power.low >>> 0, object.power.high >>> 0).toNumber();
          return message;
        };

        /**
         * Creates a plain object from a ValidatorUpdate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tendermint.abci.ValidatorUpdate
         * @static
         * @param {tendermint.abci.ValidatorUpdate} message ValidatorUpdate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ValidatorUpdate.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.pubKey = null;
            if ($util.Long) {
              var long = new $util.Long(0, 0, false);
              object.power =
                options.longs === String
                  ? long.toString()
                  : options.longs === Number
                  ? long.toNumber()
                  : long;
            } else object.power = options.longs === String ? "0" : 0;
          }
          if (message.pubKey != null && message.hasOwnProperty("pubKey"))
            object.pubKey = $root.tendermint.crypto.PublicKey.toObject(message.pubKey, options);
          if (message.power != null && message.hasOwnProperty("power"))
            if (typeof message.power === "number")
              object.power = options.longs === String ? String(message.power) : message.power;
            else
              object.power =
                options.longs === String
                  ? $util.Long.prototype.toString.call(message.power)
                  : options.longs === Number
                  ? new $util.LongBits(message.power.low >>> 0, message.power.high >>> 0).toNumber()
                  : message.power;
          return object;
        };

        /**
         * Converts this ValidatorUpdate to JSON.
         * @function toJSON
         * @memberof tendermint.abci.ValidatorUpdate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ValidatorUpdate.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ValidatorUpdate;
      })();

      abci.VoteInfo = (function () {
        /**
         * Properties of a VoteInfo.
         * @memberof tendermint.abci
         * @interface IVoteInfo
         * @property {tendermint.abci.IValidator|null} [validator] VoteInfo validator
         * @property {boolean|null} [signedLastBlock] VoteInfo signedLastBlock
         */

        /**
         * Constructs a new VoteInfo.
         * @memberof tendermint.abci
         * @classdesc Represents a VoteInfo.
         * @implements IVoteInfo
         * @constructor
         * @param {tendermint.abci.IVoteInfo=} [properties] Properties to set
         */
        function VoteInfo(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * VoteInfo validator.
         * @member {tendermint.abci.IValidator|null|undefined} validator
         * @memberof tendermint.abci.VoteInfo
         * @instance
         */
        VoteInfo.prototype.validator = null;

        /**
         * VoteInfo signedLastBlock.
         * @member {boolean} signedLastBlock
         * @memberof tendermint.abci.VoteInfo
         * @instance
         */
        VoteInfo.prototype.signedLastBlock = false;

        /**
         * Creates a new VoteInfo instance using the specified properties.
         * @function create
         * @memberof tendermint.abci.VoteInfo
         * @static
         * @param {tendermint.abci.IVoteInfo=} [properties] Properties to set
         * @returns {tendermint.abci.VoteInfo} VoteInfo instance
         */
        VoteInfo.create = function create(properties) {
          return new VoteInfo(properties);
        };

        /**
         * Encodes the specified VoteInfo message. Does not implicitly {@link tendermint.abci.VoteInfo.verify|verify} messages.
         * @function encode
         * @memberof tendermint.abci.VoteInfo
         * @static
         * @param {tendermint.abci.IVoteInfo} message VoteInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VoteInfo.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.validator != null && Object.hasOwnProperty.call(message, "validator"))
            $root.tendermint.abci.Validator.encode(
              message.validator,
              writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
            ).ldelim();
          if (message.signedLastBlock != null && Object.hasOwnProperty.call(message, "signedLastBlock"))
            writer.uint32(/* id 2, wireType 0 =*/ 16).bool(message.signedLastBlock);
          return writer;
        };

        /**
         * Encodes the specified VoteInfo message, length delimited. Does not implicitly {@link tendermint.abci.VoteInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tendermint.abci.VoteInfo
         * @static
         * @param {tendermint.abci.IVoteInfo} message VoteInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VoteInfo.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a VoteInfo message from the specified reader or buffer.
         * @function decode
         * @memberof tendermint.abci.VoteInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tendermint.abci.VoteInfo} VoteInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VoteInfo.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.tendermint.abci.VoteInfo();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.validator = $root.tendermint.abci.Validator.decode(reader, reader.uint32());
                break;
              case 2:
                message.signedLastBlock = reader.bool();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a VoteInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tendermint.abci.VoteInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tendermint.abci.VoteInfo} VoteInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VoteInfo.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a VoteInfo message.
         * @function verify
         * @memberof tendermint.abci.VoteInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        VoteInfo.verify = function verify(message) {
          if (typeof message !== "object" || message === null) return "object expected";
          if (message.validator != null && message.hasOwnProperty("validator")) {
            var error = $root.tendermint.abci.Validator.verify(message.validator);
            if (error) return "validator." + error;
          }
          if (message.signedLastBlock != null && message.hasOwnProperty("signedLastBlock"))
            if (typeof message.signedLastBlock !== "boolean") return "signedLastBlock: boolean expected";
          return null;
        };

        /**
         * Creates a VoteInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tendermint.abci.VoteInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tendermint.abci.VoteInfo} VoteInfo
         */
        VoteInfo.fromObject = function fromObject(object) {
          if (object instanceof $root.tendermint.abci.VoteInfo) return object;
          var message = new $root.tendermint.abci.VoteInfo();
          if (object.validator != null) {
            if (typeof object.validator !== "object")
              throw TypeError(".tendermint.abci.VoteInfo.validator: object expected");
            message.validator = $root.tendermint.abci.Validator.fromObject(object.validator);
          }
          if (object.signedLastBlock != null) message.signedLastBlock = Boolean(object.signedLastBlock);
          return message;
        };

        /**
         * Creates a plain object from a VoteInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tendermint.abci.VoteInfo
         * @static
         * @param {tendermint.abci.VoteInfo} message VoteInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        VoteInfo.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.validator = null;
            object.signedLastBlock = false;
          }
          if (message.validator != null && message.hasOwnProperty("validator"))
            object.validator = $root.tendermint.abci.Validator.toObject(message.validator, options);
          if (message.signedLastBlock != null && message.hasOwnProperty("signedLastBlock"))
            object.signedLastBlock = message.signedLastBlock;
          return object;
        };

        /**
         * Converts this VoteInfo to JSON.
         * @function toJSON
         * @memberof tendermint.abci.VoteInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        VoteInfo.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return VoteInfo;
      })();

      /**
       * EvidenceType enum.
       * @name tendermint.abci.EvidenceType
       * @enum {number}
       * @property {number} UNKNOWN=0 UNKNOWN value
       * @property {number} DUPLICATE_VOTE=1 DUPLICATE_VOTE value
       * @property {number} LIGHT_CLIENT_ATTACK=2 LIGHT_CLIENT_ATTACK value
       */
      abci.EvidenceType = (function () {
        var valuesById = {},
          values = Object.create(valuesById);
        values[(valuesById[0] = "UNKNOWN")] = 0;
        values[(valuesById[1] = "DUPLICATE_VOTE")] = 1;
        values[(valuesById[2] = "LIGHT_CLIENT_ATTACK")] = 2;
        return values;
      })();

      abci.Evidence = (function () {
        /**
         * Properties of an Evidence.
         * @memberof tendermint.abci
         * @interface IEvidence
         * @property {tendermint.abci.EvidenceType|null} [type] Evidence type
         * @property {tendermint.abci.IValidator|null} [validator] Evidence validator
         * @property {number|Long|null} [height] Evidence height
         * @property {google.protobuf.ITimestamp|null} [time] Evidence time
         * @property {number|Long|null} [totalVotingPower] Evidence totalVotingPower
         */

        /**
         * Constructs a new Evidence.
         * @memberof tendermint.abci
         * @classdesc Represents an Evidence.
         * @implements IEvidence
         * @constructor
         * @param {tendermint.abci.IEvidence=} [properties] Properties to set
         */
        function Evidence(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * Evidence type.
         * @member {tendermint.abci.EvidenceType} type
         * @memberof tendermint.abci.Evidence
         * @instance
         */
        Evidence.prototype.type = 0;

        /**
         * Evidence validator.
         * @member {tendermint.abci.IValidator|null|undefined} validator
         * @memberof tendermint.abci.Evidence
         * @instance
         */
        Evidence.prototype.validator = null;

        /**
         * Evidence height.
         * @member {number|Long} height
         * @memberof tendermint.abci.Evidence
         * @instance
         */
        Evidence.prototype.height = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * Evidence time.
         * @member {google.protobuf.ITimestamp|null|undefined} time
         * @memberof tendermint.abci.Evidence
         * @instance
         */
        Evidence.prototype.time = null;

        /**
         * Evidence totalVotingPower.
         * @member {number|Long} totalVotingPower
         * @memberof tendermint.abci.Evidence
         * @instance
         */
        Evidence.prototype.totalVotingPower = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * Creates a new Evidence instance using the specified properties.
         * @function create
         * @memberof tendermint.abci.Evidence
         * @static
         * @param {tendermint.abci.IEvidence=} [properties] Properties to set
         * @returns {tendermint.abci.Evidence} Evidence instance
         */
        Evidence.create = function create(properties) {
          return new Evidence(properties);
        };

        /**
         * Encodes the specified Evidence message. Does not implicitly {@link tendermint.abci.Evidence.verify|verify} messages.
         * @function encode
         * @memberof tendermint.abci.Evidence
         * @static
         * @param {tendermint.abci.IEvidence} message Evidence message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Evidence.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.type != null && Object.hasOwnProperty.call(message, "type"))
            writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.type);
          if (message.validator != null && Object.hasOwnProperty.call(message, "validator"))
            $root.tendermint.abci.Validator.encode(
              message.validator,
              writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
            ).ldelim();
          if (message.height != null && Object.hasOwnProperty.call(message, "height"))
            writer.uint32(/* id 3, wireType 0 =*/ 24).int64(message.height);
          if (message.time != null && Object.hasOwnProperty.call(message, "time"))
            $root.google.protobuf.Timestamp.encode(
              message.time,
              writer.uint32(/* id 4, wireType 2 =*/ 34).fork(),
            ).ldelim();
          if (message.totalVotingPower != null && Object.hasOwnProperty.call(message, "totalVotingPower"))
            writer.uint32(/* id 5, wireType 0 =*/ 40).int64(message.totalVotingPower);
          return writer;
        };

        /**
         * Encodes the specified Evidence message, length delimited. Does not implicitly {@link tendermint.abci.Evidence.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tendermint.abci.Evidence
         * @static
         * @param {tendermint.abci.IEvidence} message Evidence message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Evidence.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Evidence message from the specified reader or buffer.
         * @function decode
         * @memberof tendermint.abci.Evidence
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tendermint.abci.Evidence} Evidence
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Evidence.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.tendermint.abci.Evidence();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.type = reader.int32();
                break;
              case 2:
                message.validator = $root.tendermint.abci.Validator.decode(reader, reader.uint32());
                break;
              case 3:
                message.height = reader.int64();
                break;
              case 4:
                message.time = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                break;
              case 5:
                message.totalVotingPower = reader.int64();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes an Evidence message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tendermint.abci.Evidence
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tendermint.abci.Evidence} Evidence
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Evidence.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Evidence message.
         * @function verify
         * @memberof tendermint.abci.Evidence
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Evidence.verify = function verify(message) {
          if (typeof message !== "object" || message === null) return "object expected";
          if (message.type != null && message.hasOwnProperty("type"))
            switch (message.type) {
              default:
                return "type: enum value expected";
              case 0:
              case 1:
              case 2:
                break;
            }
          if (message.validator != null && message.hasOwnProperty("validator")) {
            var error = $root.tendermint.abci.Validator.verify(message.validator);
            if (error) return "validator." + error;
          }
          if (message.height != null && message.hasOwnProperty("height"))
            if (
              !$util.isInteger(message.height) &&
              !(message.height && $util.isInteger(message.height.low) && $util.isInteger(message.height.high))
            )
              return "height: integer|Long expected";
          if (message.time != null && message.hasOwnProperty("time")) {
            var error = $root.google.protobuf.Timestamp.verify(message.time);
            if (error) return "time." + error;
          }
          if (message.totalVotingPower != null && message.hasOwnProperty("totalVotingPower"))
            if (
              !$util.isInteger(message.totalVotingPower) &&
              !(
                message.totalVotingPower &&
                $util.isInteger(message.totalVotingPower.low) &&
                $util.isInteger(message.totalVotingPower.high)
              )
            )
              return "totalVotingPower: integer|Long expected";
          return null;
        };

        /**
         * Creates an Evidence message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tendermint.abci.Evidence
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tendermint.abci.Evidence} Evidence
         */
        Evidence.fromObject = function fromObject(object) {
          if (object instanceof $root.tendermint.abci.Evidence) return object;
          var message = new $root.tendermint.abci.Evidence();
          switch (object.type) {
            case "UNKNOWN":
            case 0:
              message.type = 0;
              break;
            case "DUPLICATE_VOTE":
            case 1:
              message.type = 1;
              break;
            case "LIGHT_CLIENT_ATTACK":
            case 2:
              message.type = 2;
              break;
          }
          if (object.validator != null) {
            if (typeof object.validator !== "object")
              throw TypeError(".tendermint.abci.Evidence.validator: object expected");
            message.validator = $root.tendermint.abci.Validator.fromObject(object.validator);
          }
          if (object.height != null)
            if ($util.Long) (message.height = $util.Long.fromValue(object.height)).unsigned = false;
            else if (typeof object.height === "string") message.height = parseInt(object.height, 10);
            else if (typeof object.height === "number") message.height = object.height;
            else if (typeof object.height === "object")
              message.height = new $util.LongBits(
                object.height.low >>> 0,
                object.height.high >>> 0,
              ).toNumber();
          if (object.time != null) {
            if (typeof object.time !== "object")
              throw TypeError(".tendermint.abci.Evidence.time: object expected");
            message.time = $root.google.protobuf.Timestamp.fromObject(object.time);
          }
          if (object.totalVotingPower != null)
            if ($util.Long)
              (message.totalVotingPower = $util.Long.fromValue(object.totalVotingPower)).unsigned = false;
            else if (typeof object.totalVotingPower === "string")
              message.totalVotingPower = parseInt(object.totalVotingPower, 10);
            else if (typeof object.totalVotingPower === "number")
              message.totalVotingPower = object.totalVotingPower;
            else if (typeof object.totalVotingPower === "object")
              message.totalVotingPower = new $util.LongBits(
                object.totalVotingPower.low >>> 0,
                object.totalVotingPower.high >>> 0,
              ).toNumber();
          return message;
        };

        /**
         * Creates a plain object from an Evidence message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tendermint.abci.Evidence
         * @static
         * @param {tendermint.abci.Evidence} message Evidence
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Evidence.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.type = options.enums === String ? "UNKNOWN" : 0;
            object.validator = null;
            if ($util.Long) {
              var long = new $util.Long(0, 0, false);
              object.height =
                options.longs === String
                  ? long.toString()
                  : options.longs === Number
                  ? long.toNumber()
                  : long;
            } else object.height = options.longs === String ? "0" : 0;
            object.time = null;
            if ($util.Long) {
              var long = new $util.Long(0, 0, false);
              object.totalVotingPower =
                options.longs === String
                  ? long.toString()
                  : options.longs === Number
                  ? long.toNumber()
                  : long;
            } else object.totalVotingPower = options.longs === String ? "0" : 0;
          }
          if (message.type != null && message.hasOwnProperty("type"))
            object.type =
              options.enums === String ? $root.tendermint.abci.EvidenceType[message.type] : message.type;
          if (message.validator != null && message.hasOwnProperty("validator"))
            object.validator = $root.tendermint.abci.Validator.toObject(message.validator, options);
          if (message.height != null && message.hasOwnProperty("height"))
            if (typeof message.height === "number")
              object.height = options.longs === String ? String(message.height) : message.height;
            else
              object.height =
                options.longs === String
                  ? $util.Long.prototype.toString.call(message.height)
                  : options.longs === Number
                  ? new $util.LongBits(message.height.low >>> 0, message.height.high >>> 0).toNumber()
                  : message.height;
          if (message.time != null && message.hasOwnProperty("time"))
            object.time = $root.google.protobuf.Timestamp.toObject(message.time, options);
          if (message.totalVotingPower != null && message.hasOwnProperty("totalVotingPower"))
            if (typeof message.totalVotingPower === "number")
              object.totalVotingPower =
                options.longs === String ? String(message.totalVotingPower) : message.totalVotingPower;
            else
              object.totalVotingPower =
                options.longs === String
                  ? $util.Long.prototype.toString.call(message.totalVotingPower)
                  : options.longs === Number
                  ? new $util.LongBits(
                      message.totalVotingPower.low >>> 0,
                      message.totalVotingPower.high >>> 0,
                    ).toNumber()
                  : message.totalVotingPower;
          return object;
        };

        /**
         * Converts this Evidence to JSON.
         * @function toJSON
         * @memberof tendermint.abci.Evidence
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Evidence.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Evidence;
      })();

      abci.Snapshot = (function () {
        /**
         * Properties of a Snapshot.
         * @memberof tendermint.abci
         * @interface ISnapshot
         * @property {number|Long|null} [height] Snapshot height
         * @property {number|null} [format] Snapshot format
         * @property {number|null} [chunks] Snapshot chunks
         * @property {Uint8Array|null} [hash] Snapshot hash
         * @property {Uint8Array|null} [metadata] Snapshot metadata
         */

        /**
         * Constructs a new Snapshot.
         * @memberof tendermint.abci
         * @classdesc Represents a Snapshot.
         * @implements ISnapshot
         * @constructor
         * @param {tendermint.abci.ISnapshot=} [properties] Properties to set
         */
        function Snapshot(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * Snapshot height.
         * @member {number|Long} height
         * @memberof tendermint.abci.Snapshot
         * @instance
         */
        Snapshot.prototype.height = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

        /**
         * Snapshot format.
         * @member {number} format
         * @memberof tendermint.abci.Snapshot
         * @instance
         */
        Snapshot.prototype.format = 0;

        /**
         * Snapshot chunks.
         * @member {number} chunks
         * @memberof tendermint.abci.Snapshot
         * @instance
         */
        Snapshot.prototype.chunks = 0;

        /**
         * Snapshot hash.
         * @member {Uint8Array} hash
         * @memberof tendermint.abci.Snapshot
         * @instance
         */
        Snapshot.prototype.hash = $util.newBuffer([]);

        /**
         * Snapshot metadata.
         * @member {Uint8Array} metadata
         * @memberof tendermint.abci.Snapshot
         * @instance
         */
        Snapshot.prototype.metadata = $util.newBuffer([]);

        /**
         * Creates a new Snapshot instance using the specified properties.
         * @function create
         * @memberof tendermint.abci.Snapshot
         * @static
         * @param {tendermint.abci.ISnapshot=} [properties] Properties to set
         * @returns {tendermint.abci.Snapshot} Snapshot instance
         */
        Snapshot.create = function create(properties) {
          return new Snapshot(properties);
        };

        /**
         * Encodes the specified Snapshot message. Does not implicitly {@link tendermint.abci.Snapshot.verify|verify} messages.
         * @function encode
         * @memberof tendermint.abci.Snapshot
         * @static
         * @param {tendermint.abci.ISnapshot} message Snapshot message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Snapshot.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.height != null && Object.hasOwnProperty.call(message, "height"))
            writer.uint32(/* id 1, wireType 0 =*/ 8).uint64(message.height);
          if (message.format != null && Object.hasOwnProperty.call(message, "format"))
            writer.uint32(/* id 2, wireType 0 =*/ 16).uint32(message.format);
          if (message.chunks != null && Object.hasOwnProperty.call(message, "chunks"))
            writer.uint32(/* id 3, wireType 0 =*/ 24).uint32(message.chunks);
          if (message.hash != null && Object.hasOwnProperty.call(message, "hash"))
            writer.uint32(/* id 4, wireType 2 =*/ 34).bytes(message.hash);
          if (message.metadata != null && Object.hasOwnProperty.call(message, "metadata"))
            writer.uint32(/* id 5, wireType 2 =*/ 42).bytes(message.metadata);
          return writer;
        };

        /**
         * Encodes the specified Snapshot message, length delimited. Does not implicitly {@link tendermint.abci.Snapshot.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tendermint.abci.Snapshot
         * @static
         * @param {tendermint.abci.ISnapshot} message Snapshot message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Snapshot.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Snapshot message from the specified reader or buffer.
         * @function decode
         * @memberof tendermint.abci.Snapshot
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tendermint.abci.Snapshot} Snapshot
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Snapshot.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.tendermint.abci.Snapshot();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.height = reader.uint64();
                break;
              case 2:
                message.format = reader.uint32();
                break;
              case 3:
                message.chunks = reader.uint32();
                break;
              case 4:
                message.hash = reader.bytes();
                break;
              case 5:
                message.metadata = reader.bytes();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a Snapshot message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tendermint.abci.Snapshot
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tendermint.abci.Snapshot} Snapshot
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Snapshot.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Snapshot message.
         * @function verify
         * @memberof tendermint.abci.Snapshot
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Snapshot.verify = function verify(message) {
          if (typeof message !== "object" || message === null) return "object expected";
          if (message.height != null && message.hasOwnProperty("height"))
            if (
              !$util.isInteger(message.height) &&
              !(message.height && $util.isInteger(message.height.low) && $util.isInteger(message.height.high))
            )
              return "height: integer|Long expected";
          if (message.format != null && message.hasOwnProperty("format"))
            if (!$util.isInteger(message.format)) return "format: integer expected";
          if (message.chunks != null && message.hasOwnProperty("chunks"))
            if (!$util.isInteger(message.chunks)) return "chunks: integer expected";
          if (message.hash != null && message.hasOwnProperty("hash"))
            if (!((message.hash && typeof message.hash.length === "number") || $util.isString(message.hash)))
              return "hash: buffer expected";
          if (message.metadata != null && message.hasOwnProperty("metadata"))
            if (
              !(
                (message.metadata && typeof message.metadata.length === "number") ||
                $util.isString(message.metadata)
              )
            )
              return "metadata: buffer expected";
          return null;
        };

        /**
         * Creates a Snapshot message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tendermint.abci.Snapshot
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tendermint.abci.Snapshot} Snapshot
         */
        Snapshot.fromObject = function fromObject(object) {
          if (object instanceof $root.tendermint.abci.Snapshot) return object;
          var message = new $root.tendermint.abci.Snapshot();
          if (object.height != null)
            if ($util.Long) (message.height = $util.Long.fromValue(object.height)).unsigned = true;
            else if (typeof object.height === "string") message.height = parseInt(object.height, 10);
            else if (typeof object.height === "number") message.height = object.height;
            else if (typeof object.height === "object")
              message.height = new $util.LongBits(object.height.low >>> 0, object.height.high >>> 0).toNumber(
                true,
              );
          if (object.format != null) message.format = object.format >>> 0;
          if (object.chunks != null) message.chunks = object.chunks >>> 0;
          if (object.hash != null)
            if (typeof object.hash === "string")
              $util.base64.decode(
                object.hash,
                (message.hash = $util.newBuffer($util.base64.length(object.hash))),
                0,
              );
            else if (object.hash.length) message.hash = object.hash;
          if (object.metadata != null)
            if (typeof object.metadata === "string")
              $util.base64.decode(
                object.metadata,
                (message.metadata = $util.newBuffer($util.base64.length(object.metadata))),
                0,
              );
            else if (object.metadata.length) message.metadata = object.metadata;
          return message;
        };

        /**
         * Creates a plain object from a Snapshot message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tendermint.abci.Snapshot
         * @static
         * @param {tendermint.abci.Snapshot} message Snapshot
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Snapshot.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            if ($util.Long) {
              var long = new $util.Long(0, 0, true);
              object.height =
                options.longs === String
                  ? long.toString()
                  : options.longs === Number
                  ? long.toNumber()
                  : long;
            } else object.height = options.longs === String ? "0" : 0;
            object.format = 0;
            object.chunks = 0;
            if (options.bytes === String) object.hash = "";
            else {
              object.hash = [];
              if (options.bytes !== Array) object.hash = $util.newBuffer(object.hash);
            }
            if (options.bytes === String) object.metadata = "";
            else {
              object.metadata = [];
              if (options.bytes !== Array) object.metadata = $util.newBuffer(object.metadata);
            }
          }
          if (message.height != null && message.hasOwnProperty("height"))
            if (typeof message.height === "number")
              object.height = options.longs === String ? String(message.height) : message.height;
            else
              object.height =
                options.longs === String
                  ? $util.Long.prototype.toString.call(message.height)
                  : options.longs === Number
                  ? new $util.LongBits(message.height.low >>> 0, message.height.high >>> 0).toNumber(true)
                  : message.height;
          if (message.format != null && message.hasOwnProperty("format")) object.format = message.format;
          if (message.chunks != null && message.hasOwnProperty("chunks")) object.chunks = message.chunks;
          if (message.hash != null && message.hasOwnProperty("hash"))
            object.hash =
              options.bytes === String
                ? $util.base64.encode(message.hash, 0, message.hash.length)
                : options.bytes === Array
                ? Array.prototype.slice.call(message.hash)
                : message.hash;
          if (message.metadata != null && message.hasOwnProperty("metadata"))
            object.metadata =
              options.bytes === String
                ? $util.base64.encode(message.metadata, 0, message.metadata.length)
                : options.bytes === Array
                ? Array.prototype.slice.call(message.metadata)
                : message.metadata;
          return object;
        };

        /**
         * Converts this Snapshot to JSON.
         * @function toJSON
         * @memberof tendermint.abci.Snapshot
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Snapshot.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Snapshot;
      })();

      abci.ABCIApplication = (function () {
        /**
         * Constructs a new ABCIApplication service.
         * @memberof tendermint.abci
         * @classdesc Represents a ABCIApplication
         * @extends $protobuf.rpc.Service
         * @constructor
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         */
        function ABCIApplication(rpcImpl, requestDelimited, responseDelimited) {
          $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
        }

        (ABCIApplication.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor =
          ABCIApplication;

        /**
         * Creates new ABCIApplication service using the specified rpc implementation.
         * @function create
         * @memberof tendermint.abci.ABCIApplication
         * @static
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         * @returns {ABCIApplication} RPC service. Useful where requests and/or responses are streamed.
         */
        ABCIApplication.create = function create(rpcImpl, requestDelimited, responseDelimited) {
          return new this(rpcImpl, requestDelimited, responseDelimited);
        };

        /**
         * Callback as used by {@link tendermint.abci.ABCIApplication#echo}.
         * @memberof tendermint.abci.ABCIApplication
         * @typedef EchoCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {tendermint.abci.ResponseEcho} [response] ResponseEcho
         */

        /**
         * Calls Echo.
         * @function echo
         * @memberof tendermint.abci.ABCIApplication
         * @instance
         * @param {tendermint.abci.IRequestEcho} request RequestEcho message or plain object
         * @param {tendermint.abci.ABCIApplication.EchoCallback} callback Node-style callback called with the error, if any, and ResponseEcho
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
          (ABCIApplication.prototype.echo = function echo(request, callback) {
            return this.rpcCall(
              echo,
              $root.tendermint.abci.RequestEcho,
              $root.tendermint.abci.ResponseEcho,
              request,
              callback,
            );
          }),
          "name",
          { value: "Echo" },
        );

        /**
         * Calls Echo.
         * @function echo
         * @memberof tendermint.abci.ABCIApplication
         * @instance
         * @param {tendermint.abci.IRequestEcho} request RequestEcho message or plain object
         * @returns {Promise<tendermint.abci.ResponseEcho>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link tendermint.abci.ABCIApplication#flush}.
         * @memberof tendermint.abci.ABCIApplication
         * @typedef FlushCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {tendermint.abci.ResponseFlush} [response] ResponseFlush
         */

        /**
         * Calls Flush.
         * @function flush
         * @memberof tendermint.abci.ABCIApplication
         * @instance
         * @param {tendermint.abci.IRequestFlush} request RequestFlush message or plain object
         * @param {tendermint.abci.ABCIApplication.FlushCallback} callback Node-style callback called with the error, if any, and ResponseFlush
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
          (ABCIApplication.prototype.flush = function flush(request, callback) {
            return this.rpcCall(
              flush,
              $root.tendermint.abci.RequestFlush,
              $root.tendermint.abci.ResponseFlush,
              request,
              callback,
            );
          }),
          "name",
          { value: "Flush" },
        );

        /**
         * Calls Flush.
         * @function flush
         * @memberof tendermint.abci.ABCIApplication
         * @instance
         * @param {tendermint.abci.IRequestFlush} request RequestFlush message or plain object
         * @returns {Promise<tendermint.abci.ResponseFlush>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link tendermint.abci.ABCIApplication#info}.
         * @memberof tendermint.abci.ABCIApplication
         * @typedef InfoCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {tendermint.abci.ResponseInfo} [response] ResponseInfo
         */

        /**
         * Calls Info.
         * @function info
         * @memberof tendermint.abci.ABCIApplication
         * @instance
         * @param {tendermint.abci.IRequestInfo} request RequestInfo message or plain object
         * @param {tendermint.abci.ABCIApplication.InfoCallback} callback Node-style callback called with the error, if any, and ResponseInfo
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
          (ABCIApplication.prototype.info = function info(request, callback) {
            return this.rpcCall(
              info,
              $root.tendermint.abci.RequestInfo,
              $root.tendermint.abci.ResponseInfo,
              request,
              callback,
            );
          }),
          "name",
          { value: "Info" },
        );

        /**
         * Calls Info.
         * @function info
         * @memberof tendermint.abci.ABCIApplication
         * @instance
         * @param {tendermint.abci.IRequestInfo} request RequestInfo message or plain object
         * @returns {Promise<tendermint.abci.ResponseInfo>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link tendermint.abci.ABCIApplication#setOption}.
         * @memberof tendermint.abci.ABCIApplication
         * @typedef SetOptionCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {tendermint.abci.ResponseSetOption} [response] ResponseSetOption
         */

        /**
         * Calls SetOption.
         * @function setOption
         * @memberof tendermint.abci.ABCIApplication
         * @instance
         * @param {tendermint.abci.IRequestSetOption} request RequestSetOption message or plain object
         * @param {tendermint.abci.ABCIApplication.SetOptionCallback} callback Node-style callback called with the error, if any, and ResponseSetOption
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
          (ABCIApplication.prototype.setOption = function setOption(request, callback) {
            return this.rpcCall(
              setOption,
              $root.tendermint.abci.RequestSetOption,
              $root.tendermint.abci.ResponseSetOption,
              request,
              callback,
            );
          }),
          "name",
          { value: "SetOption" },
        );

        /**
         * Calls SetOption.
         * @function setOption
         * @memberof tendermint.abci.ABCIApplication
         * @instance
         * @param {tendermint.abci.IRequestSetOption} request RequestSetOption message or plain object
         * @returns {Promise<tendermint.abci.ResponseSetOption>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link tendermint.abci.ABCIApplication#deliverTx}.
         * @memberof tendermint.abci.ABCIApplication
         * @typedef DeliverTxCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {tendermint.abci.ResponseDeliverTx} [response] ResponseDeliverTx
         */

        /**
         * Calls DeliverTx.
         * @function deliverTx
         * @memberof tendermint.abci.ABCIApplication
         * @instance
         * @param {tendermint.abci.IRequestDeliverTx} request RequestDeliverTx message or plain object
         * @param {tendermint.abci.ABCIApplication.DeliverTxCallback} callback Node-style callback called with the error, if any, and ResponseDeliverTx
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
          (ABCIApplication.prototype.deliverTx = function deliverTx(request, callback) {
            return this.rpcCall(
              deliverTx,
              $root.tendermint.abci.RequestDeliverTx,
              $root.tendermint.abci.ResponseDeliverTx,
              request,
              callback,
            );
          }),
          "name",
          { value: "DeliverTx" },
        );

        /**
         * Calls DeliverTx.
         * @function deliverTx
         * @memberof tendermint.abci.ABCIApplication
         * @instance
         * @param {tendermint.abci.IRequestDeliverTx} request RequestDeliverTx message or plain object
         * @returns {Promise<tendermint.abci.ResponseDeliverTx>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link tendermint.abci.ABCIApplication#checkTx}.
         * @memberof tendermint.abci.ABCIApplication
         * @typedef CheckTxCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {tendermint.abci.ResponseCheckTx} [response] ResponseCheckTx
         */

        /**
         * Calls CheckTx.
         * @function checkTx
         * @memberof tendermint.abci.ABCIApplication
         * @instance
         * @param {tendermint.abci.IRequestCheckTx} request RequestCheckTx message or plain object
         * @param {tendermint.abci.ABCIApplication.CheckTxCallback} callback Node-style callback called with the error, if any, and ResponseCheckTx
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
          (ABCIApplication.prototype.checkTx = function checkTx(request, callback) {
            return this.rpcCall(
              checkTx,
              $root.tendermint.abci.RequestCheckTx,
              $root.tendermint.abci.ResponseCheckTx,
              request,
              callback,
            );
          }),
          "name",
          { value: "CheckTx" },
        );

        /**
         * Calls CheckTx.
         * @function checkTx
         * @memberof tendermint.abci.ABCIApplication
         * @instance
         * @param {tendermint.abci.IRequestCheckTx} request RequestCheckTx message or plain object
         * @returns {Promise<tendermint.abci.ResponseCheckTx>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link tendermint.abci.ABCIApplication#query}.
         * @memberof tendermint.abci.ABCIApplication
         * @typedef QueryCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {tendermint.abci.ResponseQuery} [response] ResponseQuery
         */

        /**
         * Calls Query.
         * @function query
         * @memberof tendermint.abci.ABCIApplication
         * @instance
         * @param {tendermint.abci.IRequestQuery} request RequestQuery message or plain object
         * @param {tendermint.abci.ABCIApplication.QueryCallback} callback Node-style callback called with the error, if any, and ResponseQuery
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
          (ABCIApplication.prototype.query = function query(request, callback) {
            return this.rpcCall(
              query,
              $root.tendermint.abci.RequestQuery,
              $root.tendermint.abci.ResponseQuery,
              request,
              callback,
            );
          }),
          "name",
          { value: "Query" },
        );

        /**
         * Calls Query.
         * @function query
         * @memberof tendermint.abci.ABCIApplication
         * @instance
         * @param {tendermint.abci.IRequestQuery} request RequestQuery message or plain object
         * @returns {Promise<tendermint.abci.ResponseQuery>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link tendermint.abci.ABCIApplication#commit}.
         * @memberof tendermint.abci.ABCIApplication
         * @typedef CommitCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {tendermint.abci.ResponseCommit} [response] ResponseCommit
         */

        /**
         * Calls Commit.
         * @function commit
         * @memberof tendermint.abci.ABCIApplication
         * @instance
         * @param {tendermint.abci.IRequestCommit} request RequestCommit message or plain object
         * @param {tendermint.abci.ABCIApplication.CommitCallback} callback Node-style callback called with the error, if any, and ResponseCommit
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
          (ABCIApplication.prototype.commit = function commit(request, callback) {
            return this.rpcCall(
              commit,
              $root.tendermint.abci.RequestCommit,
              $root.tendermint.abci.ResponseCommit,
              request,
              callback,
            );
          }),
          "name",
          { value: "Commit" },
        );

        /**
         * Calls Commit.
         * @function commit
         * @memberof tendermint.abci.ABCIApplication
         * @instance
         * @param {tendermint.abci.IRequestCommit} request RequestCommit message or plain object
         * @returns {Promise<tendermint.abci.ResponseCommit>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link tendermint.abci.ABCIApplication#initChain}.
         * @memberof tendermint.abci.ABCIApplication
         * @typedef InitChainCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {tendermint.abci.ResponseInitChain} [response] ResponseInitChain
         */

        /**
         * Calls InitChain.
         * @function initChain
         * @memberof tendermint.abci.ABCIApplication
         * @instance
         * @param {tendermint.abci.IRequestInitChain} request RequestInitChain message or plain object
         * @param {tendermint.abci.ABCIApplication.InitChainCallback} callback Node-style callback called with the error, if any, and ResponseInitChain
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
          (ABCIApplication.prototype.initChain = function initChain(request, callback) {
            return this.rpcCall(
              initChain,
              $root.tendermint.abci.RequestInitChain,
              $root.tendermint.abci.ResponseInitChain,
              request,
              callback,
            );
          }),
          "name",
          { value: "InitChain" },
        );

        /**
         * Calls InitChain.
         * @function initChain
         * @memberof tendermint.abci.ABCIApplication
         * @instance
         * @param {tendermint.abci.IRequestInitChain} request RequestInitChain message or plain object
         * @returns {Promise<tendermint.abci.ResponseInitChain>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link tendermint.abci.ABCIApplication#beginBlock}.
         * @memberof tendermint.abci.ABCIApplication
         * @typedef BeginBlockCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {tendermint.abci.ResponseBeginBlock} [response] ResponseBeginBlock
         */

        /**
         * Calls BeginBlock.
         * @function beginBlock
         * @memberof tendermint.abci.ABCIApplication
         * @instance
         * @param {tendermint.abci.IRequestBeginBlock} request RequestBeginBlock message or plain object
         * @param {tendermint.abci.ABCIApplication.BeginBlockCallback} callback Node-style callback called with the error, if any, and ResponseBeginBlock
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
          (ABCIApplication.prototype.beginBlock = function beginBlock(request, callback) {
            return this.rpcCall(
              beginBlock,
              $root.tendermint.abci.RequestBeginBlock,
              $root.tendermint.abci.ResponseBeginBlock,
              request,
              callback,
            );
          }),
          "name",
          { value: "BeginBlock" },
        );

        /**
         * Calls BeginBlock.
         * @function beginBlock
         * @memberof tendermint.abci.ABCIApplication
         * @instance
         * @param {tendermint.abci.IRequestBeginBlock} request RequestBeginBlock message or plain object
         * @returns {Promise<tendermint.abci.ResponseBeginBlock>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link tendermint.abci.ABCIApplication#endBlock}.
         * @memberof tendermint.abci.ABCIApplication
         * @typedef EndBlockCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {tendermint.abci.ResponseEndBlock} [response] ResponseEndBlock
         */

        /**
         * Calls EndBlock.
         * @function endBlock
         * @memberof tendermint.abci.ABCIApplication
         * @instance
         * @param {tendermint.abci.IRequestEndBlock} request RequestEndBlock message or plain object
         * @param {tendermint.abci.ABCIApplication.EndBlockCallback} callback Node-style callback called with the error, if any, and ResponseEndBlock
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
          (ABCIApplication.prototype.endBlock = function endBlock(request, callback) {
            return this.rpcCall(
              endBlock,
              $root.tendermint.abci.RequestEndBlock,
              $root.tendermint.abci.ResponseEndBlock,
              request,
              callback,
            );
          }),
          "name",
          { value: "EndBlock" },
        );

        /**
         * Calls EndBlock.
         * @function endBlock
         * @memberof tendermint.abci.ABCIApplication
         * @instance
         * @param {tendermint.abci.IRequestEndBlock} request RequestEndBlock message or plain object
         * @returns {Promise<tendermint.abci.ResponseEndBlock>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link tendermint.abci.ABCIApplication#listSnapshots}.
         * @memberof tendermint.abci.ABCIApplication
         * @typedef ListSnapshotsCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {tendermint.abci.ResponseListSnapshots} [response] ResponseListSnapshots
         */

        /**
         * Calls ListSnapshots.
         * @function listSnapshots
         * @memberof tendermint.abci.ABCIApplication
         * @instance
         * @param {tendermint.abci.IRequestListSnapshots} request RequestListSnapshots message or plain object
         * @param {tendermint.abci.ABCIApplication.ListSnapshotsCallback} callback Node-style callback called with the error, if any, and ResponseListSnapshots
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
          (ABCIApplication.prototype.listSnapshots = function listSnapshots(request, callback) {
            return this.rpcCall(
              listSnapshots,
              $root.tendermint.abci.RequestListSnapshots,
              $root.tendermint.abci.ResponseListSnapshots,
              request,
              callback,
            );
          }),
          "name",
          { value: "ListSnapshots" },
        );

        /**
         * Calls ListSnapshots.
         * @function listSnapshots
         * @memberof tendermint.abci.ABCIApplication
         * @instance
         * @param {tendermint.abci.IRequestListSnapshots} request RequestListSnapshots message or plain object
         * @returns {Promise<tendermint.abci.ResponseListSnapshots>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link tendermint.abci.ABCIApplication#offerSnapshot}.
         * @memberof tendermint.abci.ABCIApplication
         * @typedef OfferSnapshotCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {tendermint.abci.ResponseOfferSnapshot} [response] ResponseOfferSnapshot
         */

        /**
         * Calls OfferSnapshot.
         * @function offerSnapshot
         * @memberof tendermint.abci.ABCIApplication
         * @instance
         * @param {tendermint.abci.IRequestOfferSnapshot} request RequestOfferSnapshot message or plain object
         * @param {tendermint.abci.ABCIApplication.OfferSnapshotCallback} callback Node-style callback called with the error, if any, and ResponseOfferSnapshot
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
          (ABCIApplication.prototype.offerSnapshot = function offerSnapshot(request, callback) {
            return this.rpcCall(
              offerSnapshot,
              $root.tendermint.abci.RequestOfferSnapshot,
              $root.tendermint.abci.ResponseOfferSnapshot,
              request,
              callback,
            );
          }),
          "name",
          { value: "OfferSnapshot" },
        );

        /**
         * Calls OfferSnapshot.
         * @function offerSnapshot
         * @memberof tendermint.abci.ABCIApplication
         * @instance
         * @param {tendermint.abci.IRequestOfferSnapshot} request RequestOfferSnapshot message or plain object
         * @returns {Promise<tendermint.abci.ResponseOfferSnapshot>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link tendermint.abci.ABCIApplication#loadSnapshotChunk}.
         * @memberof tendermint.abci.ABCIApplication
         * @typedef LoadSnapshotChunkCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {tendermint.abci.ResponseLoadSnapshotChunk} [response] ResponseLoadSnapshotChunk
         */

        /**
         * Calls LoadSnapshotChunk.
         * @function loadSnapshotChunk
         * @memberof tendermint.abci.ABCIApplication
         * @instance
         * @param {tendermint.abci.IRequestLoadSnapshotChunk} request RequestLoadSnapshotChunk message or plain object
         * @param {tendermint.abci.ABCIApplication.LoadSnapshotChunkCallback} callback Node-style callback called with the error, if any, and ResponseLoadSnapshotChunk
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
          (ABCIApplication.prototype.loadSnapshotChunk = function loadSnapshotChunk(request, callback) {
            return this.rpcCall(
              loadSnapshotChunk,
              $root.tendermint.abci.RequestLoadSnapshotChunk,
              $root.tendermint.abci.ResponseLoadSnapshotChunk,
              request,
              callback,
            );
          }),
          "name",
          { value: "LoadSnapshotChunk" },
        );

        /**
         * Calls LoadSnapshotChunk.
         * @function loadSnapshotChunk
         * @memberof tendermint.abci.ABCIApplication
         * @instance
         * @param {tendermint.abci.IRequestLoadSnapshotChunk} request RequestLoadSnapshotChunk message or plain object
         * @returns {Promise<tendermint.abci.ResponseLoadSnapshotChunk>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link tendermint.abci.ABCIApplication#applySnapshotChunk}.
         * @memberof tendermint.abci.ABCIApplication
         * @typedef ApplySnapshotChunkCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {tendermint.abci.ResponseApplySnapshotChunk} [response] ResponseApplySnapshotChunk
         */

        /**
         * Calls ApplySnapshotChunk.
         * @function applySnapshotChunk
         * @memberof tendermint.abci.ABCIApplication
         * @instance
         * @param {tendermint.abci.IRequestApplySnapshotChunk} request RequestApplySnapshotChunk message or plain object
         * @param {tendermint.abci.ABCIApplication.ApplySnapshotChunkCallback} callback Node-style callback called with the error, if any, and ResponseApplySnapshotChunk
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(
          (ABCIApplication.prototype.applySnapshotChunk = function applySnapshotChunk(request, callback) {
            return this.rpcCall(
              applySnapshotChunk,
              $root.tendermint.abci.RequestApplySnapshotChunk,
              $root.tendermint.abci.ResponseApplySnapshotChunk,
              request,
              callback,
            );
          }),
          "name",
          { value: "ApplySnapshotChunk" },
        );

        /**
         * Calls ApplySnapshotChunk.
         * @function applySnapshotChunk
         * @memberof tendermint.abci.ABCIApplication
         * @instance
         * @param {tendermint.abci.IRequestApplySnapshotChunk} request RequestApplySnapshotChunk message or plain object
         * @returns {Promise<tendermint.abci.ResponseApplySnapshotChunk>} Promise
         * @variation 2
         */

        return ABCIApplication;
      })();

      return abci;
    })();

    tendermint.types = (function () {
      /**
       * Namespace types.
       * @memberof tendermint
       * @namespace
       */
      var types = {};

      types.Block = (function () {
        /**
         * Properties of a Block.
         * @memberof tendermint.types
         * @interface IBlock
         * @property {tendermint.types.IHeader|null} [header] Block header
         * @property {tendermint.types.IData|null} [data] Block data
         * @property {tendermint.types.IEvidenceList|null} [evidence] Block evidence
         * @property {tendermint.types.ICommit|null} [lastCommit] Block lastCommit
         */

        /**
         * Constructs a new Block.
         * @memberof tendermint.types
         * @classdesc Represents a Block.
         * @implements IBlock
         * @constructor
         * @param {tendermint.types.IBlock=} [properties] Properties to set
         */
        function Block(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * Block header.
         * @member {tendermint.types.IHeader|null|undefined} header
         * @memberof tendermint.types.Block
         * @instance
         */
        Block.prototype.header = null;

        /**
         * Block data.
         * @member {tendermint.types.IData|null|undefined} data
         * @memberof tendermint.types.Block
         * @instance
         */
        Block.prototype.data = null;

        /**
         * Block evidence.
         * @member {tendermint.types.IEvidenceList|null|undefined} evidence
         * @memberof tendermint.types.Block
         * @instance
         */
        Block.prototype.evidence = null;

        /**
         * Block lastCommit.
         * @member {tendermint.types.ICommit|null|undefined} lastCommit
         * @memberof tendermint.types.Block
         * @instance
         */
        Block.prototype.lastCommit = null;

        /**
         * Creates a new Block instance using the specified properties.
         * @function create
         * @memberof tendermint.types.Block
         * @static
         * @param {tendermint.types.IBlock=} [properties] Properties to set
         * @returns {tendermint.types.Block} Block instance
         */
        Block.create = function create(properties) {
          return new Block(properties);
        };

        /**
         * Encodes the specified Block message. Does not implicitly {@link tendermint.types.Block.verify|verify} messages.
         * @function encode
         * @memberof tendermint.types.Block
         * @static
         * @param {tendermint.types.IBlock} message Block message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Block.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.header != null && Object.hasOwnProperty.call(message, "header"))
            $root.tendermint.types.Header.encode(
              message.header,
              writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
            ).ldelim();
          if (message.data != null && Object.hasOwnProperty.call(message, "data"))
            $root.tendermint.types.Data.encode(
              message.data,
              writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
            ).ldelim();
          if (message.evidence != null && Object.hasOwnProperty.call(message, "evidence"))
            $root.tendermint.types.EvidenceList.encode(
              message.evidence,
              writer.uint32(/* id 3, wireType 2 =*/ 26).fork(),
            ).ldelim();
          if (message.lastCommit != null && Object.hasOwnProperty.call(message, "lastCommit"))
            $root.tendermint.types.Commit.encode(
              message.lastCommit,
              writer.uint32(/* id 4, wireType 2 =*/ 34).fork(),
            ).ldelim();
          return writer;
        };

        /**
         * Encodes the specified Block message, length delimited. Does not implicitly {@link tendermint.types.Block.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tendermint.types.Block
         * @static
         * @param {tendermint.types.IBlock} message Block message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Block.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Block message from the specified reader or buffer.
         * @function decode
         * @memberof tendermint.types.Block
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tendermint.types.Block} Block
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Block.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.tendermint.types.Block();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.header = $root.tendermint.types.Header.decode(reader, reader.uint32());
                break;
              case 2:
                message.data = $root.tendermint.types.Data.decode(reader, reader.uint32());
                break;
              case 3:
                message.evidence = $root.tendermint.types.EvidenceList.decode(reader, reader.uint32());
                break;
              case 4:
                message.lastCommit = $root.tendermint.types.Commit.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a Block message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tendermint.types.Block
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tendermint.types.Block} Block
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Block.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Block message.
         * @function verify
         * @memberof tendermint.types.Block
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Block.verify = function verify(message) {
          if (typeof message !== "object" || message === null) return "object expected";
          if (message.header != null && message.hasOwnProperty("header")) {
            var error = $root.tendermint.types.Header.verify(message.header);
            if (error) return "header." + error;
          }
          if (message.data != null && message.hasOwnProperty("data")) {
            var error = $root.tendermint.types.Data.verify(message.data);
            if (error) return "data." + error;
          }
          if (message.evidence != null && message.hasOwnProperty("evidence")) {
            var error = $root.tendermint.types.EvidenceList.verify(message.evidence);
            if (error) return "evidence." + error;
          }
          if (message.lastCommit != null && message.hasOwnProperty("lastCommit")) {
            var error = $root.tendermint.types.Commit.verify(message.lastCommit);
            if (error) return "lastCommit." + error;
          }
          return null;
        };

        /**
         * Creates a Block message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tendermint.types.Block
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tendermint.types.Block} Block
         */
        Block.fromObject = function fromObject(object) {
          if (object instanceof $root.tendermint.types.Block) return object;
          var message = new $root.tendermint.types.Block();
          if (object.header != null) {
            if (typeof object.header !== "object")
              throw TypeError(".tendermint.types.Block.header: object expected");
            message.header = $root.tendermint.types.Header.fromObject(object.header);
          }
          if (object.data != null) {
            if (typeof object.data !== "object")
              throw TypeError(".tendermint.types.Block.data: object expected");
            message.data = $root.tendermint.types.Data.fromObject(object.data);
          }
          if (object.evidence != null) {
            if (typeof object.evidence !== "object")
              throw TypeError(".tendermint.types.Block.evidence: object expected");
            message.evidence = $root.tendermint.types.EvidenceList.fromObject(object.evidence);
          }
          if (object.lastCommit != null) {
            if (typeof object.lastCommit !== "object")
              throw TypeError(".tendermint.types.Block.lastCommit: object expected");
            message.lastCommit = $root.tendermint.types.Commit.fromObject(object.lastCommit);
          }
          return message;
        };

        /**
         * Creates a plain object from a Block message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tendermint.types.Block
         * @static
         * @param {tendermint.types.Block} message Block
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Block.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.header = null;
            object.data = null;
            object.evidence = null;
            object.lastCommit = null;
          }
          if (message.header != null && message.hasOwnProperty("header"))
            object.header = $root.tendermint.types.Header.toObject(message.header, options);
          if (message.data != null && message.hasOwnProperty("data"))
            object.data = $root.tendermint.types.Data.toObject(message.data, options);
          if (message.evidence != null && message.hasOwnProperty("evidence"))
            object.evidence = $root.tendermint.types.EvidenceList.toObject(message.evidence, options);
          if (message.lastCommit != null && message.hasOwnProperty("lastCommit"))
            object.lastCommit = $root.tendermint.types.Commit.toObject(message.lastCommit, options);
          return object;
        };

        /**
         * Converts this Block to JSON.
         * @function toJSON
         * @memberof tendermint.types.Block
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Block.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Block;
      })();

      types.Evidence = (function () {
        /**
         * Properties of an Evidence.
         * @memberof tendermint.types
         * @interface IEvidence
         * @property {tendermint.types.IDuplicateVoteEvidence|null} [duplicateVoteEvidence] Evidence duplicateVoteEvidence
         * @property {tendermint.types.ILightClientAttackEvidence|null} [lightClientAttackEvidence] Evidence lightClientAttackEvidence
         */

        /**
         * Constructs a new Evidence.
         * @memberof tendermint.types
         * @classdesc Represents an Evidence.
         * @implements IEvidence
         * @constructor
         * @param {tendermint.types.IEvidence=} [properties] Properties to set
         */
        function Evidence(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * Evidence duplicateVoteEvidence.
         * @member {tendermint.types.IDuplicateVoteEvidence|null|undefined} duplicateVoteEvidence
         * @memberof tendermint.types.Evidence
         * @instance
         */
        Evidence.prototype.duplicateVoteEvidence = null;

        /**
         * Evidence lightClientAttackEvidence.
         * @member {tendermint.types.ILightClientAttackEvidence|null|undefined} lightClientAttackEvidence
         * @memberof tendermint.types.Evidence
         * @instance
         */
        Evidence.prototype.lightClientAttackEvidence = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * Evidence sum.
         * @member {"duplicateVoteEvidence"|"lightClientAttackEvidence"|undefined} sum
         * @memberof tendermint.types.Evidence
         * @instance
         */
        Object.defineProperty(Evidence.prototype, "sum", {
          get: $util.oneOfGetter(($oneOfFields = ["duplicateVoteEvidence", "lightClientAttackEvidence"])),
          set: $util.oneOfSetter($oneOfFields),
        });

        /**
         * Creates a new Evidence instance using the specified properties.
         * @function create
         * @memberof tendermint.types.Evidence
         * @static
         * @param {tendermint.types.IEvidence=} [properties] Properties to set
         * @returns {tendermint.types.Evidence} Evidence instance
         */
        Evidence.create = function create(properties) {
          return new Evidence(properties);
        };

        /**
         * Encodes the specified Evidence message. Does not implicitly {@link tendermint.types.Evidence.verify|verify} messages.
         * @function encode
         * @memberof tendermint.types.Evidence
         * @static
         * @param {tendermint.types.IEvidence} message Evidence message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Evidence.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (
            message.duplicateVoteEvidence != null &&
            Object.hasOwnProperty.call(message, "duplicateVoteEvidence")
          )
            $root.tendermint.types.DuplicateVoteEvidence.encode(
              message.duplicateVoteEvidence,
              writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
            ).ldelim();
          if (
            message.lightClientAttackEvidence != null &&
            Object.hasOwnProperty.call(message, "lightClientAttackEvidence")
          )
            $root.tendermint.types.LightClientAttackEvidence.encode(
              message.lightClientAttackEvidence,
              writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
            ).ldelim();
          return writer;
        };

        /**
         * Encodes the specified Evidence message, length delimited. Does not implicitly {@link tendermint.types.Evidence.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tendermint.types.Evidence
         * @static
         * @param {tendermint.types.IEvidence} message Evidence message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Evidence.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Evidence message from the specified reader or buffer.
         * @function decode
         * @memberof tendermint.types.Evidence
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tendermint.types.Evidence} Evidence
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Evidence.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.tendermint.types.Evidence();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.duplicateVoteEvidence = $root.tendermint.types.DuplicateVoteEvidence.decode(
                  reader,
                  reader.uint32(),
                );
                break;
              case 2:
                message.lightClientAttackEvidence = $root.tendermint.types.LightClientAttackEvidence.decode(
                  reader,
                  reader.uint32(),
                );
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes an Evidence message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tendermint.types.Evidence
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tendermint.types.Evidence} Evidence
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Evidence.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Evidence message.
         * @function verify
         * @memberof tendermint.types.Evidence
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Evidence.verify = function verify(message) {
          if (typeof message !== "object" || message === null) return "object expected";
          var properties = {};
          if (message.duplicateVoteEvidence != null && message.hasOwnProperty("duplicateVoteEvidence")) {
            properties.sum = 1;
            {
              var error = $root.tendermint.types.DuplicateVoteEvidence.verify(message.duplicateVoteEvidence);
              if (error) return "duplicateVoteEvidence." + error;
            }
          }
          if (
            message.lightClientAttackEvidence != null &&
            message.hasOwnProperty("lightClientAttackEvidence")
          ) {
            if (properties.sum === 1) return "sum: multiple values";
            properties.sum = 1;
            {
              var error = $root.tendermint.types.LightClientAttackEvidence.verify(
                message.lightClientAttackEvidence,
              );
              if (error) return "lightClientAttackEvidence." + error;
            }
          }
          return null;
        };

        /**
         * Creates an Evidence message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tendermint.types.Evidence
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tendermint.types.Evidence} Evidence
         */
        Evidence.fromObject = function fromObject(object) {
          if (object instanceof $root.tendermint.types.Evidence) return object;
          var message = new $root.tendermint.types.Evidence();
          if (object.duplicateVoteEvidence != null) {
            if (typeof object.duplicateVoteEvidence !== "object")
              throw TypeError(".tendermint.types.Evidence.duplicateVoteEvidence: object expected");
            message.duplicateVoteEvidence = $root.tendermint.types.DuplicateVoteEvidence.fromObject(
              object.duplicateVoteEvidence,
            );
          }
          if (object.lightClientAttackEvidence != null) {
            if (typeof object.lightClientAttackEvidence !== "object")
              throw TypeError(".tendermint.types.Evidence.lightClientAttackEvidence: object expected");
            message.lightClientAttackEvidence = $root.tendermint.types.LightClientAttackEvidence.fromObject(
              object.lightClientAttackEvidence,
            );
          }
          return message;
        };

        /**
         * Creates a plain object from an Evidence message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tendermint.types.Evidence
         * @static
         * @param {tendermint.types.Evidence} message Evidence
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Evidence.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (message.duplicateVoteEvidence != null && message.hasOwnProperty("duplicateVoteEvidence")) {
            object.duplicateVoteEvidence = $root.tendermint.types.DuplicateVoteEvidence.toObject(
              message.duplicateVoteEvidence,
              options,
            );
            if (options.oneofs) object.sum = "duplicateVoteEvidence";
          }
          if (
            message.lightClientAttackEvidence != null &&
            message.hasOwnProperty("lightClientAttackEvidence")
          ) {
            object.lightClientAttackEvidence = $root.tendermint.types.LightClientAttackEvidence.toObject(
              message.lightClientAttackEvidence,
              options,
            );
            if (options.oneofs) object.sum = "lightClientAttackEvidence";
          }
          return object;
        };

        /**
         * Converts this Evidence to JSON.
         * @function toJSON
         * @memberof tendermint.types.Evidence
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Evidence.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Evidence;
      })();

      types.DuplicateVoteEvidence = (function () {
        /**
         * Properties of a DuplicateVoteEvidence.
         * @memberof tendermint.types
         * @interface IDuplicateVoteEvidence
         * @property {tendermint.types.IVote|null} [voteA] DuplicateVoteEvidence voteA
         * @property {tendermint.types.IVote|null} [voteB] DuplicateVoteEvidence voteB
         * @property {number|Long|null} [totalVotingPower] DuplicateVoteEvidence totalVotingPower
         * @property {number|Long|null} [validatorPower] DuplicateVoteEvidence validatorPower
         * @property {google.protobuf.ITimestamp|null} [timestamp] DuplicateVoteEvidence timestamp
         */

        /**
         * Constructs a new DuplicateVoteEvidence.
         * @memberof tendermint.types
         * @classdesc Represents a DuplicateVoteEvidence.
         * @implements IDuplicateVoteEvidence
         * @constructor
         * @param {tendermint.types.IDuplicateVoteEvidence=} [properties] Properties to set
         */
        function DuplicateVoteEvidence(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * DuplicateVoteEvidence voteA.
         * @member {tendermint.types.IVote|null|undefined} voteA
         * @memberof tendermint.types.DuplicateVoteEvidence
         * @instance
         */
        DuplicateVoteEvidence.prototype.voteA = null;

        /**
         * DuplicateVoteEvidence voteB.
         * @member {tendermint.types.IVote|null|undefined} voteB
         * @memberof tendermint.types.DuplicateVoteEvidence
         * @instance
         */
        DuplicateVoteEvidence.prototype.voteB = null;

        /**
         * DuplicateVoteEvidence totalVotingPower.
         * @member {number|Long} totalVotingPower
         * @memberof tendermint.types.DuplicateVoteEvidence
         * @instance
         */
        DuplicateVoteEvidence.prototype.totalVotingPower = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * DuplicateVoteEvidence validatorPower.
         * @member {number|Long} validatorPower
         * @memberof tendermint.types.DuplicateVoteEvidence
         * @instance
         */
        DuplicateVoteEvidence.prototype.validatorPower = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * DuplicateVoteEvidence timestamp.
         * @member {google.protobuf.ITimestamp|null|undefined} timestamp
         * @memberof tendermint.types.DuplicateVoteEvidence
         * @instance
         */
        DuplicateVoteEvidence.prototype.timestamp = null;

        /**
         * Creates a new DuplicateVoteEvidence instance using the specified properties.
         * @function create
         * @memberof tendermint.types.DuplicateVoteEvidence
         * @static
         * @param {tendermint.types.IDuplicateVoteEvidence=} [properties] Properties to set
         * @returns {tendermint.types.DuplicateVoteEvidence} DuplicateVoteEvidence instance
         */
        DuplicateVoteEvidence.create = function create(properties) {
          return new DuplicateVoteEvidence(properties);
        };

        /**
         * Encodes the specified DuplicateVoteEvidence message. Does not implicitly {@link tendermint.types.DuplicateVoteEvidence.verify|verify} messages.
         * @function encode
         * @memberof tendermint.types.DuplicateVoteEvidence
         * @static
         * @param {tendermint.types.IDuplicateVoteEvidence} message DuplicateVoteEvidence message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DuplicateVoteEvidence.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.voteA != null && Object.hasOwnProperty.call(message, "voteA"))
            $root.tendermint.types.Vote.encode(
              message.voteA,
              writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
            ).ldelim();
          if (message.voteB != null && Object.hasOwnProperty.call(message, "voteB"))
            $root.tendermint.types.Vote.encode(
              message.voteB,
              writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
            ).ldelim();
          if (message.totalVotingPower != null && Object.hasOwnProperty.call(message, "totalVotingPower"))
            writer.uint32(/* id 3, wireType 0 =*/ 24).int64(message.totalVotingPower);
          if (message.validatorPower != null && Object.hasOwnProperty.call(message, "validatorPower"))
            writer.uint32(/* id 4, wireType 0 =*/ 32).int64(message.validatorPower);
          if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
            $root.google.protobuf.Timestamp.encode(
              message.timestamp,
              writer.uint32(/* id 5, wireType 2 =*/ 42).fork(),
            ).ldelim();
          return writer;
        };

        /**
         * Encodes the specified DuplicateVoteEvidence message, length delimited. Does not implicitly {@link tendermint.types.DuplicateVoteEvidence.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tendermint.types.DuplicateVoteEvidence
         * @static
         * @param {tendermint.types.IDuplicateVoteEvidence} message DuplicateVoteEvidence message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DuplicateVoteEvidence.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DuplicateVoteEvidence message from the specified reader or buffer.
         * @function decode
         * @memberof tendermint.types.DuplicateVoteEvidence
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tendermint.types.DuplicateVoteEvidence} DuplicateVoteEvidence
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DuplicateVoteEvidence.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.tendermint.types.DuplicateVoteEvidence();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.voteA = $root.tendermint.types.Vote.decode(reader, reader.uint32());
                break;
              case 2:
                message.voteB = $root.tendermint.types.Vote.decode(reader, reader.uint32());
                break;
              case 3:
                message.totalVotingPower = reader.int64();
                break;
              case 4:
                message.validatorPower = reader.int64();
                break;
              case 5:
                message.timestamp = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a DuplicateVoteEvidence message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tendermint.types.DuplicateVoteEvidence
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tendermint.types.DuplicateVoteEvidence} DuplicateVoteEvidence
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DuplicateVoteEvidence.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DuplicateVoteEvidence message.
         * @function verify
         * @memberof tendermint.types.DuplicateVoteEvidence
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DuplicateVoteEvidence.verify = function verify(message) {
          if (typeof message !== "object" || message === null) return "object expected";
          if (message.voteA != null && message.hasOwnProperty("voteA")) {
            var error = $root.tendermint.types.Vote.verify(message.voteA);
            if (error) return "voteA." + error;
          }
          if (message.voteB != null && message.hasOwnProperty("voteB")) {
            var error = $root.tendermint.types.Vote.verify(message.voteB);
            if (error) return "voteB." + error;
          }
          if (message.totalVotingPower != null && message.hasOwnProperty("totalVotingPower"))
            if (
              !$util.isInteger(message.totalVotingPower) &&
              !(
                message.totalVotingPower &&
                $util.isInteger(message.totalVotingPower.low) &&
                $util.isInteger(message.totalVotingPower.high)
              )
            )
              return "totalVotingPower: integer|Long expected";
          if (message.validatorPower != null && message.hasOwnProperty("validatorPower"))
            if (
              !$util.isInteger(message.validatorPower) &&
              !(
                message.validatorPower &&
                $util.isInteger(message.validatorPower.low) &&
                $util.isInteger(message.validatorPower.high)
              )
            )
              return "validatorPower: integer|Long expected";
          if (message.timestamp != null && message.hasOwnProperty("timestamp")) {
            var error = $root.google.protobuf.Timestamp.verify(message.timestamp);
            if (error) return "timestamp." + error;
          }
          return null;
        };

        /**
         * Creates a DuplicateVoteEvidence message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tendermint.types.DuplicateVoteEvidence
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tendermint.types.DuplicateVoteEvidence} DuplicateVoteEvidence
         */
        DuplicateVoteEvidence.fromObject = function fromObject(object) {
          if (object instanceof $root.tendermint.types.DuplicateVoteEvidence) return object;
          var message = new $root.tendermint.types.DuplicateVoteEvidence();
          if (object.voteA != null) {
            if (typeof object.voteA !== "object")
              throw TypeError(".tendermint.types.DuplicateVoteEvidence.voteA: object expected");
            message.voteA = $root.tendermint.types.Vote.fromObject(object.voteA);
          }
          if (object.voteB != null) {
            if (typeof object.voteB !== "object")
              throw TypeError(".tendermint.types.DuplicateVoteEvidence.voteB: object expected");
            message.voteB = $root.tendermint.types.Vote.fromObject(object.voteB);
          }
          if (object.totalVotingPower != null)
            if ($util.Long)
              (message.totalVotingPower = $util.Long.fromValue(object.totalVotingPower)).unsigned = false;
            else if (typeof object.totalVotingPower === "string")
              message.totalVotingPower = parseInt(object.totalVotingPower, 10);
            else if (typeof object.totalVotingPower === "number")
              message.totalVotingPower = object.totalVotingPower;
            else if (typeof object.totalVotingPower === "object")
              message.totalVotingPower = new $util.LongBits(
                object.totalVotingPower.low >>> 0,
                object.totalVotingPower.high >>> 0,
              ).toNumber();
          if (object.validatorPower != null)
            if ($util.Long)
              (message.validatorPower = $util.Long.fromValue(object.validatorPower)).unsigned = false;
            else if (typeof object.validatorPower === "string")
              message.validatorPower = parseInt(object.validatorPower, 10);
            else if (typeof object.validatorPower === "number")
              message.validatorPower = object.validatorPower;
            else if (typeof object.validatorPower === "object")
              message.validatorPower = new $util.LongBits(
                object.validatorPower.low >>> 0,
                object.validatorPower.high >>> 0,
              ).toNumber();
          if (object.timestamp != null) {
            if (typeof object.timestamp !== "object")
              throw TypeError(".tendermint.types.DuplicateVoteEvidence.timestamp: object expected");
            message.timestamp = $root.google.protobuf.Timestamp.fromObject(object.timestamp);
          }
          return message;
        };

        /**
         * Creates a plain object from a DuplicateVoteEvidence message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tendermint.types.DuplicateVoteEvidence
         * @static
         * @param {tendermint.types.DuplicateVoteEvidence} message DuplicateVoteEvidence
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DuplicateVoteEvidence.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.voteA = null;
            object.voteB = null;
            if ($util.Long) {
              var long = new $util.Long(0, 0, false);
              object.totalVotingPower =
                options.longs === String
                  ? long.toString()
                  : options.longs === Number
                  ? long.toNumber()
                  : long;
            } else object.totalVotingPower = options.longs === String ? "0" : 0;
            if ($util.Long) {
              var long = new $util.Long(0, 0, false);
              object.validatorPower =
                options.longs === String
                  ? long.toString()
                  : options.longs === Number
                  ? long.toNumber()
                  : long;
            } else object.validatorPower = options.longs === String ? "0" : 0;
            object.timestamp = null;
          }
          if (message.voteA != null && message.hasOwnProperty("voteA"))
            object.voteA = $root.tendermint.types.Vote.toObject(message.voteA, options);
          if (message.voteB != null && message.hasOwnProperty("voteB"))
            object.voteB = $root.tendermint.types.Vote.toObject(message.voteB, options);
          if (message.totalVotingPower != null && message.hasOwnProperty("totalVotingPower"))
            if (typeof message.totalVotingPower === "number")
              object.totalVotingPower =
                options.longs === String ? String(message.totalVotingPower) : message.totalVotingPower;
            else
              object.totalVotingPower =
                options.longs === String
                  ? $util.Long.prototype.toString.call(message.totalVotingPower)
                  : options.longs === Number
                  ? new $util.LongBits(
                      message.totalVotingPower.low >>> 0,
                      message.totalVotingPower.high >>> 0,
                    ).toNumber()
                  : message.totalVotingPower;
          if (message.validatorPower != null && message.hasOwnProperty("validatorPower"))
            if (typeof message.validatorPower === "number")
              object.validatorPower =
                options.longs === String ? String(message.validatorPower) : message.validatorPower;
            else
              object.validatorPower =
                options.longs === String
                  ? $util.Long.prototype.toString.call(message.validatorPower)
                  : options.longs === Number
                  ? new $util.LongBits(
                      message.validatorPower.low >>> 0,
                      message.validatorPower.high >>> 0,
                    ).toNumber()
                  : message.validatorPower;
          if (message.timestamp != null && message.hasOwnProperty("timestamp"))
            object.timestamp = $root.google.protobuf.Timestamp.toObject(message.timestamp, options);
          return object;
        };

        /**
         * Converts this DuplicateVoteEvidence to JSON.
         * @function toJSON
         * @memberof tendermint.types.DuplicateVoteEvidence
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DuplicateVoteEvidence.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DuplicateVoteEvidence;
      })();

      types.LightClientAttackEvidence = (function () {
        /**
         * Properties of a LightClientAttackEvidence.
         * @memberof tendermint.types
         * @interface ILightClientAttackEvidence
         * @property {tendermint.types.ILightBlock|null} [conflictingBlock] LightClientAttackEvidence conflictingBlock
         * @property {number|Long|null} [commonHeight] LightClientAttackEvidence commonHeight
         * @property {Array.<tendermint.types.IValidator>|null} [byzantineValidators] LightClientAttackEvidence byzantineValidators
         * @property {number|Long|null} [totalVotingPower] LightClientAttackEvidence totalVotingPower
         * @property {google.protobuf.ITimestamp|null} [timestamp] LightClientAttackEvidence timestamp
         */

        /**
         * Constructs a new LightClientAttackEvidence.
         * @memberof tendermint.types
         * @classdesc Represents a LightClientAttackEvidence.
         * @implements ILightClientAttackEvidence
         * @constructor
         * @param {tendermint.types.ILightClientAttackEvidence=} [properties] Properties to set
         */
        function LightClientAttackEvidence(properties) {
          this.byzantineValidators = [];
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * LightClientAttackEvidence conflictingBlock.
         * @member {tendermint.types.ILightBlock|null|undefined} conflictingBlock
         * @memberof tendermint.types.LightClientAttackEvidence
         * @instance
         */
        LightClientAttackEvidence.prototype.conflictingBlock = null;

        /**
         * LightClientAttackEvidence commonHeight.
         * @member {number|Long} commonHeight
         * @memberof tendermint.types.LightClientAttackEvidence
         * @instance
         */
        LightClientAttackEvidence.prototype.commonHeight = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * LightClientAttackEvidence byzantineValidators.
         * @member {Array.<tendermint.types.IValidator>} byzantineValidators
         * @memberof tendermint.types.LightClientAttackEvidence
         * @instance
         */
        LightClientAttackEvidence.prototype.byzantineValidators = $util.emptyArray;

        /**
         * LightClientAttackEvidence totalVotingPower.
         * @member {number|Long} totalVotingPower
         * @memberof tendermint.types.LightClientAttackEvidence
         * @instance
         */
        LightClientAttackEvidence.prototype.totalVotingPower = $util.Long
          ? $util.Long.fromBits(0, 0, false)
          : 0;

        /**
         * LightClientAttackEvidence timestamp.
         * @member {google.protobuf.ITimestamp|null|undefined} timestamp
         * @memberof tendermint.types.LightClientAttackEvidence
         * @instance
         */
        LightClientAttackEvidence.prototype.timestamp = null;

        /**
         * Creates a new LightClientAttackEvidence instance using the specified properties.
         * @function create
         * @memberof tendermint.types.LightClientAttackEvidence
         * @static
         * @param {tendermint.types.ILightClientAttackEvidence=} [properties] Properties to set
         * @returns {tendermint.types.LightClientAttackEvidence} LightClientAttackEvidence instance
         */
        LightClientAttackEvidence.create = function create(properties) {
          return new LightClientAttackEvidence(properties);
        };

        /**
         * Encodes the specified LightClientAttackEvidence message. Does not implicitly {@link tendermint.types.LightClientAttackEvidence.verify|verify} messages.
         * @function encode
         * @memberof tendermint.types.LightClientAttackEvidence
         * @static
         * @param {tendermint.types.ILightClientAttackEvidence} message LightClientAttackEvidence message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LightClientAttackEvidence.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.conflictingBlock != null && Object.hasOwnProperty.call(message, "conflictingBlock"))
            $root.tendermint.types.LightBlock.encode(
              message.conflictingBlock,
              writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
            ).ldelim();
          if (message.commonHeight != null && Object.hasOwnProperty.call(message, "commonHeight"))
            writer.uint32(/* id 2, wireType 0 =*/ 16).int64(message.commonHeight);
          if (message.byzantineValidators != null && message.byzantineValidators.length)
            for (var i = 0; i < message.byzantineValidators.length; ++i)
              $root.tendermint.types.Validator.encode(
                message.byzantineValidators[i],
                writer.uint32(/* id 3, wireType 2 =*/ 26).fork(),
              ).ldelim();
          if (message.totalVotingPower != null && Object.hasOwnProperty.call(message, "totalVotingPower"))
            writer.uint32(/* id 4, wireType 0 =*/ 32).int64(message.totalVotingPower);
          if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
            $root.google.protobuf.Timestamp.encode(
              message.timestamp,
              writer.uint32(/* id 5, wireType 2 =*/ 42).fork(),
            ).ldelim();
          return writer;
        };

        /**
         * Encodes the specified LightClientAttackEvidence message, length delimited. Does not implicitly {@link tendermint.types.LightClientAttackEvidence.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tendermint.types.LightClientAttackEvidence
         * @static
         * @param {tendermint.types.ILightClientAttackEvidence} message LightClientAttackEvidence message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LightClientAttackEvidence.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LightClientAttackEvidence message from the specified reader or buffer.
         * @function decode
         * @memberof tendermint.types.LightClientAttackEvidence
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tendermint.types.LightClientAttackEvidence} LightClientAttackEvidence
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LightClientAttackEvidence.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.tendermint.types.LightClientAttackEvidence();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.conflictingBlock = $root.tendermint.types.LightBlock.decode(reader, reader.uint32());
                break;
              case 2:
                message.commonHeight = reader.int64();
                break;
              case 3:
                if (!(message.byzantineValidators && message.byzantineValidators.length))
                  message.byzantineValidators = [];
                message.byzantineValidators.push(
                  $root.tendermint.types.Validator.decode(reader, reader.uint32()),
                );
                break;
              case 4:
                message.totalVotingPower = reader.int64();
                break;
              case 5:
                message.timestamp = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a LightClientAttackEvidence message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tendermint.types.LightClientAttackEvidence
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tendermint.types.LightClientAttackEvidence} LightClientAttackEvidence
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LightClientAttackEvidence.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LightClientAttackEvidence message.
         * @function verify
         * @memberof tendermint.types.LightClientAttackEvidence
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LightClientAttackEvidence.verify = function verify(message) {
          if (typeof message !== "object" || message === null) return "object expected";
          if (message.conflictingBlock != null && message.hasOwnProperty("conflictingBlock")) {
            var error = $root.tendermint.types.LightBlock.verify(message.conflictingBlock);
            if (error) return "conflictingBlock." + error;
          }
          if (message.commonHeight != null && message.hasOwnProperty("commonHeight"))
            if (
              !$util.isInteger(message.commonHeight) &&
              !(
                message.commonHeight &&
                $util.isInteger(message.commonHeight.low) &&
                $util.isInteger(message.commonHeight.high)
              )
            )
              return "commonHeight: integer|Long expected";
          if (message.byzantineValidators != null && message.hasOwnProperty("byzantineValidators")) {
            if (!Array.isArray(message.byzantineValidators)) return "byzantineValidators: array expected";
            for (var i = 0; i < message.byzantineValidators.length; ++i) {
              var error = $root.tendermint.types.Validator.verify(message.byzantineValidators[i]);
              if (error) return "byzantineValidators." + error;
            }
          }
          if (message.totalVotingPower != null && message.hasOwnProperty("totalVotingPower"))
            if (
              !$util.isInteger(message.totalVotingPower) &&
              !(
                message.totalVotingPower &&
                $util.isInteger(message.totalVotingPower.low) &&
                $util.isInteger(message.totalVotingPower.high)
              )
            )
              return "totalVotingPower: integer|Long expected";
          if (message.timestamp != null && message.hasOwnProperty("timestamp")) {
            var error = $root.google.protobuf.Timestamp.verify(message.timestamp);
            if (error) return "timestamp." + error;
          }
          return null;
        };

        /**
         * Creates a LightClientAttackEvidence message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tendermint.types.LightClientAttackEvidence
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tendermint.types.LightClientAttackEvidence} LightClientAttackEvidence
         */
        LightClientAttackEvidence.fromObject = function fromObject(object) {
          if (object instanceof $root.tendermint.types.LightClientAttackEvidence) return object;
          var message = new $root.tendermint.types.LightClientAttackEvidence();
          if (object.conflictingBlock != null) {
            if (typeof object.conflictingBlock !== "object")
              throw TypeError(
                ".tendermint.types.LightClientAttackEvidence.conflictingBlock: object expected",
              );
            message.conflictingBlock = $root.tendermint.types.LightBlock.fromObject(object.conflictingBlock);
          }
          if (object.commonHeight != null)
            if ($util.Long)
              (message.commonHeight = $util.Long.fromValue(object.commonHeight)).unsigned = false;
            else if (typeof object.commonHeight === "string")
              message.commonHeight = parseInt(object.commonHeight, 10);
            else if (typeof object.commonHeight === "number") message.commonHeight = object.commonHeight;
            else if (typeof object.commonHeight === "object")
              message.commonHeight = new $util.LongBits(
                object.commonHeight.low >>> 0,
                object.commonHeight.high >>> 0,
              ).toNumber();
          if (object.byzantineValidators) {
            if (!Array.isArray(object.byzantineValidators))
              throw TypeError(
                ".tendermint.types.LightClientAttackEvidence.byzantineValidators: array expected",
              );
            message.byzantineValidators = [];
            for (var i = 0; i < object.byzantineValidators.length; ++i) {
              if (typeof object.byzantineValidators[i] !== "object")
                throw TypeError(
                  ".tendermint.types.LightClientAttackEvidence.byzantineValidators: object expected",
                );
              message.byzantineValidators[i] = $root.tendermint.types.Validator.fromObject(
                object.byzantineValidators[i],
              );
            }
          }
          if (object.totalVotingPower != null)
            if ($util.Long)
              (message.totalVotingPower = $util.Long.fromValue(object.totalVotingPower)).unsigned = false;
            else if (typeof object.totalVotingPower === "string")
              message.totalVotingPower = parseInt(object.totalVotingPower, 10);
            else if (typeof object.totalVotingPower === "number")
              message.totalVotingPower = object.totalVotingPower;
            else if (typeof object.totalVotingPower === "object")
              message.totalVotingPower = new $util.LongBits(
                object.totalVotingPower.low >>> 0,
                object.totalVotingPower.high >>> 0,
              ).toNumber();
          if (object.timestamp != null) {
            if (typeof object.timestamp !== "object")
              throw TypeError(".tendermint.types.LightClientAttackEvidence.timestamp: object expected");
            message.timestamp = $root.google.protobuf.Timestamp.fromObject(object.timestamp);
          }
          return message;
        };

        /**
         * Creates a plain object from a LightClientAttackEvidence message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tendermint.types.LightClientAttackEvidence
         * @static
         * @param {tendermint.types.LightClientAttackEvidence} message LightClientAttackEvidence
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        LightClientAttackEvidence.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.arrays || options.defaults) object.byzantineValidators = [];
          if (options.defaults) {
            object.conflictingBlock = null;
            if ($util.Long) {
              var long = new $util.Long(0, 0, false);
              object.commonHeight =
                options.longs === String
                  ? long.toString()
                  : options.longs === Number
                  ? long.toNumber()
                  : long;
            } else object.commonHeight = options.longs === String ? "0" : 0;
            if ($util.Long) {
              var long = new $util.Long(0, 0, false);
              object.totalVotingPower =
                options.longs === String
                  ? long.toString()
                  : options.longs === Number
                  ? long.toNumber()
                  : long;
            } else object.totalVotingPower = options.longs === String ? "0" : 0;
            object.timestamp = null;
          }
          if (message.conflictingBlock != null && message.hasOwnProperty("conflictingBlock"))
            object.conflictingBlock = $root.tendermint.types.LightBlock.toObject(
              message.conflictingBlock,
              options,
            );
          if (message.commonHeight != null && message.hasOwnProperty("commonHeight"))
            if (typeof message.commonHeight === "number")
              object.commonHeight =
                options.longs === String ? String(message.commonHeight) : message.commonHeight;
            else
              object.commonHeight =
                options.longs === String
                  ? $util.Long.prototype.toString.call(message.commonHeight)
                  : options.longs === Number
                  ? new $util.LongBits(
                      message.commonHeight.low >>> 0,
                      message.commonHeight.high >>> 0,
                    ).toNumber()
                  : message.commonHeight;
          if (message.byzantineValidators && message.byzantineValidators.length) {
            object.byzantineValidators = [];
            for (var j = 0; j < message.byzantineValidators.length; ++j)
              object.byzantineValidators[j] = $root.tendermint.types.Validator.toObject(
                message.byzantineValidators[j],
                options,
              );
          }
          if (message.totalVotingPower != null && message.hasOwnProperty("totalVotingPower"))
            if (typeof message.totalVotingPower === "number")
              object.totalVotingPower =
                options.longs === String ? String(message.totalVotingPower) : message.totalVotingPower;
            else
              object.totalVotingPower =
                options.longs === String
                  ? $util.Long.prototype.toString.call(message.totalVotingPower)
                  : options.longs === Number
                  ? new $util.LongBits(
                      message.totalVotingPower.low >>> 0,
                      message.totalVotingPower.high >>> 0,
                    ).toNumber()
                  : message.totalVotingPower;
          if (message.timestamp != null && message.hasOwnProperty("timestamp"))
            object.timestamp = $root.google.protobuf.Timestamp.toObject(message.timestamp, options);
          return object;
        };

        /**
         * Converts this LightClientAttackEvidence to JSON.
         * @function toJSON
         * @memberof tendermint.types.LightClientAttackEvidence
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        LightClientAttackEvidence.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return LightClientAttackEvidence;
      })();

      types.EvidenceList = (function () {
        /**
         * Properties of an EvidenceList.
         * @memberof tendermint.types
         * @interface IEvidenceList
         * @property {Array.<tendermint.types.IEvidence>|null} [evidence] EvidenceList evidence
         */

        /**
         * Constructs a new EvidenceList.
         * @memberof tendermint.types
         * @classdesc Represents an EvidenceList.
         * @implements IEvidenceList
         * @constructor
         * @param {tendermint.types.IEvidenceList=} [properties] Properties to set
         */
        function EvidenceList(properties) {
          this.evidence = [];
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * EvidenceList evidence.
         * @member {Array.<tendermint.types.IEvidence>} evidence
         * @memberof tendermint.types.EvidenceList
         * @instance
         */
        EvidenceList.prototype.evidence = $util.emptyArray;

        /**
         * Creates a new EvidenceList instance using the specified properties.
         * @function create
         * @memberof tendermint.types.EvidenceList
         * @static
         * @param {tendermint.types.IEvidenceList=} [properties] Properties to set
         * @returns {tendermint.types.EvidenceList} EvidenceList instance
         */
        EvidenceList.create = function create(properties) {
          return new EvidenceList(properties);
        };

        /**
         * Encodes the specified EvidenceList message. Does not implicitly {@link tendermint.types.EvidenceList.verify|verify} messages.
         * @function encode
         * @memberof tendermint.types.EvidenceList
         * @static
         * @param {tendermint.types.IEvidenceList} message EvidenceList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EvidenceList.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.evidence != null && message.evidence.length)
            for (var i = 0; i < message.evidence.length; ++i)
              $root.tendermint.types.Evidence.encode(
                message.evidence[i],
                writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
              ).ldelim();
          return writer;
        };

        /**
         * Encodes the specified EvidenceList message, length delimited. Does not implicitly {@link tendermint.types.EvidenceList.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tendermint.types.EvidenceList
         * @static
         * @param {tendermint.types.IEvidenceList} message EvidenceList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EvidenceList.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EvidenceList message from the specified reader or buffer.
         * @function decode
         * @memberof tendermint.types.EvidenceList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tendermint.types.EvidenceList} EvidenceList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EvidenceList.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.tendermint.types.EvidenceList();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                if (!(message.evidence && message.evidence.length)) message.evidence = [];
                message.evidence.push($root.tendermint.types.Evidence.decode(reader, reader.uint32()));
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes an EvidenceList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tendermint.types.EvidenceList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tendermint.types.EvidenceList} EvidenceList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EvidenceList.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EvidenceList message.
         * @function verify
         * @memberof tendermint.types.EvidenceList
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EvidenceList.verify = function verify(message) {
          if (typeof message !== "object" || message === null) return "object expected";
          if (message.evidence != null && message.hasOwnProperty("evidence")) {
            if (!Array.isArray(message.evidence)) return "evidence: array expected";
            for (var i = 0; i < message.evidence.length; ++i) {
              var error = $root.tendermint.types.Evidence.verify(message.evidence[i]);
              if (error) return "evidence." + error;
            }
          }
          return null;
        };

        /**
         * Creates an EvidenceList message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tendermint.types.EvidenceList
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tendermint.types.EvidenceList} EvidenceList
         */
        EvidenceList.fromObject = function fromObject(object) {
          if (object instanceof $root.tendermint.types.EvidenceList) return object;
          var message = new $root.tendermint.types.EvidenceList();
          if (object.evidence) {
            if (!Array.isArray(object.evidence))
              throw TypeError(".tendermint.types.EvidenceList.evidence: array expected");
            message.evidence = [];
            for (var i = 0; i < object.evidence.length; ++i) {
              if (typeof object.evidence[i] !== "object")
                throw TypeError(".tendermint.types.EvidenceList.evidence: object expected");
              message.evidence[i] = $root.tendermint.types.Evidence.fromObject(object.evidence[i]);
            }
          }
          return message;
        };

        /**
         * Creates a plain object from an EvidenceList message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tendermint.types.EvidenceList
         * @static
         * @param {tendermint.types.EvidenceList} message EvidenceList
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EvidenceList.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.arrays || options.defaults) object.evidence = [];
          if (message.evidence && message.evidence.length) {
            object.evidence = [];
            for (var j = 0; j < message.evidence.length; ++j)
              object.evidence[j] = $root.tendermint.types.Evidence.toObject(message.evidence[j], options);
          }
          return object;
        };

        /**
         * Converts this EvidenceList to JSON.
         * @function toJSON
         * @memberof tendermint.types.EvidenceList
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EvidenceList.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return EvidenceList;
      })();

      types.ConsensusParams = (function () {
        /**
         * Properties of a ConsensusParams.
         * @memberof tendermint.types
         * @interface IConsensusParams
         * @property {tendermint.types.IBlockParams|null} [block] ConsensusParams block
         * @property {tendermint.types.IEvidenceParams|null} [evidence] ConsensusParams evidence
         * @property {tendermint.types.IValidatorParams|null} [validator] ConsensusParams validator
         * @property {tendermint.types.IVersionParams|null} [version] ConsensusParams version
         */

        /**
         * Constructs a new ConsensusParams.
         * @memberof tendermint.types
         * @classdesc Represents a ConsensusParams.
         * @implements IConsensusParams
         * @constructor
         * @param {tendermint.types.IConsensusParams=} [properties] Properties to set
         */
        function ConsensusParams(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * ConsensusParams block.
         * @member {tendermint.types.IBlockParams|null|undefined} block
         * @memberof tendermint.types.ConsensusParams
         * @instance
         */
        ConsensusParams.prototype.block = null;

        /**
         * ConsensusParams evidence.
         * @member {tendermint.types.IEvidenceParams|null|undefined} evidence
         * @memberof tendermint.types.ConsensusParams
         * @instance
         */
        ConsensusParams.prototype.evidence = null;

        /**
         * ConsensusParams validator.
         * @member {tendermint.types.IValidatorParams|null|undefined} validator
         * @memberof tendermint.types.ConsensusParams
         * @instance
         */
        ConsensusParams.prototype.validator = null;

        /**
         * ConsensusParams version.
         * @member {tendermint.types.IVersionParams|null|undefined} version
         * @memberof tendermint.types.ConsensusParams
         * @instance
         */
        ConsensusParams.prototype.version = null;

        /**
         * Creates a new ConsensusParams instance using the specified properties.
         * @function create
         * @memberof tendermint.types.ConsensusParams
         * @static
         * @param {tendermint.types.IConsensusParams=} [properties] Properties to set
         * @returns {tendermint.types.ConsensusParams} ConsensusParams instance
         */
        ConsensusParams.create = function create(properties) {
          return new ConsensusParams(properties);
        };

        /**
         * Encodes the specified ConsensusParams message. Does not implicitly {@link tendermint.types.ConsensusParams.verify|verify} messages.
         * @function encode
         * @memberof tendermint.types.ConsensusParams
         * @static
         * @param {tendermint.types.IConsensusParams} message ConsensusParams message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ConsensusParams.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.block != null && Object.hasOwnProperty.call(message, "block"))
            $root.tendermint.types.BlockParams.encode(
              message.block,
              writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
            ).ldelim();
          if (message.evidence != null && Object.hasOwnProperty.call(message, "evidence"))
            $root.tendermint.types.EvidenceParams.encode(
              message.evidence,
              writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
            ).ldelim();
          if (message.validator != null && Object.hasOwnProperty.call(message, "validator"))
            $root.tendermint.types.ValidatorParams.encode(
              message.validator,
              writer.uint32(/* id 3, wireType 2 =*/ 26).fork(),
            ).ldelim();
          if (message.version != null && Object.hasOwnProperty.call(message, "version"))
            $root.tendermint.types.VersionParams.encode(
              message.version,
              writer.uint32(/* id 4, wireType 2 =*/ 34).fork(),
            ).ldelim();
          return writer;
        };

        /**
         * Encodes the specified ConsensusParams message, length delimited. Does not implicitly {@link tendermint.types.ConsensusParams.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tendermint.types.ConsensusParams
         * @static
         * @param {tendermint.types.IConsensusParams} message ConsensusParams message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ConsensusParams.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ConsensusParams message from the specified reader or buffer.
         * @function decode
         * @memberof tendermint.types.ConsensusParams
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tendermint.types.ConsensusParams} ConsensusParams
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ConsensusParams.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.tendermint.types.ConsensusParams();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.block = $root.tendermint.types.BlockParams.decode(reader, reader.uint32());
                break;
              case 2:
                message.evidence = $root.tendermint.types.EvidenceParams.decode(reader, reader.uint32());
                break;
              case 3:
                message.validator = $root.tendermint.types.ValidatorParams.decode(reader, reader.uint32());
                break;
              case 4:
                message.version = $root.tendermint.types.VersionParams.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a ConsensusParams message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tendermint.types.ConsensusParams
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tendermint.types.ConsensusParams} ConsensusParams
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ConsensusParams.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ConsensusParams message.
         * @function verify
         * @memberof tendermint.types.ConsensusParams
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ConsensusParams.verify = function verify(message) {
          if (typeof message !== "object" || message === null) return "object expected";
          if (message.block != null && message.hasOwnProperty("block")) {
            var error = $root.tendermint.types.BlockParams.verify(message.block);
            if (error) return "block." + error;
          }
          if (message.evidence != null && message.hasOwnProperty("evidence")) {
            var error = $root.tendermint.types.EvidenceParams.verify(message.evidence);
            if (error) return "evidence." + error;
          }
          if (message.validator != null && message.hasOwnProperty("validator")) {
            var error = $root.tendermint.types.ValidatorParams.verify(message.validator);
            if (error) return "validator." + error;
          }
          if (message.version != null && message.hasOwnProperty("version")) {
            var error = $root.tendermint.types.VersionParams.verify(message.version);
            if (error) return "version." + error;
          }
          return null;
        };

        /**
         * Creates a ConsensusParams message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tendermint.types.ConsensusParams
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tendermint.types.ConsensusParams} ConsensusParams
         */
        ConsensusParams.fromObject = function fromObject(object) {
          if (object instanceof $root.tendermint.types.ConsensusParams) return object;
          var message = new $root.tendermint.types.ConsensusParams();
          if (object.block != null) {
            if (typeof object.block !== "object")
              throw TypeError(".tendermint.types.ConsensusParams.block: object expected");
            message.block = $root.tendermint.types.BlockParams.fromObject(object.block);
          }
          if (object.evidence != null) {
            if (typeof object.evidence !== "object")
              throw TypeError(".tendermint.types.ConsensusParams.evidence: object expected");
            message.evidence = $root.tendermint.types.EvidenceParams.fromObject(object.evidence);
          }
          if (object.validator != null) {
            if (typeof object.validator !== "object")
              throw TypeError(".tendermint.types.ConsensusParams.validator: object expected");
            message.validator = $root.tendermint.types.ValidatorParams.fromObject(object.validator);
          }
          if (object.version != null) {
            if (typeof object.version !== "object")
              throw TypeError(".tendermint.types.ConsensusParams.version: object expected");
            message.version = $root.tendermint.types.VersionParams.fromObject(object.version);
          }
          return message;
        };

        /**
         * Creates a plain object from a ConsensusParams message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tendermint.types.ConsensusParams
         * @static
         * @param {tendermint.types.ConsensusParams} message ConsensusParams
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ConsensusParams.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.block = null;
            object.evidence = null;
            object.validator = null;
            object.version = null;
          }
          if (message.block != null && message.hasOwnProperty("block"))
            object.block = $root.tendermint.types.BlockParams.toObject(message.block, options);
          if (message.evidence != null && message.hasOwnProperty("evidence"))
            object.evidence = $root.tendermint.types.EvidenceParams.toObject(message.evidence, options);
          if (message.validator != null && message.hasOwnProperty("validator"))
            object.validator = $root.tendermint.types.ValidatorParams.toObject(message.validator, options);
          if (message.version != null && message.hasOwnProperty("version"))
            object.version = $root.tendermint.types.VersionParams.toObject(message.version, options);
          return object;
        };

        /**
         * Converts this ConsensusParams to JSON.
         * @function toJSON
         * @memberof tendermint.types.ConsensusParams
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ConsensusParams.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ConsensusParams;
      })();

      types.BlockParams = (function () {
        /**
         * Properties of a BlockParams.
         * @memberof tendermint.types
         * @interface IBlockParams
         * @property {number|Long|null} [maxBytes] BlockParams maxBytes
         * @property {number|Long|null} [maxGas] BlockParams maxGas
         * @property {number|Long|null} [timeIotaMs] BlockParams timeIotaMs
         */

        /**
         * Constructs a new BlockParams.
         * @memberof tendermint.types
         * @classdesc Represents a BlockParams.
         * @implements IBlockParams
         * @constructor
         * @param {tendermint.types.IBlockParams=} [properties] Properties to set
         */
        function BlockParams(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * BlockParams maxBytes.
         * @member {number|Long} maxBytes
         * @memberof tendermint.types.BlockParams
         * @instance
         */
        BlockParams.prototype.maxBytes = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * BlockParams maxGas.
         * @member {number|Long} maxGas
         * @memberof tendermint.types.BlockParams
         * @instance
         */
        BlockParams.prototype.maxGas = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * BlockParams timeIotaMs.
         * @member {number|Long} timeIotaMs
         * @memberof tendermint.types.BlockParams
         * @instance
         */
        BlockParams.prototype.timeIotaMs = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * Creates a new BlockParams instance using the specified properties.
         * @function create
         * @memberof tendermint.types.BlockParams
         * @static
         * @param {tendermint.types.IBlockParams=} [properties] Properties to set
         * @returns {tendermint.types.BlockParams} BlockParams instance
         */
        BlockParams.create = function create(properties) {
          return new BlockParams(properties);
        };

        /**
         * Encodes the specified BlockParams message. Does not implicitly {@link tendermint.types.BlockParams.verify|verify} messages.
         * @function encode
         * @memberof tendermint.types.BlockParams
         * @static
         * @param {tendermint.types.IBlockParams} message BlockParams message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BlockParams.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.maxBytes != null && Object.hasOwnProperty.call(message, "maxBytes"))
            writer.uint32(/* id 1, wireType 0 =*/ 8).int64(message.maxBytes);
          if (message.maxGas != null && Object.hasOwnProperty.call(message, "maxGas"))
            writer.uint32(/* id 2, wireType 0 =*/ 16).int64(message.maxGas);
          if (message.timeIotaMs != null && Object.hasOwnProperty.call(message, "timeIotaMs"))
            writer.uint32(/* id 3, wireType 0 =*/ 24).int64(message.timeIotaMs);
          return writer;
        };

        /**
         * Encodes the specified BlockParams message, length delimited. Does not implicitly {@link tendermint.types.BlockParams.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tendermint.types.BlockParams
         * @static
         * @param {tendermint.types.IBlockParams} message BlockParams message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BlockParams.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BlockParams message from the specified reader or buffer.
         * @function decode
         * @memberof tendermint.types.BlockParams
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tendermint.types.BlockParams} BlockParams
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BlockParams.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.tendermint.types.BlockParams();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.maxBytes = reader.int64();
                break;
              case 2:
                message.maxGas = reader.int64();
                break;
              case 3:
                message.timeIotaMs = reader.int64();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a BlockParams message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tendermint.types.BlockParams
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tendermint.types.BlockParams} BlockParams
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BlockParams.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BlockParams message.
         * @function verify
         * @memberof tendermint.types.BlockParams
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BlockParams.verify = function verify(message) {
          if (typeof message !== "object" || message === null) return "object expected";
          if (message.maxBytes != null && message.hasOwnProperty("maxBytes"))
            if (
              !$util.isInteger(message.maxBytes) &&
              !(
                message.maxBytes &&
                $util.isInteger(message.maxBytes.low) &&
                $util.isInteger(message.maxBytes.high)
              )
            )
              return "maxBytes: integer|Long expected";
          if (message.maxGas != null && message.hasOwnProperty("maxGas"))
            if (
              !$util.isInteger(message.maxGas) &&
              !(message.maxGas && $util.isInteger(message.maxGas.low) && $util.isInteger(message.maxGas.high))
            )
              return "maxGas: integer|Long expected";
          if (message.timeIotaMs != null && message.hasOwnProperty("timeIotaMs"))
            if (
              !$util.isInteger(message.timeIotaMs) &&
              !(
                message.timeIotaMs &&
                $util.isInteger(message.timeIotaMs.low) &&
                $util.isInteger(message.timeIotaMs.high)
              )
            )
              return "timeIotaMs: integer|Long expected";
          return null;
        };

        /**
         * Creates a BlockParams message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tendermint.types.BlockParams
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tendermint.types.BlockParams} BlockParams
         */
        BlockParams.fromObject = function fromObject(object) {
          if (object instanceof $root.tendermint.types.BlockParams) return object;
          var message = new $root.tendermint.types.BlockParams();
          if (object.maxBytes != null)
            if ($util.Long) (message.maxBytes = $util.Long.fromValue(object.maxBytes)).unsigned = false;
            else if (typeof object.maxBytes === "string") message.maxBytes = parseInt(object.maxBytes, 10);
            else if (typeof object.maxBytes === "number") message.maxBytes = object.maxBytes;
            else if (typeof object.maxBytes === "object")
              message.maxBytes = new $util.LongBits(
                object.maxBytes.low >>> 0,
                object.maxBytes.high >>> 0,
              ).toNumber();
          if (object.maxGas != null)
            if ($util.Long) (message.maxGas = $util.Long.fromValue(object.maxGas)).unsigned = false;
            else if (typeof object.maxGas === "string") message.maxGas = parseInt(object.maxGas, 10);
            else if (typeof object.maxGas === "number") message.maxGas = object.maxGas;
            else if (typeof object.maxGas === "object")
              message.maxGas = new $util.LongBits(
                object.maxGas.low >>> 0,
                object.maxGas.high >>> 0,
              ).toNumber();
          if (object.timeIotaMs != null)
            if ($util.Long) (message.timeIotaMs = $util.Long.fromValue(object.timeIotaMs)).unsigned = false;
            else if (typeof object.timeIotaMs === "string")
              message.timeIotaMs = parseInt(object.timeIotaMs, 10);
            else if (typeof object.timeIotaMs === "number") message.timeIotaMs = object.timeIotaMs;
            else if (typeof object.timeIotaMs === "object")
              message.timeIotaMs = new $util.LongBits(
                object.timeIotaMs.low >>> 0,
                object.timeIotaMs.high >>> 0,
              ).toNumber();
          return message;
        };

        /**
         * Creates a plain object from a BlockParams message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tendermint.types.BlockParams
         * @static
         * @param {tendermint.types.BlockParams} message BlockParams
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BlockParams.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            if ($util.Long) {
              var long = new $util.Long(0, 0, false);
              object.maxBytes =
                options.longs === String
                  ? long.toString()
                  : options.longs === Number
                  ? long.toNumber()
                  : long;
            } else object.maxBytes = options.longs === String ? "0" : 0;
            if ($util.Long) {
              var long = new $util.Long(0, 0, false);
              object.maxGas =
                options.longs === String
                  ? long.toString()
                  : options.longs === Number
                  ? long.toNumber()
                  : long;
            } else object.maxGas = options.longs === String ? "0" : 0;
            if ($util.Long) {
              var long = new $util.Long(0, 0, false);
              object.timeIotaMs =
                options.longs === String
                  ? long.toString()
                  : options.longs === Number
                  ? long.toNumber()
                  : long;
            } else object.timeIotaMs = options.longs === String ? "0" : 0;
          }
          if (message.maxBytes != null && message.hasOwnProperty("maxBytes"))
            if (typeof message.maxBytes === "number")
              object.maxBytes = options.longs === String ? String(message.maxBytes) : message.maxBytes;
            else
              object.maxBytes =
                options.longs === String
                  ? $util.Long.prototype.toString.call(message.maxBytes)
                  : options.longs === Number
                  ? new $util.LongBits(message.maxBytes.low >>> 0, message.maxBytes.high >>> 0).toNumber()
                  : message.maxBytes;
          if (message.maxGas != null && message.hasOwnProperty("maxGas"))
            if (typeof message.maxGas === "number")
              object.maxGas = options.longs === String ? String(message.maxGas) : message.maxGas;
            else
              object.maxGas =
                options.longs === String
                  ? $util.Long.prototype.toString.call(message.maxGas)
                  : options.longs === Number
                  ? new $util.LongBits(message.maxGas.low >>> 0, message.maxGas.high >>> 0).toNumber()
                  : message.maxGas;
          if (message.timeIotaMs != null && message.hasOwnProperty("timeIotaMs"))
            if (typeof message.timeIotaMs === "number")
              object.timeIotaMs = options.longs === String ? String(message.timeIotaMs) : message.timeIotaMs;
            else
              object.timeIotaMs =
                options.longs === String
                  ? $util.Long.prototype.toString.call(message.timeIotaMs)
                  : options.longs === Number
                  ? new $util.LongBits(message.timeIotaMs.low >>> 0, message.timeIotaMs.high >>> 0).toNumber()
                  : message.timeIotaMs;
          return object;
        };

        /**
         * Converts this BlockParams to JSON.
         * @function toJSON
         * @memberof tendermint.types.BlockParams
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BlockParams.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BlockParams;
      })();

      types.EvidenceParams = (function () {
        /**
         * Properties of an EvidenceParams.
         * @memberof tendermint.types
         * @interface IEvidenceParams
         * @property {number|Long|null} [maxAgeNumBlocks] EvidenceParams maxAgeNumBlocks
         * @property {google.protobuf.IDuration|null} [maxAgeDuration] EvidenceParams maxAgeDuration
         * @property {number|Long|null} [maxBytes] EvidenceParams maxBytes
         */

        /**
         * Constructs a new EvidenceParams.
         * @memberof tendermint.types
         * @classdesc Represents an EvidenceParams.
         * @implements IEvidenceParams
         * @constructor
         * @param {tendermint.types.IEvidenceParams=} [properties] Properties to set
         */
        function EvidenceParams(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * EvidenceParams maxAgeNumBlocks.
         * @member {number|Long} maxAgeNumBlocks
         * @memberof tendermint.types.EvidenceParams
         * @instance
         */
        EvidenceParams.prototype.maxAgeNumBlocks = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * EvidenceParams maxAgeDuration.
         * @member {google.protobuf.IDuration|null|undefined} maxAgeDuration
         * @memberof tendermint.types.EvidenceParams
         * @instance
         */
        EvidenceParams.prototype.maxAgeDuration = null;

        /**
         * EvidenceParams maxBytes.
         * @member {number|Long} maxBytes
         * @memberof tendermint.types.EvidenceParams
         * @instance
         */
        EvidenceParams.prototype.maxBytes = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * Creates a new EvidenceParams instance using the specified properties.
         * @function create
         * @memberof tendermint.types.EvidenceParams
         * @static
         * @param {tendermint.types.IEvidenceParams=} [properties] Properties to set
         * @returns {tendermint.types.EvidenceParams} EvidenceParams instance
         */
        EvidenceParams.create = function create(properties) {
          return new EvidenceParams(properties);
        };

        /**
         * Encodes the specified EvidenceParams message. Does not implicitly {@link tendermint.types.EvidenceParams.verify|verify} messages.
         * @function encode
         * @memberof tendermint.types.EvidenceParams
         * @static
         * @param {tendermint.types.IEvidenceParams} message EvidenceParams message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EvidenceParams.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.maxAgeNumBlocks != null && Object.hasOwnProperty.call(message, "maxAgeNumBlocks"))
            writer.uint32(/* id 1, wireType 0 =*/ 8).int64(message.maxAgeNumBlocks);
          if (message.maxAgeDuration != null && Object.hasOwnProperty.call(message, "maxAgeDuration"))
            $root.google.protobuf.Duration.encode(
              message.maxAgeDuration,
              writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
            ).ldelim();
          if (message.maxBytes != null && Object.hasOwnProperty.call(message, "maxBytes"))
            writer.uint32(/* id 3, wireType 0 =*/ 24).int64(message.maxBytes);
          return writer;
        };

        /**
         * Encodes the specified EvidenceParams message, length delimited. Does not implicitly {@link tendermint.types.EvidenceParams.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tendermint.types.EvidenceParams
         * @static
         * @param {tendermint.types.IEvidenceParams} message EvidenceParams message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EvidenceParams.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EvidenceParams message from the specified reader or buffer.
         * @function decode
         * @memberof tendermint.types.EvidenceParams
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tendermint.types.EvidenceParams} EvidenceParams
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EvidenceParams.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.tendermint.types.EvidenceParams();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.maxAgeNumBlocks = reader.int64();
                break;
              case 2:
                message.maxAgeDuration = $root.google.protobuf.Duration.decode(reader, reader.uint32());
                break;
              case 3:
                message.maxBytes = reader.int64();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes an EvidenceParams message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tendermint.types.EvidenceParams
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tendermint.types.EvidenceParams} EvidenceParams
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EvidenceParams.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EvidenceParams message.
         * @function verify
         * @memberof tendermint.types.EvidenceParams
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EvidenceParams.verify = function verify(message) {
          if (typeof message !== "object" || message === null) return "object expected";
          if (message.maxAgeNumBlocks != null && message.hasOwnProperty("maxAgeNumBlocks"))
            if (
              !$util.isInteger(message.maxAgeNumBlocks) &&
              !(
                message.maxAgeNumBlocks &&
                $util.isInteger(message.maxAgeNumBlocks.low) &&
                $util.isInteger(message.maxAgeNumBlocks.high)
              )
            )
              return "maxAgeNumBlocks: integer|Long expected";
          if (message.maxAgeDuration != null && message.hasOwnProperty("maxAgeDuration")) {
            var error = $root.google.protobuf.Duration.verify(message.maxAgeDuration);
            if (error) return "maxAgeDuration." + error;
          }
          if (message.maxBytes != null && message.hasOwnProperty("maxBytes"))
            if (
              !$util.isInteger(message.maxBytes) &&
              !(
                message.maxBytes &&
                $util.isInteger(message.maxBytes.low) &&
                $util.isInteger(message.maxBytes.high)
              )
            )
              return "maxBytes: integer|Long expected";
          return null;
        };

        /**
         * Creates an EvidenceParams message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tendermint.types.EvidenceParams
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tendermint.types.EvidenceParams} EvidenceParams
         */
        EvidenceParams.fromObject = function fromObject(object) {
          if (object instanceof $root.tendermint.types.EvidenceParams) return object;
          var message = new $root.tendermint.types.EvidenceParams();
          if (object.maxAgeNumBlocks != null)
            if ($util.Long)
              (message.maxAgeNumBlocks = $util.Long.fromValue(object.maxAgeNumBlocks)).unsigned = false;
            else if (typeof object.maxAgeNumBlocks === "string")
              message.maxAgeNumBlocks = parseInt(object.maxAgeNumBlocks, 10);
            else if (typeof object.maxAgeNumBlocks === "number")
              message.maxAgeNumBlocks = object.maxAgeNumBlocks;
            else if (typeof object.maxAgeNumBlocks === "object")
              message.maxAgeNumBlocks = new $util.LongBits(
                object.maxAgeNumBlocks.low >>> 0,
                object.maxAgeNumBlocks.high >>> 0,
              ).toNumber();
          if (object.maxAgeDuration != null) {
            if (typeof object.maxAgeDuration !== "object")
              throw TypeError(".tendermint.types.EvidenceParams.maxAgeDuration: object expected");
            message.maxAgeDuration = $root.google.protobuf.Duration.fromObject(object.maxAgeDuration);
          }
          if (object.maxBytes != null)
            if ($util.Long) (message.maxBytes = $util.Long.fromValue(object.maxBytes)).unsigned = false;
            else if (typeof object.maxBytes === "string") message.maxBytes = parseInt(object.maxBytes, 10);
            else if (typeof object.maxBytes === "number") message.maxBytes = object.maxBytes;
            else if (typeof object.maxBytes === "object")
              message.maxBytes = new $util.LongBits(
                object.maxBytes.low >>> 0,
                object.maxBytes.high >>> 0,
              ).toNumber();
          return message;
        };

        /**
         * Creates a plain object from an EvidenceParams message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tendermint.types.EvidenceParams
         * @static
         * @param {tendermint.types.EvidenceParams} message EvidenceParams
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EvidenceParams.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            if ($util.Long) {
              var long = new $util.Long(0, 0, false);
              object.maxAgeNumBlocks =
                options.longs === String
                  ? long.toString()
                  : options.longs === Number
                  ? long.toNumber()
                  : long;
            } else object.maxAgeNumBlocks = options.longs === String ? "0" : 0;
            object.maxAgeDuration = null;
            if ($util.Long) {
              var long = new $util.Long(0, 0, false);
              object.maxBytes =
                options.longs === String
                  ? long.toString()
                  : options.longs === Number
                  ? long.toNumber()
                  : long;
            } else object.maxBytes = options.longs === String ? "0" : 0;
          }
          if (message.maxAgeNumBlocks != null && message.hasOwnProperty("maxAgeNumBlocks"))
            if (typeof message.maxAgeNumBlocks === "number")
              object.maxAgeNumBlocks =
                options.longs === String ? String(message.maxAgeNumBlocks) : message.maxAgeNumBlocks;
            else
              object.maxAgeNumBlocks =
                options.longs === String
                  ? $util.Long.prototype.toString.call(message.maxAgeNumBlocks)
                  : options.longs === Number
                  ? new $util.LongBits(
                      message.maxAgeNumBlocks.low >>> 0,
                      message.maxAgeNumBlocks.high >>> 0,
                    ).toNumber()
                  : message.maxAgeNumBlocks;
          if (message.maxAgeDuration != null && message.hasOwnProperty("maxAgeDuration"))
            object.maxAgeDuration = $root.google.protobuf.Duration.toObject(message.maxAgeDuration, options);
          if (message.maxBytes != null && message.hasOwnProperty("maxBytes"))
            if (typeof message.maxBytes === "number")
              object.maxBytes = options.longs === String ? String(message.maxBytes) : message.maxBytes;
            else
              object.maxBytes =
                options.longs === String
                  ? $util.Long.prototype.toString.call(message.maxBytes)
                  : options.longs === Number
                  ? new $util.LongBits(message.maxBytes.low >>> 0, message.maxBytes.high >>> 0).toNumber()
                  : message.maxBytes;
          return object;
        };

        /**
         * Converts this EvidenceParams to JSON.
         * @function toJSON
         * @memberof tendermint.types.EvidenceParams
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EvidenceParams.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return EvidenceParams;
      })();

      types.ValidatorParams = (function () {
        /**
         * Properties of a ValidatorParams.
         * @memberof tendermint.types
         * @interface IValidatorParams
         * @property {Array.<string>|null} [pubKeyTypes] ValidatorParams pubKeyTypes
         */

        /**
         * Constructs a new ValidatorParams.
         * @memberof tendermint.types
         * @classdesc Represents a ValidatorParams.
         * @implements IValidatorParams
         * @constructor
         * @param {tendermint.types.IValidatorParams=} [properties] Properties to set
         */
        function ValidatorParams(properties) {
          this.pubKeyTypes = [];
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * ValidatorParams pubKeyTypes.
         * @member {Array.<string>} pubKeyTypes
         * @memberof tendermint.types.ValidatorParams
         * @instance
         */
        ValidatorParams.prototype.pubKeyTypes = $util.emptyArray;

        /**
         * Creates a new ValidatorParams instance using the specified properties.
         * @function create
         * @memberof tendermint.types.ValidatorParams
         * @static
         * @param {tendermint.types.IValidatorParams=} [properties] Properties to set
         * @returns {tendermint.types.ValidatorParams} ValidatorParams instance
         */
        ValidatorParams.create = function create(properties) {
          return new ValidatorParams(properties);
        };

        /**
         * Encodes the specified ValidatorParams message. Does not implicitly {@link tendermint.types.ValidatorParams.verify|verify} messages.
         * @function encode
         * @memberof tendermint.types.ValidatorParams
         * @static
         * @param {tendermint.types.IValidatorParams} message ValidatorParams message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ValidatorParams.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.pubKeyTypes != null && message.pubKeyTypes.length)
            for (var i = 0; i < message.pubKeyTypes.length; ++i)
              writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.pubKeyTypes[i]);
          return writer;
        };

        /**
         * Encodes the specified ValidatorParams message, length delimited. Does not implicitly {@link tendermint.types.ValidatorParams.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tendermint.types.ValidatorParams
         * @static
         * @param {tendermint.types.IValidatorParams} message ValidatorParams message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ValidatorParams.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ValidatorParams message from the specified reader or buffer.
         * @function decode
         * @memberof tendermint.types.ValidatorParams
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tendermint.types.ValidatorParams} ValidatorParams
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ValidatorParams.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.tendermint.types.ValidatorParams();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                if (!(message.pubKeyTypes && message.pubKeyTypes.length)) message.pubKeyTypes = [];
                message.pubKeyTypes.push(reader.string());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a ValidatorParams message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tendermint.types.ValidatorParams
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tendermint.types.ValidatorParams} ValidatorParams
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ValidatorParams.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ValidatorParams message.
         * @function verify
         * @memberof tendermint.types.ValidatorParams
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ValidatorParams.verify = function verify(message) {
          if (typeof message !== "object" || message === null) return "object expected";
          if (message.pubKeyTypes != null && message.hasOwnProperty("pubKeyTypes")) {
            if (!Array.isArray(message.pubKeyTypes)) return "pubKeyTypes: array expected";
            for (var i = 0; i < message.pubKeyTypes.length; ++i)
              if (!$util.isString(message.pubKeyTypes[i])) return "pubKeyTypes: string[] expected";
          }
          return null;
        };

        /**
         * Creates a ValidatorParams message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tendermint.types.ValidatorParams
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tendermint.types.ValidatorParams} ValidatorParams
         */
        ValidatorParams.fromObject = function fromObject(object) {
          if (object instanceof $root.tendermint.types.ValidatorParams) return object;
          var message = new $root.tendermint.types.ValidatorParams();
          if (object.pubKeyTypes) {
            if (!Array.isArray(object.pubKeyTypes))
              throw TypeError(".tendermint.types.ValidatorParams.pubKeyTypes: array expected");
            message.pubKeyTypes = [];
            for (var i = 0; i < object.pubKeyTypes.length; ++i)
              message.pubKeyTypes[i] = String(object.pubKeyTypes[i]);
          }
          return message;
        };

        /**
         * Creates a plain object from a ValidatorParams message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tendermint.types.ValidatorParams
         * @static
         * @param {tendermint.types.ValidatorParams} message ValidatorParams
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ValidatorParams.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.arrays || options.defaults) object.pubKeyTypes = [];
          if (message.pubKeyTypes && message.pubKeyTypes.length) {
            object.pubKeyTypes = [];
            for (var j = 0; j < message.pubKeyTypes.length; ++j)
              object.pubKeyTypes[j] = message.pubKeyTypes[j];
          }
          return object;
        };

        /**
         * Converts this ValidatorParams to JSON.
         * @function toJSON
         * @memberof tendermint.types.ValidatorParams
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ValidatorParams.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ValidatorParams;
      })();

      types.VersionParams = (function () {
        /**
         * Properties of a VersionParams.
         * @memberof tendermint.types
         * @interface IVersionParams
         * @property {number|Long|null} [appVersion] VersionParams appVersion
         */

        /**
         * Constructs a new VersionParams.
         * @memberof tendermint.types
         * @classdesc Represents a VersionParams.
         * @implements IVersionParams
         * @constructor
         * @param {tendermint.types.IVersionParams=} [properties] Properties to set
         */
        function VersionParams(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * VersionParams appVersion.
         * @member {number|Long} appVersion
         * @memberof tendermint.types.VersionParams
         * @instance
         */
        VersionParams.prototype.appVersion = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

        /**
         * Creates a new VersionParams instance using the specified properties.
         * @function create
         * @memberof tendermint.types.VersionParams
         * @static
         * @param {tendermint.types.IVersionParams=} [properties] Properties to set
         * @returns {tendermint.types.VersionParams} VersionParams instance
         */
        VersionParams.create = function create(properties) {
          return new VersionParams(properties);
        };

        /**
         * Encodes the specified VersionParams message. Does not implicitly {@link tendermint.types.VersionParams.verify|verify} messages.
         * @function encode
         * @memberof tendermint.types.VersionParams
         * @static
         * @param {tendermint.types.IVersionParams} message VersionParams message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VersionParams.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.appVersion != null && Object.hasOwnProperty.call(message, "appVersion"))
            writer.uint32(/* id 1, wireType 0 =*/ 8).uint64(message.appVersion);
          return writer;
        };

        /**
         * Encodes the specified VersionParams message, length delimited. Does not implicitly {@link tendermint.types.VersionParams.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tendermint.types.VersionParams
         * @static
         * @param {tendermint.types.IVersionParams} message VersionParams message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VersionParams.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a VersionParams message from the specified reader or buffer.
         * @function decode
         * @memberof tendermint.types.VersionParams
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tendermint.types.VersionParams} VersionParams
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VersionParams.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.tendermint.types.VersionParams();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.appVersion = reader.uint64();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a VersionParams message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tendermint.types.VersionParams
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tendermint.types.VersionParams} VersionParams
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VersionParams.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a VersionParams message.
         * @function verify
         * @memberof tendermint.types.VersionParams
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        VersionParams.verify = function verify(message) {
          if (typeof message !== "object" || message === null) return "object expected";
          if (message.appVersion != null && message.hasOwnProperty("appVersion"))
            if (
              !$util.isInteger(message.appVersion) &&
              !(
                message.appVersion &&
                $util.isInteger(message.appVersion.low) &&
                $util.isInteger(message.appVersion.high)
              )
            )
              return "appVersion: integer|Long expected";
          return null;
        };

        /**
         * Creates a VersionParams message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tendermint.types.VersionParams
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tendermint.types.VersionParams} VersionParams
         */
        VersionParams.fromObject = function fromObject(object) {
          if (object instanceof $root.tendermint.types.VersionParams) return object;
          var message = new $root.tendermint.types.VersionParams();
          if (object.appVersion != null)
            if ($util.Long) (message.appVersion = $util.Long.fromValue(object.appVersion)).unsigned = true;
            else if (typeof object.appVersion === "string")
              message.appVersion = parseInt(object.appVersion, 10);
            else if (typeof object.appVersion === "number") message.appVersion = object.appVersion;
            else if (typeof object.appVersion === "object")
              message.appVersion = new $util.LongBits(
                object.appVersion.low >>> 0,
                object.appVersion.high >>> 0,
              ).toNumber(true);
          return message;
        };

        /**
         * Creates a plain object from a VersionParams message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tendermint.types.VersionParams
         * @static
         * @param {tendermint.types.VersionParams} message VersionParams
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        VersionParams.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults)
            if ($util.Long) {
              var long = new $util.Long(0, 0, true);
              object.appVersion =
                options.longs === String
                  ? long.toString()
                  : options.longs === Number
                  ? long.toNumber()
                  : long;
            } else object.appVersion = options.longs === String ? "0" : 0;
          if (message.appVersion != null && message.hasOwnProperty("appVersion"))
            if (typeof message.appVersion === "number")
              object.appVersion = options.longs === String ? String(message.appVersion) : message.appVersion;
            else
              object.appVersion =
                options.longs === String
                  ? $util.Long.prototype.toString.call(message.appVersion)
                  : options.longs === Number
                  ? new $util.LongBits(message.appVersion.low >>> 0, message.appVersion.high >>> 0).toNumber(
                      true,
                    )
                  : message.appVersion;
          return object;
        };

        /**
         * Converts this VersionParams to JSON.
         * @function toJSON
         * @memberof tendermint.types.VersionParams
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        VersionParams.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return VersionParams;
      })();

      types.HashedParams = (function () {
        /**
         * Properties of a HashedParams.
         * @memberof tendermint.types
         * @interface IHashedParams
         * @property {number|Long|null} [blockMaxBytes] HashedParams blockMaxBytes
         * @property {number|Long|null} [blockMaxGas] HashedParams blockMaxGas
         */

        /**
         * Constructs a new HashedParams.
         * @memberof tendermint.types
         * @classdesc Represents a HashedParams.
         * @implements IHashedParams
         * @constructor
         * @param {tendermint.types.IHashedParams=} [properties] Properties to set
         */
        function HashedParams(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * HashedParams blockMaxBytes.
         * @member {number|Long} blockMaxBytes
         * @memberof tendermint.types.HashedParams
         * @instance
         */
        HashedParams.prototype.blockMaxBytes = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * HashedParams blockMaxGas.
         * @member {number|Long} blockMaxGas
         * @memberof tendermint.types.HashedParams
         * @instance
         */
        HashedParams.prototype.blockMaxGas = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * Creates a new HashedParams instance using the specified properties.
         * @function create
         * @memberof tendermint.types.HashedParams
         * @static
         * @param {tendermint.types.IHashedParams=} [properties] Properties to set
         * @returns {tendermint.types.HashedParams} HashedParams instance
         */
        HashedParams.create = function create(properties) {
          return new HashedParams(properties);
        };

        /**
         * Encodes the specified HashedParams message. Does not implicitly {@link tendermint.types.HashedParams.verify|verify} messages.
         * @function encode
         * @memberof tendermint.types.HashedParams
         * @static
         * @param {tendermint.types.IHashedParams} message HashedParams message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HashedParams.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.blockMaxBytes != null && Object.hasOwnProperty.call(message, "blockMaxBytes"))
            writer.uint32(/* id 1, wireType 0 =*/ 8).int64(message.blockMaxBytes);
          if (message.blockMaxGas != null && Object.hasOwnProperty.call(message, "blockMaxGas"))
            writer.uint32(/* id 2, wireType 0 =*/ 16).int64(message.blockMaxGas);
          return writer;
        };

        /**
         * Encodes the specified HashedParams message, length delimited. Does not implicitly {@link tendermint.types.HashedParams.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tendermint.types.HashedParams
         * @static
         * @param {tendermint.types.IHashedParams} message HashedParams message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HashedParams.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a HashedParams message from the specified reader or buffer.
         * @function decode
         * @memberof tendermint.types.HashedParams
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tendermint.types.HashedParams} HashedParams
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HashedParams.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.tendermint.types.HashedParams();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.blockMaxBytes = reader.int64();
                break;
              case 2:
                message.blockMaxGas = reader.int64();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a HashedParams message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tendermint.types.HashedParams
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tendermint.types.HashedParams} HashedParams
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HashedParams.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a HashedParams message.
         * @function verify
         * @memberof tendermint.types.HashedParams
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        HashedParams.verify = function verify(message) {
          if (typeof message !== "object" || message === null) return "object expected";
          if (message.blockMaxBytes != null && message.hasOwnProperty("blockMaxBytes"))
            if (
              !$util.isInteger(message.blockMaxBytes) &&
              !(
                message.blockMaxBytes &&
                $util.isInteger(message.blockMaxBytes.low) &&
                $util.isInteger(message.blockMaxBytes.high)
              )
            )
              return "blockMaxBytes: integer|Long expected";
          if (message.blockMaxGas != null && message.hasOwnProperty("blockMaxGas"))
            if (
              !$util.isInteger(message.blockMaxGas) &&
              !(
                message.blockMaxGas &&
                $util.isInteger(message.blockMaxGas.low) &&
                $util.isInteger(message.blockMaxGas.high)
              )
            )
              return "blockMaxGas: integer|Long expected";
          return null;
        };

        /**
         * Creates a HashedParams message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tendermint.types.HashedParams
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tendermint.types.HashedParams} HashedParams
         */
        HashedParams.fromObject = function fromObject(object) {
          if (object instanceof $root.tendermint.types.HashedParams) return object;
          var message = new $root.tendermint.types.HashedParams();
          if (object.blockMaxBytes != null)
            if ($util.Long)
              (message.blockMaxBytes = $util.Long.fromValue(object.blockMaxBytes)).unsigned = false;
            else if (typeof object.blockMaxBytes === "string")
              message.blockMaxBytes = parseInt(object.blockMaxBytes, 10);
            else if (typeof object.blockMaxBytes === "number") message.blockMaxBytes = object.blockMaxBytes;
            else if (typeof object.blockMaxBytes === "object")
              message.blockMaxBytes = new $util.LongBits(
                object.blockMaxBytes.low >>> 0,
                object.blockMaxBytes.high >>> 0,
              ).toNumber();
          if (object.blockMaxGas != null)
            if ($util.Long) (message.blockMaxGas = $util.Long.fromValue(object.blockMaxGas)).unsigned = false;
            else if (typeof object.blockMaxGas === "string")
              message.blockMaxGas = parseInt(object.blockMaxGas, 10);
            else if (typeof object.blockMaxGas === "number") message.blockMaxGas = object.blockMaxGas;
            else if (typeof object.blockMaxGas === "object")
              message.blockMaxGas = new $util.LongBits(
                object.blockMaxGas.low >>> 0,
                object.blockMaxGas.high >>> 0,
              ).toNumber();
          return message;
        };

        /**
         * Creates a plain object from a HashedParams message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tendermint.types.HashedParams
         * @static
         * @param {tendermint.types.HashedParams} message HashedParams
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        HashedParams.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            if ($util.Long) {
              var long = new $util.Long(0, 0, false);
              object.blockMaxBytes =
                options.longs === String
                  ? long.toString()
                  : options.longs === Number
                  ? long.toNumber()
                  : long;
            } else object.blockMaxBytes = options.longs === String ? "0" : 0;
            if ($util.Long) {
              var long = new $util.Long(0, 0, false);
              object.blockMaxGas =
                options.longs === String
                  ? long.toString()
                  : options.longs === Number
                  ? long.toNumber()
                  : long;
            } else object.blockMaxGas = options.longs === String ? "0" : 0;
          }
          if (message.blockMaxBytes != null && message.hasOwnProperty("blockMaxBytes"))
            if (typeof message.blockMaxBytes === "number")
              object.blockMaxBytes =
                options.longs === String ? String(message.blockMaxBytes) : message.blockMaxBytes;
            else
              object.blockMaxBytes =
                options.longs === String
                  ? $util.Long.prototype.toString.call(message.blockMaxBytes)
                  : options.longs === Number
                  ? new $util.LongBits(
                      message.blockMaxBytes.low >>> 0,
                      message.blockMaxBytes.high >>> 0,
                    ).toNumber()
                  : message.blockMaxBytes;
          if (message.blockMaxGas != null && message.hasOwnProperty("blockMaxGas"))
            if (typeof message.blockMaxGas === "number")
              object.blockMaxGas =
                options.longs === String ? String(message.blockMaxGas) : message.blockMaxGas;
            else
              object.blockMaxGas =
                options.longs === String
                  ? $util.Long.prototype.toString.call(message.blockMaxGas)
                  : options.longs === Number
                  ? new $util.LongBits(
                      message.blockMaxGas.low >>> 0,
                      message.blockMaxGas.high >>> 0,
                    ).toNumber()
                  : message.blockMaxGas;
          return object;
        };

        /**
         * Converts this HashedParams to JSON.
         * @function toJSON
         * @memberof tendermint.types.HashedParams
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        HashedParams.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return HashedParams;
      })();

      /**
       * BlockIDFlag enum.
       * @name tendermint.types.BlockIDFlag
       * @enum {number}
       * @property {number} BLOCK_ID_FLAG_UNKNOWN=0 BLOCK_ID_FLAG_UNKNOWN value
       * @property {number} BLOCK_ID_FLAG_ABSENT=1 BLOCK_ID_FLAG_ABSENT value
       * @property {number} BLOCK_ID_FLAG_COMMIT=2 BLOCK_ID_FLAG_COMMIT value
       * @property {number} BLOCK_ID_FLAG_NIL=3 BLOCK_ID_FLAG_NIL value
       */
      types.BlockIDFlag = (function () {
        var valuesById = {},
          values = Object.create(valuesById);
        values[(valuesById[0] = "BLOCK_ID_FLAG_UNKNOWN")] = 0;
        values[(valuesById[1] = "BLOCK_ID_FLAG_ABSENT")] = 1;
        values[(valuesById[2] = "BLOCK_ID_FLAG_COMMIT")] = 2;
        values[(valuesById[3] = "BLOCK_ID_FLAG_NIL")] = 3;
        return values;
      })();

      /**
       * SignedMsgType enum.
       * @name tendermint.types.SignedMsgType
       * @enum {number}
       * @property {number} SIGNED_MSG_TYPE_UNKNOWN=0 SIGNED_MSG_TYPE_UNKNOWN value
       * @property {number} SIGNED_MSG_TYPE_PREVOTE=1 SIGNED_MSG_TYPE_PREVOTE value
       * @property {number} SIGNED_MSG_TYPE_PRECOMMIT=2 SIGNED_MSG_TYPE_PRECOMMIT value
       * @property {number} SIGNED_MSG_TYPE_PROPOSAL=32 SIGNED_MSG_TYPE_PROPOSAL value
       */
      types.SignedMsgType = (function () {
        var valuesById = {},
          values = Object.create(valuesById);
        values[(valuesById[0] = "SIGNED_MSG_TYPE_UNKNOWN")] = 0;
        values[(valuesById[1] = "SIGNED_MSG_TYPE_PREVOTE")] = 1;
        values[(valuesById[2] = "SIGNED_MSG_TYPE_PRECOMMIT")] = 2;
        values[(valuesById[32] = "SIGNED_MSG_TYPE_PROPOSAL")] = 32;
        return values;
      })();

      types.PartSetHeader = (function () {
        /**
         * Properties of a PartSetHeader.
         * @memberof tendermint.types
         * @interface IPartSetHeader
         * @property {number|null} [total] PartSetHeader total
         * @property {Uint8Array|null} [hash] PartSetHeader hash
         */

        /**
         * Constructs a new PartSetHeader.
         * @memberof tendermint.types
         * @classdesc Represents a PartSetHeader.
         * @implements IPartSetHeader
         * @constructor
         * @param {tendermint.types.IPartSetHeader=} [properties] Properties to set
         */
        function PartSetHeader(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * PartSetHeader total.
         * @member {number} total
         * @memberof tendermint.types.PartSetHeader
         * @instance
         */
        PartSetHeader.prototype.total = 0;

        /**
         * PartSetHeader hash.
         * @member {Uint8Array} hash
         * @memberof tendermint.types.PartSetHeader
         * @instance
         */
        PartSetHeader.prototype.hash = $util.newBuffer([]);

        /**
         * Creates a new PartSetHeader instance using the specified properties.
         * @function create
         * @memberof tendermint.types.PartSetHeader
         * @static
         * @param {tendermint.types.IPartSetHeader=} [properties] Properties to set
         * @returns {tendermint.types.PartSetHeader} PartSetHeader instance
         */
        PartSetHeader.create = function create(properties) {
          return new PartSetHeader(properties);
        };

        /**
         * Encodes the specified PartSetHeader message. Does not implicitly {@link tendermint.types.PartSetHeader.verify|verify} messages.
         * @function encode
         * @memberof tendermint.types.PartSetHeader
         * @static
         * @param {tendermint.types.IPartSetHeader} message PartSetHeader message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PartSetHeader.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.total != null && Object.hasOwnProperty.call(message, "total"))
            writer.uint32(/* id 1, wireType 0 =*/ 8).uint32(message.total);
          if (message.hash != null && Object.hasOwnProperty.call(message, "hash"))
            writer.uint32(/* id 2, wireType 2 =*/ 18).bytes(message.hash);
          return writer;
        };

        /**
         * Encodes the specified PartSetHeader message, length delimited. Does not implicitly {@link tendermint.types.PartSetHeader.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tendermint.types.PartSetHeader
         * @static
         * @param {tendermint.types.IPartSetHeader} message PartSetHeader message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PartSetHeader.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PartSetHeader message from the specified reader or buffer.
         * @function decode
         * @memberof tendermint.types.PartSetHeader
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tendermint.types.PartSetHeader} PartSetHeader
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PartSetHeader.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.tendermint.types.PartSetHeader();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.total = reader.uint32();
                break;
              case 2:
                message.hash = reader.bytes();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a PartSetHeader message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tendermint.types.PartSetHeader
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tendermint.types.PartSetHeader} PartSetHeader
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PartSetHeader.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PartSetHeader message.
         * @function verify
         * @memberof tendermint.types.PartSetHeader
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PartSetHeader.verify = function verify(message) {
          if (typeof message !== "object" || message === null) return "object expected";
          if (message.total != null && message.hasOwnProperty("total"))
            if (!$util.isInteger(message.total)) return "total: integer expected";
          if (message.hash != null && message.hasOwnProperty("hash"))
            if (!((message.hash && typeof message.hash.length === "number") || $util.isString(message.hash)))
              return "hash: buffer expected";
          return null;
        };

        /**
         * Creates a PartSetHeader message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tendermint.types.PartSetHeader
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tendermint.types.PartSetHeader} PartSetHeader
         */
        PartSetHeader.fromObject = function fromObject(object) {
          if (object instanceof $root.tendermint.types.PartSetHeader) return object;
          var message = new $root.tendermint.types.PartSetHeader();
          if (object.total != null) message.total = object.total >>> 0;
          if (object.hash != null)
            if (typeof object.hash === "string")
              $util.base64.decode(
                object.hash,
                (message.hash = $util.newBuffer($util.base64.length(object.hash))),
                0,
              );
            else if (object.hash.length) message.hash = object.hash;
          return message;
        };

        /**
         * Creates a plain object from a PartSetHeader message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tendermint.types.PartSetHeader
         * @static
         * @param {tendermint.types.PartSetHeader} message PartSetHeader
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PartSetHeader.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.total = 0;
            if (options.bytes === String) object.hash = "";
            else {
              object.hash = [];
              if (options.bytes !== Array) object.hash = $util.newBuffer(object.hash);
            }
          }
          if (message.total != null && message.hasOwnProperty("total")) object.total = message.total;
          if (message.hash != null && message.hasOwnProperty("hash"))
            object.hash =
              options.bytes === String
                ? $util.base64.encode(message.hash, 0, message.hash.length)
                : options.bytes === Array
                ? Array.prototype.slice.call(message.hash)
                : message.hash;
          return object;
        };

        /**
         * Converts this PartSetHeader to JSON.
         * @function toJSON
         * @memberof tendermint.types.PartSetHeader
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PartSetHeader.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PartSetHeader;
      })();

      types.Part = (function () {
        /**
         * Properties of a Part.
         * @memberof tendermint.types
         * @interface IPart
         * @property {number|null} [index] Part index
         * @property {Uint8Array|null} [bytes] Part bytes
         * @property {tendermint.crypto.IProof|null} [proof] Part proof
         */

        /**
         * Constructs a new Part.
         * @memberof tendermint.types
         * @classdesc Represents a Part.
         * @implements IPart
         * @constructor
         * @param {tendermint.types.IPart=} [properties] Properties to set
         */
        function Part(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * Part index.
         * @member {number} index
         * @memberof tendermint.types.Part
         * @instance
         */
        Part.prototype.index = 0;

        /**
         * Part bytes.
         * @member {Uint8Array} bytes
         * @memberof tendermint.types.Part
         * @instance
         */
        Part.prototype.bytes = $util.newBuffer([]);

        /**
         * Part proof.
         * @member {tendermint.crypto.IProof|null|undefined} proof
         * @memberof tendermint.types.Part
         * @instance
         */
        Part.prototype.proof = null;

        /**
         * Creates a new Part instance using the specified properties.
         * @function create
         * @memberof tendermint.types.Part
         * @static
         * @param {tendermint.types.IPart=} [properties] Properties to set
         * @returns {tendermint.types.Part} Part instance
         */
        Part.create = function create(properties) {
          return new Part(properties);
        };

        /**
         * Encodes the specified Part message. Does not implicitly {@link tendermint.types.Part.verify|verify} messages.
         * @function encode
         * @memberof tendermint.types.Part
         * @static
         * @param {tendermint.types.IPart} message Part message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Part.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.index != null && Object.hasOwnProperty.call(message, "index"))
            writer.uint32(/* id 1, wireType 0 =*/ 8).uint32(message.index);
          if (message.bytes != null && Object.hasOwnProperty.call(message, "bytes"))
            writer.uint32(/* id 2, wireType 2 =*/ 18).bytes(message.bytes);
          if (message.proof != null && Object.hasOwnProperty.call(message, "proof"))
            $root.tendermint.crypto.Proof.encode(
              message.proof,
              writer.uint32(/* id 3, wireType 2 =*/ 26).fork(),
            ).ldelim();
          return writer;
        };

        /**
         * Encodes the specified Part message, length delimited. Does not implicitly {@link tendermint.types.Part.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tendermint.types.Part
         * @static
         * @param {tendermint.types.IPart} message Part message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Part.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Part message from the specified reader or buffer.
         * @function decode
         * @memberof tendermint.types.Part
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tendermint.types.Part} Part
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Part.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.tendermint.types.Part();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.index = reader.uint32();
                break;
              case 2:
                message.bytes = reader.bytes();
                break;
              case 3:
                message.proof = $root.tendermint.crypto.Proof.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a Part message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tendermint.types.Part
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tendermint.types.Part} Part
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Part.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Part message.
         * @function verify
         * @memberof tendermint.types.Part
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Part.verify = function verify(message) {
          if (typeof message !== "object" || message === null) return "object expected";
          if (message.index != null && message.hasOwnProperty("index"))
            if (!$util.isInteger(message.index)) return "index: integer expected";
          if (message.bytes != null && message.hasOwnProperty("bytes"))
            if (
              !((message.bytes && typeof message.bytes.length === "number") || $util.isString(message.bytes))
            )
              return "bytes: buffer expected";
          if (message.proof != null && message.hasOwnProperty("proof")) {
            var error = $root.tendermint.crypto.Proof.verify(message.proof);
            if (error) return "proof." + error;
          }
          return null;
        };

        /**
         * Creates a Part message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tendermint.types.Part
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tendermint.types.Part} Part
         */
        Part.fromObject = function fromObject(object) {
          if (object instanceof $root.tendermint.types.Part) return object;
          var message = new $root.tendermint.types.Part();
          if (object.index != null) message.index = object.index >>> 0;
          if (object.bytes != null)
            if (typeof object.bytes === "string")
              $util.base64.decode(
                object.bytes,
                (message.bytes = $util.newBuffer($util.base64.length(object.bytes))),
                0,
              );
            else if (object.bytes.length) message.bytes = object.bytes;
          if (object.proof != null) {
            if (typeof object.proof !== "object")
              throw TypeError(".tendermint.types.Part.proof: object expected");
            message.proof = $root.tendermint.crypto.Proof.fromObject(object.proof);
          }
          return message;
        };

        /**
         * Creates a plain object from a Part message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tendermint.types.Part
         * @static
         * @param {tendermint.types.Part} message Part
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Part.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.index = 0;
            if (options.bytes === String) object.bytes = "";
            else {
              object.bytes = [];
              if (options.bytes !== Array) object.bytes = $util.newBuffer(object.bytes);
            }
            object.proof = null;
          }
          if (message.index != null && message.hasOwnProperty("index")) object.index = message.index;
          if (message.bytes != null && message.hasOwnProperty("bytes"))
            object.bytes =
              options.bytes === String
                ? $util.base64.encode(message.bytes, 0, message.bytes.length)
                : options.bytes === Array
                ? Array.prototype.slice.call(message.bytes)
                : message.bytes;
          if (message.proof != null && message.hasOwnProperty("proof"))
            object.proof = $root.tendermint.crypto.Proof.toObject(message.proof, options);
          return object;
        };

        /**
         * Converts this Part to JSON.
         * @function toJSON
         * @memberof tendermint.types.Part
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Part.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Part;
      })();

      types.BlockID = (function () {
        /**
         * Properties of a BlockID.
         * @memberof tendermint.types
         * @interface IBlockID
         * @property {Uint8Array|null} [hash] BlockID hash
         * @property {tendermint.types.IPartSetHeader|null} [partSetHeader] BlockID partSetHeader
         */

        /**
         * Constructs a new BlockID.
         * @memberof tendermint.types
         * @classdesc Represents a BlockID.
         * @implements IBlockID
         * @constructor
         * @param {tendermint.types.IBlockID=} [properties] Properties to set
         */
        function BlockID(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * BlockID hash.
         * @member {Uint8Array} hash
         * @memberof tendermint.types.BlockID
         * @instance
         */
        BlockID.prototype.hash = $util.newBuffer([]);

        /**
         * BlockID partSetHeader.
         * @member {tendermint.types.IPartSetHeader|null|undefined} partSetHeader
         * @memberof tendermint.types.BlockID
         * @instance
         */
        BlockID.prototype.partSetHeader = null;

        /**
         * Creates a new BlockID instance using the specified properties.
         * @function create
         * @memberof tendermint.types.BlockID
         * @static
         * @param {tendermint.types.IBlockID=} [properties] Properties to set
         * @returns {tendermint.types.BlockID} BlockID instance
         */
        BlockID.create = function create(properties) {
          return new BlockID(properties);
        };

        /**
         * Encodes the specified BlockID message. Does not implicitly {@link tendermint.types.BlockID.verify|verify} messages.
         * @function encode
         * @memberof tendermint.types.BlockID
         * @static
         * @param {tendermint.types.IBlockID} message BlockID message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BlockID.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.hash != null && Object.hasOwnProperty.call(message, "hash"))
            writer.uint32(/* id 1, wireType 2 =*/ 10).bytes(message.hash);
          if (message.partSetHeader != null && Object.hasOwnProperty.call(message, "partSetHeader"))
            $root.tendermint.types.PartSetHeader.encode(
              message.partSetHeader,
              writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
            ).ldelim();
          return writer;
        };

        /**
         * Encodes the specified BlockID message, length delimited. Does not implicitly {@link tendermint.types.BlockID.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tendermint.types.BlockID
         * @static
         * @param {tendermint.types.IBlockID} message BlockID message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BlockID.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BlockID message from the specified reader or buffer.
         * @function decode
         * @memberof tendermint.types.BlockID
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tendermint.types.BlockID} BlockID
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BlockID.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.tendermint.types.BlockID();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.hash = reader.bytes();
                break;
              case 2:
                message.partSetHeader = $root.tendermint.types.PartSetHeader.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a BlockID message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tendermint.types.BlockID
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tendermint.types.BlockID} BlockID
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BlockID.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BlockID message.
         * @function verify
         * @memberof tendermint.types.BlockID
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BlockID.verify = function verify(message) {
          if (typeof message !== "object" || message === null) return "object expected";
          if (message.hash != null && message.hasOwnProperty("hash"))
            if (!((message.hash && typeof message.hash.length === "number") || $util.isString(message.hash)))
              return "hash: buffer expected";
          if (message.partSetHeader != null && message.hasOwnProperty("partSetHeader")) {
            var error = $root.tendermint.types.PartSetHeader.verify(message.partSetHeader);
            if (error) return "partSetHeader." + error;
          }
          return null;
        };

        /**
         * Creates a BlockID message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tendermint.types.BlockID
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tendermint.types.BlockID} BlockID
         */
        BlockID.fromObject = function fromObject(object) {
          if (object instanceof $root.tendermint.types.BlockID) return object;
          var message = new $root.tendermint.types.BlockID();
          if (object.hash != null)
            if (typeof object.hash === "string")
              $util.base64.decode(
                object.hash,
                (message.hash = $util.newBuffer($util.base64.length(object.hash))),
                0,
              );
            else if (object.hash.length) message.hash = object.hash;
          if (object.partSetHeader != null) {
            if (typeof object.partSetHeader !== "object")
              throw TypeError(".tendermint.types.BlockID.partSetHeader: object expected");
            message.partSetHeader = $root.tendermint.types.PartSetHeader.fromObject(object.partSetHeader);
          }
          return message;
        };

        /**
         * Creates a plain object from a BlockID message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tendermint.types.BlockID
         * @static
         * @param {tendermint.types.BlockID} message BlockID
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BlockID.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            if (options.bytes === String) object.hash = "";
            else {
              object.hash = [];
              if (options.bytes !== Array) object.hash = $util.newBuffer(object.hash);
            }
            object.partSetHeader = null;
          }
          if (message.hash != null && message.hasOwnProperty("hash"))
            object.hash =
              options.bytes === String
                ? $util.base64.encode(message.hash, 0, message.hash.length)
                : options.bytes === Array
                ? Array.prototype.slice.call(message.hash)
                : message.hash;
          if (message.partSetHeader != null && message.hasOwnProperty("partSetHeader"))
            object.partSetHeader = $root.tendermint.types.PartSetHeader.toObject(
              message.partSetHeader,
              options,
            );
          return object;
        };

        /**
         * Converts this BlockID to JSON.
         * @function toJSON
         * @memberof tendermint.types.BlockID
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BlockID.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BlockID;
      })();

      types.Header = (function () {
        /**
         * Properties of a Header.
         * @memberof tendermint.types
         * @interface IHeader
         * @property {tendermint.version.IConsensus|null} [version] Header version
         * @property {string|null} [chainId] Header chainId
         * @property {number|Long|null} [height] Header height
         * @property {google.protobuf.ITimestamp|null} [time] Header time
         * @property {tendermint.types.IBlockID|null} [lastBlockId] Header lastBlockId
         * @property {Uint8Array|null} [lastCommitHash] Header lastCommitHash
         * @property {Uint8Array|null} [dataHash] Header dataHash
         * @property {Uint8Array|null} [validatorsHash] Header validatorsHash
         * @property {Uint8Array|null} [nextValidatorsHash] Header nextValidatorsHash
         * @property {Uint8Array|null} [consensusHash] Header consensusHash
         * @property {Uint8Array|null} [appHash] Header appHash
         * @property {Uint8Array|null} [lastResultsHash] Header lastResultsHash
         * @property {Uint8Array|null} [evidenceHash] Header evidenceHash
         * @property {Uint8Array|null} [proposerAddress] Header proposerAddress
         */

        /**
         * Constructs a new Header.
         * @memberof tendermint.types
         * @classdesc Represents a Header.
         * @implements IHeader
         * @constructor
         * @param {tendermint.types.IHeader=} [properties] Properties to set
         */
        function Header(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * Header version.
         * @member {tendermint.version.IConsensus|null|undefined} version
         * @memberof tendermint.types.Header
         * @instance
         */
        Header.prototype.version = null;

        /**
         * Header chainId.
         * @member {string} chainId
         * @memberof tendermint.types.Header
         * @instance
         */
        Header.prototype.chainId = "";

        /**
         * Header height.
         * @member {number|Long} height
         * @memberof tendermint.types.Header
         * @instance
         */
        Header.prototype.height = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * Header time.
         * @member {google.protobuf.ITimestamp|null|undefined} time
         * @memberof tendermint.types.Header
         * @instance
         */
        Header.prototype.time = null;

        /**
         * Header lastBlockId.
         * @member {tendermint.types.IBlockID|null|undefined} lastBlockId
         * @memberof tendermint.types.Header
         * @instance
         */
        Header.prototype.lastBlockId = null;

        /**
         * Header lastCommitHash.
         * @member {Uint8Array} lastCommitHash
         * @memberof tendermint.types.Header
         * @instance
         */
        Header.prototype.lastCommitHash = $util.newBuffer([]);

        /**
         * Header dataHash.
         * @member {Uint8Array} dataHash
         * @memberof tendermint.types.Header
         * @instance
         */
        Header.prototype.dataHash = $util.newBuffer([]);

        /**
         * Header validatorsHash.
         * @member {Uint8Array} validatorsHash
         * @memberof tendermint.types.Header
         * @instance
         */
        Header.prototype.validatorsHash = $util.newBuffer([]);

        /**
         * Header nextValidatorsHash.
         * @member {Uint8Array} nextValidatorsHash
         * @memberof tendermint.types.Header
         * @instance
         */
        Header.prototype.nextValidatorsHash = $util.newBuffer([]);

        /**
         * Header consensusHash.
         * @member {Uint8Array} consensusHash
         * @memberof tendermint.types.Header
         * @instance
         */
        Header.prototype.consensusHash = $util.newBuffer([]);

        /**
         * Header appHash.
         * @member {Uint8Array} appHash
         * @memberof tendermint.types.Header
         * @instance
         */
        Header.prototype.appHash = $util.newBuffer([]);

        /**
         * Header lastResultsHash.
         * @member {Uint8Array} lastResultsHash
         * @memberof tendermint.types.Header
         * @instance
         */
        Header.prototype.lastResultsHash = $util.newBuffer([]);

        /**
         * Header evidenceHash.
         * @member {Uint8Array} evidenceHash
         * @memberof tendermint.types.Header
         * @instance
         */
        Header.prototype.evidenceHash = $util.newBuffer([]);

        /**
         * Header proposerAddress.
         * @member {Uint8Array} proposerAddress
         * @memberof tendermint.types.Header
         * @instance
         */
        Header.prototype.proposerAddress = $util.newBuffer([]);

        /**
         * Creates a new Header instance using the specified properties.
         * @function create
         * @memberof tendermint.types.Header
         * @static
         * @param {tendermint.types.IHeader=} [properties] Properties to set
         * @returns {tendermint.types.Header} Header instance
         */
        Header.create = function create(properties) {
          return new Header(properties);
        };

        /**
         * Encodes the specified Header message. Does not implicitly {@link tendermint.types.Header.verify|verify} messages.
         * @function encode
         * @memberof tendermint.types.Header
         * @static
         * @param {tendermint.types.IHeader} message Header message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Header.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.version != null && Object.hasOwnProperty.call(message, "version"))
            $root.tendermint.version.Consensus.encode(
              message.version,
              writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
            ).ldelim();
          if (message.chainId != null && Object.hasOwnProperty.call(message, "chainId"))
            writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.chainId);
          if (message.height != null && Object.hasOwnProperty.call(message, "height"))
            writer.uint32(/* id 3, wireType 0 =*/ 24).int64(message.height);
          if (message.time != null && Object.hasOwnProperty.call(message, "time"))
            $root.google.protobuf.Timestamp.encode(
              message.time,
              writer.uint32(/* id 4, wireType 2 =*/ 34).fork(),
            ).ldelim();
          if (message.lastBlockId != null && Object.hasOwnProperty.call(message, "lastBlockId"))
            $root.tendermint.types.BlockID.encode(
              message.lastBlockId,
              writer.uint32(/* id 5, wireType 2 =*/ 42).fork(),
            ).ldelim();
          if (message.lastCommitHash != null && Object.hasOwnProperty.call(message, "lastCommitHash"))
            writer.uint32(/* id 6, wireType 2 =*/ 50).bytes(message.lastCommitHash);
          if (message.dataHash != null && Object.hasOwnProperty.call(message, "dataHash"))
            writer.uint32(/* id 7, wireType 2 =*/ 58).bytes(message.dataHash);
          if (message.validatorsHash != null && Object.hasOwnProperty.call(message, "validatorsHash"))
            writer.uint32(/* id 8, wireType 2 =*/ 66).bytes(message.validatorsHash);
          if (message.nextValidatorsHash != null && Object.hasOwnProperty.call(message, "nextValidatorsHash"))
            writer.uint32(/* id 9, wireType 2 =*/ 74).bytes(message.nextValidatorsHash);
          if (message.consensusHash != null && Object.hasOwnProperty.call(message, "consensusHash"))
            writer.uint32(/* id 10, wireType 2 =*/ 82).bytes(message.consensusHash);
          if (message.appHash != null && Object.hasOwnProperty.call(message, "appHash"))
            writer.uint32(/* id 11, wireType 2 =*/ 90).bytes(message.appHash);
          if (message.lastResultsHash != null && Object.hasOwnProperty.call(message, "lastResultsHash"))
            writer.uint32(/* id 12, wireType 2 =*/ 98).bytes(message.lastResultsHash);
          if (message.evidenceHash != null && Object.hasOwnProperty.call(message, "evidenceHash"))
            writer.uint32(/* id 13, wireType 2 =*/ 106).bytes(message.evidenceHash);
          if (message.proposerAddress != null && Object.hasOwnProperty.call(message, "proposerAddress"))
            writer.uint32(/* id 14, wireType 2 =*/ 114).bytes(message.proposerAddress);
          return writer;
        };

        /**
         * Encodes the specified Header message, length delimited. Does not implicitly {@link tendermint.types.Header.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tendermint.types.Header
         * @static
         * @param {tendermint.types.IHeader} message Header message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Header.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Header message from the specified reader or buffer.
         * @function decode
         * @memberof tendermint.types.Header
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tendermint.types.Header} Header
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Header.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.tendermint.types.Header();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.version = $root.tendermint.version.Consensus.decode(reader, reader.uint32());
                break;
              case 2:
                message.chainId = reader.string();
                break;
              case 3:
                message.height = reader.int64();
                break;
              case 4:
                message.time = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                break;
              case 5:
                message.lastBlockId = $root.tendermint.types.BlockID.decode(reader, reader.uint32());
                break;
              case 6:
                message.lastCommitHash = reader.bytes();
                break;
              case 7:
                message.dataHash = reader.bytes();
                break;
              case 8:
                message.validatorsHash = reader.bytes();
                break;
              case 9:
                message.nextValidatorsHash = reader.bytes();
                break;
              case 10:
                message.consensusHash = reader.bytes();
                break;
              case 11:
                message.appHash = reader.bytes();
                break;
              case 12:
                message.lastResultsHash = reader.bytes();
                break;
              case 13:
                message.evidenceHash = reader.bytes();
                break;
              case 14:
                message.proposerAddress = reader.bytes();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a Header message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tendermint.types.Header
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tendermint.types.Header} Header
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Header.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Header message.
         * @function verify
         * @memberof tendermint.types.Header
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Header.verify = function verify(message) {
          if (typeof message !== "object" || message === null) return "object expected";
          if (message.version != null && message.hasOwnProperty("version")) {
            var error = $root.tendermint.version.Consensus.verify(message.version);
            if (error) return "version." + error;
          }
          if (message.chainId != null && message.hasOwnProperty("chainId"))
            if (!$util.isString(message.chainId)) return "chainId: string expected";
          if (message.height != null && message.hasOwnProperty("height"))
            if (
              !$util.isInteger(message.height) &&
              !(message.height && $util.isInteger(message.height.low) && $util.isInteger(message.height.high))
            )
              return "height: integer|Long expected";
          if (message.time != null && message.hasOwnProperty("time")) {
            var error = $root.google.protobuf.Timestamp.verify(message.time);
            if (error) return "time." + error;
          }
          if (message.lastBlockId != null && message.hasOwnProperty("lastBlockId")) {
            var error = $root.tendermint.types.BlockID.verify(message.lastBlockId);
            if (error) return "lastBlockId." + error;
          }
          if (message.lastCommitHash != null && message.hasOwnProperty("lastCommitHash"))
            if (
              !(
                (message.lastCommitHash && typeof message.lastCommitHash.length === "number") ||
                $util.isString(message.lastCommitHash)
              )
            )
              return "lastCommitHash: buffer expected";
          if (message.dataHash != null && message.hasOwnProperty("dataHash"))
            if (
              !(
                (message.dataHash && typeof message.dataHash.length === "number") ||
                $util.isString(message.dataHash)
              )
            )
              return "dataHash: buffer expected";
          if (message.validatorsHash != null && message.hasOwnProperty("validatorsHash"))
            if (
              !(
                (message.validatorsHash && typeof message.validatorsHash.length === "number") ||
                $util.isString(message.validatorsHash)
              )
            )
              return "validatorsHash: buffer expected";
          if (message.nextValidatorsHash != null && message.hasOwnProperty("nextValidatorsHash"))
            if (
              !(
                (message.nextValidatorsHash && typeof message.nextValidatorsHash.length === "number") ||
                $util.isString(message.nextValidatorsHash)
              )
            )
              return "nextValidatorsHash: buffer expected";
          if (message.consensusHash != null && message.hasOwnProperty("consensusHash"))
            if (
              !(
                (message.consensusHash && typeof message.consensusHash.length === "number") ||
                $util.isString(message.consensusHash)
              )
            )
              return "consensusHash: buffer expected";
          if (message.appHash != null && message.hasOwnProperty("appHash"))
            if (
              !(
                (message.appHash && typeof message.appHash.length === "number") ||
                $util.isString(message.appHash)
              )
            )
              return "appHash: buffer expected";
          if (message.lastResultsHash != null && message.hasOwnProperty("lastResultsHash"))
            if (
              !(
                (message.lastResultsHash && typeof message.lastResultsHash.length === "number") ||
                $util.isString(message.lastResultsHash)
              )
            )
              return "lastResultsHash: buffer expected";
          if (message.evidenceHash != null && message.hasOwnProperty("evidenceHash"))
            if (
              !(
                (message.evidenceHash && typeof message.evidenceHash.length === "number") ||
                $util.isString(message.evidenceHash)
              )
            )
              return "evidenceHash: buffer expected";
          if (message.proposerAddress != null && message.hasOwnProperty("proposerAddress"))
            if (
              !(
                (message.proposerAddress && typeof message.proposerAddress.length === "number") ||
                $util.isString(message.proposerAddress)
              )
            )
              return "proposerAddress: buffer expected";
          return null;
        };

        /**
         * Creates a Header message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tendermint.types.Header
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tendermint.types.Header} Header
         */
        Header.fromObject = function fromObject(object) {
          if (object instanceof $root.tendermint.types.Header) return object;
          var message = new $root.tendermint.types.Header();
          if (object.version != null) {
            if (typeof object.version !== "object")
              throw TypeError(".tendermint.types.Header.version: object expected");
            message.version = $root.tendermint.version.Consensus.fromObject(object.version);
          }
          if (object.chainId != null) message.chainId = String(object.chainId);
          if (object.height != null)
            if ($util.Long) (message.height = $util.Long.fromValue(object.height)).unsigned = false;
            else if (typeof object.height === "string") message.height = parseInt(object.height, 10);
            else if (typeof object.height === "number") message.height = object.height;
            else if (typeof object.height === "object")
              message.height = new $util.LongBits(
                object.height.low >>> 0,
                object.height.high >>> 0,
              ).toNumber();
          if (object.time != null) {
            if (typeof object.time !== "object")
              throw TypeError(".tendermint.types.Header.time: object expected");
            message.time = $root.google.protobuf.Timestamp.fromObject(object.time);
          }
          if (object.lastBlockId != null) {
            if (typeof object.lastBlockId !== "object")
              throw TypeError(".tendermint.types.Header.lastBlockId: object expected");
            message.lastBlockId = $root.tendermint.types.BlockID.fromObject(object.lastBlockId);
          }
          if (object.lastCommitHash != null)
            if (typeof object.lastCommitHash === "string")
              $util.base64.decode(
                object.lastCommitHash,
                (message.lastCommitHash = $util.newBuffer($util.base64.length(object.lastCommitHash))),
                0,
              );
            else if (object.lastCommitHash.length) message.lastCommitHash = object.lastCommitHash;
          if (object.dataHash != null)
            if (typeof object.dataHash === "string")
              $util.base64.decode(
                object.dataHash,
                (message.dataHash = $util.newBuffer($util.base64.length(object.dataHash))),
                0,
              );
            else if (object.dataHash.length) message.dataHash = object.dataHash;
          if (object.validatorsHash != null)
            if (typeof object.validatorsHash === "string")
              $util.base64.decode(
                object.validatorsHash,
                (message.validatorsHash = $util.newBuffer($util.base64.length(object.validatorsHash))),
                0,
              );
            else if (object.validatorsHash.length) message.validatorsHash = object.validatorsHash;
          if (object.nextValidatorsHash != null)
            if (typeof object.nextValidatorsHash === "string")
              $util.base64.decode(
                object.nextValidatorsHash,
                (message.nextValidatorsHash = $util.newBuffer(
                  $util.base64.length(object.nextValidatorsHash),
                )),
                0,
              );
            else if (object.nextValidatorsHash.length) message.nextValidatorsHash = object.nextValidatorsHash;
          if (object.consensusHash != null)
            if (typeof object.consensusHash === "string")
              $util.base64.decode(
                object.consensusHash,
                (message.consensusHash = $util.newBuffer($util.base64.length(object.consensusHash))),
                0,
              );
            else if (object.consensusHash.length) message.consensusHash = object.consensusHash;
          if (object.appHash != null)
            if (typeof object.appHash === "string")
              $util.base64.decode(
                object.appHash,
                (message.appHash = $util.newBuffer($util.base64.length(object.appHash))),
                0,
              );
            else if (object.appHash.length) message.appHash = object.appHash;
          if (object.lastResultsHash != null)
            if (typeof object.lastResultsHash === "string")
              $util.base64.decode(
                object.lastResultsHash,
                (message.lastResultsHash = $util.newBuffer($util.base64.length(object.lastResultsHash))),
                0,
              );
            else if (object.lastResultsHash.length) message.lastResultsHash = object.lastResultsHash;
          if (object.evidenceHash != null)
            if (typeof object.evidenceHash === "string")
              $util.base64.decode(
                object.evidenceHash,
                (message.evidenceHash = $util.newBuffer($util.base64.length(object.evidenceHash))),
                0,
              );
            else if (object.evidenceHash.length) message.evidenceHash = object.evidenceHash;
          if (object.proposerAddress != null)
            if (typeof object.proposerAddress === "string")
              $util.base64.decode(
                object.proposerAddress,
                (message.proposerAddress = $util.newBuffer($util.base64.length(object.proposerAddress))),
                0,
              );
            else if (object.proposerAddress.length) message.proposerAddress = object.proposerAddress;
          return message;
        };

        /**
         * Creates a plain object from a Header message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tendermint.types.Header
         * @static
         * @param {tendermint.types.Header} message Header
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Header.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.version = null;
            object.chainId = "";
            if ($util.Long) {
              var long = new $util.Long(0, 0, false);
              object.height =
                options.longs === String
                  ? long.toString()
                  : options.longs === Number
                  ? long.toNumber()
                  : long;
            } else object.height = options.longs === String ? "0" : 0;
            object.time = null;
            object.lastBlockId = null;
            if (options.bytes === String) object.lastCommitHash = "";
            else {
              object.lastCommitHash = [];
              if (options.bytes !== Array) object.lastCommitHash = $util.newBuffer(object.lastCommitHash);
            }
            if (options.bytes === String) object.dataHash = "";
            else {
              object.dataHash = [];
              if (options.bytes !== Array) object.dataHash = $util.newBuffer(object.dataHash);
            }
            if (options.bytes === String) object.validatorsHash = "";
            else {
              object.validatorsHash = [];
              if (options.bytes !== Array) object.validatorsHash = $util.newBuffer(object.validatorsHash);
            }
            if (options.bytes === String) object.nextValidatorsHash = "";
            else {
              object.nextValidatorsHash = [];
              if (options.bytes !== Array)
                object.nextValidatorsHash = $util.newBuffer(object.nextValidatorsHash);
            }
            if (options.bytes === String) object.consensusHash = "";
            else {
              object.consensusHash = [];
              if (options.bytes !== Array) object.consensusHash = $util.newBuffer(object.consensusHash);
            }
            if (options.bytes === String) object.appHash = "";
            else {
              object.appHash = [];
              if (options.bytes !== Array) object.appHash = $util.newBuffer(object.appHash);
            }
            if (options.bytes === String) object.lastResultsHash = "";
            else {
              object.lastResultsHash = [];
              if (options.bytes !== Array) object.lastResultsHash = $util.newBuffer(object.lastResultsHash);
            }
            if (options.bytes === String) object.evidenceHash = "";
            else {
              object.evidenceHash = [];
              if (options.bytes !== Array) object.evidenceHash = $util.newBuffer(object.evidenceHash);
            }
            if (options.bytes === String) object.proposerAddress = "";
            else {
              object.proposerAddress = [];
              if (options.bytes !== Array) object.proposerAddress = $util.newBuffer(object.proposerAddress);
            }
          }
          if (message.version != null && message.hasOwnProperty("version"))
            object.version = $root.tendermint.version.Consensus.toObject(message.version, options);
          if (message.chainId != null && message.hasOwnProperty("chainId")) object.chainId = message.chainId;
          if (message.height != null && message.hasOwnProperty("height"))
            if (typeof message.height === "number")
              object.height = options.longs === String ? String(message.height) : message.height;
            else
              object.height =
                options.longs === String
                  ? $util.Long.prototype.toString.call(message.height)
                  : options.longs === Number
                  ? new $util.LongBits(message.height.low >>> 0, message.height.high >>> 0).toNumber()
                  : message.height;
          if (message.time != null && message.hasOwnProperty("time"))
            object.time = $root.google.protobuf.Timestamp.toObject(message.time, options);
          if (message.lastBlockId != null && message.hasOwnProperty("lastBlockId"))
            object.lastBlockId = $root.tendermint.types.BlockID.toObject(message.lastBlockId, options);
          if (message.lastCommitHash != null && message.hasOwnProperty("lastCommitHash"))
            object.lastCommitHash =
              options.bytes === String
                ? $util.base64.encode(message.lastCommitHash, 0, message.lastCommitHash.length)
                : options.bytes === Array
                ? Array.prototype.slice.call(message.lastCommitHash)
                : message.lastCommitHash;
          if (message.dataHash != null && message.hasOwnProperty("dataHash"))
            object.dataHash =
              options.bytes === String
                ? $util.base64.encode(message.dataHash, 0, message.dataHash.length)
                : options.bytes === Array
                ? Array.prototype.slice.call(message.dataHash)
                : message.dataHash;
          if (message.validatorsHash != null && message.hasOwnProperty("validatorsHash"))
            object.validatorsHash =
              options.bytes === String
                ? $util.base64.encode(message.validatorsHash, 0, message.validatorsHash.length)
                : options.bytes === Array
                ? Array.prototype.slice.call(message.validatorsHash)
                : message.validatorsHash;
          if (message.nextValidatorsHash != null && message.hasOwnProperty("nextValidatorsHash"))
            object.nextValidatorsHash =
              options.bytes === String
                ? $util.base64.encode(message.nextValidatorsHash, 0, message.nextValidatorsHash.length)
                : options.bytes === Array
                ? Array.prototype.slice.call(message.nextValidatorsHash)
                : message.nextValidatorsHash;
          if (message.consensusHash != null && message.hasOwnProperty("consensusHash"))
            object.consensusHash =
              options.bytes === String
                ? $util.base64.encode(message.consensusHash, 0, message.consensusHash.length)
                : options.bytes === Array
                ? Array.prototype.slice.call(message.consensusHash)
                : message.consensusHash;
          if (message.appHash != null && message.hasOwnProperty("appHash"))
            object.appHash =
              options.bytes === String
                ? $util.base64.encode(message.appHash, 0, message.appHash.length)
                : options.bytes === Array
                ? Array.prototype.slice.call(message.appHash)
                : message.appHash;
          if (message.lastResultsHash != null && message.hasOwnProperty("lastResultsHash"))
            object.lastResultsHash =
              options.bytes === String
                ? $util.base64.encode(message.lastResultsHash, 0, message.lastResultsHash.length)
                : options.bytes === Array
                ? Array.prototype.slice.call(message.lastResultsHash)
                : message.lastResultsHash;
          if (message.evidenceHash != null && message.hasOwnProperty("evidenceHash"))
            object.evidenceHash =
              options.bytes === String
                ? $util.base64.encode(message.evidenceHash, 0, message.evidenceHash.length)
                : options.bytes === Array
                ? Array.prototype.slice.call(message.evidenceHash)
                : message.evidenceHash;
          if (message.proposerAddress != null && message.hasOwnProperty("proposerAddress"))
            object.proposerAddress =
              options.bytes === String
                ? $util.base64.encode(message.proposerAddress, 0, message.proposerAddress.length)
                : options.bytes === Array
                ? Array.prototype.slice.call(message.proposerAddress)
                : message.proposerAddress;
          return object;
        };

        /**
         * Converts this Header to JSON.
         * @function toJSON
         * @memberof tendermint.types.Header
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Header.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Header;
      })();

      types.Data = (function () {
        /**
         * Properties of a Data.
         * @memberof tendermint.types
         * @interface IData
         * @property {Array.<Uint8Array>|null} [txs] Data txs
         */

        /**
         * Constructs a new Data.
         * @memberof tendermint.types
         * @classdesc Represents a Data.
         * @implements IData
         * @constructor
         * @param {tendermint.types.IData=} [properties] Properties to set
         */
        function Data(properties) {
          this.txs = [];
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * Data txs.
         * @member {Array.<Uint8Array>} txs
         * @memberof tendermint.types.Data
         * @instance
         */
        Data.prototype.txs = $util.emptyArray;

        /**
         * Creates a new Data instance using the specified properties.
         * @function create
         * @memberof tendermint.types.Data
         * @static
         * @param {tendermint.types.IData=} [properties] Properties to set
         * @returns {tendermint.types.Data} Data instance
         */
        Data.create = function create(properties) {
          return new Data(properties);
        };

        /**
         * Encodes the specified Data message. Does not implicitly {@link tendermint.types.Data.verify|verify} messages.
         * @function encode
         * @memberof tendermint.types.Data
         * @static
         * @param {tendermint.types.IData} message Data message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Data.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.txs != null && message.txs.length)
            for (var i = 0; i < message.txs.length; ++i)
              writer.uint32(/* id 1, wireType 2 =*/ 10).bytes(message.txs[i]);
          return writer;
        };

        /**
         * Encodes the specified Data message, length delimited. Does not implicitly {@link tendermint.types.Data.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tendermint.types.Data
         * @static
         * @param {tendermint.types.IData} message Data message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Data.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Data message from the specified reader or buffer.
         * @function decode
         * @memberof tendermint.types.Data
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tendermint.types.Data} Data
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Data.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.tendermint.types.Data();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                if (!(message.txs && message.txs.length)) message.txs = [];
                message.txs.push(reader.bytes());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a Data message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tendermint.types.Data
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tendermint.types.Data} Data
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Data.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Data message.
         * @function verify
         * @memberof tendermint.types.Data
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Data.verify = function verify(message) {
          if (typeof message !== "object" || message === null) return "object expected";
          if (message.txs != null && message.hasOwnProperty("txs")) {
            if (!Array.isArray(message.txs)) return "txs: array expected";
            for (var i = 0; i < message.txs.length; ++i)
              if (
                !(
                  (message.txs[i] && typeof message.txs[i].length === "number") ||
                  $util.isString(message.txs[i])
                )
              )
                return "txs: buffer[] expected";
          }
          return null;
        };

        /**
         * Creates a Data message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tendermint.types.Data
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tendermint.types.Data} Data
         */
        Data.fromObject = function fromObject(object) {
          if (object instanceof $root.tendermint.types.Data) return object;
          var message = new $root.tendermint.types.Data();
          if (object.txs) {
            if (!Array.isArray(object.txs)) throw TypeError(".tendermint.types.Data.txs: array expected");
            message.txs = [];
            for (var i = 0; i < object.txs.length; ++i)
              if (typeof object.txs[i] === "string")
                $util.base64.decode(
                  object.txs[i],
                  (message.txs[i] = $util.newBuffer($util.base64.length(object.txs[i]))),
                  0,
                );
              else if (object.txs[i].length) message.txs[i] = object.txs[i];
          }
          return message;
        };

        /**
         * Creates a plain object from a Data message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tendermint.types.Data
         * @static
         * @param {tendermint.types.Data} message Data
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Data.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.arrays || options.defaults) object.txs = [];
          if (message.txs && message.txs.length) {
            object.txs = [];
            for (var j = 0; j < message.txs.length; ++j)
              object.txs[j] =
                options.bytes === String
                  ? $util.base64.encode(message.txs[j], 0, message.txs[j].length)
                  : options.bytes === Array
                  ? Array.prototype.slice.call(message.txs[j])
                  : message.txs[j];
          }
          return object;
        };

        /**
         * Converts this Data to JSON.
         * @function toJSON
         * @memberof tendermint.types.Data
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Data.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Data;
      })();

      types.Vote = (function () {
        /**
         * Properties of a Vote.
         * @memberof tendermint.types
         * @interface IVote
         * @property {tendermint.types.SignedMsgType|null} [type] Vote type
         * @property {number|Long|null} [height] Vote height
         * @property {number|null} [round] Vote round
         * @property {tendermint.types.IBlockID|null} [blockId] Vote blockId
         * @property {google.protobuf.ITimestamp|null} [timestamp] Vote timestamp
         * @property {Uint8Array|null} [validatorAddress] Vote validatorAddress
         * @property {number|null} [validatorIndex] Vote validatorIndex
         * @property {Uint8Array|null} [signature] Vote signature
         */

        /**
         * Constructs a new Vote.
         * @memberof tendermint.types
         * @classdesc Represents a Vote.
         * @implements IVote
         * @constructor
         * @param {tendermint.types.IVote=} [properties] Properties to set
         */
        function Vote(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * Vote type.
         * @member {tendermint.types.SignedMsgType} type
         * @memberof tendermint.types.Vote
         * @instance
         */
        Vote.prototype.type = 0;

        /**
         * Vote height.
         * @member {number|Long} height
         * @memberof tendermint.types.Vote
         * @instance
         */
        Vote.prototype.height = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * Vote round.
         * @member {number} round
         * @memberof tendermint.types.Vote
         * @instance
         */
        Vote.prototype.round = 0;

        /**
         * Vote blockId.
         * @member {tendermint.types.IBlockID|null|undefined} blockId
         * @memberof tendermint.types.Vote
         * @instance
         */
        Vote.prototype.blockId = null;

        /**
         * Vote timestamp.
         * @member {google.protobuf.ITimestamp|null|undefined} timestamp
         * @memberof tendermint.types.Vote
         * @instance
         */
        Vote.prototype.timestamp = null;

        /**
         * Vote validatorAddress.
         * @member {Uint8Array} validatorAddress
         * @memberof tendermint.types.Vote
         * @instance
         */
        Vote.prototype.validatorAddress = $util.newBuffer([]);

        /**
         * Vote validatorIndex.
         * @member {number} validatorIndex
         * @memberof tendermint.types.Vote
         * @instance
         */
        Vote.prototype.validatorIndex = 0;

        /**
         * Vote signature.
         * @member {Uint8Array} signature
         * @memberof tendermint.types.Vote
         * @instance
         */
        Vote.prototype.signature = $util.newBuffer([]);

        /**
         * Creates a new Vote instance using the specified properties.
         * @function create
         * @memberof tendermint.types.Vote
         * @static
         * @param {tendermint.types.IVote=} [properties] Properties to set
         * @returns {tendermint.types.Vote} Vote instance
         */
        Vote.create = function create(properties) {
          return new Vote(properties);
        };

        /**
         * Encodes the specified Vote message. Does not implicitly {@link tendermint.types.Vote.verify|verify} messages.
         * @function encode
         * @memberof tendermint.types.Vote
         * @static
         * @param {tendermint.types.IVote} message Vote message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Vote.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.type != null && Object.hasOwnProperty.call(message, "type"))
            writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.type);
          if (message.height != null && Object.hasOwnProperty.call(message, "height"))
            writer.uint32(/* id 2, wireType 0 =*/ 16).int64(message.height);
          if (message.round != null && Object.hasOwnProperty.call(message, "round"))
            writer.uint32(/* id 3, wireType 0 =*/ 24).int32(message.round);
          if (message.blockId != null && Object.hasOwnProperty.call(message, "blockId"))
            $root.tendermint.types.BlockID.encode(
              message.blockId,
              writer.uint32(/* id 4, wireType 2 =*/ 34).fork(),
            ).ldelim();
          if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
            $root.google.protobuf.Timestamp.encode(
              message.timestamp,
              writer.uint32(/* id 5, wireType 2 =*/ 42).fork(),
            ).ldelim();
          if (message.validatorAddress != null && Object.hasOwnProperty.call(message, "validatorAddress"))
            writer.uint32(/* id 6, wireType 2 =*/ 50).bytes(message.validatorAddress);
          if (message.validatorIndex != null && Object.hasOwnProperty.call(message, "validatorIndex"))
            writer.uint32(/* id 7, wireType 0 =*/ 56).int32(message.validatorIndex);
          if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
            writer.uint32(/* id 8, wireType 2 =*/ 66).bytes(message.signature);
          return writer;
        };

        /**
         * Encodes the specified Vote message, length delimited. Does not implicitly {@link tendermint.types.Vote.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tendermint.types.Vote
         * @static
         * @param {tendermint.types.IVote} message Vote message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Vote.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Vote message from the specified reader or buffer.
         * @function decode
         * @memberof tendermint.types.Vote
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tendermint.types.Vote} Vote
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Vote.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.tendermint.types.Vote();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.type = reader.int32();
                break;
              case 2:
                message.height = reader.int64();
                break;
              case 3:
                message.round = reader.int32();
                break;
              case 4:
                message.blockId = $root.tendermint.types.BlockID.decode(reader, reader.uint32());
                break;
              case 5:
                message.timestamp = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                break;
              case 6:
                message.validatorAddress = reader.bytes();
                break;
              case 7:
                message.validatorIndex = reader.int32();
                break;
              case 8:
                message.signature = reader.bytes();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a Vote message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tendermint.types.Vote
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tendermint.types.Vote} Vote
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Vote.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Vote message.
         * @function verify
         * @memberof tendermint.types.Vote
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Vote.verify = function verify(message) {
          if (typeof message !== "object" || message === null) return "object expected";
          if (message.type != null && message.hasOwnProperty("type"))
            switch (message.type) {
              default:
                return "type: enum value expected";
              case 0:
              case 1:
              case 2:
              case 32:
                break;
            }
          if (message.height != null && message.hasOwnProperty("height"))
            if (
              !$util.isInteger(message.height) &&
              !(message.height && $util.isInteger(message.height.low) && $util.isInteger(message.height.high))
            )
              return "height: integer|Long expected";
          if (message.round != null && message.hasOwnProperty("round"))
            if (!$util.isInteger(message.round)) return "round: integer expected";
          if (message.blockId != null && message.hasOwnProperty("blockId")) {
            var error = $root.tendermint.types.BlockID.verify(message.blockId);
            if (error) return "blockId." + error;
          }
          if (message.timestamp != null && message.hasOwnProperty("timestamp")) {
            var error = $root.google.protobuf.Timestamp.verify(message.timestamp);
            if (error) return "timestamp." + error;
          }
          if (message.validatorAddress != null && message.hasOwnProperty("validatorAddress"))
            if (
              !(
                (message.validatorAddress && typeof message.validatorAddress.length === "number") ||
                $util.isString(message.validatorAddress)
              )
            )
              return "validatorAddress: buffer expected";
          if (message.validatorIndex != null && message.hasOwnProperty("validatorIndex"))
            if (!$util.isInteger(message.validatorIndex)) return "validatorIndex: integer expected";
          if (message.signature != null && message.hasOwnProperty("signature"))
            if (
              !(
                (message.signature && typeof message.signature.length === "number") ||
                $util.isString(message.signature)
              )
            )
              return "signature: buffer expected";
          return null;
        };

        /**
         * Creates a Vote message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tendermint.types.Vote
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tendermint.types.Vote} Vote
         */
        Vote.fromObject = function fromObject(object) {
          if (object instanceof $root.tendermint.types.Vote) return object;
          var message = new $root.tendermint.types.Vote();
          switch (object.type) {
            case "SIGNED_MSG_TYPE_UNKNOWN":
            case 0:
              message.type = 0;
              break;
            case "SIGNED_MSG_TYPE_PREVOTE":
            case 1:
              message.type = 1;
              break;
            case "SIGNED_MSG_TYPE_PRECOMMIT":
            case 2:
              message.type = 2;
              break;
            case "SIGNED_MSG_TYPE_PROPOSAL":
            case 32:
              message.type = 32;
              break;
          }
          if (object.height != null)
            if ($util.Long) (message.height = $util.Long.fromValue(object.height)).unsigned = false;
            else if (typeof object.height === "string") message.height = parseInt(object.height, 10);
            else if (typeof object.height === "number") message.height = object.height;
            else if (typeof object.height === "object")
              message.height = new $util.LongBits(
                object.height.low >>> 0,
                object.height.high >>> 0,
              ).toNumber();
          if (object.round != null) message.round = object.round | 0;
          if (object.blockId != null) {
            if (typeof object.blockId !== "object")
              throw TypeError(".tendermint.types.Vote.blockId: object expected");
            message.blockId = $root.tendermint.types.BlockID.fromObject(object.blockId);
          }
          if (object.timestamp != null) {
            if (typeof object.timestamp !== "object")
              throw TypeError(".tendermint.types.Vote.timestamp: object expected");
            message.timestamp = $root.google.protobuf.Timestamp.fromObject(object.timestamp);
          }
          if (object.validatorAddress != null)
            if (typeof object.validatorAddress === "string")
              $util.base64.decode(
                object.validatorAddress,
                (message.validatorAddress = $util.newBuffer($util.base64.length(object.validatorAddress))),
                0,
              );
            else if (object.validatorAddress.length) message.validatorAddress = object.validatorAddress;
          if (object.validatorIndex != null) message.validatorIndex = object.validatorIndex | 0;
          if (object.signature != null)
            if (typeof object.signature === "string")
              $util.base64.decode(
                object.signature,
                (message.signature = $util.newBuffer($util.base64.length(object.signature))),
                0,
              );
            else if (object.signature.length) message.signature = object.signature;
          return message;
        };

        /**
         * Creates a plain object from a Vote message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tendermint.types.Vote
         * @static
         * @param {tendermint.types.Vote} message Vote
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Vote.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.type = options.enums === String ? "SIGNED_MSG_TYPE_UNKNOWN" : 0;
            if ($util.Long) {
              var long = new $util.Long(0, 0, false);
              object.height =
                options.longs === String
                  ? long.toString()
                  : options.longs === Number
                  ? long.toNumber()
                  : long;
            } else object.height = options.longs === String ? "0" : 0;
            object.round = 0;
            object.blockId = null;
            object.timestamp = null;
            if (options.bytes === String) object.validatorAddress = "";
            else {
              object.validatorAddress = [];
              if (options.bytes !== Array) object.validatorAddress = $util.newBuffer(object.validatorAddress);
            }
            object.validatorIndex = 0;
            if (options.bytes === String) object.signature = "";
            else {
              object.signature = [];
              if (options.bytes !== Array) object.signature = $util.newBuffer(object.signature);
            }
          }
          if (message.type != null && message.hasOwnProperty("type"))
            object.type =
              options.enums === String ? $root.tendermint.types.SignedMsgType[message.type] : message.type;
          if (message.height != null && message.hasOwnProperty("height"))
            if (typeof message.height === "number")
              object.height = options.longs === String ? String(message.height) : message.height;
            else
              object.height =
                options.longs === String
                  ? $util.Long.prototype.toString.call(message.height)
                  : options.longs === Number
                  ? new $util.LongBits(message.height.low >>> 0, message.height.high >>> 0).toNumber()
                  : message.height;
          if (message.round != null && message.hasOwnProperty("round")) object.round = message.round;
          if (message.blockId != null && message.hasOwnProperty("blockId"))
            object.blockId = $root.tendermint.types.BlockID.toObject(message.blockId, options);
          if (message.timestamp != null && message.hasOwnProperty("timestamp"))
            object.timestamp = $root.google.protobuf.Timestamp.toObject(message.timestamp, options);
          if (message.validatorAddress != null && message.hasOwnProperty("validatorAddress"))
            object.validatorAddress =
              options.bytes === String
                ? $util.base64.encode(message.validatorAddress, 0, message.validatorAddress.length)
                : options.bytes === Array
                ? Array.prototype.slice.call(message.validatorAddress)
                : message.validatorAddress;
          if (message.validatorIndex != null && message.hasOwnProperty("validatorIndex"))
            object.validatorIndex = message.validatorIndex;
          if (message.signature != null && message.hasOwnProperty("signature"))
            object.signature =
              options.bytes === String
                ? $util.base64.encode(message.signature, 0, message.signature.length)
                : options.bytes === Array
                ? Array.prototype.slice.call(message.signature)
                : message.signature;
          return object;
        };

        /**
         * Converts this Vote to JSON.
         * @function toJSON
         * @memberof tendermint.types.Vote
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Vote.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Vote;
      })();

      types.Commit = (function () {
        /**
         * Properties of a Commit.
         * @memberof tendermint.types
         * @interface ICommit
         * @property {number|Long|null} [height] Commit height
         * @property {number|null} [round] Commit round
         * @property {tendermint.types.IBlockID|null} [blockId] Commit blockId
         * @property {Array.<tendermint.types.ICommitSig>|null} [signatures] Commit signatures
         */

        /**
         * Constructs a new Commit.
         * @memberof tendermint.types
         * @classdesc Represents a Commit.
         * @implements ICommit
         * @constructor
         * @param {tendermint.types.ICommit=} [properties] Properties to set
         */
        function Commit(properties) {
          this.signatures = [];
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * Commit height.
         * @member {number|Long} height
         * @memberof tendermint.types.Commit
         * @instance
         */
        Commit.prototype.height = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * Commit round.
         * @member {number} round
         * @memberof tendermint.types.Commit
         * @instance
         */
        Commit.prototype.round = 0;

        /**
         * Commit blockId.
         * @member {tendermint.types.IBlockID|null|undefined} blockId
         * @memberof tendermint.types.Commit
         * @instance
         */
        Commit.prototype.blockId = null;

        /**
         * Commit signatures.
         * @member {Array.<tendermint.types.ICommitSig>} signatures
         * @memberof tendermint.types.Commit
         * @instance
         */
        Commit.prototype.signatures = $util.emptyArray;

        /**
         * Creates a new Commit instance using the specified properties.
         * @function create
         * @memberof tendermint.types.Commit
         * @static
         * @param {tendermint.types.ICommit=} [properties] Properties to set
         * @returns {tendermint.types.Commit} Commit instance
         */
        Commit.create = function create(properties) {
          return new Commit(properties);
        };

        /**
         * Encodes the specified Commit message. Does not implicitly {@link tendermint.types.Commit.verify|verify} messages.
         * @function encode
         * @memberof tendermint.types.Commit
         * @static
         * @param {tendermint.types.ICommit} message Commit message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Commit.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.height != null && Object.hasOwnProperty.call(message, "height"))
            writer.uint32(/* id 1, wireType 0 =*/ 8).int64(message.height);
          if (message.round != null && Object.hasOwnProperty.call(message, "round"))
            writer.uint32(/* id 2, wireType 0 =*/ 16).int32(message.round);
          if (message.blockId != null && Object.hasOwnProperty.call(message, "blockId"))
            $root.tendermint.types.BlockID.encode(
              message.blockId,
              writer.uint32(/* id 3, wireType 2 =*/ 26).fork(),
            ).ldelim();
          if (message.signatures != null && message.signatures.length)
            for (var i = 0; i < message.signatures.length; ++i)
              $root.tendermint.types.CommitSig.encode(
                message.signatures[i],
                writer.uint32(/* id 4, wireType 2 =*/ 34).fork(),
              ).ldelim();
          return writer;
        };

        /**
         * Encodes the specified Commit message, length delimited. Does not implicitly {@link tendermint.types.Commit.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tendermint.types.Commit
         * @static
         * @param {tendermint.types.ICommit} message Commit message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Commit.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Commit message from the specified reader or buffer.
         * @function decode
         * @memberof tendermint.types.Commit
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tendermint.types.Commit} Commit
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Commit.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.tendermint.types.Commit();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.height = reader.int64();
                break;
              case 2:
                message.round = reader.int32();
                break;
              case 3:
                message.blockId = $root.tendermint.types.BlockID.decode(reader, reader.uint32());
                break;
              case 4:
                if (!(message.signatures && message.signatures.length)) message.signatures = [];
                message.signatures.push($root.tendermint.types.CommitSig.decode(reader, reader.uint32()));
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a Commit message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tendermint.types.Commit
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tendermint.types.Commit} Commit
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Commit.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Commit message.
         * @function verify
         * @memberof tendermint.types.Commit
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Commit.verify = function verify(message) {
          if (typeof message !== "object" || message === null) return "object expected";
          if (message.height != null && message.hasOwnProperty("height"))
            if (
              !$util.isInteger(message.height) &&
              !(message.height && $util.isInteger(message.height.low) && $util.isInteger(message.height.high))
            )
              return "height: integer|Long expected";
          if (message.round != null && message.hasOwnProperty("round"))
            if (!$util.isInteger(message.round)) return "round: integer expected";
          if (message.blockId != null && message.hasOwnProperty("blockId")) {
            var error = $root.tendermint.types.BlockID.verify(message.blockId);
            if (error) return "blockId." + error;
          }
          if (message.signatures != null && message.hasOwnProperty("signatures")) {
            if (!Array.isArray(message.signatures)) return "signatures: array expected";
            for (var i = 0; i < message.signatures.length; ++i) {
              var error = $root.tendermint.types.CommitSig.verify(message.signatures[i]);
              if (error) return "signatures." + error;
            }
          }
          return null;
        };

        /**
         * Creates a Commit message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tendermint.types.Commit
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tendermint.types.Commit} Commit
         */
        Commit.fromObject = function fromObject(object) {
          if (object instanceof $root.tendermint.types.Commit) return object;
          var message = new $root.tendermint.types.Commit();
          if (object.height != null)
            if ($util.Long) (message.height = $util.Long.fromValue(object.height)).unsigned = false;
            else if (typeof object.height === "string") message.height = parseInt(object.height, 10);
            else if (typeof object.height === "number") message.height = object.height;
            else if (typeof object.height === "object")
              message.height = new $util.LongBits(
                object.height.low >>> 0,
                object.height.high >>> 0,
              ).toNumber();
          if (object.round != null) message.round = object.round | 0;
          if (object.blockId != null) {
            if (typeof object.blockId !== "object")
              throw TypeError(".tendermint.types.Commit.blockId: object expected");
            message.blockId = $root.tendermint.types.BlockID.fromObject(object.blockId);
          }
          if (object.signatures) {
            if (!Array.isArray(object.signatures))
              throw TypeError(".tendermint.types.Commit.signatures: array expected");
            message.signatures = [];
            for (var i = 0; i < object.signatures.length; ++i) {
              if (typeof object.signatures[i] !== "object")
                throw TypeError(".tendermint.types.Commit.signatures: object expected");
              message.signatures[i] = $root.tendermint.types.CommitSig.fromObject(object.signatures[i]);
            }
          }
          return message;
        };

        /**
         * Creates a plain object from a Commit message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tendermint.types.Commit
         * @static
         * @param {tendermint.types.Commit} message Commit
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Commit.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.arrays || options.defaults) object.signatures = [];
          if (options.defaults) {
            if ($util.Long) {
              var long = new $util.Long(0, 0, false);
              object.height =
                options.longs === String
                  ? long.toString()
                  : options.longs === Number
                  ? long.toNumber()
                  : long;
            } else object.height = options.longs === String ? "0" : 0;
            object.round = 0;
            object.blockId = null;
          }
          if (message.height != null && message.hasOwnProperty("height"))
            if (typeof message.height === "number")
              object.height = options.longs === String ? String(message.height) : message.height;
            else
              object.height =
                options.longs === String
                  ? $util.Long.prototype.toString.call(message.height)
                  : options.longs === Number
                  ? new $util.LongBits(message.height.low >>> 0, message.height.high >>> 0).toNumber()
                  : message.height;
          if (message.round != null && message.hasOwnProperty("round")) object.round = message.round;
          if (message.blockId != null && message.hasOwnProperty("blockId"))
            object.blockId = $root.tendermint.types.BlockID.toObject(message.blockId, options);
          if (message.signatures && message.signatures.length) {
            object.signatures = [];
            for (var j = 0; j < message.signatures.length; ++j)
              object.signatures[j] = $root.tendermint.types.CommitSig.toObject(
                message.signatures[j],
                options,
              );
          }
          return object;
        };

        /**
         * Converts this Commit to JSON.
         * @function toJSON
         * @memberof tendermint.types.Commit
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Commit.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Commit;
      })();

      types.CommitSig = (function () {
        /**
         * Properties of a CommitSig.
         * @memberof tendermint.types
         * @interface ICommitSig
         * @property {tendermint.types.BlockIDFlag|null} [blockIdFlag] CommitSig blockIdFlag
         * @property {Uint8Array|null} [validatorAddress] CommitSig validatorAddress
         * @property {google.protobuf.ITimestamp|null} [timestamp] CommitSig timestamp
         * @property {Uint8Array|null} [signature] CommitSig signature
         */

        /**
         * Constructs a new CommitSig.
         * @memberof tendermint.types
         * @classdesc Represents a CommitSig.
         * @implements ICommitSig
         * @constructor
         * @param {tendermint.types.ICommitSig=} [properties] Properties to set
         */
        function CommitSig(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * CommitSig blockIdFlag.
         * @member {tendermint.types.BlockIDFlag} blockIdFlag
         * @memberof tendermint.types.CommitSig
         * @instance
         */
        CommitSig.prototype.blockIdFlag = 0;

        /**
         * CommitSig validatorAddress.
         * @member {Uint8Array} validatorAddress
         * @memberof tendermint.types.CommitSig
         * @instance
         */
        CommitSig.prototype.validatorAddress = $util.newBuffer([]);

        /**
         * CommitSig timestamp.
         * @member {google.protobuf.ITimestamp|null|undefined} timestamp
         * @memberof tendermint.types.CommitSig
         * @instance
         */
        CommitSig.prototype.timestamp = null;

        /**
         * CommitSig signature.
         * @member {Uint8Array} signature
         * @memberof tendermint.types.CommitSig
         * @instance
         */
        CommitSig.prototype.signature = $util.newBuffer([]);

        /**
         * Creates a new CommitSig instance using the specified properties.
         * @function create
         * @memberof tendermint.types.CommitSig
         * @static
         * @param {tendermint.types.ICommitSig=} [properties] Properties to set
         * @returns {tendermint.types.CommitSig} CommitSig instance
         */
        CommitSig.create = function create(properties) {
          return new CommitSig(properties);
        };

        /**
         * Encodes the specified CommitSig message. Does not implicitly {@link tendermint.types.CommitSig.verify|verify} messages.
         * @function encode
         * @memberof tendermint.types.CommitSig
         * @static
         * @param {tendermint.types.ICommitSig} message CommitSig message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CommitSig.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.blockIdFlag != null && Object.hasOwnProperty.call(message, "blockIdFlag"))
            writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.blockIdFlag);
          if (message.validatorAddress != null && Object.hasOwnProperty.call(message, "validatorAddress"))
            writer.uint32(/* id 2, wireType 2 =*/ 18).bytes(message.validatorAddress);
          if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
            $root.google.protobuf.Timestamp.encode(
              message.timestamp,
              writer.uint32(/* id 3, wireType 2 =*/ 26).fork(),
            ).ldelim();
          if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
            writer.uint32(/* id 4, wireType 2 =*/ 34).bytes(message.signature);
          return writer;
        };

        /**
         * Encodes the specified CommitSig message, length delimited. Does not implicitly {@link tendermint.types.CommitSig.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tendermint.types.CommitSig
         * @static
         * @param {tendermint.types.ICommitSig} message CommitSig message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CommitSig.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CommitSig message from the specified reader or buffer.
         * @function decode
         * @memberof tendermint.types.CommitSig
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tendermint.types.CommitSig} CommitSig
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CommitSig.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.tendermint.types.CommitSig();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.blockIdFlag = reader.int32();
                break;
              case 2:
                message.validatorAddress = reader.bytes();
                break;
              case 3:
                message.timestamp = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                break;
              case 4:
                message.signature = reader.bytes();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a CommitSig message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tendermint.types.CommitSig
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tendermint.types.CommitSig} CommitSig
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CommitSig.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CommitSig message.
         * @function verify
         * @memberof tendermint.types.CommitSig
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CommitSig.verify = function verify(message) {
          if (typeof message !== "object" || message === null) return "object expected";
          if (message.blockIdFlag != null && message.hasOwnProperty("blockIdFlag"))
            switch (message.blockIdFlag) {
              default:
                return "blockIdFlag: enum value expected";
              case 0:
              case 1:
              case 2:
              case 3:
                break;
            }
          if (message.validatorAddress != null && message.hasOwnProperty("validatorAddress"))
            if (
              !(
                (message.validatorAddress && typeof message.validatorAddress.length === "number") ||
                $util.isString(message.validatorAddress)
              )
            )
              return "validatorAddress: buffer expected";
          if (message.timestamp != null && message.hasOwnProperty("timestamp")) {
            var error = $root.google.protobuf.Timestamp.verify(message.timestamp);
            if (error) return "timestamp." + error;
          }
          if (message.signature != null && message.hasOwnProperty("signature"))
            if (
              !(
                (message.signature && typeof message.signature.length === "number") ||
                $util.isString(message.signature)
              )
            )
              return "signature: buffer expected";
          return null;
        };

        /**
         * Creates a CommitSig message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tendermint.types.CommitSig
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tendermint.types.CommitSig} CommitSig
         */
        CommitSig.fromObject = function fromObject(object) {
          if (object instanceof $root.tendermint.types.CommitSig) return object;
          var message = new $root.tendermint.types.CommitSig();
          switch (object.blockIdFlag) {
            case "BLOCK_ID_FLAG_UNKNOWN":
            case 0:
              message.blockIdFlag = 0;
              break;
            case "BLOCK_ID_FLAG_ABSENT":
            case 1:
              message.blockIdFlag = 1;
              break;
            case "BLOCK_ID_FLAG_COMMIT":
            case 2:
              message.blockIdFlag = 2;
              break;
            case "BLOCK_ID_FLAG_NIL":
            case 3:
              message.blockIdFlag = 3;
              break;
          }
          if (object.validatorAddress != null)
            if (typeof object.validatorAddress === "string")
              $util.base64.decode(
                object.validatorAddress,
                (message.validatorAddress = $util.newBuffer($util.base64.length(object.validatorAddress))),
                0,
              );
            else if (object.validatorAddress.length) message.validatorAddress = object.validatorAddress;
          if (object.timestamp != null) {
            if (typeof object.timestamp !== "object")
              throw TypeError(".tendermint.types.CommitSig.timestamp: object expected");
            message.timestamp = $root.google.protobuf.Timestamp.fromObject(object.timestamp);
          }
          if (object.signature != null)
            if (typeof object.signature === "string")
              $util.base64.decode(
                object.signature,
                (message.signature = $util.newBuffer($util.base64.length(object.signature))),
                0,
              );
            else if (object.signature.length) message.signature = object.signature;
          return message;
        };

        /**
         * Creates a plain object from a CommitSig message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tendermint.types.CommitSig
         * @static
         * @param {tendermint.types.CommitSig} message CommitSig
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CommitSig.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.blockIdFlag = options.enums === String ? "BLOCK_ID_FLAG_UNKNOWN" : 0;
            if (options.bytes === String) object.validatorAddress = "";
            else {
              object.validatorAddress = [];
              if (options.bytes !== Array) object.validatorAddress = $util.newBuffer(object.validatorAddress);
            }
            object.timestamp = null;
            if (options.bytes === String) object.signature = "";
            else {
              object.signature = [];
              if (options.bytes !== Array) object.signature = $util.newBuffer(object.signature);
            }
          }
          if (message.blockIdFlag != null && message.hasOwnProperty("blockIdFlag"))
            object.blockIdFlag =
              options.enums === String
                ? $root.tendermint.types.BlockIDFlag[message.blockIdFlag]
                : message.blockIdFlag;
          if (message.validatorAddress != null && message.hasOwnProperty("validatorAddress"))
            object.validatorAddress =
              options.bytes === String
                ? $util.base64.encode(message.validatorAddress, 0, message.validatorAddress.length)
                : options.bytes === Array
                ? Array.prototype.slice.call(message.validatorAddress)
                : message.validatorAddress;
          if (message.timestamp != null && message.hasOwnProperty("timestamp"))
            object.timestamp = $root.google.protobuf.Timestamp.toObject(message.timestamp, options);
          if (message.signature != null && message.hasOwnProperty("signature"))
            object.signature =
              options.bytes === String
                ? $util.base64.encode(message.signature, 0, message.signature.length)
                : options.bytes === Array
                ? Array.prototype.slice.call(message.signature)
                : message.signature;
          return object;
        };

        /**
         * Converts this CommitSig to JSON.
         * @function toJSON
         * @memberof tendermint.types.CommitSig
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CommitSig.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CommitSig;
      })();

      types.Proposal = (function () {
        /**
         * Properties of a Proposal.
         * @memberof tendermint.types
         * @interface IProposal
         * @property {tendermint.types.SignedMsgType|null} [type] Proposal type
         * @property {number|Long|null} [height] Proposal height
         * @property {number|null} [round] Proposal round
         * @property {number|null} [polRound] Proposal polRound
         * @property {tendermint.types.IBlockID|null} [blockId] Proposal blockId
         * @property {google.protobuf.ITimestamp|null} [timestamp] Proposal timestamp
         * @property {Uint8Array|null} [signature] Proposal signature
         */

        /**
         * Constructs a new Proposal.
         * @memberof tendermint.types
         * @classdesc Represents a Proposal.
         * @implements IProposal
         * @constructor
         * @param {tendermint.types.IProposal=} [properties] Properties to set
         */
        function Proposal(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * Proposal type.
         * @member {tendermint.types.SignedMsgType} type
         * @memberof tendermint.types.Proposal
         * @instance
         */
        Proposal.prototype.type = 0;

        /**
         * Proposal height.
         * @member {number|Long} height
         * @memberof tendermint.types.Proposal
         * @instance
         */
        Proposal.prototype.height = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * Proposal round.
         * @member {number} round
         * @memberof tendermint.types.Proposal
         * @instance
         */
        Proposal.prototype.round = 0;

        /**
         * Proposal polRound.
         * @member {number} polRound
         * @memberof tendermint.types.Proposal
         * @instance
         */
        Proposal.prototype.polRound = 0;

        /**
         * Proposal blockId.
         * @member {tendermint.types.IBlockID|null|undefined} blockId
         * @memberof tendermint.types.Proposal
         * @instance
         */
        Proposal.prototype.blockId = null;

        /**
         * Proposal timestamp.
         * @member {google.protobuf.ITimestamp|null|undefined} timestamp
         * @memberof tendermint.types.Proposal
         * @instance
         */
        Proposal.prototype.timestamp = null;

        /**
         * Proposal signature.
         * @member {Uint8Array} signature
         * @memberof tendermint.types.Proposal
         * @instance
         */
        Proposal.prototype.signature = $util.newBuffer([]);

        /**
         * Creates a new Proposal instance using the specified properties.
         * @function create
         * @memberof tendermint.types.Proposal
         * @static
         * @param {tendermint.types.IProposal=} [properties] Properties to set
         * @returns {tendermint.types.Proposal} Proposal instance
         */
        Proposal.create = function create(properties) {
          return new Proposal(properties);
        };

        /**
         * Encodes the specified Proposal message. Does not implicitly {@link tendermint.types.Proposal.verify|verify} messages.
         * @function encode
         * @memberof tendermint.types.Proposal
         * @static
         * @param {tendermint.types.IProposal} message Proposal message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Proposal.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.type != null && Object.hasOwnProperty.call(message, "type"))
            writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.type);
          if (message.height != null && Object.hasOwnProperty.call(message, "height"))
            writer.uint32(/* id 2, wireType 0 =*/ 16).int64(message.height);
          if (message.round != null && Object.hasOwnProperty.call(message, "round"))
            writer.uint32(/* id 3, wireType 0 =*/ 24).int32(message.round);
          if (message.polRound != null && Object.hasOwnProperty.call(message, "polRound"))
            writer.uint32(/* id 4, wireType 0 =*/ 32).int32(message.polRound);
          if (message.blockId != null && Object.hasOwnProperty.call(message, "blockId"))
            $root.tendermint.types.BlockID.encode(
              message.blockId,
              writer.uint32(/* id 5, wireType 2 =*/ 42).fork(),
            ).ldelim();
          if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
            $root.google.protobuf.Timestamp.encode(
              message.timestamp,
              writer.uint32(/* id 6, wireType 2 =*/ 50).fork(),
            ).ldelim();
          if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
            writer.uint32(/* id 7, wireType 2 =*/ 58).bytes(message.signature);
          return writer;
        };

        /**
         * Encodes the specified Proposal message, length delimited. Does not implicitly {@link tendermint.types.Proposal.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tendermint.types.Proposal
         * @static
         * @param {tendermint.types.IProposal} message Proposal message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Proposal.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Proposal message from the specified reader or buffer.
         * @function decode
         * @memberof tendermint.types.Proposal
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tendermint.types.Proposal} Proposal
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Proposal.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.tendermint.types.Proposal();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.type = reader.int32();
                break;
              case 2:
                message.height = reader.int64();
                break;
              case 3:
                message.round = reader.int32();
                break;
              case 4:
                message.polRound = reader.int32();
                break;
              case 5:
                message.blockId = $root.tendermint.types.BlockID.decode(reader, reader.uint32());
                break;
              case 6:
                message.timestamp = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                break;
              case 7:
                message.signature = reader.bytes();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a Proposal message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tendermint.types.Proposal
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tendermint.types.Proposal} Proposal
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Proposal.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Proposal message.
         * @function verify
         * @memberof tendermint.types.Proposal
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Proposal.verify = function verify(message) {
          if (typeof message !== "object" || message === null) return "object expected";
          if (message.type != null && message.hasOwnProperty("type"))
            switch (message.type) {
              default:
                return "type: enum value expected";
              case 0:
              case 1:
              case 2:
              case 32:
                break;
            }
          if (message.height != null && message.hasOwnProperty("height"))
            if (
              !$util.isInteger(message.height) &&
              !(message.height && $util.isInteger(message.height.low) && $util.isInteger(message.height.high))
            )
              return "height: integer|Long expected";
          if (message.round != null && message.hasOwnProperty("round"))
            if (!$util.isInteger(message.round)) return "round: integer expected";
          if (message.polRound != null && message.hasOwnProperty("polRound"))
            if (!$util.isInteger(message.polRound)) return "polRound: integer expected";
          if (message.blockId != null && message.hasOwnProperty("blockId")) {
            var error = $root.tendermint.types.BlockID.verify(message.blockId);
            if (error) return "blockId." + error;
          }
          if (message.timestamp != null && message.hasOwnProperty("timestamp")) {
            var error = $root.google.protobuf.Timestamp.verify(message.timestamp);
            if (error) return "timestamp." + error;
          }
          if (message.signature != null && message.hasOwnProperty("signature"))
            if (
              !(
                (message.signature && typeof message.signature.length === "number") ||
                $util.isString(message.signature)
              )
            )
              return "signature: buffer expected";
          return null;
        };

        /**
         * Creates a Proposal message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tendermint.types.Proposal
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tendermint.types.Proposal} Proposal
         */
        Proposal.fromObject = function fromObject(object) {
          if (object instanceof $root.tendermint.types.Proposal) return object;
          var message = new $root.tendermint.types.Proposal();
          switch (object.type) {
            case "SIGNED_MSG_TYPE_UNKNOWN":
            case 0:
              message.type = 0;
              break;
            case "SIGNED_MSG_TYPE_PREVOTE":
            case 1:
              message.type = 1;
              break;
            case "SIGNED_MSG_TYPE_PRECOMMIT":
            case 2:
              message.type = 2;
              break;
            case "SIGNED_MSG_TYPE_PROPOSAL":
            case 32:
              message.type = 32;
              break;
          }
          if (object.height != null)
            if ($util.Long) (message.height = $util.Long.fromValue(object.height)).unsigned = false;
            else if (typeof object.height === "string") message.height = parseInt(object.height, 10);
            else if (typeof object.height === "number") message.height = object.height;
            else if (typeof object.height === "object")
              message.height = new $util.LongBits(
                object.height.low >>> 0,
                object.height.high >>> 0,
              ).toNumber();
          if (object.round != null) message.round = object.round | 0;
          if (object.polRound != null) message.polRound = object.polRound | 0;
          if (object.blockId != null) {
            if (typeof object.blockId !== "object")
              throw TypeError(".tendermint.types.Proposal.blockId: object expected");
            message.blockId = $root.tendermint.types.BlockID.fromObject(object.blockId);
          }
          if (object.timestamp != null) {
            if (typeof object.timestamp !== "object")
              throw TypeError(".tendermint.types.Proposal.timestamp: object expected");
            message.timestamp = $root.google.protobuf.Timestamp.fromObject(object.timestamp);
          }
          if (object.signature != null)
            if (typeof object.signature === "string")
              $util.base64.decode(
                object.signature,
                (message.signature = $util.newBuffer($util.base64.length(object.signature))),
                0,
              );
            else if (object.signature.length) message.signature = object.signature;
          return message;
        };

        /**
         * Creates a plain object from a Proposal message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tendermint.types.Proposal
         * @static
         * @param {tendermint.types.Proposal} message Proposal
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Proposal.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.type = options.enums === String ? "SIGNED_MSG_TYPE_UNKNOWN" : 0;
            if ($util.Long) {
              var long = new $util.Long(0, 0, false);
              object.height =
                options.longs === String
                  ? long.toString()
                  : options.longs === Number
                  ? long.toNumber()
                  : long;
            } else object.height = options.longs === String ? "0" : 0;
            object.round = 0;
            object.polRound = 0;
            object.blockId = null;
            object.timestamp = null;
            if (options.bytes === String) object.signature = "";
            else {
              object.signature = [];
              if (options.bytes !== Array) object.signature = $util.newBuffer(object.signature);
            }
          }
          if (message.type != null && message.hasOwnProperty("type"))
            object.type =
              options.enums === String ? $root.tendermint.types.SignedMsgType[message.type] : message.type;
          if (message.height != null && message.hasOwnProperty("height"))
            if (typeof message.height === "number")
              object.height = options.longs === String ? String(message.height) : message.height;
            else
              object.height =
                options.longs === String
                  ? $util.Long.prototype.toString.call(message.height)
                  : options.longs === Number
                  ? new $util.LongBits(message.height.low >>> 0, message.height.high >>> 0).toNumber()
                  : message.height;
          if (message.round != null && message.hasOwnProperty("round")) object.round = message.round;
          if (message.polRound != null && message.hasOwnProperty("polRound"))
            object.polRound = message.polRound;
          if (message.blockId != null && message.hasOwnProperty("blockId"))
            object.blockId = $root.tendermint.types.BlockID.toObject(message.blockId, options);
          if (message.timestamp != null && message.hasOwnProperty("timestamp"))
            object.timestamp = $root.google.protobuf.Timestamp.toObject(message.timestamp, options);
          if (message.signature != null && message.hasOwnProperty("signature"))
            object.signature =
              options.bytes === String
                ? $util.base64.encode(message.signature, 0, message.signature.length)
                : options.bytes === Array
                ? Array.prototype.slice.call(message.signature)
                : message.signature;
          return object;
        };

        /**
         * Converts this Proposal to JSON.
         * @function toJSON
         * @memberof tendermint.types.Proposal
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Proposal.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Proposal;
      })();

      types.SignedHeader = (function () {
        /**
         * Properties of a SignedHeader.
         * @memberof tendermint.types
         * @interface ISignedHeader
         * @property {tendermint.types.IHeader|null} [header] SignedHeader header
         * @property {tendermint.types.ICommit|null} [commit] SignedHeader commit
         */

        /**
         * Constructs a new SignedHeader.
         * @memberof tendermint.types
         * @classdesc Represents a SignedHeader.
         * @implements ISignedHeader
         * @constructor
         * @param {tendermint.types.ISignedHeader=} [properties] Properties to set
         */
        function SignedHeader(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * SignedHeader header.
         * @member {tendermint.types.IHeader|null|undefined} header
         * @memberof tendermint.types.SignedHeader
         * @instance
         */
        SignedHeader.prototype.header = null;

        /**
         * SignedHeader commit.
         * @member {tendermint.types.ICommit|null|undefined} commit
         * @memberof tendermint.types.SignedHeader
         * @instance
         */
        SignedHeader.prototype.commit = null;

        /**
         * Creates a new SignedHeader instance using the specified properties.
         * @function create
         * @memberof tendermint.types.SignedHeader
         * @static
         * @param {tendermint.types.ISignedHeader=} [properties] Properties to set
         * @returns {tendermint.types.SignedHeader} SignedHeader instance
         */
        SignedHeader.create = function create(properties) {
          return new SignedHeader(properties);
        };

        /**
         * Encodes the specified SignedHeader message. Does not implicitly {@link tendermint.types.SignedHeader.verify|verify} messages.
         * @function encode
         * @memberof tendermint.types.SignedHeader
         * @static
         * @param {tendermint.types.ISignedHeader} message SignedHeader message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SignedHeader.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.header != null && Object.hasOwnProperty.call(message, "header"))
            $root.tendermint.types.Header.encode(
              message.header,
              writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
            ).ldelim();
          if (message.commit != null && Object.hasOwnProperty.call(message, "commit"))
            $root.tendermint.types.Commit.encode(
              message.commit,
              writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
            ).ldelim();
          return writer;
        };

        /**
         * Encodes the specified SignedHeader message, length delimited. Does not implicitly {@link tendermint.types.SignedHeader.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tendermint.types.SignedHeader
         * @static
         * @param {tendermint.types.ISignedHeader} message SignedHeader message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SignedHeader.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SignedHeader message from the specified reader or buffer.
         * @function decode
         * @memberof tendermint.types.SignedHeader
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tendermint.types.SignedHeader} SignedHeader
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SignedHeader.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.tendermint.types.SignedHeader();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.header = $root.tendermint.types.Header.decode(reader, reader.uint32());
                break;
              case 2:
                message.commit = $root.tendermint.types.Commit.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a SignedHeader message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tendermint.types.SignedHeader
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tendermint.types.SignedHeader} SignedHeader
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SignedHeader.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SignedHeader message.
         * @function verify
         * @memberof tendermint.types.SignedHeader
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SignedHeader.verify = function verify(message) {
          if (typeof message !== "object" || message === null) return "object expected";
          if (message.header != null && message.hasOwnProperty("header")) {
            var error = $root.tendermint.types.Header.verify(message.header);
            if (error) return "header." + error;
          }
          if (message.commit != null && message.hasOwnProperty("commit")) {
            var error = $root.tendermint.types.Commit.verify(message.commit);
            if (error) return "commit." + error;
          }
          return null;
        };

        /**
         * Creates a SignedHeader message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tendermint.types.SignedHeader
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tendermint.types.SignedHeader} SignedHeader
         */
        SignedHeader.fromObject = function fromObject(object) {
          if (object instanceof $root.tendermint.types.SignedHeader) return object;
          var message = new $root.tendermint.types.SignedHeader();
          if (object.header != null) {
            if (typeof object.header !== "object")
              throw TypeError(".tendermint.types.SignedHeader.header: object expected");
            message.header = $root.tendermint.types.Header.fromObject(object.header);
          }
          if (object.commit != null) {
            if (typeof object.commit !== "object")
              throw TypeError(".tendermint.types.SignedHeader.commit: object expected");
            message.commit = $root.tendermint.types.Commit.fromObject(object.commit);
          }
          return message;
        };

        /**
         * Creates a plain object from a SignedHeader message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tendermint.types.SignedHeader
         * @static
         * @param {tendermint.types.SignedHeader} message SignedHeader
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SignedHeader.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.header = null;
            object.commit = null;
          }
          if (message.header != null && message.hasOwnProperty("header"))
            object.header = $root.tendermint.types.Header.toObject(message.header, options);
          if (message.commit != null && message.hasOwnProperty("commit"))
            object.commit = $root.tendermint.types.Commit.toObject(message.commit, options);
          return object;
        };

        /**
         * Converts this SignedHeader to JSON.
         * @function toJSON
         * @memberof tendermint.types.SignedHeader
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SignedHeader.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SignedHeader;
      })();

      types.LightBlock = (function () {
        /**
         * Properties of a LightBlock.
         * @memberof tendermint.types
         * @interface ILightBlock
         * @property {tendermint.types.ISignedHeader|null} [signedHeader] LightBlock signedHeader
         * @property {tendermint.types.IValidatorSet|null} [validatorSet] LightBlock validatorSet
         */

        /**
         * Constructs a new LightBlock.
         * @memberof tendermint.types
         * @classdesc Represents a LightBlock.
         * @implements ILightBlock
         * @constructor
         * @param {tendermint.types.ILightBlock=} [properties] Properties to set
         */
        function LightBlock(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * LightBlock signedHeader.
         * @member {tendermint.types.ISignedHeader|null|undefined} signedHeader
         * @memberof tendermint.types.LightBlock
         * @instance
         */
        LightBlock.prototype.signedHeader = null;

        /**
         * LightBlock validatorSet.
         * @member {tendermint.types.IValidatorSet|null|undefined} validatorSet
         * @memberof tendermint.types.LightBlock
         * @instance
         */
        LightBlock.prototype.validatorSet = null;

        /**
         * Creates a new LightBlock instance using the specified properties.
         * @function create
         * @memberof tendermint.types.LightBlock
         * @static
         * @param {tendermint.types.ILightBlock=} [properties] Properties to set
         * @returns {tendermint.types.LightBlock} LightBlock instance
         */
        LightBlock.create = function create(properties) {
          return new LightBlock(properties);
        };

        /**
         * Encodes the specified LightBlock message. Does not implicitly {@link tendermint.types.LightBlock.verify|verify} messages.
         * @function encode
         * @memberof tendermint.types.LightBlock
         * @static
         * @param {tendermint.types.ILightBlock} message LightBlock message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LightBlock.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.signedHeader != null && Object.hasOwnProperty.call(message, "signedHeader"))
            $root.tendermint.types.SignedHeader.encode(
              message.signedHeader,
              writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
            ).ldelim();
          if (message.validatorSet != null && Object.hasOwnProperty.call(message, "validatorSet"))
            $root.tendermint.types.ValidatorSet.encode(
              message.validatorSet,
              writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
            ).ldelim();
          return writer;
        };

        /**
         * Encodes the specified LightBlock message, length delimited. Does not implicitly {@link tendermint.types.LightBlock.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tendermint.types.LightBlock
         * @static
         * @param {tendermint.types.ILightBlock} message LightBlock message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LightBlock.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LightBlock message from the specified reader or buffer.
         * @function decode
         * @memberof tendermint.types.LightBlock
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tendermint.types.LightBlock} LightBlock
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LightBlock.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.tendermint.types.LightBlock();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.signedHeader = $root.tendermint.types.SignedHeader.decode(reader, reader.uint32());
                break;
              case 2:
                message.validatorSet = $root.tendermint.types.ValidatorSet.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a LightBlock message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tendermint.types.LightBlock
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tendermint.types.LightBlock} LightBlock
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LightBlock.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LightBlock message.
         * @function verify
         * @memberof tendermint.types.LightBlock
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LightBlock.verify = function verify(message) {
          if (typeof message !== "object" || message === null) return "object expected";
          if (message.signedHeader != null && message.hasOwnProperty("signedHeader")) {
            var error = $root.tendermint.types.SignedHeader.verify(message.signedHeader);
            if (error) return "signedHeader." + error;
          }
          if (message.validatorSet != null && message.hasOwnProperty("validatorSet")) {
            var error = $root.tendermint.types.ValidatorSet.verify(message.validatorSet);
            if (error) return "validatorSet." + error;
          }
          return null;
        };

        /**
         * Creates a LightBlock message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tendermint.types.LightBlock
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tendermint.types.LightBlock} LightBlock
         */
        LightBlock.fromObject = function fromObject(object) {
          if (object instanceof $root.tendermint.types.LightBlock) return object;
          var message = new $root.tendermint.types.LightBlock();
          if (object.signedHeader != null) {
            if (typeof object.signedHeader !== "object")
              throw TypeError(".tendermint.types.LightBlock.signedHeader: object expected");
            message.signedHeader = $root.tendermint.types.SignedHeader.fromObject(object.signedHeader);
          }
          if (object.validatorSet != null) {
            if (typeof object.validatorSet !== "object")
              throw TypeError(".tendermint.types.LightBlock.validatorSet: object expected");
            message.validatorSet = $root.tendermint.types.ValidatorSet.fromObject(object.validatorSet);
          }
          return message;
        };

        /**
         * Creates a plain object from a LightBlock message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tendermint.types.LightBlock
         * @static
         * @param {tendermint.types.LightBlock} message LightBlock
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        LightBlock.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.signedHeader = null;
            object.validatorSet = null;
          }
          if (message.signedHeader != null && message.hasOwnProperty("signedHeader"))
            object.signedHeader = $root.tendermint.types.SignedHeader.toObject(message.signedHeader, options);
          if (message.validatorSet != null && message.hasOwnProperty("validatorSet"))
            object.validatorSet = $root.tendermint.types.ValidatorSet.toObject(message.validatorSet, options);
          return object;
        };

        /**
         * Converts this LightBlock to JSON.
         * @function toJSON
         * @memberof tendermint.types.LightBlock
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        LightBlock.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return LightBlock;
      })();

      types.BlockMeta = (function () {
        /**
         * Properties of a BlockMeta.
         * @memberof tendermint.types
         * @interface IBlockMeta
         * @property {tendermint.types.IBlockID|null} [blockId] BlockMeta blockId
         * @property {number|Long|null} [blockSize] BlockMeta blockSize
         * @property {tendermint.types.IHeader|null} [header] BlockMeta header
         * @property {number|Long|null} [numTxs] BlockMeta numTxs
         */

        /**
         * Constructs a new BlockMeta.
         * @memberof tendermint.types
         * @classdesc Represents a BlockMeta.
         * @implements IBlockMeta
         * @constructor
         * @param {tendermint.types.IBlockMeta=} [properties] Properties to set
         */
        function BlockMeta(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * BlockMeta blockId.
         * @member {tendermint.types.IBlockID|null|undefined} blockId
         * @memberof tendermint.types.BlockMeta
         * @instance
         */
        BlockMeta.prototype.blockId = null;

        /**
         * BlockMeta blockSize.
         * @member {number|Long} blockSize
         * @memberof tendermint.types.BlockMeta
         * @instance
         */
        BlockMeta.prototype.blockSize = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * BlockMeta header.
         * @member {tendermint.types.IHeader|null|undefined} header
         * @memberof tendermint.types.BlockMeta
         * @instance
         */
        BlockMeta.prototype.header = null;

        /**
         * BlockMeta numTxs.
         * @member {number|Long} numTxs
         * @memberof tendermint.types.BlockMeta
         * @instance
         */
        BlockMeta.prototype.numTxs = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * Creates a new BlockMeta instance using the specified properties.
         * @function create
         * @memberof tendermint.types.BlockMeta
         * @static
         * @param {tendermint.types.IBlockMeta=} [properties] Properties to set
         * @returns {tendermint.types.BlockMeta} BlockMeta instance
         */
        BlockMeta.create = function create(properties) {
          return new BlockMeta(properties);
        };

        /**
         * Encodes the specified BlockMeta message. Does not implicitly {@link tendermint.types.BlockMeta.verify|verify} messages.
         * @function encode
         * @memberof tendermint.types.BlockMeta
         * @static
         * @param {tendermint.types.IBlockMeta} message BlockMeta message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BlockMeta.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.blockId != null && Object.hasOwnProperty.call(message, "blockId"))
            $root.tendermint.types.BlockID.encode(
              message.blockId,
              writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
            ).ldelim();
          if (message.blockSize != null && Object.hasOwnProperty.call(message, "blockSize"))
            writer.uint32(/* id 2, wireType 0 =*/ 16).int64(message.blockSize);
          if (message.header != null && Object.hasOwnProperty.call(message, "header"))
            $root.tendermint.types.Header.encode(
              message.header,
              writer.uint32(/* id 3, wireType 2 =*/ 26).fork(),
            ).ldelim();
          if (message.numTxs != null && Object.hasOwnProperty.call(message, "numTxs"))
            writer.uint32(/* id 4, wireType 0 =*/ 32).int64(message.numTxs);
          return writer;
        };

        /**
         * Encodes the specified BlockMeta message, length delimited. Does not implicitly {@link tendermint.types.BlockMeta.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tendermint.types.BlockMeta
         * @static
         * @param {tendermint.types.IBlockMeta} message BlockMeta message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BlockMeta.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BlockMeta message from the specified reader or buffer.
         * @function decode
         * @memberof tendermint.types.BlockMeta
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tendermint.types.BlockMeta} BlockMeta
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BlockMeta.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.tendermint.types.BlockMeta();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.blockId = $root.tendermint.types.BlockID.decode(reader, reader.uint32());
                break;
              case 2:
                message.blockSize = reader.int64();
                break;
              case 3:
                message.header = $root.tendermint.types.Header.decode(reader, reader.uint32());
                break;
              case 4:
                message.numTxs = reader.int64();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a BlockMeta message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tendermint.types.BlockMeta
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tendermint.types.BlockMeta} BlockMeta
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BlockMeta.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BlockMeta message.
         * @function verify
         * @memberof tendermint.types.BlockMeta
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BlockMeta.verify = function verify(message) {
          if (typeof message !== "object" || message === null) return "object expected";
          if (message.blockId != null && message.hasOwnProperty("blockId")) {
            var error = $root.tendermint.types.BlockID.verify(message.blockId);
            if (error) return "blockId." + error;
          }
          if (message.blockSize != null && message.hasOwnProperty("blockSize"))
            if (
              !$util.isInteger(message.blockSize) &&
              !(
                message.blockSize &&
                $util.isInteger(message.blockSize.low) &&
                $util.isInteger(message.blockSize.high)
              )
            )
              return "blockSize: integer|Long expected";
          if (message.header != null && message.hasOwnProperty("header")) {
            var error = $root.tendermint.types.Header.verify(message.header);
            if (error) return "header." + error;
          }
          if (message.numTxs != null && message.hasOwnProperty("numTxs"))
            if (
              !$util.isInteger(message.numTxs) &&
              !(message.numTxs && $util.isInteger(message.numTxs.low) && $util.isInteger(message.numTxs.high))
            )
              return "numTxs: integer|Long expected";
          return null;
        };

        /**
         * Creates a BlockMeta message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tendermint.types.BlockMeta
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tendermint.types.BlockMeta} BlockMeta
         */
        BlockMeta.fromObject = function fromObject(object) {
          if (object instanceof $root.tendermint.types.BlockMeta) return object;
          var message = new $root.tendermint.types.BlockMeta();
          if (object.blockId != null) {
            if (typeof object.blockId !== "object")
              throw TypeError(".tendermint.types.BlockMeta.blockId: object expected");
            message.blockId = $root.tendermint.types.BlockID.fromObject(object.blockId);
          }
          if (object.blockSize != null)
            if ($util.Long) (message.blockSize = $util.Long.fromValue(object.blockSize)).unsigned = false;
            else if (typeof object.blockSize === "string") message.blockSize = parseInt(object.blockSize, 10);
            else if (typeof object.blockSize === "number") message.blockSize = object.blockSize;
            else if (typeof object.blockSize === "object")
              message.blockSize = new $util.LongBits(
                object.blockSize.low >>> 0,
                object.blockSize.high >>> 0,
              ).toNumber();
          if (object.header != null) {
            if (typeof object.header !== "object")
              throw TypeError(".tendermint.types.BlockMeta.header: object expected");
            message.header = $root.tendermint.types.Header.fromObject(object.header);
          }
          if (object.numTxs != null)
            if ($util.Long) (message.numTxs = $util.Long.fromValue(object.numTxs)).unsigned = false;
            else if (typeof object.numTxs === "string") message.numTxs = parseInt(object.numTxs, 10);
            else if (typeof object.numTxs === "number") message.numTxs = object.numTxs;
            else if (typeof object.numTxs === "object")
              message.numTxs = new $util.LongBits(
                object.numTxs.low >>> 0,
                object.numTxs.high >>> 0,
              ).toNumber();
          return message;
        };

        /**
         * Creates a plain object from a BlockMeta message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tendermint.types.BlockMeta
         * @static
         * @param {tendermint.types.BlockMeta} message BlockMeta
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BlockMeta.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.blockId = null;
            if ($util.Long) {
              var long = new $util.Long(0, 0, false);
              object.blockSize =
                options.longs === String
                  ? long.toString()
                  : options.longs === Number
                  ? long.toNumber()
                  : long;
            } else object.blockSize = options.longs === String ? "0" : 0;
            object.header = null;
            if ($util.Long) {
              var long = new $util.Long(0, 0, false);
              object.numTxs =
                options.longs === String
                  ? long.toString()
                  : options.longs === Number
                  ? long.toNumber()
                  : long;
            } else object.numTxs = options.longs === String ? "0" : 0;
          }
          if (message.blockId != null && message.hasOwnProperty("blockId"))
            object.blockId = $root.tendermint.types.BlockID.toObject(message.blockId, options);
          if (message.blockSize != null && message.hasOwnProperty("blockSize"))
            if (typeof message.blockSize === "number")
              object.blockSize = options.longs === String ? String(message.blockSize) : message.blockSize;
            else
              object.blockSize =
                options.longs === String
                  ? $util.Long.prototype.toString.call(message.blockSize)
                  : options.longs === Number
                  ? new $util.LongBits(message.blockSize.low >>> 0, message.blockSize.high >>> 0).toNumber()
                  : message.blockSize;
          if (message.header != null && message.hasOwnProperty("header"))
            object.header = $root.tendermint.types.Header.toObject(message.header, options);
          if (message.numTxs != null && message.hasOwnProperty("numTxs"))
            if (typeof message.numTxs === "number")
              object.numTxs = options.longs === String ? String(message.numTxs) : message.numTxs;
            else
              object.numTxs =
                options.longs === String
                  ? $util.Long.prototype.toString.call(message.numTxs)
                  : options.longs === Number
                  ? new $util.LongBits(message.numTxs.low >>> 0, message.numTxs.high >>> 0).toNumber()
                  : message.numTxs;
          return object;
        };

        /**
         * Converts this BlockMeta to JSON.
         * @function toJSON
         * @memberof tendermint.types.BlockMeta
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BlockMeta.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BlockMeta;
      })();

      types.TxProof = (function () {
        /**
         * Properties of a TxProof.
         * @memberof tendermint.types
         * @interface ITxProof
         * @property {Uint8Array|null} [rootHash] TxProof rootHash
         * @property {Uint8Array|null} [data] TxProof data
         * @property {tendermint.crypto.IProof|null} [proof] TxProof proof
         */

        /**
         * Constructs a new TxProof.
         * @memberof tendermint.types
         * @classdesc Represents a TxProof.
         * @implements ITxProof
         * @constructor
         * @param {tendermint.types.ITxProof=} [properties] Properties to set
         */
        function TxProof(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * TxProof rootHash.
         * @member {Uint8Array} rootHash
         * @memberof tendermint.types.TxProof
         * @instance
         */
        TxProof.prototype.rootHash = $util.newBuffer([]);

        /**
         * TxProof data.
         * @member {Uint8Array} data
         * @memberof tendermint.types.TxProof
         * @instance
         */
        TxProof.prototype.data = $util.newBuffer([]);

        /**
         * TxProof proof.
         * @member {tendermint.crypto.IProof|null|undefined} proof
         * @memberof tendermint.types.TxProof
         * @instance
         */
        TxProof.prototype.proof = null;

        /**
         * Creates a new TxProof instance using the specified properties.
         * @function create
         * @memberof tendermint.types.TxProof
         * @static
         * @param {tendermint.types.ITxProof=} [properties] Properties to set
         * @returns {tendermint.types.TxProof} TxProof instance
         */
        TxProof.create = function create(properties) {
          return new TxProof(properties);
        };

        /**
         * Encodes the specified TxProof message. Does not implicitly {@link tendermint.types.TxProof.verify|verify} messages.
         * @function encode
         * @memberof tendermint.types.TxProof
         * @static
         * @param {tendermint.types.ITxProof} message TxProof message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TxProof.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.rootHash != null && Object.hasOwnProperty.call(message, "rootHash"))
            writer.uint32(/* id 1, wireType 2 =*/ 10).bytes(message.rootHash);
          if (message.data != null && Object.hasOwnProperty.call(message, "data"))
            writer.uint32(/* id 2, wireType 2 =*/ 18).bytes(message.data);
          if (message.proof != null && Object.hasOwnProperty.call(message, "proof"))
            $root.tendermint.crypto.Proof.encode(
              message.proof,
              writer.uint32(/* id 3, wireType 2 =*/ 26).fork(),
            ).ldelim();
          return writer;
        };

        /**
         * Encodes the specified TxProof message, length delimited. Does not implicitly {@link tendermint.types.TxProof.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tendermint.types.TxProof
         * @static
         * @param {tendermint.types.ITxProof} message TxProof message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TxProof.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TxProof message from the specified reader or buffer.
         * @function decode
         * @memberof tendermint.types.TxProof
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tendermint.types.TxProof} TxProof
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TxProof.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.tendermint.types.TxProof();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.rootHash = reader.bytes();
                break;
              case 2:
                message.data = reader.bytes();
                break;
              case 3:
                message.proof = $root.tendermint.crypto.Proof.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a TxProof message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tendermint.types.TxProof
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tendermint.types.TxProof} TxProof
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TxProof.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TxProof message.
         * @function verify
         * @memberof tendermint.types.TxProof
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TxProof.verify = function verify(message) {
          if (typeof message !== "object" || message === null) return "object expected";
          if (message.rootHash != null && message.hasOwnProperty("rootHash"))
            if (
              !(
                (message.rootHash && typeof message.rootHash.length === "number") ||
                $util.isString(message.rootHash)
              )
            )
              return "rootHash: buffer expected";
          if (message.data != null && message.hasOwnProperty("data"))
            if (!((message.data && typeof message.data.length === "number") || $util.isString(message.data)))
              return "data: buffer expected";
          if (message.proof != null && message.hasOwnProperty("proof")) {
            var error = $root.tendermint.crypto.Proof.verify(message.proof);
            if (error) return "proof." + error;
          }
          return null;
        };

        /**
         * Creates a TxProof message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tendermint.types.TxProof
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tendermint.types.TxProof} TxProof
         */
        TxProof.fromObject = function fromObject(object) {
          if (object instanceof $root.tendermint.types.TxProof) return object;
          var message = new $root.tendermint.types.TxProof();
          if (object.rootHash != null)
            if (typeof object.rootHash === "string")
              $util.base64.decode(
                object.rootHash,
                (message.rootHash = $util.newBuffer($util.base64.length(object.rootHash))),
                0,
              );
            else if (object.rootHash.length) message.rootHash = object.rootHash;
          if (object.data != null)
            if (typeof object.data === "string")
              $util.base64.decode(
                object.data,
                (message.data = $util.newBuffer($util.base64.length(object.data))),
                0,
              );
            else if (object.data.length) message.data = object.data;
          if (object.proof != null) {
            if (typeof object.proof !== "object")
              throw TypeError(".tendermint.types.TxProof.proof: object expected");
            message.proof = $root.tendermint.crypto.Proof.fromObject(object.proof);
          }
          return message;
        };

        /**
         * Creates a plain object from a TxProof message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tendermint.types.TxProof
         * @static
         * @param {tendermint.types.TxProof} message TxProof
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TxProof.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            if (options.bytes === String) object.rootHash = "";
            else {
              object.rootHash = [];
              if (options.bytes !== Array) object.rootHash = $util.newBuffer(object.rootHash);
            }
            if (options.bytes === String) object.data = "";
            else {
              object.data = [];
              if (options.bytes !== Array) object.data = $util.newBuffer(object.data);
            }
            object.proof = null;
          }
          if (message.rootHash != null && message.hasOwnProperty("rootHash"))
            object.rootHash =
              options.bytes === String
                ? $util.base64.encode(message.rootHash, 0, message.rootHash.length)
                : options.bytes === Array
                ? Array.prototype.slice.call(message.rootHash)
                : message.rootHash;
          if (message.data != null && message.hasOwnProperty("data"))
            object.data =
              options.bytes === String
                ? $util.base64.encode(message.data, 0, message.data.length)
                : options.bytes === Array
                ? Array.prototype.slice.call(message.data)
                : message.data;
          if (message.proof != null && message.hasOwnProperty("proof"))
            object.proof = $root.tendermint.crypto.Proof.toObject(message.proof, options);
          return object;
        };

        /**
         * Converts this TxProof to JSON.
         * @function toJSON
         * @memberof tendermint.types.TxProof
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TxProof.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TxProof;
      })();

      types.ValidatorSet = (function () {
        /**
         * Properties of a ValidatorSet.
         * @memberof tendermint.types
         * @interface IValidatorSet
         * @property {Array.<tendermint.types.IValidator>|null} [validators] ValidatorSet validators
         * @property {tendermint.types.IValidator|null} [proposer] ValidatorSet proposer
         * @property {number|Long|null} [totalVotingPower] ValidatorSet totalVotingPower
         */

        /**
         * Constructs a new ValidatorSet.
         * @memberof tendermint.types
         * @classdesc Represents a ValidatorSet.
         * @implements IValidatorSet
         * @constructor
         * @param {tendermint.types.IValidatorSet=} [properties] Properties to set
         */
        function ValidatorSet(properties) {
          this.validators = [];
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * ValidatorSet validators.
         * @member {Array.<tendermint.types.IValidator>} validators
         * @memberof tendermint.types.ValidatorSet
         * @instance
         */
        ValidatorSet.prototype.validators = $util.emptyArray;

        /**
         * ValidatorSet proposer.
         * @member {tendermint.types.IValidator|null|undefined} proposer
         * @memberof tendermint.types.ValidatorSet
         * @instance
         */
        ValidatorSet.prototype.proposer = null;

        /**
         * ValidatorSet totalVotingPower.
         * @member {number|Long} totalVotingPower
         * @memberof tendermint.types.ValidatorSet
         * @instance
         */
        ValidatorSet.prototype.totalVotingPower = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * Creates a new ValidatorSet instance using the specified properties.
         * @function create
         * @memberof tendermint.types.ValidatorSet
         * @static
         * @param {tendermint.types.IValidatorSet=} [properties] Properties to set
         * @returns {tendermint.types.ValidatorSet} ValidatorSet instance
         */
        ValidatorSet.create = function create(properties) {
          return new ValidatorSet(properties);
        };

        /**
         * Encodes the specified ValidatorSet message. Does not implicitly {@link tendermint.types.ValidatorSet.verify|verify} messages.
         * @function encode
         * @memberof tendermint.types.ValidatorSet
         * @static
         * @param {tendermint.types.IValidatorSet} message ValidatorSet message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ValidatorSet.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.validators != null && message.validators.length)
            for (var i = 0; i < message.validators.length; ++i)
              $root.tendermint.types.Validator.encode(
                message.validators[i],
                writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
              ).ldelim();
          if (message.proposer != null && Object.hasOwnProperty.call(message, "proposer"))
            $root.tendermint.types.Validator.encode(
              message.proposer,
              writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
            ).ldelim();
          if (message.totalVotingPower != null && Object.hasOwnProperty.call(message, "totalVotingPower"))
            writer.uint32(/* id 3, wireType 0 =*/ 24).int64(message.totalVotingPower);
          return writer;
        };

        /**
         * Encodes the specified ValidatorSet message, length delimited. Does not implicitly {@link tendermint.types.ValidatorSet.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tendermint.types.ValidatorSet
         * @static
         * @param {tendermint.types.IValidatorSet} message ValidatorSet message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ValidatorSet.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ValidatorSet message from the specified reader or buffer.
         * @function decode
         * @memberof tendermint.types.ValidatorSet
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tendermint.types.ValidatorSet} ValidatorSet
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ValidatorSet.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.tendermint.types.ValidatorSet();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                if (!(message.validators && message.validators.length)) message.validators = [];
                message.validators.push($root.tendermint.types.Validator.decode(reader, reader.uint32()));
                break;
              case 2:
                message.proposer = $root.tendermint.types.Validator.decode(reader, reader.uint32());
                break;
              case 3:
                message.totalVotingPower = reader.int64();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a ValidatorSet message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tendermint.types.ValidatorSet
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tendermint.types.ValidatorSet} ValidatorSet
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ValidatorSet.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ValidatorSet message.
         * @function verify
         * @memberof tendermint.types.ValidatorSet
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ValidatorSet.verify = function verify(message) {
          if (typeof message !== "object" || message === null) return "object expected";
          if (message.validators != null && message.hasOwnProperty("validators")) {
            if (!Array.isArray(message.validators)) return "validators: array expected";
            for (var i = 0; i < message.validators.length; ++i) {
              var error = $root.tendermint.types.Validator.verify(message.validators[i]);
              if (error) return "validators." + error;
            }
          }
          if (message.proposer != null && message.hasOwnProperty("proposer")) {
            var error = $root.tendermint.types.Validator.verify(message.proposer);
            if (error) return "proposer." + error;
          }
          if (message.totalVotingPower != null && message.hasOwnProperty("totalVotingPower"))
            if (
              !$util.isInteger(message.totalVotingPower) &&
              !(
                message.totalVotingPower &&
                $util.isInteger(message.totalVotingPower.low) &&
                $util.isInteger(message.totalVotingPower.high)
              )
            )
              return "totalVotingPower: integer|Long expected";
          return null;
        };

        /**
         * Creates a ValidatorSet message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tendermint.types.ValidatorSet
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tendermint.types.ValidatorSet} ValidatorSet
         */
        ValidatorSet.fromObject = function fromObject(object) {
          if (object instanceof $root.tendermint.types.ValidatorSet) return object;
          var message = new $root.tendermint.types.ValidatorSet();
          if (object.validators) {
            if (!Array.isArray(object.validators))
              throw TypeError(".tendermint.types.ValidatorSet.validators: array expected");
            message.validators = [];
            for (var i = 0; i < object.validators.length; ++i) {
              if (typeof object.validators[i] !== "object")
                throw TypeError(".tendermint.types.ValidatorSet.validators: object expected");
              message.validators[i] = $root.tendermint.types.Validator.fromObject(object.validators[i]);
            }
          }
          if (object.proposer != null) {
            if (typeof object.proposer !== "object")
              throw TypeError(".tendermint.types.ValidatorSet.proposer: object expected");
            message.proposer = $root.tendermint.types.Validator.fromObject(object.proposer);
          }
          if (object.totalVotingPower != null)
            if ($util.Long)
              (message.totalVotingPower = $util.Long.fromValue(object.totalVotingPower)).unsigned = false;
            else if (typeof object.totalVotingPower === "string")
              message.totalVotingPower = parseInt(object.totalVotingPower, 10);
            else if (typeof object.totalVotingPower === "number")
              message.totalVotingPower = object.totalVotingPower;
            else if (typeof object.totalVotingPower === "object")
              message.totalVotingPower = new $util.LongBits(
                object.totalVotingPower.low >>> 0,
                object.totalVotingPower.high >>> 0,
              ).toNumber();
          return message;
        };

        /**
         * Creates a plain object from a ValidatorSet message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tendermint.types.ValidatorSet
         * @static
         * @param {tendermint.types.ValidatorSet} message ValidatorSet
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ValidatorSet.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.arrays || options.defaults) object.validators = [];
          if (options.defaults) {
            object.proposer = null;
            if ($util.Long) {
              var long = new $util.Long(0, 0, false);
              object.totalVotingPower =
                options.longs === String
                  ? long.toString()
                  : options.longs === Number
                  ? long.toNumber()
                  : long;
            } else object.totalVotingPower = options.longs === String ? "0" : 0;
          }
          if (message.validators && message.validators.length) {
            object.validators = [];
            for (var j = 0; j < message.validators.length; ++j)
              object.validators[j] = $root.tendermint.types.Validator.toObject(
                message.validators[j],
                options,
              );
          }
          if (message.proposer != null && message.hasOwnProperty("proposer"))
            object.proposer = $root.tendermint.types.Validator.toObject(message.proposer, options);
          if (message.totalVotingPower != null && message.hasOwnProperty("totalVotingPower"))
            if (typeof message.totalVotingPower === "number")
              object.totalVotingPower =
                options.longs === String ? String(message.totalVotingPower) : message.totalVotingPower;
            else
              object.totalVotingPower =
                options.longs === String
                  ? $util.Long.prototype.toString.call(message.totalVotingPower)
                  : options.longs === Number
                  ? new $util.LongBits(
                      message.totalVotingPower.low >>> 0,
                      message.totalVotingPower.high >>> 0,
                    ).toNumber()
                  : message.totalVotingPower;
          return object;
        };

        /**
         * Converts this ValidatorSet to JSON.
         * @function toJSON
         * @memberof tendermint.types.ValidatorSet
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ValidatorSet.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ValidatorSet;
      })();

      types.Validator = (function () {
        /**
         * Properties of a Validator.
         * @memberof tendermint.types
         * @interface IValidator
         * @property {Uint8Array|null} [address] Validator address
         * @property {tendermint.crypto.IPublicKey|null} [pubKey] Validator pubKey
         * @property {number|Long|null} [votingPower] Validator votingPower
         * @property {number|Long|null} [proposerPriority] Validator proposerPriority
         */

        /**
         * Constructs a new Validator.
         * @memberof tendermint.types
         * @classdesc Represents a Validator.
         * @implements IValidator
         * @constructor
         * @param {tendermint.types.IValidator=} [properties] Properties to set
         */
        function Validator(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * Validator address.
         * @member {Uint8Array} address
         * @memberof tendermint.types.Validator
         * @instance
         */
        Validator.prototype.address = $util.newBuffer([]);

        /**
         * Validator pubKey.
         * @member {tendermint.crypto.IPublicKey|null|undefined} pubKey
         * @memberof tendermint.types.Validator
         * @instance
         */
        Validator.prototype.pubKey = null;

        /**
         * Validator votingPower.
         * @member {number|Long} votingPower
         * @memberof tendermint.types.Validator
         * @instance
         */
        Validator.prototype.votingPower = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * Validator proposerPriority.
         * @member {number|Long} proposerPriority
         * @memberof tendermint.types.Validator
         * @instance
         */
        Validator.prototype.proposerPriority = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * Creates a new Validator instance using the specified properties.
         * @function create
         * @memberof tendermint.types.Validator
         * @static
         * @param {tendermint.types.IValidator=} [properties] Properties to set
         * @returns {tendermint.types.Validator} Validator instance
         */
        Validator.create = function create(properties) {
          return new Validator(properties);
        };

        /**
         * Encodes the specified Validator message. Does not implicitly {@link tendermint.types.Validator.verify|verify} messages.
         * @function encode
         * @memberof tendermint.types.Validator
         * @static
         * @param {tendermint.types.IValidator} message Validator message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Validator.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.address != null && Object.hasOwnProperty.call(message, "address"))
            writer.uint32(/* id 1, wireType 2 =*/ 10).bytes(message.address);
          if (message.pubKey != null && Object.hasOwnProperty.call(message, "pubKey"))
            $root.tendermint.crypto.PublicKey.encode(
              message.pubKey,
              writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
            ).ldelim();
          if (message.votingPower != null && Object.hasOwnProperty.call(message, "votingPower"))
            writer.uint32(/* id 3, wireType 0 =*/ 24).int64(message.votingPower);
          if (message.proposerPriority != null && Object.hasOwnProperty.call(message, "proposerPriority"))
            writer.uint32(/* id 4, wireType 0 =*/ 32).int64(message.proposerPriority);
          return writer;
        };

        /**
         * Encodes the specified Validator message, length delimited. Does not implicitly {@link tendermint.types.Validator.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tendermint.types.Validator
         * @static
         * @param {tendermint.types.IValidator} message Validator message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Validator.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Validator message from the specified reader or buffer.
         * @function decode
         * @memberof tendermint.types.Validator
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tendermint.types.Validator} Validator
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Validator.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.tendermint.types.Validator();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.address = reader.bytes();
                break;
              case 2:
                message.pubKey = $root.tendermint.crypto.PublicKey.decode(reader, reader.uint32());
                break;
              case 3:
                message.votingPower = reader.int64();
                break;
              case 4:
                message.proposerPriority = reader.int64();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a Validator message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tendermint.types.Validator
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tendermint.types.Validator} Validator
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Validator.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Validator message.
         * @function verify
         * @memberof tendermint.types.Validator
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Validator.verify = function verify(message) {
          if (typeof message !== "object" || message === null) return "object expected";
          if (message.address != null && message.hasOwnProperty("address"))
            if (
              !(
                (message.address && typeof message.address.length === "number") ||
                $util.isString(message.address)
              )
            )
              return "address: buffer expected";
          if (message.pubKey != null && message.hasOwnProperty("pubKey")) {
            var error = $root.tendermint.crypto.PublicKey.verify(message.pubKey);
            if (error) return "pubKey." + error;
          }
          if (message.votingPower != null && message.hasOwnProperty("votingPower"))
            if (
              !$util.isInteger(message.votingPower) &&
              !(
                message.votingPower &&
                $util.isInteger(message.votingPower.low) &&
                $util.isInteger(message.votingPower.high)
              )
            )
              return "votingPower: integer|Long expected";
          if (message.proposerPriority != null && message.hasOwnProperty("proposerPriority"))
            if (
              !$util.isInteger(message.proposerPriority) &&
              !(
                message.proposerPriority &&
                $util.isInteger(message.proposerPriority.low) &&
                $util.isInteger(message.proposerPriority.high)
              )
            )
              return "proposerPriority: integer|Long expected";
          return null;
        };

        /**
         * Creates a Validator message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tendermint.types.Validator
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tendermint.types.Validator} Validator
         */
        Validator.fromObject = function fromObject(object) {
          if (object instanceof $root.tendermint.types.Validator) return object;
          var message = new $root.tendermint.types.Validator();
          if (object.address != null)
            if (typeof object.address === "string")
              $util.base64.decode(
                object.address,
                (message.address = $util.newBuffer($util.base64.length(object.address))),
                0,
              );
            else if (object.address.length) message.address = object.address;
          if (object.pubKey != null) {
            if (typeof object.pubKey !== "object")
              throw TypeError(".tendermint.types.Validator.pubKey: object expected");
            message.pubKey = $root.tendermint.crypto.PublicKey.fromObject(object.pubKey);
          }
          if (object.votingPower != null)
            if ($util.Long) (message.votingPower = $util.Long.fromValue(object.votingPower)).unsigned = false;
            else if (typeof object.votingPower === "string")
              message.votingPower = parseInt(object.votingPower, 10);
            else if (typeof object.votingPower === "number") message.votingPower = object.votingPower;
            else if (typeof object.votingPower === "object")
              message.votingPower = new $util.LongBits(
                object.votingPower.low >>> 0,
                object.votingPower.high >>> 0,
              ).toNumber();
          if (object.proposerPriority != null)
            if ($util.Long)
              (message.proposerPriority = $util.Long.fromValue(object.proposerPriority)).unsigned = false;
            else if (typeof object.proposerPriority === "string")
              message.proposerPriority = parseInt(object.proposerPriority, 10);
            else if (typeof object.proposerPriority === "number")
              message.proposerPriority = object.proposerPriority;
            else if (typeof object.proposerPriority === "object")
              message.proposerPriority = new $util.LongBits(
                object.proposerPriority.low >>> 0,
                object.proposerPriority.high >>> 0,
              ).toNumber();
          return message;
        };

        /**
         * Creates a plain object from a Validator message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tendermint.types.Validator
         * @static
         * @param {tendermint.types.Validator} message Validator
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Validator.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            if (options.bytes === String) object.address = "";
            else {
              object.address = [];
              if (options.bytes !== Array) object.address = $util.newBuffer(object.address);
            }
            object.pubKey = null;
            if ($util.Long) {
              var long = new $util.Long(0, 0, false);
              object.votingPower =
                options.longs === String
                  ? long.toString()
                  : options.longs === Number
                  ? long.toNumber()
                  : long;
            } else object.votingPower = options.longs === String ? "0" : 0;
            if ($util.Long) {
              var long = new $util.Long(0, 0, false);
              object.proposerPriority =
                options.longs === String
                  ? long.toString()
                  : options.longs === Number
                  ? long.toNumber()
                  : long;
            } else object.proposerPriority = options.longs === String ? "0" : 0;
          }
          if (message.address != null && message.hasOwnProperty("address"))
            object.address =
              options.bytes === String
                ? $util.base64.encode(message.address, 0, message.address.length)
                : options.bytes === Array
                ? Array.prototype.slice.call(message.address)
                : message.address;
          if (message.pubKey != null && message.hasOwnProperty("pubKey"))
            object.pubKey = $root.tendermint.crypto.PublicKey.toObject(message.pubKey, options);
          if (message.votingPower != null && message.hasOwnProperty("votingPower"))
            if (typeof message.votingPower === "number")
              object.votingPower =
                options.longs === String ? String(message.votingPower) : message.votingPower;
            else
              object.votingPower =
                options.longs === String
                  ? $util.Long.prototype.toString.call(message.votingPower)
                  : options.longs === Number
                  ? new $util.LongBits(
                      message.votingPower.low >>> 0,
                      message.votingPower.high >>> 0,
                    ).toNumber()
                  : message.votingPower;
          if (message.proposerPriority != null && message.hasOwnProperty("proposerPriority"))
            if (typeof message.proposerPriority === "number")
              object.proposerPriority =
                options.longs === String ? String(message.proposerPriority) : message.proposerPriority;
            else
              object.proposerPriority =
                options.longs === String
                  ? $util.Long.prototype.toString.call(message.proposerPriority)
                  : options.longs === Number
                  ? new $util.LongBits(
                      message.proposerPriority.low >>> 0,
                      message.proposerPriority.high >>> 0,
                    ).toNumber()
                  : message.proposerPriority;
          return object;
        };

        /**
         * Converts this Validator to JSON.
         * @function toJSON
         * @memberof tendermint.types.Validator
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Validator.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Validator;
      })();

      types.SimpleValidator = (function () {
        /**
         * Properties of a SimpleValidator.
         * @memberof tendermint.types
         * @interface ISimpleValidator
         * @property {tendermint.crypto.IPublicKey|null} [pubKey] SimpleValidator pubKey
         * @property {number|Long|null} [votingPower] SimpleValidator votingPower
         */

        /**
         * Constructs a new SimpleValidator.
         * @memberof tendermint.types
         * @classdesc Represents a SimpleValidator.
         * @implements ISimpleValidator
         * @constructor
         * @param {tendermint.types.ISimpleValidator=} [properties] Properties to set
         */
        function SimpleValidator(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * SimpleValidator pubKey.
         * @member {tendermint.crypto.IPublicKey|null|undefined} pubKey
         * @memberof tendermint.types.SimpleValidator
         * @instance
         */
        SimpleValidator.prototype.pubKey = null;

        /**
         * SimpleValidator votingPower.
         * @member {number|Long} votingPower
         * @memberof tendermint.types.SimpleValidator
         * @instance
         */
        SimpleValidator.prototype.votingPower = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * Creates a new SimpleValidator instance using the specified properties.
         * @function create
         * @memberof tendermint.types.SimpleValidator
         * @static
         * @param {tendermint.types.ISimpleValidator=} [properties] Properties to set
         * @returns {tendermint.types.SimpleValidator} SimpleValidator instance
         */
        SimpleValidator.create = function create(properties) {
          return new SimpleValidator(properties);
        };

        /**
         * Encodes the specified SimpleValidator message. Does not implicitly {@link tendermint.types.SimpleValidator.verify|verify} messages.
         * @function encode
         * @memberof tendermint.types.SimpleValidator
         * @static
         * @param {tendermint.types.ISimpleValidator} message SimpleValidator message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SimpleValidator.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.pubKey != null && Object.hasOwnProperty.call(message, "pubKey"))
            $root.tendermint.crypto.PublicKey.encode(
              message.pubKey,
              writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
            ).ldelim();
          if (message.votingPower != null && Object.hasOwnProperty.call(message, "votingPower"))
            writer.uint32(/* id 2, wireType 0 =*/ 16).int64(message.votingPower);
          return writer;
        };

        /**
         * Encodes the specified SimpleValidator message, length delimited. Does not implicitly {@link tendermint.types.SimpleValidator.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tendermint.types.SimpleValidator
         * @static
         * @param {tendermint.types.ISimpleValidator} message SimpleValidator message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SimpleValidator.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SimpleValidator message from the specified reader or buffer.
         * @function decode
         * @memberof tendermint.types.SimpleValidator
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tendermint.types.SimpleValidator} SimpleValidator
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SimpleValidator.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.tendermint.types.SimpleValidator();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.pubKey = $root.tendermint.crypto.PublicKey.decode(reader, reader.uint32());
                break;
              case 2:
                message.votingPower = reader.int64();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a SimpleValidator message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tendermint.types.SimpleValidator
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tendermint.types.SimpleValidator} SimpleValidator
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SimpleValidator.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SimpleValidator message.
         * @function verify
         * @memberof tendermint.types.SimpleValidator
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SimpleValidator.verify = function verify(message) {
          if (typeof message !== "object" || message === null) return "object expected";
          if (message.pubKey != null && message.hasOwnProperty("pubKey")) {
            var error = $root.tendermint.crypto.PublicKey.verify(message.pubKey);
            if (error) return "pubKey." + error;
          }
          if (message.votingPower != null && message.hasOwnProperty("votingPower"))
            if (
              !$util.isInteger(message.votingPower) &&
              !(
                message.votingPower &&
                $util.isInteger(message.votingPower.low) &&
                $util.isInteger(message.votingPower.high)
              )
            )
              return "votingPower: integer|Long expected";
          return null;
        };

        /**
         * Creates a SimpleValidator message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tendermint.types.SimpleValidator
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tendermint.types.SimpleValidator} SimpleValidator
         */
        SimpleValidator.fromObject = function fromObject(object) {
          if (object instanceof $root.tendermint.types.SimpleValidator) return object;
          var message = new $root.tendermint.types.SimpleValidator();
          if (object.pubKey != null) {
            if (typeof object.pubKey !== "object")
              throw TypeError(".tendermint.types.SimpleValidator.pubKey: object expected");
            message.pubKey = $root.tendermint.crypto.PublicKey.fromObject(object.pubKey);
          }
          if (object.votingPower != null)
            if ($util.Long) (message.votingPower = $util.Long.fromValue(object.votingPower)).unsigned = false;
            else if (typeof object.votingPower === "string")
              message.votingPower = parseInt(object.votingPower, 10);
            else if (typeof object.votingPower === "number") message.votingPower = object.votingPower;
            else if (typeof object.votingPower === "object")
              message.votingPower = new $util.LongBits(
                object.votingPower.low >>> 0,
                object.votingPower.high >>> 0,
              ).toNumber();
          return message;
        };

        /**
         * Creates a plain object from a SimpleValidator message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tendermint.types.SimpleValidator
         * @static
         * @param {tendermint.types.SimpleValidator} message SimpleValidator
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SimpleValidator.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.pubKey = null;
            if ($util.Long) {
              var long = new $util.Long(0, 0, false);
              object.votingPower =
                options.longs === String
                  ? long.toString()
                  : options.longs === Number
                  ? long.toNumber()
                  : long;
            } else object.votingPower = options.longs === String ? "0" : 0;
          }
          if (message.pubKey != null && message.hasOwnProperty("pubKey"))
            object.pubKey = $root.tendermint.crypto.PublicKey.toObject(message.pubKey, options);
          if (message.votingPower != null && message.hasOwnProperty("votingPower"))
            if (typeof message.votingPower === "number")
              object.votingPower =
                options.longs === String ? String(message.votingPower) : message.votingPower;
            else
              object.votingPower =
                options.longs === String
                  ? $util.Long.prototype.toString.call(message.votingPower)
                  : options.longs === Number
                  ? new $util.LongBits(
                      message.votingPower.low >>> 0,
                      message.votingPower.high >>> 0,
                    ).toNumber()
                  : message.votingPower;
          return object;
        };

        /**
         * Converts this SimpleValidator to JSON.
         * @function toJSON
         * @memberof tendermint.types.SimpleValidator
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SimpleValidator.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SimpleValidator;
      })();

      return types;
    })();

    tendermint.crypto = (function () {
      /**
       * Namespace crypto.
       * @memberof tendermint
       * @namespace
       */
      var crypto = {};

      crypto.PublicKey = (function () {
        /**
         * Properties of a PublicKey.
         * @memberof tendermint.crypto
         * @interface IPublicKey
         * @property {Uint8Array|null} [ed25519] PublicKey ed25519
         * @property {Uint8Array|null} [secp256k1] PublicKey secp256k1
         */

        /**
         * Constructs a new PublicKey.
         * @memberof tendermint.crypto
         * @classdesc Represents a PublicKey.
         * @implements IPublicKey
         * @constructor
         * @param {tendermint.crypto.IPublicKey=} [properties] Properties to set
         */
        function PublicKey(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * PublicKey ed25519.
         * @member {Uint8Array|null|undefined} ed25519
         * @memberof tendermint.crypto.PublicKey
         * @instance
         */
        PublicKey.prototype.ed25519 = null;

        /**
         * PublicKey secp256k1.
         * @member {Uint8Array|null|undefined} secp256k1
         * @memberof tendermint.crypto.PublicKey
         * @instance
         */
        PublicKey.prototype.secp256k1 = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * PublicKey sum.
         * @member {"ed25519"|"secp256k1"|undefined} sum
         * @memberof tendermint.crypto.PublicKey
         * @instance
         */
        Object.defineProperty(PublicKey.prototype, "sum", {
          get: $util.oneOfGetter(($oneOfFields = ["ed25519", "secp256k1"])),
          set: $util.oneOfSetter($oneOfFields),
        });

        /**
         * Creates a new PublicKey instance using the specified properties.
         * @function create
         * @memberof tendermint.crypto.PublicKey
         * @static
         * @param {tendermint.crypto.IPublicKey=} [properties] Properties to set
         * @returns {tendermint.crypto.PublicKey} PublicKey instance
         */
        PublicKey.create = function create(properties) {
          return new PublicKey(properties);
        };

        /**
         * Encodes the specified PublicKey message. Does not implicitly {@link tendermint.crypto.PublicKey.verify|verify} messages.
         * @function encode
         * @memberof tendermint.crypto.PublicKey
         * @static
         * @param {tendermint.crypto.IPublicKey} message PublicKey message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PublicKey.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.ed25519 != null && Object.hasOwnProperty.call(message, "ed25519"))
            writer.uint32(/* id 1, wireType 2 =*/ 10).bytes(message.ed25519);
          if (message.secp256k1 != null && Object.hasOwnProperty.call(message, "secp256k1"))
            writer.uint32(/* id 2, wireType 2 =*/ 18).bytes(message.secp256k1);
          return writer;
        };

        /**
         * Encodes the specified PublicKey message, length delimited. Does not implicitly {@link tendermint.crypto.PublicKey.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tendermint.crypto.PublicKey
         * @static
         * @param {tendermint.crypto.IPublicKey} message PublicKey message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PublicKey.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PublicKey message from the specified reader or buffer.
         * @function decode
         * @memberof tendermint.crypto.PublicKey
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tendermint.crypto.PublicKey} PublicKey
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PublicKey.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.tendermint.crypto.PublicKey();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.ed25519 = reader.bytes();
                break;
              case 2:
                message.secp256k1 = reader.bytes();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a PublicKey message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tendermint.crypto.PublicKey
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tendermint.crypto.PublicKey} PublicKey
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PublicKey.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PublicKey message.
         * @function verify
         * @memberof tendermint.crypto.PublicKey
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PublicKey.verify = function verify(message) {
          if (typeof message !== "object" || message === null) return "object expected";
          var properties = {};
          if (message.ed25519 != null && message.hasOwnProperty("ed25519")) {
            properties.sum = 1;
            if (
              !(
                (message.ed25519 && typeof message.ed25519.length === "number") ||
                $util.isString(message.ed25519)
              )
            )
              return "ed25519: buffer expected";
          }
          if (message.secp256k1 != null && message.hasOwnProperty("secp256k1")) {
            if (properties.sum === 1) return "sum: multiple values";
            properties.sum = 1;
            if (
              !(
                (message.secp256k1 && typeof message.secp256k1.length === "number") ||
                $util.isString(message.secp256k1)
              )
            )
              return "secp256k1: buffer expected";
          }
          return null;
        };

        /**
         * Creates a PublicKey message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tendermint.crypto.PublicKey
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tendermint.crypto.PublicKey} PublicKey
         */
        PublicKey.fromObject = function fromObject(object) {
          if (object instanceof $root.tendermint.crypto.PublicKey) return object;
          var message = new $root.tendermint.crypto.PublicKey();
          if (object.ed25519 != null)
            if (typeof object.ed25519 === "string")
              $util.base64.decode(
                object.ed25519,
                (message.ed25519 = $util.newBuffer($util.base64.length(object.ed25519))),
                0,
              );
            else if (object.ed25519.length) message.ed25519 = object.ed25519;
          if (object.secp256k1 != null)
            if (typeof object.secp256k1 === "string")
              $util.base64.decode(
                object.secp256k1,
                (message.secp256k1 = $util.newBuffer($util.base64.length(object.secp256k1))),
                0,
              );
            else if (object.secp256k1.length) message.secp256k1 = object.secp256k1;
          return message;
        };

        /**
         * Creates a plain object from a PublicKey message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tendermint.crypto.PublicKey
         * @static
         * @param {tendermint.crypto.PublicKey} message PublicKey
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PublicKey.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (message.ed25519 != null && message.hasOwnProperty("ed25519")) {
            object.ed25519 =
              options.bytes === String
                ? $util.base64.encode(message.ed25519, 0, message.ed25519.length)
                : options.bytes === Array
                ? Array.prototype.slice.call(message.ed25519)
                : message.ed25519;
            if (options.oneofs) object.sum = "ed25519";
          }
          if (message.secp256k1 != null && message.hasOwnProperty("secp256k1")) {
            object.secp256k1 =
              options.bytes === String
                ? $util.base64.encode(message.secp256k1, 0, message.secp256k1.length)
                : options.bytes === Array
                ? Array.prototype.slice.call(message.secp256k1)
                : message.secp256k1;
            if (options.oneofs) object.sum = "secp256k1";
          }
          return object;
        };

        /**
         * Converts this PublicKey to JSON.
         * @function toJSON
         * @memberof tendermint.crypto.PublicKey
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PublicKey.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PublicKey;
      })();

      crypto.Proof = (function () {
        /**
         * Properties of a Proof.
         * @memberof tendermint.crypto
         * @interface IProof
         * @property {number|Long|null} [total] Proof total
         * @property {number|Long|null} [index] Proof index
         * @property {Uint8Array|null} [leafHash] Proof leafHash
         * @property {Array.<Uint8Array>|null} [aunts] Proof aunts
         */

        /**
         * Constructs a new Proof.
         * @memberof tendermint.crypto
         * @classdesc Represents a Proof.
         * @implements IProof
         * @constructor
         * @param {tendermint.crypto.IProof=} [properties] Properties to set
         */
        function Proof(properties) {
          this.aunts = [];
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * Proof total.
         * @member {number|Long} total
         * @memberof tendermint.crypto.Proof
         * @instance
         */
        Proof.prototype.total = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * Proof index.
         * @member {number|Long} index
         * @memberof tendermint.crypto.Proof
         * @instance
         */
        Proof.prototype.index = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * Proof leafHash.
         * @member {Uint8Array} leafHash
         * @memberof tendermint.crypto.Proof
         * @instance
         */
        Proof.prototype.leafHash = $util.newBuffer([]);

        /**
         * Proof aunts.
         * @member {Array.<Uint8Array>} aunts
         * @memberof tendermint.crypto.Proof
         * @instance
         */
        Proof.prototype.aunts = $util.emptyArray;

        /**
         * Creates a new Proof instance using the specified properties.
         * @function create
         * @memberof tendermint.crypto.Proof
         * @static
         * @param {tendermint.crypto.IProof=} [properties] Properties to set
         * @returns {tendermint.crypto.Proof} Proof instance
         */
        Proof.create = function create(properties) {
          return new Proof(properties);
        };

        /**
         * Encodes the specified Proof message. Does not implicitly {@link tendermint.crypto.Proof.verify|verify} messages.
         * @function encode
         * @memberof tendermint.crypto.Proof
         * @static
         * @param {tendermint.crypto.IProof} message Proof message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Proof.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.total != null && Object.hasOwnProperty.call(message, "total"))
            writer.uint32(/* id 1, wireType 0 =*/ 8).int64(message.total);
          if (message.index != null && Object.hasOwnProperty.call(message, "index"))
            writer.uint32(/* id 2, wireType 0 =*/ 16).int64(message.index);
          if (message.leafHash != null && Object.hasOwnProperty.call(message, "leafHash"))
            writer.uint32(/* id 3, wireType 2 =*/ 26).bytes(message.leafHash);
          if (message.aunts != null && message.aunts.length)
            for (var i = 0; i < message.aunts.length; ++i)
              writer.uint32(/* id 4, wireType 2 =*/ 34).bytes(message.aunts[i]);
          return writer;
        };

        /**
         * Encodes the specified Proof message, length delimited. Does not implicitly {@link tendermint.crypto.Proof.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tendermint.crypto.Proof
         * @static
         * @param {tendermint.crypto.IProof} message Proof message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Proof.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Proof message from the specified reader or buffer.
         * @function decode
         * @memberof tendermint.crypto.Proof
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tendermint.crypto.Proof} Proof
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Proof.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.tendermint.crypto.Proof();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.total = reader.int64();
                break;
              case 2:
                message.index = reader.int64();
                break;
              case 3:
                message.leafHash = reader.bytes();
                break;
              case 4:
                if (!(message.aunts && message.aunts.length)) message.aunts = [];
                message.aunts.push(reader.bytes());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a Proof message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tendermint.crypto.Proof
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tendermint.crypto.Proof} Proof
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Proof.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Proof message.
         * @function verify
         * @memberof tendermint.crypto.Proof
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Proof.verify = function verify(message) {
          if (typeof message !== "object" || message === null) return "object expected";
          if (message.total != null && message.hasOwnProperty("total"))
            if (
              !$util.isInteger(message.total) &&
              !(message.total && $util.isInteger(message.total.low) && $util.isInteger(message.total.high))
            )
              return "total: integer|Long expected";
          if (message.index != null && message.hasOwnProperty("index"))
            if (
              !$util.isInteger(message.index) &&
              !(message.index && $util.isInteger(message.index.low) && $util.isInteger(message.index.high))
            )
              return "index: integer|Long expected";
          if (message.leafHash != null && message.hasOwnProperty("leafHash"))
            if (
              !(
                (message.leafHash && typeof message.leafHash.length === "number") ||
                $util.isString(message.leafHash)
              )
            )
              return "leafHash: buffer expected";
          if (message.aunts != null && message.hasOwnProperty("aunts")) {
            if (!Array.isArray(message.aunts)) return "aunts: array expected";
            for (var i = 0; i < message.aunts.length; ++i)
              if (
                !(
                  (message.aunts[i] && typeof message.aunts[i].length === "number") ||
                  $util.isString(message.aunts[i])
                )
              )
                return "aunts: buffer[] expected";
          }
          return null;
        };

        /**
         * Creates a Proof message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tendermint.crypto.Proof
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tendermint.crypto.Proof} Proof
         */
        Proof.fromObject = function fromObject(object) {
          if (object instanceof $root.tendermint.crypto.Proof) return object;
          var message = new $root.tendermint.crypto.Proof();
          if (object.total != null)
            if ($util.Long) (message.total = $util.Long.fromValue(object.total)).unsigned = false;
            else if (typeof object.total === "string") message.total = parseInt(object.total, 10);
            else if (typeof object.total === "number") message.total = object.total;
            else if (typeof object.total === "object")
              message.total = new $util.LongBits(object.total.low >>> 0, object.total.high >>> 0).toNumber();
          if (object.index != null)
            if ($util.Long) (message.index = $util.Long.fromValue(object.index)).unsigned = false;
            else if (typeof object.index === "string") message.index = parseInt(object.index, 10);
            else if (typeof object.index === "number") message.index = object.index;
            else if (typeof object.index === "object")
              message.index = new $util.LongBits(object.index.low >>> 0, object.index.high >>> 0).toNumber();
          if (object.leafHash != null)
            if (typeof object.leafHash === "string")
              $util.base64.decode(
                object.leafHash,
                (message.leafHash = $util.newBuffer($util.base64.length(object.leafHash))),
                0,
              );
            else if (object.leafHash.length) message.leafHash = object.leafHash;
          if (object.aunts) {
            if (!Array.isArray(object.aunts))
              throw TypeError(".tendermint.crypto.Proof.aunts: array expected");
            message.aunts = [];
            for (var i = 0; i < object.aunts.length; ++i)
              if (typeof object.aunts[i] === "string")
                $util.base64.decode(
                  object.aunts[i],
                  (message.aunts[i] = $util.newBuffer($util.base64.length(object.aunts[i]))),
                  0,
                );
              else if (object.aunts[i].length) message.aunts[i] = object.aunts[i];
          }
          return message;
        };

        /**
         * Creates a plain object from a Proof message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tendermint.crypto.Proof
         * @static
         * @param {tendermint.crypto.Proof} message Proof
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Proof.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.arrays || options.defaults) object.aunts = [];
          if (options.defaults) {
            if ($util.Long) {
              var long = new $util.Long(0, 0, false);
              object.total =
                options.longs === String
                  ? long.toString()
                  : options.longs === Number
                  ? long.toNumber()
                  : long;
            } else object.total = options.longs === String ? "0" : 0;
            if ($util.Long) {
              var long = new $util.Long(0, 0, false);
              object.index =
                options.longs === String
                  ? long.toString()
                  : options.longs === Number
                  ? long.toNumber()
                  : long;
            } else object.index = options.longs === String ? "0" : 0;
            if (options.bytes === String) object.leafHash = "";
            else {
              object.leafHash = [];
              if (options.bytes !== Array) object.leafHash = $util.newBuffer(object.leafHash);
            }
          }
          if (message.total != null && message.hasOwnProperty("total"))
            if (typeof message.total === "number")
              object.total = options.longs === String ? String(message.total) : message.total;
            else
              object.total =
                options.longs === String
                  ? $util.Long.prototype.toString.call(message.total)
                  : options.longs === Number
                  ? new $util.LongBits(message.total.low >>> 0, message.total.high >>> 0).toNumber()
                  : message.total;
          if (message.index != null && message.hasOwnProperty("index"))
            if (typeof message.index === "number")
              object.index = options.longs === String ? String(message.index) : message.index;
            else
              object.index =
                options.longs === String
                  ? $util.Long.prototype.toString.call(message.index)
                  : options.longs === Number
                  ? new $util.LongBits(message.index.low >>> 0, message.index.high >>> 0).toNumber()
                  : message.index;
          if (message.leafHash != null && message.hasOwnProperty("leafHash"))
            object.leafHash =
              options.bytes === String
                ? $util.base64.encode(message.leafHash, 0, message.leafHash.length)
                : options.bytes === Array
                ? Array.prototype.slice.call(message.leafHash)
                : message.leafHash;
          if (message.aunts && message.aunts.length) {
            object.aunts = [];
            for (var j = 0; j < message.aunts.length; ++j)
              object.aunts[j] =
                options.bytes === String
                  ? $util.base64.encode(message.aunts[j], 0, message.aunts[j].length)
                  : options.bytes === Array
                  ? Array.prototype.slice.call(message.aunts[j])
                  : message.aunts[j];
          }
          return object;
        };

        /**
         * Converts this Proof to JSON.
         * @function toJSON
         * @memberof tendermint.crypto.Proof
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Proof.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Proof;
      })();

      crypto.ValueOp = (function () {
        /**
         * Properties of a ValueOp.
         * @memberof tendermint.crypto
         * @interface IValueOp
         * @property {Uint8Array|null} [key] ValueOp key
         * @property {tendermint.crypto.IProof|null} [proof] ValueOp proof
         */

        /**
         * Constructs a new ValueOp.
         * @memberof tendermint.crypto
         * @classdesc Represents a ValueOp.
         * @implements IValueOp
         * @constructor
         * @param {tendermint.crypto.IValueOp=} [properties] Properties to set
         */
        function ValueOp(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * ValueOp key.
         * @member {Uint8Array} key
         * @memberof tendermint.crypto.ValueOp
         * @instance
         */
        ValueOp.prototype.key = $util.newBuffer([]);

        /**
         * ValueOp proof.
         * @member {tendermint.crypto.IProof|null|undefined} proof
         * @memberof tendermint.crypto.ValueOp
         * @instance
         */
        ValueOp.prototype.proof = null;

        /**
         * Creates a new ValueOp instance using the specified properties.
         * @function create
         * @memberof tendermint.crypto.ValueOp
         * @static
         * @param {tendermint.crypto.IValueOp=} [properties] Properties to set
         * @returns {tendermint.crypto.ValueOp} ValueOp instance
         */
        ValueOp.create = function create(properties) {
          return new ValueOp(properties);
        };

        /**
         * Encodes the specified ValueOp message. Does not implicitly {@link tendermint.crypto.ValueOp.verify|verify} messages.
         * @function encode
         * @memberof tendermint.crypto.ValueOp
         * @static
         * @param {tendermint.crypto.IValueOp} message ValueOp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ValueOp.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.key != null && Object.hasOwnProperty.call(message, "key"))
            writer.uint32(/* id 1, wireType 2 =*/ 10).bytes(message.key);
          if (message.proof != null && Object.hasOwnProperty.call(message, "proof"))
            $root.tendermint.crypto.Proof.encode(
              message.proof,
              writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
            ).ldelim();
          return writer;
        };

        /**
         * Encodes the specified ValueOp message, length delimited. Does not implicitly {@link tendermint.crypto.ValueOp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tendermint.crypto.ValueOp
         * @static
         * @param {tendermint.crypto.IValueOp} message ValueOp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ValueOp.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ValueOp message from the specified reader or buffer.
         * @function decode
         * @memberof tendermint.crypto.ValueOp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tendermint.crypto.ValueOp} ValueOp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ValueOp.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.tendermint.crypto.ValueOp();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.key = reader.bytes();
                break;
              case 2:
                message.proof = $root.tendermint.crypto.Proof.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a ValueOp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tendermint.crypto.ValueOp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tendermint.crypto.ValueOp} ValueOp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ValueOp.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ValueOp message.
         * @function verify
         * @memberof tendermint.crypto.ValueOp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ValueOp.verify = function verify(message) {
          if (typeof message !== "object" || message === null) return "object expected";
          if (message.key != null && message.hasOwnProperty("key"))
            if (!((message.key && typeof message.key.length === "number") || $util.isString(message.key)))
              return "key: buffer expected";
          if (message.proof != null && message.hasOwnProperty("proof")) {
            var error = $root.tendermint.crypto.Proof.verify(message.proof);
            if (error) return "proof." + error;
          }
          return null;
        };

        /**
         * Creates a ValueOp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tendermint.crypto.ValueOp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tendermint.crypto.ValueOp} ValueOp
         */
        ValueOp.fromObject = function fromObject(object) {
          if (object instanceof $root.tendermint.crypto.ValueOp) return object;
          var message = new $root.tendermint.crypto.ValueOp();
          if (object.key != null)
            if (typeof object.key === "string")
              $util.base64.decode(
                object.key,
                (message.key = $util.newBuffer($util.base64.length(object.key))),
                0,
              );
            else if (object.key.length) message.key = object.key;
          if (object.proof != null) {
            if (typeof object.proof !== "object")
              throw TypeError(".tendermint.crypto.ValueOp.proof: object expected");
            message.proof = $root.tendermint.crypto.Proof.fromObject(object.proof);
          }
          return message;
        };

        /**
         * Creates a plain object from a ValueOp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tendermint.crypto.ValueOp
         * @static
         * @param {tendermint.crypto.ValueOp} message ValueOp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ValueOp.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            if (options.bytes === String) object.key = "";
            else {
              object.key = [];
              if (options.bytes !== Array) object.key = $util.newBuffer(object.key);
            }
            object.proof = null;
          }
          if (message.key != null && message.hasOwnProperty("key"))
            object.key =
              options.bytes === String
                ? $util.base64.encode(message.key, 0, message.key.length)
                : options.bytes === Array
                ? Array.prototype.slice.call(message.key)
                : message.key;
          if (message.proof != null && message.hasOwnProperty("proof"))
            object.proof = $root.tendermint.crypto.Proof.toObject(message.proof, options);
          return object;
        };

        /**
         * Converts this ValueOp to JSON.
         * @function toJSON
         * @memberof tendermint.crypto.ValueOp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ValueOp.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ValueOp;
      })();

      crypto.DominoOp = (function () {
        /**
         * Properties of a DominoOp.
         * @memberof tendermint.crypto
         * @interface IDominoOp
         * @property {string|null} [key] DominoOp key
         * @property {string|null} [input] DominoOp input
         * @property {string|null} [output] DominoOp output
         */

        /**
         * Constructs a new DominoOp.
         * @memberof tendermint.crypto
         * @classdesc Represents a DominoOp.
         * @implements IDominoOp
         * @constructor
         * @param {tendermint.crypto.IDominoOp=} [properties] Properties to set
         */
        function DominoOp(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * DominoOp key.
         * @member {string} key
         * @memberof tendermint.crypto.DominoOp
         * @instance
         */
        DominoOp.prototype.key = "";

        /**
         * DominoOp input.
         * @member {string} input
         * @memberof tendermint.crypto.DominoOp
         * @instance
         */
        DominoOp.prototype.input = "";

        /**
         * DominoOp output.
         * @member {string} output
         * @memberof tendermint.crypto.DominoOp
         * @instance
         */
        DominoOp.prototype.output = "";

        /**
         * Creates a new DominoOp instance using the specified properties.
         * @function create
         * @memberof tendermint.crypto.DominoOp
         * @static
         * @param {tendermint.crypto.IDominoOp=} [properties] Properties to set
         * @returns {tendermint.crypto.DominoOp} DominoOp instance
         */
        DominoOp.create = function create(properties) {
          return new DominoOp(properties);
        };

        /**
         * Encodes the specified DominoOp message. Does not implicitly {@link tendermint.crypto.DominoOp.verify|verify} messages.
         * @function encode
         * @memberof tendermint.crypto.DominoOp
         * @static
         * @param {tendermint.crypto.IDominoOp} message DominoOp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DominoOp.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.key != null && Object.hasOwnProperty.call(message, "key"))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.key);
          if (message.input != null && Object.hasOwnProperty.call(message, "input"))
            writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.input);
          if (message.output != null && Object.hasOwnProperty.call(message, "output"))
            writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.output);
          return writer;
        };

        /**
         * Encodes the specified DominoOp message, length delimited. Does not implicitly {@link tendermint.crypto.DominoOp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tendermint.crypto.DominoOp
         * @static
         * @param {tendermint.crypto.IDominoOp} message DominoOp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DominoOp.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DominoOp message from the specified reader or buffer.
         * @function decode
         * @memberof tendermint.crypto.DominoOp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tendermint.crypto.DominoOp} DominoOp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DominoOp.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.tendermint.crypto.DominoOp();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.key = reader.string();
                break;
              case 2:
                message.input = reader.string();
                break;
              case 3:
                message.output = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a DominoOp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tendermint.crypto.DominoOp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tendermint.crypto.DominoOp} DominoOp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DominoOp.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DominoOp message.
         * @function verify
         * @memberof tendermint.crypto.DominoOp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DominoOp.verify = function verify(message) {
          if (typeof message !== "object" || message === null) return "object expected";
          if (message.key != null && message.hasOwnProperty("key"))
            if (!$util.isString(message.key)) return "key: string expected";
          if (message.input != null && message.hasOwnProperty("input"))
            if (!$util.isString(message.input)) return "input: string expected";
          if (message.output != null && message.hasOwnProperty("output"))
            if (!$util.isString(message.output)) return "output: string expected";
          return null;
        };

        /**
         * Creates a DominoOp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tendermint.crypto.DominoOp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tendermint.crypto.DominoOp} DominoOp
         */
        DominoOp.fromObject = function fromObject(object) {
          if (object instanceof $root.tendermint.crypto.DominoOp) return object;
          var message = new $root.tendermint.crypto.DominoOp();
          if (object.key != null) message.key = String(object.key);
          if (object.input != null) message.input = String(object.input);
          if (object.output != null) message.output = String(object.output);
          return message;
        };

        /**
         * Creates a plain object from a DominoOp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tendermint.crypto.DominoOp
         * @static
         * @param {tendermint.crypto.DominoOp} message DominoOp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DominoOp.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.key = "";
            object.input = "";
            object.output = "";
          }
          if (message.key != null && message.hasOwnProperty("key")) object.key = message.key;
          if (message.input != null && message.hasOwnProperty("input")) object.input = message.input;
          if (message.output != null && message.hasOwnProperty("output")) object.output = message.output;
          return object;
        };

        /**
         * Converts this DominoOp to JSON.
         * @function toJSON
         * @memberof tendermint.crypto.DominoOp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DominoOp.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DominoOp;
      })();

      crypto.ProofOp = (function () {
        /**
         * Properties of a ProofOp.
         * @memberof tendermint.crypto
         * @interface IProofOp
         * @property {string|null} [type] ProofOp type
         * @property {Uint8Array|null} [key] ProofOp key
         * @property {Uint8Array|null} [data] ProofOp data
         */

        /**
         * Constructs a new ProofOp.
         * @memberof tendermint.crypto
         * @classdesc Represents a ProofOp.
         * @implements IProofOp
         * @constructor
         * @param {tendermint.crypto.IProofOp=} [properties] Properties to set
         */
        function ProofOp(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProofOp type.
         * @member {string} type
         * @memberof tendermint.crypto.ProofOp
         * @instance
         */
        ProofOp.prototype.type = "";

        /**
         * ProofOp key.
         * @member {Uint8Array} key
         * @memberof tendermint.crypto.ProofOp
         * @instance
         */
        ProofOp.prototype.key = $util.newBuffer([]);

        /**
         * ProofOp data.
         * @member {Uint8Array} data
         * @memberof tendermint.crypto.ProofOp
         * @instance
         */
        ProofOp.prototype.data = $util.newBuffer([]);

        /**
         * Creates a new ProofOp instance using the specified properties.
         * @function create
         * @memberof tendermint.crypto.ProofOp
         * @static
         * @param {tendermint.crypto.IProofOp=} [properties] Properties to set
         * @returns {tendermint.crypto.ProofOp} ProofOp instance
         */
        ProofOp.create = function create(properties) {
          return new ProofOp(properties);
        };

        /**
         * Encodes the specified ProofOp message. Does not implicitly {@link tendermint.crypto.ProofOp.verify|verify} messages.
         * @function encode
         * @memberof tendermint.crypto.ProofOp
         * @static
         * @param {tendermint.crypto.IProofOp} message ProofOp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProofOp.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.type != null && Object.hasOwnProperty.call(message, "type"))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.type);
          if (message.key != null && Object.hasOwnProperty.call(message, "key"))
            writer.uint32(/* id 2, wireType 2 =*/ 18).bytes(message.key);
          if (message.data != null && Object.hasOwnProperty.call(message, "data"))
            writer.uint32(/* id 3, wireType 2 =*/ 26).bytes(message.data);
          return writer;
        };

        /**
         * Encodes the specified ProofOp message, length delimited. Does not implicitly {@link tendermint.crypto.ProofOp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tendermint.crypto.ProofOp
         * @static
         * @param {tendermint.crypto.IProofOp} message ProofOp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProofOp.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProofOp message from the specified reader or buffer.
         * @function decode
         * @memberof tendermint.crypto.ProofOp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tendermint.crypto.ProofOp} ProofOp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProofOp.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.tendermint.crypto.ProofOp();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.type = reader.string();
                break;
              case 2:
                message.key = reader.bytes();
                break;
              case 3:
                message.data = reader.bytes();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a ProofOp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tendermint.crypto.ProofOp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tendermint.crypto.ProofOp} ProofOp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProofOp.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProofOp message.
         * @function verify
         * @memberof tendermint.crypto.ProofOp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProofOp.verify = function verify(message) {
          if (typeof message !== "object" || message === null) return "object expected";
          if (message.type != null && message.hasOwnProperty("type"))
            if (!$util.isString(message.type)) return "type: string expected";
          if (message.key != null && message.hasOwnProperty("key"))
            if (!((message.key && typeof message.key.length === "number") || $util.isString(message.key)))
              return "key: buffer expected";
          if (message.data != null && message.hasOwnProperty("data"))
            if (!((message.data && typeof message.data.length === "number") || $util.isString(message.data)))
              return "data: buffer expected";
          return null;
        };

        /**
         * Creates a ProofOp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tendermint.crypto.ProofOp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tendermint.crypto.ProofOp} ProofOp
         */
        ProofOp.fromObject = function fromObject(object) {
          if (object instanceof $root.tendermint.crypto.ProofOp) return object;
          var message = new $root.tendermint.crypto.ProofOp();
          if (object.type != null) message.type = String(object.type);
          if (object.key != null)
            if (typeof object.key === "string")
              $util.base64.decode(
                object.key,
                (message.key = $util.newBuffer($util.base64.length(object.key))),
                0,
              );
            else if (object.key.length) message.key = object.key;
          if (object.data != null)
            if (typeof object.data === "string")
              $util.base64.decode(
                object.data,
                (message.data = $util.newBuffer($util.base64.length(object.data))),
                0,
              );
            else if (object.data.length) message.data = object.data;
          return message;
        };

        /**
         * Creates a plain object from a ProofOp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tendermint.crypto.ProofOp
         * @static
         * @param {tendermint.crypto.ProofOp} message ProofOp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProofOp.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.type = "";
            if (options.bytes === String) object.key = "";
            else {
              object.key = [];
              if (options.bytes !== Array) object.key = $util.newBuffer(object.key);
            }
            if (options.bytes === String) object.data = "";
            else {
              object.data = [];
              if (options.bytes !== Array) object.data = $util.newBuffer(object.data);
            }
          }
          if (message.type != null && message.hasOwnProperty("type")) object.type = message.type;
          if (message.key != null && message.hasOwnProperty("key"))
            object.key =
              options.bytes === String
                ? $util.base64.encode(message.key, 0, message.key.length)
                : options.bytes === Array
                ? Array.prototype.slice.call(message.key)
                : message.key;
          if (message.data != null && message.hasOwnProperty("data"))
            object.data =
              options.bytes === String
                ? $util.base64.encode(message.data, 0, message.data.length)
                : options.bytes === Array
                ? Array.prototype.slice.call(message.data)
                : message.data;
          return object;
        };

        /**
         * Converts this ProofOp to JSON.
         * @function toJSON
         * @memberof tendermint.crypto.ProofOp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProofOp.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ProofOp;
      })();

      crypto.ProofOps = (function () {
        /**
         * Properties of a ProofOps.
         * @memberof tendermint.crypto
         * @interface IProofOps
         * @property {Array.<tendermint.crypto.IProofOp>|null} [ops] ProofOps ops
         */

        /**
         * Constructs a new ProofOps.
         * @memberof tendermint.crypto
         * @classdesc Represents a ProofOps.
         * @implements IProofOps
         * @constructor
         * @param {tendermint.crypto.IProofOps=} [properties] Properties to set
         */
        function ProofOps(properties) {
          this.ops = [];
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProofOps ops.
         * @member {Array.<tendermint.crypto.IProofOp>} ops
         * @memberof tendermint.crypto.ProofOps
         * @instance
         */
        ProofOps.prototype.ops = $util.emptyArray;

        /**
         * Creates a new ProofOps instance using the specified properties.
         * @function create
         * @memberof tendermint.crypto.ProofOps
         * @static
         * @param {tendermint.crypto.IProofOps=} [properties] Properties to set
         * @returns {tendermint.crypto.ProofOps} ProofOps instance
         */
        ProofOps.create = function create(properties) {
          return new ProofOps(properties);
        };

        /**
         * Encodes the specified ProofOps message. Does not implicitly {@link tendermint.crypto.ProofOps.verify|verify} messages.
         * @function encode
         * @memberof tendermint.crypto.ProofOps
         * @static
         * @param {tendermint.crypto.IProofOps} message ProofOps message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProofOps.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.ops != null && message.ops.length)
            for (var i = 0; i < message.ops.length; ++i)
              $root.tendermint.crypto.ProofOp.encode(
                message.ops[i],
                writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
              ).ldelim();
          return writer;
        };

        /**
         * Encodes the specified ProofOps message, length delimited. Does not implicitly {@link tendermint.crypto.ProofOps.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tendermint.crypto.ProofOps
         * @static
         * @param {tendermint.crypto.IProofOps} message ProofOps message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProofOps.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProofOps message from the specified reader or buffer.
         * @function decode
         * @memberof tendermint.crypto.ProofOps
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tendermint.crypto.ProofOps} ProofOps
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProofOps.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.tendermint.crypto.ProofOps();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                if (!(message.ops && message.ops.length)) message.ops = [];
                message.ops.push($root.tendermint.crypto.ProofOp.decode(reader, reader.uint32()));
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a ProofOps message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tendermint.crypto.ProofOps
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tendermint.crypto.ProofOps} ProofOps
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProofOps.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProofOps message.
         * @function verify
         * @memberof tendermint.crypto.ProofOps
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProofOps.verify = function verify(message) {
          if (typeof message !== "object" || message === null) return "object expected";
          if (message.ops != null && message.hasOwnProperty("ops")) {
            if (!Array.isArray(message.ops)) return "ops: array expected";
            for (var i = 0; i < message.ops.length; ++i) {
              var error = $root.tendermint.crypto.ProofOp.verify(message.ops[i]);
              if (error) return "ops." + error;
            }
          }
          return null;
        };

        /**
         * Creates a ProofOps message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tendermint.crypto.ProofOps
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tendermint.crypto.ProofOps} ProofOps
         */
        ProofOps.fromObject = function fromObject(object) {
          if (object instanceof $root.tendermint.crypto.ProofOps) return object;
          var message = new $root.tendermint.crypto.ProofOps();
          if (object.ops) {
            if (!Array.isArray(object.ops))
              throw TypeError(".tendermint.crypto.ProofOps.ops: array expected");
            message.ops = [];
            for (var i = 0; i < object.ops.length; ++i) {
              if (typeof object.ops[i] !== "object")
                throw TypeError(".tendermint.crypto.ProofOps.ops: object expected");
              message.ops[i] = $root.tendermint.crypto.ProofOp.fromObject(object.ops[i]);
            }
          }
          return message;
        };

        /**
         * Creates a plain object from a ProofOps message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tendermint.crypto.ProofOps
         * @static
         * @param {tendermint.crypto.ProofOps} message ProofOps
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProofOps.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.arrays || options.defaults) object.ops = [];
          if (message.ops && message.ops.length) {
            object.ops = [];
            for (var j = 0; j < message.ops.length; ++j)
              object.ops[j] = $root.tendermint.crypto.ProofOp.toObject(message.ops[j], options);
          }
          return object;
        };

        /**
         * Converts this ProofOps to JSON.
         * @function toJSON
         * @memberof tendermint.crypto.ProofOps
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProofOps.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ProofOps;
      })();

      return crypto;
    })();

    tendermint.version = (function () {
      /**
       * Namespace version.
       * @memberof tendermint
       * @namespace
       */
      var version = {};

      version.App = (function () {
        /**
         * Properties of an App.
         * @memberof tendermint.version
         * @interface IApp
         * @property {number|Long|null} [protocol] App protocol
         * @property {string|null} [software] App software
         */

        /**
         * Constructs a new App.
         * @memberof tendermint.version
         * @classdesc Represents an App.
         * @implements IApp
         * @constructor
         * @param {tendermint.version.IApp=} [properties] Properties to set
         */
        function App(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * App protocol.
         * @member {number|Long} protocol
         * @memberof tendermint.version.App
         * @instance
         */
        App.prototype.protocol = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

        /**
         * App software.
         * @member {string} software
         * @memberof tendermint.version.App
         * @instance
         */
        App.prototype.software = "";

        /**
         * Creates a new App instance using the specified properties.
         * @function create
         * @memberof tendermint.version.App
         * @static
         * @param {tendermint.version.IApp=} [properties] Properties to set
         * @returns {tendermint.version.App} App instance
         */
        App.create = function create(properties) {
          return new App(properties);
        };

        /**
         * Encodes the specified App message. Does not implicitly {@link tendermint.version.App.verify|verify} messages.
         * @function encode
         * @memberof tendermint.version.App
         * @static
         * @param {tendermint.version.IApp} message App message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        App.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.protocol != null && Object.hasOwnProperty.call(message, "protocol"))
            writer.uint32(/* id 1, wireType 0 =*/ 8).uint64(message.protocol);
          if (message.software != null && Object.hasOwnProperty.call(message, "software"))
            writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.software);
          return writer;
        };

        /**
         * Encodes the specified App message, length delimited. Does not implicitly {@link tendermint.version.App.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tendermint.version.App
         * @static
         * @param {tendermint.version.IApp} message App message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        App.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an App message from the specified reader or buffer.
         * @function decode
         * @memberof tendermint.version.App
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tendermint.version.App} App
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        App.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.tendermint.version.App();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.protocol = reader.uint64();
                break;
              case 2:
                message.software = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes an App message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tendermint.version.App
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tendermint.version.App} App
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        App.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an App message.
         * @function verify
         * @memberof tendermint.version.App
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        App.verify = function verify(message) {
          if (typeof message !== "object" || message === null) return "object expected";
          if (message.protocol != null && message.hasOwnProperty("protocol"))
            if (
              !$util.isInteger(message.protocol) &&
              !(
                message.protocol &&
                $util.isInteger(message.protocol.low) &&
                $util.isInteger(message.protocol.high)
              )
            )
              return "protocol: integer|Long expected";
          if (message.software != null && message.hasOwnProperty("software"))
            if (!$util.isString(message.software)) return "software: string expected";
          return null;
        };

        /**
         * Creates an App message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tendermint.version.App
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tendermint.version.App} App
         */
        App.fromObject = function fromObject(object) {
          if (object instanceof $root.tendermint.version.App) return object;
          var message = new $root.tendermint.version.App();
          if (object.protocol != null)
            if ($util.Long) (message.protocol = $util.Long.fromValue(object.protocol)).unsigned = true;
            else if (typeof object.protocol === "string") message.protocol = parseInt(object.protocol, 10);
            else if (typeof object.protocol === "number") message.protocol = object.protocol;
            else if (typeof object.protocol === "object")
              message.protocol = new $util.LongBits(
                object.protocol.low >>> 0,
                object.protocol.high >>> 0,
              ).toNumber(true);
          if (object.software != null) message.software = String(object.software);
          return message;
        };

        /**
         * Creates a plain object from an App message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tendermint.version.App
         * @static
         * @param {tendermint.version.App} message App
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        App.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            if ($util.Long) {
              var long = new $util.Long(0, 0, true);
              object.protocol =
                options.longs === String
                  ? long.toString()
                  : options.longs === Number
                  ? long.toNumber()
                  : long;
            } else object.protocol = options.longs === String ? "0" : 0;
            object.software = "";
          }
          if (message.protocol != null && message.hasOwnProperty("protocol"))
            if (typeof message.protocol === "number")
              object.protocol = options.longs === String ? String(message.protocol) : message.protocol;
            else
              object.protocol =
                options.longs === String
                  ? $util.Long.prototype.toString.call(message.protocol)
                  : options.longs === Number
                  ? new $util.LongBits(message.protocol.low >>> 0, message.protocol.high >>> 0).toNumber(true)
                  : message.protocol;
          if (message.software != null && message.hasOwnProperty("software"))
            object.software = message.software;
          return object;
        };

        /**
         * Converts this App to JSON.
         * @function toJSON
         * @memberof tendermint.version.App
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        App.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return App;
      })();

      version.Consensus = (function () {
        /**
         * Properties of a Consensus.
         * @memberof tendermint.version
         * @interface IConsensus
         * @property {number|Long|null} [block] Consensus block
         * @property {number|Long|null} [app] Consensus app
         */

        /**
         * Constructs a new Consensus.
         * @memberof tendermint.version
         * @classdesc Represents a Consensus.
         * @implements IConsensus
         * @constructor
         * @param {tendermint.version.IConsensus=} [properties] Properties to set
         */
        function Consensus(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * Consensus block.
         * @member {number|Long} block
         * @memberof tendermint.version.Consensus
         * @instance
         */
        Consensus.prototype.block = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

        /**
         * Consensus app.
         * @member {number|Long} app
         * @memberof tendermint.version.Consensus
         * @instance
         */
        Consensus.prototype.app = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

        /**
         * Creates a new Consensus instance using the specified properties.
         * @function create
         * @memberof tendermint.version.Consensus
         * @static
         * @param {tendermint.version.IConsensus=} [properties] Properties to set
         * @returns {tendermint.version.Consensus} Consensus instance
         */
        Consensus.create = function create(properties) {
          return new Consensus(properties);
        };

        /**
         * Encodes the specified Consensus message. Does not implicitly {@link tendermint.version.Consensus.verify|verify} messages.
         * @function encode
         * @memberof tendermint.version.Consensus
         * @static
         * @param {tendermint.version.IConsensus} message Consensus message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Consensus.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.block != null && Object.hasOwnProperty.call(message, "block"))
            writer.uint32(/* id 1, wireType 0 =*/ 8).uint64(message.block);
          if (message.app != null && Object.hasOwnProperty.call(message, "app"))
            writer.uint32(/* id 2, wireType 0 =*/ 16).uint64(message.app);
          return writer;
        };

        /**
         * Encodes the specified Consensus message, length delimited. Does not implicitly {@link tendermint.version.Consensus.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tendermint.version.Consensus
         * @static
         * @param {tendermint.version.IConsensus} message Consensus message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Consensus.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Consensus message from the specified reader or buffer.
         * @function decode
         * @memberof tendermint.version.Consensus
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tendermint.version.Consensus} Consensus
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Consensus.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.tendermint.version.Consensus();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.block = reader.uint64();
                break;
              case 2:
                message.app = reader.uint64();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a Consensus message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tendermint.version.Consensus
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tendermint.version.Consensus} Consensus
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Consensus.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Consensus message.
         * @function verify
         * @memberof tendermint.version.Consensus
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Consensus.verify = function verify(message) {
          if (typeof message !== "object" || message === null) return "object expected";
          if (message.block != null && message.hasOwnProperty("block"))
            if (
              !$util.isInteger(message.block) &&
              !(message.block && $util.isInteger(message.block.low) && $util.isInteger(message.block.high))
            )
              return "block: integer|Long expected";
          if (message.app != null && message.hasOwnProperty("app"))
            if (
              !$util.isInteger(message.app) &&
              !(message.app && $util.isInteger(message.app.low) && $util.isInteger(message.app.high))
            )
              return "app: integer|Long expected";
          return null;
        };

        /**
         * Creates a Consensus message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tendermint.version.Consensus
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tendermint.version.Consensus} Consensus
         */
        Consensus.fromObject = function fromObject(object) {
          if (object instanceof $root.tendermint.version.Consensus) return object;
          var message = new $root.tendermint.version.Consensus();
          if (object.block != null)
            if ($util.Long) (message.block = $util.Long.fromValue(object.block)).unsigned = true;
            else if (typeof object.block === "string") message.block = parseInt(object.block, 10);
            else if (typeof object.block === "number") message.block = object.block;
            else if (typeof object.block === "object")
              message.block = new $util.LongBits(object.block.low >>> 0, object.block.high >>> 0).toNumber(
                true,
              );
          if (object.app != null)
            if ($util.Long) (message.app = $util.Long.fromValue(object.app)).unsigned = true;
            else if (typeof object.app === "string") message.app = parseInt(object.app, 10);
            else if (typeof object.app === "number") message.app = object.app;
            else if (typeof object.app === "object")
              message.app = new $util.LongBits(object.app.low >>> 0, object.app.high >>> 0).toNumber(true);
          return message;
        };

        /**
         * Creates a plain object from a Consensus message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tendermint.version.Consensus
         * @static
         * @param {tendermint.version.Consensus} message Consensus
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Consensus.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            if ($util.Long) {
              var long = new $util.Long(0, 0, true);
              object.block =
                options.longs === String
                  ? long.toString()
                  : options.longs === Number
                  ? long.toNumber()
                  : long;
            } else object.block = options.longs === String ? "0" : 0;
            if ($util.Long) {
              var long = new $util.Long(0, 0, true);
              object.app =
                options.longs === String
                  ? long.toString()
                  : options.longs === Number
                  ? long.toNumber()
                  : long;
            } else object.app = options.longs === String ? "0" : 0;
          }
          if (message.block != null && message.hasOwnProperty("block"))
            if (typeof message.block === "number")
              object.block = options.longs === String ? String(message.block) : message.block;
            else
              object.block =
                options.longs === String
                  ? $util.Long.prototype.toString.call(message.block)
                  : options.longs === Number
                  ? new $util.LongBits(message.block.low >>> 0, message.block.high >>> 0).toNumber(true)
                  : message.block;
          if (message.app != null && message.hasOwnProperty("app"))
            if (typeof message.app === "number")
              object.app = options.longs === String ? String(message.app) : message.app;
            else
              object.app =
                options.longs === String
                  ? $util.Long.prototype.toString.call(message.app)
                  : options.longs === Number
                  ? new $util.LongBits(message.app.low >>> 0, message.app.high >>> 0).toNumber(true)
                  : message.app;
          return object;
        };

        /**
         * Converts this Consensus to JSON.
         * @function toJSON
         * @memberof tendermint.version.Consensus
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Consensus.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Consensus;
      })();

      return version;
    })();

    return tendermint;
  })();

  $root.cosmos = (function () {
    /**
     * Namespace cosmos.
     * @exports cosmos
     * @namespace
     */
    var cosmos = {};

    cosmos.base = (function () {
      /**
       * Namespace base.
       * @memberof cosmos
       * @namespace
       */
      var base = {};

      base.abci = (function () {
        /**
         * Namespace abci.
         * @memberof cosmos.base
         * @namespace
         */
        var abci = {};

        abci.v1beta1 = (function () {
          /**
           * Namespace v1beta1.
           * @memberof cosmos.base.abci
           * @namespace
           */
          var v1beta1 = {};

          v1beta1.TxResponse = (function () {
            /**
             * Properties of a TxResponse.
             * @memberof cosmos.base.abci.v1beta1
             * @interface ITxResponse
             * @property {number|Long|null} [height] TxResponse height
             * @property {string|null} [txhash] TxResponse txhash
             * @property {string|null} [codespace] TxResponse codespace
             * @property {number|null} [code] TxResponse code
             * @property {string|null} [data] TxResponse data
             * @property {string|null} [rawLog] TxResponse rawLog
             * @property {Array.<cosmos.base.abci.v1beta1.IABCIMessageLog>|null} [logs] TxResponse logs
             * @property {string|null} [info] TxResponse info
             * @property {number|Long|null} [gasWanted] TxResponse gasWanted
             * @property {number|Long|null} [gasUsed] TxResponse gasUsed
             * @property {google.protobuf.IAny|null} [tx] TxResponse tx
             * @property {string|null} [timestamp] TxResponse timestamp
             */

            /**
             * Constructs a new TxResponse.
             * @memberof cosmos.base.abci.v1beta1
             * @classdesc Represents a TxResponse.
             * @implements ITxResponse
             * @constructor
             * @param {cosmos.base.abci.v1beta1.ITxResponse=} [properties] Properties to set
             */
            function TxResponse(properties) {
              this.logs = [];
              if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                  if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
            }

            /**
             * TxResponse height.
             * @member {number|Long} height
             * @memberof cosmos.base.abci.v1beta1.TxResponse
             * @instance
             */
            TxResponse.prototype.height = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

            /**
             * TxResponse txhash.
             * @member {string} txhash
             * @memberof cosmos.base.abci.v1beta1.TxResponse
             * @instance
             */
            TxResponse.prototype.txhash = "";

            /**
             * TxResponse codespace.
             * @member {string} codespace
             * @memberof cosmos.base.abci.v1beta1.TxResponse
             * @instance
             */
            TxResponse.prototype.codespace = "";

            /**
             * TxResponse code.
             * @member {number} code
             * @memberof cosmos.base.abci.v1beta1.TxResponse
             * @instance
             */
            TxResponse.prototype.code = 0;

            /**
             * TxResponse data.
             * @member {string} data
             * @memberof cosmos.base.abci.v1beta1.TxResponse
             * @instance
             */
            TxResponse.prototype.data = "";

            /**
             * TxResponse rawLog.
             * @member {string} rawLog
             * @memberof cosmos.base.abci.v1beta1.TxResponse
             * @instance
             */
            TxResponse.prototype.rawLog = "";

            /**
             * TxResponse logs.
             * @member {Array.<cosmos.base.abci.v1beta1.IABCIMessageLog>} logs
             * @memberof cosmos.base.abci.v1beta1.TxResponse
             * @instance
             */
            TxResponse.prototype.logs = $util.emptyArray;

            /**
             * TxResponse info.
             * @member {string} info
             * @memberof cosmos.base.abci.v1beta1.TxResponse
             * @instance
             */
            TxResponse.prototype.info = "";

            /**
             * TxResponse gasWanted.
             * @member {number|Long} gasWanted
             * @memberof cosmos.base.abci.v1beta1.TxResponse
             * @instance
             */
            TxResponse.prototype.gasWanted = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

            /**
             * TxResponse gasUsed.
             * @member {number|Long} gasUsed
             * @memberof cosmos.base.abci.v1beta1.TxResponse
             * @instance
             */
            TxResponse.prototype.gasUsed = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

            /**
             * TxResponse tx.
             * @member {google.protobuf.IAny|null|undefined} tx
             * @memberof cosmos.base.abci.v1beta1.TxResponse
             * @instance
             */
            TxResponse.prototype.tx = null;

            /**
             * TxResponse timestamp.
             * @member {string} timestamp
             * @memberof cosmos.base.abci.v1beta1.TxResponse
             * @instance
             */
            TxResponse.prototype.timestamp = "";

            /**
             * Creates a new TxResponse instance using the specified properties.
             * @function create
             * @memberof cosmos.base.abci.v1beta1.TxResponse
             * @static
             * @param {cosmos.base.abci.v1beta1.ITxResponse=} [properties] Properties to set
             * @returns {cosmos.base.abci.v1beta1.TxResponse} TxResponse instance
             */
            TxResponse.create = function create(properties) {
              return new TxResponse(properties);
            };

            /**
             * Encodes the specified TxResponse message. Does not implicitly {@link cosmos.base.abci.v1beta1.TxResponse.verify|verify} messages.
             * @function encode
             * @memberof cosmos.base.abci.v1beta1.TxResponse
             * @static
             * @param {cosmos.base.abci.v1beta1.ITxResponse} message TxResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TxResponse.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.height != null && Object.hasOwnProperty.call(message, "height"))
                writer.uint32(/* id 1, wireType 0 =*/ 8).int64(message.height);
              if (message.txhash != null && Object.hasOwnProperty.call(message, "txhash"))
                writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.txhash);
              if (message.codespace != null && Object.hasOwnProperty.call(message, "codespace"))
                writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.codespace);
              if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                writer.uint32(/* id 4, wireType 0 =*/ 32).uint32(message.code);
              if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                writer.uint32(/* id 5, wireType 2 =*/ 42).string(message.data);
              if (message.rawLog != null && Object.hasOwnProperty.call(message, "rawLog"))
                writer.uint32(/* id 6, wireType 2 =*/ 50).string(message.rawLog);
              if (message.logs != null && message.logs.length)
                for (var i = 0; i < message.logs.length; ++i)
                  $root.cosmos.base.abci.v1beta1.ABCIMessageLog.encode(
                    message.logs[i],
                    writer.uint32(/* id 7, wireType 2 =*/ 58).fork(),
                  ).ldelim();
              if (message.info != null && Object.hasOwnProperty.call(message, "info"))
                writer.uint32(/* id 8, wireType 2 =*/ 66).string(message.info);
              if (message.gasWanted != null && Object.hasOwnProperty.call(message, "gasWanted"))
                writer.uint32(/* id 9, wireType 0 =*/ 72).int64(message.gasWanted);
              if (message.gasUsed != null && Object.hasOwnProperty.call(message, "gasUsed"))
                writer.uint32(/* id 10, wireType 0 =*/ 80).int64(message.gasUsed);
              if (message.tx != null && Object.hasOwnProperty.call(message, "tx"))
                $root.google.protobuf.Any.encode(
                  message.tx,
                  writer.uint32(/* id 11, wireType 2 =*/ 90).fork(),
                ).ldelim();
              if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 12, wireType 2 =*/ 98).string(message.timestamp);
              return writer;
            };

            /**
             * Encodes the specified TxResponse message, length delimited. Does not implicitly {@link cosmos.base.abci.v1beta1.TxResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof cosmos.base.abci.v1beta1.TxResponse
             * @static
             * @param {cosmos.base.abci.v1beta1.ITxResponse} message TxResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TxResponse.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a TxResponse message from the specified reader or buffer.
             * @function decode
             * @memberof cosmos.base.abci.v1beta1.TxResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {cosmos.base.abci.v1beta1.TxResponse} TxResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TxResponse.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                message = new $root.cosmos.base.abci.v1beta1.TxResponse();
              while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1:
                    message.height = reader.int64();
                    break;
                  case 2:
                    message.txhash = reader.string();
                    break;
                  case 3:
                    message.codespace = reader.string();
                    break;
                  case 4:
                    message.code = reader.uint32();
                    break;
                  case 5:
                    message.data = reader.string();
                    break;
                  case 6:
                    message.rawLog = reader.string();
                    break;
                  case 7:
                    if (!(message.logs && message.logs.length)) message.logs = [];
                    message.logs.push(
                      $root.cosmos.base.abci.v1beta1.ABCIMessageLog.decode(reader, reader.uint32()),
                    );
                    break;
                  case 8:
                    message.info = reader.string();
                    break;
                  case 9:
                    message.gasWanted = reader.int64();
                    break;
                  case 10:
                    message.gasUsed = reader.int64();
                    break;
                  case 11:
                    message.tx = $root.google.protobuf.Any.decode(reader, reader.uint32());
                    break;
                  case 12:
                    message.timestamp = reader.string();
                    break;
                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }
              return message;
            };

            /**
             * Decodes a TxResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof cosmos.base.abci.v1beta1.TxResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {cosmos.base.abci.v1beta1.TxResponse} TxResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TxResponse.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a TxResponse message.
             * @function verify
             * @memberof cosmos.base.abci.v1beta1.TxResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TxResponse.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.height != null && message.hasOwnProperty("height"))
                if (
                  !$util.isInteger(message.height) &&
                  !(
                    message.height &&
                    $util.isInteger(message.height.low) &&
                    $util.isInteger(message.height.high)
                  )
                )
                  return "height: integer|Long expected";
              if (message.txhash != null && message.hasOwnProperty("txhash"))
                if (!$util.isString(message.txhash)) return "txhash: string expected";
              if (message.codespace != null && message.hasOwnProperty("codespace"))
                if (!$util.isString(message.codespace)) return "codespace: string expected";
              if (message.code != null && message.hasOwnProperty("code"))
                if (!$util.isInteger(message.code)) return "code: integer expected";
              if (message.data != null && message.hasOwnProperty("data"))
                if (!$util.isString(message.data)) return "data: string expected";
              if (message.rawLog != null && message.hasOwnProperty("rawLog"))
                if (!$util.isString(message.rawLog)) return "rawLog: string expected";
              if (message.logs != null && message.hasOwnProperty("logs")) {
                if (!Array.isArray(message.logs)) return "logs: array expected";
                for (var i = 0; i < message.logs.length; ++i) {
                  var error = $root.cosmos.base.abci.v1beta1.ABCIMessageLog.verify(message.logs[i]);
                  if (error) return "logs." + error;
                }
              }
              if (message.info != null && message.hasOwnProperty("info"))
                if (!$util.isString(message.info)) return "info: string expected";
              if (message.gasWanted != null && message.hasOwnProperty("gasWanted"))
                if (
                  !$util.isInteger(message.gasWanted) &&
                  !(
                    message.gasWanted &&
                    $util.isInteger(message.gasWanted.low) &&
                    $util.isInteger(message.gasWanted.high)
                  )
                )
                  return "gasWanted: integer|Long expected";
              if (message.gasUsed != null && message.hasOwnProperty("gasUsed"))
                if (
                  !$util.isInteger(message.gasUsed) &&
                  !(
                    message.gasUsed &&
                    $util.isInteger(message.gasUsed.low) &&
                    $util.isInteger(message.gasUsed.high)
                  )
                )
                  return "gasUsed: integer|Long expected";
              if (message.tx != null && message.hasOwnProperty("tx")) {
                var error = $root.google.protobuf.Any.verify(message.tx);
                if (error) return "tx." + error;
              }
              if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isString(message.timestamp)) return "timestamp: string expected";
              return null;
            };

            /**
             * Creates a TxResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof cosmos.base.abci.v1beta1.TxResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {cosmos.base.abci.v1beta1.TxResponse} TxResponse
             */
            TxResponse.fromObject = function fromObject(object) {
              if (object instanceof $root.cosmos.base.abci.v1beta1.TxResponse) return object;
              var message = new $root.cosmos.base.abci.v1beta1.TxResponse();
              if (object.height != null)
                if ($util.Long) (message.height = $util.Long.fromValue(object.height)).unsigned = false;
                else if (typeof object.height === "string") message.height = parseInt(object.height, 10);
                else if (typeof object.height === "number") message.height = object.height;
                else if (typeof object.height === "object")
                  message.height = new $util.LongBits(
                    object.height.low >>> 0,
                    object.height.high >>> 0,
                  ).toNumber();
              if (object.txhash != null) message.txhash = String(object.txhash);
              if (object.codespace != null) message.codespace = String(object.codespace);
              if (object.code != null) message.code = object.code >>> 0;
              if (object.data != null) message.data = String(object.data);
              if (object.rawLog != null) message.rawLog = String(object.rawLog);
              if (object.logs) {
                if (!Array.isArray(object.logs))
                  throw TypeError(".cosmos.base.abci.v1beta1.TxResponse.logs: array expected");
                message.logs = [];
                for (var i = 0; i < object.logs.length; ++i) {
                  if (typeof object.logs[i] !== "object")
                    throw TypeError(".cosmos.base.abci.v1beta1.TxResponse.logs: object expected");
                  message.logs[i] = $root.cosmos.base.abci.v1beta1.ABCIMessageLog.fromObject(object.logs[i]);
                }
              }
              if (object.info != null) message.info = String(object.info);
              if (object.gasWanted != null)
                if ($util.Long) (message.gasWanted = $util.Long.fromValue(object.gasWanted)).unsigned = false;
                else if (typeof object.gasWanted === "string")
                  message.gasWanted = parseInt(object.gasWanted, 10);
                else if (typeof object.gasWanted === "number") message.gasWanted = object.gasWanted;
                else if (typeof object.gasWanted === "object")
                  message.gasWanted = new $util.LongBits(
                    object.gasWanted.low >>> 0,
                    object.gasWanted.high >>> 0,
                  ).toNumber();
              if (object.gasUsed != null)
                if ($util.Long) (message.gasUsed = $util.Long.fromValue(object.gasUsed)).unsigned = false;
                else if (typeof object.gasUsed === "string") message.gasUsed = parseInt(object.gasUsed, 10);
                else if (typeof object.gasUsed === "number") message.gasUsed = object.gasUsed;
                else if (typeof object.gasUsed === "object")
                  message.gasUsed = new $util.LongBits(
                    object.gasUsed.low >>> 0,
                    object.gasUsed.high >>> 0,
                  ).toNumber();
              if (object.tx != null) {
                if (typeof object.tx !== "object")
                  throw TypeError(".cosmos.base.abci.v1beta1.TxResponse.tx: object expected");
                message.tx = $root.google.protobuf.Any.fromObject(object.tx);
              }
              if (object.timestamp != null) message.timestamp = String(object.timestamp);
              return message;
            };

            /**
             * Creates a plain object from a TxResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof cosmos.base.abci.v1beta1.TxResponse
             * @static
             * @param {cosmos.base.abci.v1beta1.TxResponse} message TxResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TxResponse.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};
              if (options.arrays || options.defaults) object.logs = [];
              if (options.defaults) {
                if ($util.Long) {
                  var long = new $util.Long(0, 0, false);
                  object.height =
                    options.longs === String
                      ? long.toString()
                      : options.longs === Number
                      ? long.toNumber()
                      : long;
                } else object.height = options.longs === String ? "0" : 0;
                object.txhash = "";
                object.codespace = "";
                object.code = 0;
                object.data = "";
                object.rawLog = "";
                object.info = "";
                if ($util.Long) {
                  var long = new $util.Long(0, 0, false);
                  object.gasWanted =
                    options.longs === String
                      ? long.toString()
                      : options.longs === Number
                      ? long.toNumber()
                      : long;
                } else object.gasWanted = options.longs === String ? "0" : 0;
                if ($util.Long) {
                  var long = new $util.Long(0, 0, false);
                  object.gasUsed =
                    options.longs === String
                      ? long.toString()
                      : options.longs === Number
                      ? long.toNumber()
                      : long;
                } else object.gasUsed = options.longs === String ? "0" : 0;
                object.tx = null;
                object.timestamp = "";
              }
              if (message.height != null && message.hasOwnProperty("height"))
                if (typeof message.height === "number")
                  object.height = options.longs === String ? String(message.height) : message.height;
                else
                  object.height =
                    options.longs === String
                      ? $util.Long.prototype.toString.call(message.height)
                      : options.longs === Number
                      ? new $util.LongBits(message.height.low >>> 0, message.height.high >>> 0).toNumber()
                      : message.height;
              if (message.txhash != null && message.hasOwnProperty("txhash")) object.txhash = message.txhash;
              if (message.codespace != null && message.hasOwnProperty("codespace"))
                object.codespace = message.codespace;
              if (message.code != null && message.hasOwnProperty("code")) object.code = message.code;
              if (message.data != null && message.hasOwnProperty("data")) object.data = message.data;
              if (message.rawLog != null && message.hasOwnProperty("rawLog")) object.rawLog = message.rawLog;
              if (message.logs && message.logs.length) {
                object.logs = [];
                for (var j = 0; j < message.logs.length; ++j)
                  object.logs[j] = $root.cosmos.base.abci.v1beta1.ABCIMessageLog.toObject(
                    message.logs[j],
                    options,
                  );
              }
              if (message.info != null && message.hasOwnProperty("info")) object.info = message.info;
              if (message.gasWanted != null && message.hasOwnProperty("gasWanted"))
                if (typeof message.gasWanted === "number")
                  object.gasWanted = options.longs === String ? String(message.gasWanted) : message.gasWanted;
                else
                  object.gasWanted =
                    options.longs === String
                      ? $util.Long.prototype.toString.call(message.gasWanted)
                      : options.longs === Number
                      ? new $util.LongBits(
                          message.gasWanted.low >>> 0,
                          message.gasWanted.high >>> 0,
                        ).toNumber()
                      : message.gasWanted;
              if (message.gasUsed != null && message.hasOwnProperty("gasUsed"))
                if (typeof message.gasUsed === "number")
                  object.gasUsed = options.longs === String ? String(message.gasUsed) : message.gasUsed;
                else
                  object.gasUsed =
                    options.longs === String
                      ? $util.Long.prototype.toString.call(message.gasUsed)
                      : options.longs === Number
                      ? new $util.LongBits(message.gasUsed.low >>> 0, message.gasUsed.high >>> 0).toNumber()
                      : message.gasUsed;
              if (message.tx != null && message.hasOwnProperty("tx"))
                object.tx = $root.google.protobuf.Any.toObject(message.tx, options);
              if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                object.timestamp = message.timestamp;
              return object;
            };

            /**
             * Converts this TxResponse to JSON.
             * @function toJSON
             * @memberof cosmos.base.abci.v1beta1.TxResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TxResponse.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return TxResponse;
          })();

          v1beta1.ABCIMessageLog = (function () {
            /**
             * Properties of a ABCIMessageLog.
             * @memberof cosmos.base.abci.v1beta1
             * @interface IABCIMessageLog
             * @property {number|null} [msgIndex] ABCIMessageLog msgIndex
             * @property {string|null} [log] ABCIMessageLog log
             * @property {Array.<cosmos.base.abci.v1beta1.IStringEvent>|null} [events] ABCIMessageLog events
             */

            /**
             * Constructs a new ABCIMessageLog.
             * @memberof cosmos.base.abci.v1beta1
             * @classdesc Represents a ABCIMessageLog.
             * @implements IABCIMessageLog
             * @constructor
             * @param {cosmos.base.abci.v1beta1.IABCIMessageLog=} [properties] Properties to set
             */
            function ABCIMessageLog(properties) {
              this.events = [];
              if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                  if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
            }

            /**
             * ABCIMessageLog msgIndex.
             * @member {number} msgIndex
             * @memberof cosmos.base.abci.v1beta1.ABCIMessageLog
             * @instance
             */
            ABCIMessageLog.prototype.msgIndex = 0;

            /**
             * ABCIMessageLog log.
             * @member {string} log
             * @memberof cosmos.base.abci.v1beta1.ABCIMessageLog
             * @instance
             */
            ABCIMessageLog.prototype.log = "";

            /**
             * ABCIMessageLog events.
             * @member {Array.<cosmos.base.abci.v1beta1.IStringEvent>} events
             * @memberof cosmos.base.abci.v1beta1.ABCIMessageLog
             * @instance
             */
            ABCIMessageLog.prototype.events = $util.emptyArray;

            /**
             * Creates a new ABCIMessageLog instance using the specified properties.
             * @function create
             * @memberof cosmos.base.abci.v1beta1.ABCIMessageLog
             * @static
             * @param {cosmos.base.abci.v1beta1.IABCIMessageLog=} [properties] Properties to set
             * @returns {cosmos.base.abci.v1beta1.ABCIMessageLog} ABCIMessageLog instance
             */
            ABCIMessageLog.create = function create(properties) {
              return new ABCIMessageLog(properties);
            };

            /**
             * Encodes the specified ABCIMessageLog message. Does not implicitly {@link cosmos.base.abci.v1beta1.ABCIMessageLog.verify|verify} messages.
             * @function encode
             * @memberof cosmos.base.abci.v1beta1.ABCIMessageLog
             * @static
             * @param {cosmos.base.abci.v1beta1.IABCIMessageLog} message ABCIMessageLog message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ABCIMessageLog.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.msgIndex != null && Object.hasOwnProperty.call(message, "msgIndex"))
                writer.uint32(/* id 1, wireType 0 =*/ 8).uint32(message.msgIndex);
              if (message.log != null && Object.hasOwnProperty.call(message, "log"))
                writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.log);
              if (message.events != null && message.events.length)
                for (var i = 0; i < message.events.length; ++i)
                  $root.cosmos.base.abci.v1beta1.StringEvent.encode(
                    message.events[i],
                    writer.uint32(/* id 3, wireType 2 =*/ 26).fork(),
                  ).ldelim();
              return writer;
            };

            /**
             * Encodes the specified ABCIMessageLog message, length delimited. Does not implicitly {@link cosmos.base.abci.v1beta1.ABCIMessageLog.verify|verify} messages.
             * @function encodeDelimited
             * @memberof cosmos.base.abci.v1beta1.ABCIMessageLog
             * @static
             * @param {cosmos.base.abci.v1beta1.IABCIMessageLog} message ABCIMessageLog message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ABCIMessageLog.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ABCIMessageLog message from the specified reader or buffer.
             * @function decode
             * @memberof cosmos.base.abci.v1beta1.ABCIMessageLog
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {cosmos.base.abci.v1beta1.ABCIMessageLog} ABCIMessageLog
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ABCIMessageLog.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                message = new $root.cosmos.base.abci.v1beta1.ABCIMessageLog();
              while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1:
                    message.msgIndex = reader.uint32();
                    break;
                  case 2:
                    message.log = reader.string();
                    break;
                  case 3:
                    if (!(message.events && message.events.length)) message.events = [];
                    message.events.push(
                      $root.cosmos.base.abci.v1beta1.StringEvent.decode(reader, reader.uint32()),
                    );
                    break;
                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }
              return message;
            };

            /**
             * Decodes a ABCIMessageLog message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof cosmos.base.abci.v1beta1.ABCIMessageLog
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {cosmos.base.abci.v1beta1.ABCIMessageLog} ABCIMessageLog
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ABCIMessageLog.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ABCIMessageLog message.
             * @function verify
             * @memberof cosmos.base.abci.v1beta1.ABCIMessageLog
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ABCIMessageLog.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.msgIndex != null && message.hasOwnProperty("msgIndex"))
                if (!$util.isInteger(message.msgIndex)) return "msgIndex: integer expected";
              if (message.log != null && message.hasOwnProperty("log"))
                if (!$util.isString(message.log)) return "log: string expected";
              if (message.events != null && message.hasOwnProperty("events")) {
                if (!Array.isArray(message.events)) return "events: array expected";
                for (var i = 0; i < message.events.length; ++i) {
                  var error = $root.cosmos.base.abci.v1beta1.StringEvent.verify(message.events[i]);
                  if (error) return "events." + error;
                }
              }
              return null;
            };

            /**
             * Creates a ABCIMessageLog message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof cosmos.base.abci.v1beta1.ABCIMessageLog
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {cosmos.base.abci.v1beta1.ABCIMessageLog} ABCIMessageLog
             */
            ABCIMessageLog.fromObject = function fromObject(object) {
              if (object instanceof $root.cosmos.base.abci.v1beta1.ABCIMessageLog) return object;
              var message = new $root.cosmos.base.abci.v1beta1.ABCIMessageLog();
              if (object.msgIndex != null) message.msgIndex = object.msgIndex >>> 0;
              if (object.log != null) message.log = String(object.log);
              if (object.events) {
                if (!Array.isArray(object.events))
                  throw TypeError(".cosmos.base.abci.v1beta1.ABCIMessageLog.events: array expected");
                message.events = [];
                for (var i = 0; i < object.events.length; ++i) {
                  if (typeof object.events[i] !== "object")
                    throw TypeError(".cosmos.base.abci.v1beta1.ABCIMessageLog.events: object expected");
                  message.events[i] = $root.cosmos.base.abci.v1beta1.StringEvent.fromObject(object.events[i]);
                }
              }
              return message;
            };

            /**
             * Creates a plain object from a ABCIMessageLog message. Also converts values to other types if specified.
             * @function toObject
             * @memberof cosmos.base.abci.v1beta1.ABCIMessageLog
             * @static
             * @param {cosmos.base.abci.v1beta1.ABCIMessageLog} message ABCIMessageLog
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ABCIMessageLog.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};
              if (options.arrays || options.defaults) object.events = [];
              if (options.defaults) {
                object.msgIndex = 0;
                object.log = "";
              }
              if (message.msgIndex != null && message.hasOwnProperty("msgIndex"))
                object.msgIndex = message.msgIndex;
              if (message.log != null && message.hasOwnProperty("log")) object.log = message.log;
              if (message.events && message.events.length) {
                object.events = [];
                for (var j = 0; j < message.events.length; ++j)
                  object.events[j] = $root.cosmos.base.abci.v1beta1.StringEvent.toObject(
                    message.events[j],
                    options,
                  );
              }
              return object;
            };

            /**
             * Converts this ABCIMessageLog to JSON.
             * @function toJSON
             * @memberof cosmos.base.abci.v1beta1.ABCIMessageLog
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ABCIMessageLog.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ABCIMessageLog;
          })();

          v1beta1.StringEvent = (function () {
            /**
             * Properties of a StringEvent.
             * @memberof cosmos.base.abci.v1beta1
             * @interface IStringEvent
             * @property {string|null} [type] StringEvent type
             * @property {Array.<cosmos.base.abci.v1beta1.IAttribute>|null} [attributes] StringEvent attributes
             */

            /**
             * Constructs a new StringEvent.
             * @memberof cosmos.base.abci.v1beta1
             * @classdesc Represents a StringEvent.
             * @implements IStringEvent
             * @constructor
             * @param {cosmos.base.abci.v1beta1.IStringEvent=} [properties] Properties to set
             */
            function StringEvent(properties) {
              this.attributes = [];
              if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                  if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
            }

            /**
             * StringEvent type.
             * @member {string} type
             * @memberof cosmos.base.abci.v1beta1.StringEvent
             * @instance
             */
            StringEvent.prototype.type = "";

            /**
             * StringEvent attributes.
             * @member {Array.<cosmos.base.abci.v1beta1.IAttribute>} attributes
             * @memberof cosmos.base.abci.v1beta1.StringEvent
             * @instance
             */
            StringEvent.prototype.attributes = $util.emptyArray;

            /**
             * Creates a new StringEvent instance using the specified properties.
             * @function create
             * @memberof cosmos.base.abci.v1beta1.StringEvent
             * @static
             * @param {cosmos.base.abci.v1beta1.IStringEvent=} [properties] Properties to set
             * @returns {cosmos.base.abci.v1beta1.StringEvent} StringEvent instance
             */
            StringEvent.create = function create(properties) {
              return new StringEvent(properties);
            };

            /**
             * Encodes the specified StringEvent message. Does not implicitly {@link cosmos.base.abci.v1beta1.StringEvent.verify|verify} messages.
             * @function encode
             * @memberof cosmos.base.abci.v1beta1.StringEvent
             * @static
             * @param {cosmos.base.abci.v1beta1.IStringEvent} message StringEvent message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StringEvent.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.type);
              if (message.attributes != null && message.attributes.length)
                for (var i = 0; i < message.attributes.length; ++i)
                  $root.cosmos.base.abci.v1beta1.Attribute.encode(
                    message.attributes[i],
                    writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
                  ).ldelim();
              return writer;
            };

            /**
             * Encodes the specified StringEvent message, length delimited. Does not implicitly {@link cosmos.base.abci.v1beta1.StringEvent.verify|verify} messages.
             * @function encodeDelimited
             * @memberof cosmos.base.abci.v1beta1.StringEvent
             * @static
             * @param {cosmos.base.abci.v1beta1.IStringEvent} message StringEvent message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StringEvent.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a StringEvent message from the specified reader or buffer.
             * @function decode
             * @memberof cosmos.base.abci.v1beta1.StringEvent
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {cosmos.base.abci.v1beta1.StringEvent} StringEvent
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StringEvent.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                message = new $root.cosmos.base.abci.v1beta1.StringEvent();
              while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1:
                    message.type = reader.string();
                    break;
                  case 2:
                    if (!(message.attributes && message.attributes.length)) message.attributes = [];
                    message.attributes.push(
                      $root.cosmos.base.abci.v1beta1.Attribute.decode(reader, reader.uint32()),
                    );
                    break;
                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }
              return message;
            };

            /**
             * Decodes a StringEvent message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof cosmos.base.abci.v1beta1.StringEvent
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {cosmos.base.abci.v1beta1.StringEvent} StringEvent
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StringEvent.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a StringEvent message.
             * @function verify
             * @memberof cosmos.base.abci.v1beta1.StringEvent
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            StringEvent.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isString(message.type)) return "type: string expected";
              if (message.attributes != null && message.hasOwnProperty("attributes")) {
                if (!Array.isArray(message.attributes)) return "attributes: array expected";
                for (var i = 0; i < message.attributes.length; ++i) {
                  var error = $root.cosmos.base.abci.v1beta1.Attribute.verify(message.attributes[i]);
                  if (error) return "attributes." + error;
                }
              }
              return null;
            };

            /**
             * Creates a StringEvent message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof cosmos.base.abci.v1beta1.StringEvent
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {cosmos.base.abci.v1beta1.StringEvent} StringEvent
             */
            StringEvent.fromObject = function fromObject(object) {
              if (object instanceof $root.cosmos.base.abci.v1beta1.StringEvent) return object;
              var message = new $root.cosmos.base.abci.v1beta1.StringEvent();
              if (object.type != null) message.type = String(object.type);
              if (object.attributes) {
                if (!Array.isArray(object.attributes))
                  throw TypeError(".cosmos.base.abci.v1beta1.StringEvent.attributes: array expected");
                message.attributes = [];
                for (var i = 0; i < object.attributes.length; ++i) {
                  if (typeof object.attributes[i] !== "object")
                    throw TypeError(".cosmos.base.abci.v1beta1.StringEvent.attributes: object expected");
                  message.attributes[i] = $root.cosmos.base.abci.v1beta1.Attribute.fromObject(
                    object.attributes[i],
                  );
                }
              }
              return message;
            };

            /**
             * Creates a plain object from a StringEvent message. Also converts values to other types if specified.
             * @function toObject
             * @memberof cosmos.base.abci.v1beta1.StringEvent
             * @static
             * @param {cosmos.base.abci.v1beta1.StringEvent} message StringEvent
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StringEvent.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};
              if (options.arrays || options.defaults) object.attributes = [];
              if (options.defaults) object.type = "";
              if (message.type != null && message.hasOwnProperty("type")) object.type = message.type;
              if (message.attributes && message.attributes.length) {
                object.attributes = [];
                for (var j = 0; j < message.attributes.length; ++j)
                  object.attributes[j] = $root.cosmos.base.abci.v1beta1.Attribute.toObject(
                    message.attributes[j],
                    options,
                  );
              }
              return object;
            };

            /**
             * Converts this StringEvent to JSON.
             * @function toJSON
             * @memberof cosmos.base.abci.v1beta1.StringEvent
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            StringEvent.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return StringEvent;
          })();

          v1beta1.Attribute = (function () {
            /**
             * Properties of an Attribute.
             * @memberof cosmos.base.abci.v1beta1
             * @interface IAttribute
             * @property {string|null} [key] Attribute key
             * @property {string|null} [value] Attribute value
             */

            /**
             * Constructs a new Attribute.
             * @memberof cosmos.base.abci.v1beta1
             * @classdesc Represents an Attribute.
             * @implements IAttribute
             * @constructor
             * @param {cosmos.base.abci.v1beta1.IAttribute=} [properties] Properties to set
             */
            function Attribute(properties) {
              if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                  if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
            }

            /**
             * Attribute key.
             * @member {string} key
             * @memberof cosmos.base.abci.v1beta1.Attribute
             * @instance
             */
            Attribute.prototype.key = "";

            /**
             * Attribute value.
             * @member {string} value
             * @memberof cosmos.base.abci.v1beta1.Attribute
             * @instance
             */
            Attribute.prototype.value = "";

            /**
             * Creates a new Attribute instance using the specified properties.
             * @function create
             * @memberof cosmos.base.abci.v1beta1.Attribute
             * @static
             * @param {cosmos.base.abci.v1beta1.IAttribute=} [properties] Properties to set
             * @returns {cosmos.base.abci.v1beta1.Attribute} Attribute instance
             */
            Attribute.create = function create(properties) {
              return new Attribute(properties);
            };

            /**
             * Encodes the specified Attribute message. Does not implicitly {@link cosmos.base.abci.v1beta1.Attribute.verify|verify} messages.
             * @function encode
             * @memberof cosmos.base.abci.v1beta1.Attribute
             * @static
             * @param {cosmos.base.abci.v1beta1.IAttribute} message Attribute message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Attribute.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.key);
              if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.value);
              return writer;
            };

            /**
             * Encodes the specified Attribute message, length delimited. Does not implicitly {@link cosmos.base.abci.v1beta1.Attribute.verify|verify} messages.
             * @function encodeDelimited
             * @memberof cosmos.base.abci.v1beta1.Attribute
             * @static
             * @param {cosmos.base.abci.v1beta1.IAttribute} message Attribute message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Attribute.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Attribute message from the specified reader or buffer.
             * @function decode
             * @memberof cosmos.base.abci.v1beta1.Attribute
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {cosmos.base.abci.v1beta1.Attribute} Attribute
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Attribute.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                message = new $root.cosmos.base.abci.v1beta1.Attribute();
              while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1:
                    message.key = reader.string();
                    break;
                  case 2:
                    message.value = reader.string();
                    break;
                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }
              return message;
            };

            /**
             * Decodes an Attribute message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof cosmos.base.abci.v1beta1.Attribute
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {cosmos.base.abci.v1beta1.Attribute} Attribute
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Attribute.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Attribute message.
             * @function verify
             * @memberof cosmos.base.abci.v1beta1.Attribute
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Attribute.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.key != null && message.hasOwnProperty("key"))
                if (!$util.isString(message.key)) return "key: string expected";
              if (message.value != null && message.hasOwnProperty("value"))
                if (!$util.isString(message.value)) return "value: string expected";
              return null;
            };

            /**
             * Creates an Attribute message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof cosmos.base.abci.v1beta1.Attribute
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {cosmos.base.abci.v1beta1.Attribute} Attribute
             */
            Attribute.fromObject = function fromObject(object) {
              if (object instanceof $root.cosmos.base.abci.v1beta1.Attribute) return object;
              var message = new $root.cosmos.base.abci.v1beta1.Attribute();
              if (object.key != null) message.key = String(object.key);
              if (object.value != null) message.value = String(object.value);
              return message;
            };

            /**
             * Creates a plain object from an Attribute message. Also converts values to other types if specified.
             * @function toObject
             * @memberof cosmos.base.abci.v1beta1.Attribute
             * @static
             * @param {cosmos.base.abci.v1beta1.Attribute} message Attribute
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Attribute.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};
              if (options.defaults) {
                object.key = "";
                object.value = "";
              }
              if (message.key != null && message.hasOwnProperty("key")) object.key = message.key;
              if (message.value != null && message.hasOwnProperty("value")) object.value = message.value;
              return object;
            };

            /**
             * Converts this Attribute to JSON.
             * @function toJSON
             * @memberof cosmos.base.abci.v1beta1.Attribute
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Attribute.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Attribute;
          })();

          v1beta1.GasInfo = (function () {
            /**
             * Properties of a GasInfo.
             * @memberof cosmos.base.abci.v1beta1
             * @interface IGasInfo
             * @property {number|Long|null} [gasWanted] GasInfo gasWanted
             * @property {number|Long|null} [gasUsed] GasInfo gasUsed
             */

            /**
             * Constructs a new GasInfo.
             * @memberof cosmos.base.abci.v1beta1
             * @classdesc Represents a GasInfo.
             * @implements IGasInfo
             * @constructor
             * @param {cosmos.base.abci.v1beta1.IGasInfo=} [properties] Properties to set
             */
            function GasInfo(properties) {
              if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                  if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
            }

            /**
             * GasInfo gasWanted.
             * @member {number|Long} gasWanted
             * @memberof cosmos.base.abci.v1beta1.GasInfo
             * @instance
             */
            GasInfo.prototype.gasWanted = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

            /**
             * GasInfo gasUsed.
             * @member {number|Long} gasUsed
             * @memberof cosmos.base.abci.v1beta1.GasInfo
             * @instance
             */
            GasInfo.prototype.gasUsed = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

            /**
             * Creates a new GasInfo instance using the specified properties.
             * @function create
             * @memberof cosmos.base.abci.v1beta1.GasInfo
             * @static
             * @param {cosmos.base.abci.v1beta1.IGasInfo=} [properties] Properties to set
             * @returns {cosmos.base.abci.v1beta1.GasInfo} GasInfo instance
             */
            GasInfo.create = function create(properties) {
              return new GasInfo(properties);
            };

            /**
             * Encodes the specified GasInfo message. Does not implicitly {@link cosmos.base.abci.v1beta1.GasInfo.verify|verify} messages.
             * @function encode
             * @memberof cosmos.base.abci.v1beta1.GasInfo
             * @static
             * @param {cosmos.base.abci.v1beta1.IGasInfo} message GasInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GasInfo.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.gasWanted != null && Object.hasOwnProperty.call(message, "gasWanted"))
                writer.uint32(/* id 1, wireType 0 =*/ 8).uint64(message.gasWanted);
              if (message.gasUsed != null && Object.hasOwnProperty.call(message, "gasUsed"))
                writer.uint32(/* id 2, wireType 0 =*/ 16).uint64(message.gasUsed);
              return writer;
            };

            /**
             * Encodes the specified GasInfo message, length delimited. Does not implicitly {@link cosmos.base.abci.v1beta1.GasInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof cosmos.base.abci.v1beta1.GasInfo
             * @static
             * @param {cosmos.base.abci.v1beta1.IGasInfo} message GasInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GasInfo.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GasInfo message from the specified reader or buffer.
             * @function decode
             * @memberof cosmos.base.abci.v1beta1.GasInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {cosmos.base.abci.v1beta1.GasInfo} GasInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GasInfo.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                message = new $root.cosmos.base.abci.v1beta1.GasInfo();
              while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1:
                    message.gasWanted = reader.uint64();
                    break;
                  case 2:
                    message.gasUsed = reader.uint64();
                    break;
                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }
              return message;
            };

            /**
             * Decodes a GasInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof cosmos.base.abci.v1beta1.GasInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {cosmos.base.abci.v1beta1.GasInfo} GasInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GasInfo.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GasInfo message.
             * @function verify
             * @memberof cosmos.base.abci.v1beta1.GasInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GasInfo.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.gasWanted != null && message.hasOwnProperty("gasWanted"))
                if (
                  !$util.isInteger(message.gasWanted) &&
                  !(
                    message.gasWanted &&
                    $util.isInteger(message.gasWanted.low) &&
                    $util.isInteger(message.gasWanted.high)
                  )
                )
                  return "gasWanted: integer|Long expected";
              if (message.gasUsed != null && message.hasOwnProperty("gasUsed"))
                if (
                  !$util.isInteger(message.gasUsed) &&
                  !(
                    message.gasUsed &&
                    $util.isInteger(message.gasUsed.low) &&
                    $util.isInteger(message.gasUsed.high)
                  )
                )
                  return "gasUsed: integer|Long expected";
              return null;
            };

            /**
             * Creates a GasInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof cosmos.base.abci.v1beta1.GasInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {cosmos.base.abci.v1beta1.GasInfo} GasInfo
             */
            GasInfo.fromObject = function fromObject(object) {
              if (object instanceof $root.cosmos.base.abci.v1beta1.GasInfo) return object;
              var message = new $root.cosmos.base.abci.v1beta1.GasInfo();
              if (object.gasWanted != null)
                if ($util.Long) (message.gasWanted = $util.Long.fromValue(object.gasWanted)).unsigned = true;
                else if (typeof object.gasWanted === "string")
                  message.gasWanted = parseInt(object.gasWanted, 10);
                else if (typeof object.gasWanted === "number") message.gasWanted = object.gasWanted;
                else if (typeof object.gasWanted === "object")
                  message.gasWanted = new $util.LongBits(
                    object.gasWanted.low >>> 0,
                    object.gasWanted.high >>> 0,
                  ).toNumber(true);
              if (object.gasUsed != null)
                if ($util.Long) (message.gasUsed = $util.Long.fromValue(object.gasUsed)).unsigned = true;
                else if (typeof object.gasUsed === "string") message.gasUsed = parseInt(object.gasUsed, 10);
                else if (typeof object.gasUsed === "number") message.gasUsed = object.gasUsed;
                else if (typeof object.gasUsed === "object")
                  message.gasUsed = new $util.LongBits(
                    object.gasUsed.low >>> 0,
                    object.gasUsed.high >>> 0,
                  ).toNumber(true);
              return message;
            };

            /**
             * Creates a plain object from a GasInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof cosmos.base.abci.v1beta1.GasInfo
             * @static
             * @param {cosmos.base.abci.v1beta1.GasInfo} message GasInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GasInfo.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};
              if (options.defaults) {
                if ($util.Long) {
                  var long = new $util.Long(0, 0, true);
                  object.gasWanted =
                    options.longs === String
                      ? long.toString()
                      : options.longs === Number
                      ? long.toNumber()
                      : long;
                } else object.gasWanted = options.longs === String ? "0" : 0;
                if ($util.Long) {
                  var long = new $util.Long(0, 0, true);
                  object.gasUsed =
                    options.longs === String
                      ? long.toString()
                      : options.longs === Number
                      ? long.toNumber()
                      : long;
                } else object.gasUsed = options.longs === String ? "0" : 0;
              }
              if (message.gasWanted != null && message.hasOwnProperty("gasWanted"))
                if (typeof message.gasWanted === "number")
                  object.gasWanted = options.longs === String ? String(message.gasWanted) : message.gasWanted;
                else
                  object.gasWanted =
                    options.longs === String
                      ? $util.Long.prototype.toString.call(message.gasWanted)
                      : options.longs === Number
                      ? new $util.LongBits(
                          message.gasWanted.low >>> 0,
                          message.gasWanted.high >>> 0,
                        ).toNumber(true)
                      : message.gasWanted;
              if (message.gasUsed != null && message.hasOwnProperty("gasUsed"))
                if (typeof message.gasUsed === "number")
                  object.gasUsed = options.longs === String ? String(message.gasUsed) : message.gasUsed;
                else
                  object.gasUsed =
                    options.longs === String
                      ? $util.Long.prototype.toString.call(message.gasUsed)
                      : options.longs === Number
                      ? new $util.LongBits(message.gasUsed.low >>> 0, message.gasUsed.high >>> 0).toNumber(
                          true,
                        )
                      : message.gasUsed;
              return object;
            };

            /**
             * Converts this GasInfo to JSON.
             * @function toJSON
             * @memberof cosmos.base.abci.v1beta1.GasInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GasInfo.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return GasInfo;
          })();

          v1beta1.Result = (function () {
            /**
             * Properties of a Result.
             * @memberof cosmos.base.abci.v1beta1
             * @interface IResult
             * @property {Uint8Array|null} [data] Result data
             * @property {string|null} [log] Result log
             * @property {Array.<tendermint.abci.IEvent>|null} [events] Result events
             */

            /**
             * Constructs a new Result.
             * @memberof cosmos.base.abci.v1beta1
             * @classdesc Represents a Result.
             * @implements IResult
             * @constructor
             * @param {cosmos.base.abci.v1beta1.IResult=} [properties] Properties to set
             */
            function Result(properties) {
              this.events = [];
              if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                  if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
            }

            /**
             * Result data.
             * @member {Uint8Array} data
             * @memberof cosmos.base.abci.v1beta1.Result
             * @instance
             */
            Result.prototype.data = $util.newBuffer([]);

            /**
             * Result log.
             * @member {string} log
             * @memberof cosmos.base.abci.v1beta1.Result
             * @instance
             */
            Result.prototype.log = "";

            /**
             * Result events.
             * @member {Array.<tendermint.abci.IEvent>} events
             * @memberof cosmos.base.abci.v1beta1.Result
             * @instance
             */
            Result.prototype.events = $util.emptyArray;

            /**
             * Creates a new Result instance using the specified properties.
             * @function create
             * @memberof cosmos.base.abci.v1beta1.Result
             * @static
             * @param {cosmos.base.abci.v1beta1.IResult=} [properties] Properties to set
             * @returns {cosmos.base.abci.v1beta1.Result} Result instance
             */
            Result.create = function create(properties) {
              return new Result(properties);
            };

            /**
             * Encodes the specified Result message. Does not implicitly {@link cosmos.base.abci.v1beta1.Result.verify|verify} messages.
             * @function encode
             * @memberof cosmos.base.abci.v1beta1.Result
             * @static
             * @param {cosmos.base.abci.v1beta1.IResult} message Result message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Result.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                writer.uint32(/* id 1, wireType 2 =*/ 10).bytes(message.data);
              if (message.log != null && Object.hasOwnProperty.call(message, "log"))
                writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.log);
              if (message.events != null && message.events.length)
                for (var i = 0; i < message.events.length; ++i)
                  $root.tendermint.abci.Event.encode(
                    message.events[i],
                    writer.uint32(/* id 3, wireType 2 =*/ 26).fork(),
                  ).ldelim();
              return writer;
            };

            /**
             * Encodes the specified Result message, length delimited. Does not implicitly {@link cosmos.base.abci.v1beta1.Result.verify|verify} messages.
             * @function encodeDelimited
             * @memberof cosmos.base.abci.v1beta1.Result
             * @static
             * @param {cosmos.base.abci.v1beta1.IResult} message Result message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Result.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Result message from the specified reader or buffer.
             * @function decode
             * @memberof cosmos.base.abci.v1beta1.Result
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {cosmos.base.abci.v1beta1.Result} Result
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Result.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                message = new $root.cosmos.base.abci.v1beta1.Result();
              while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1:
                    message.data = reader.bytes();
                    break;
                  case 2:
                    message.log = reader.string();
                    break;
                  case 3:
                    if (!(message.events && message.events.length)) message.events = [];
                    message.events.push($root.tendermint.abci.Event.decode(reader, reader.uint32()));
                    break;
                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }
              return message;
            };

            /**
             * Decodes a Result message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof cosmos.base.abci.v1beta1.Result
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {cosmos.base.abci.v1beta1.Result} Result
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Result.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Result message.
             * @function verify
             * @memberof cosmos.base.abci.v1beta1.Result
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Result.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.data != null && message.hasOwnProperty("data"))
                if (
                  !((message.data && typeof message.data.length === "number") || $util.isString(message.data))
                )
                  return "data: buffer expected";
              if (message.log != null && message.hasOwnProperty("log"))
                if (!$util.isString(message.log)) return "log: string expected";
              if (message.events != null && message.hasOwnProperty("events")) {
                if (!Array.isArray(message.events)) return "events: array expected";
                for (var i = 0; i < message.events.length; ++i) {
                  var error = $root.tendermint.abci.Event.verify(message.events[i]);
                  if (error) return "events." + error;
                }
              }
              return null;
            };

            /**
             * Creates a Result message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof cosmos.base.abci.v1beta1.Result
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {cosmos.base.abci.v1beta1.Result} Result
             */
            Result.fromObject = function fromObject(object) {
              if (object instanceof $root.cosmos.base.abci.v1beta1.Result) return object;
              var message = new $root.cosmos.base.abci.v1beta1.Result();
              if (object.data != null)
                if (typeof object.data === "string")
                  $util.base64.decode(
                    object.data,
                    (message.data = $util.newBuffer($util.base64.length(object.data))),
                    0,
                  );
                else if (object.data.length) message.data = object.data;
              if (object.log != null) message.log = String(object.log);
              if (object.events) {
                if (!Array.isArray(object.events))
                  throw TypeError(".cosmos.base.abci.v1beta1.Result.events: array expected");
                message.events = [];
                for (var i = 0; i < object.events.length; ++i) {
                  if (typeof object.events[i] !== "object")
                    throw TypeError(".cosmos.base.abci.v1beta1.Result.events: object expected");
                  message.events[i] = $root.tendermint.abci.Event.fromObject(object.events[i]);
                }
              }
              return message;
            };

            /**
             * Creates a plain object from a Result message. Also converts values to other types if specified.
             * @function toObject
             * @memberof cosmos.base.abci.v1beta1.Result
             * @static
             * @param {cosmos.base.abci.v1beta1.Result} message Result
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Result.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};
              if (options.arrays || options.defaults) object.events = [];
              if (options.defaults) {
                if (options.bytes === String) object.data = "";
                else {
                  object.data = [];
                  if (options.bytes !== Array) object.data = $util.newBuffer(object.data);
                }
                object.log = "";
              }
              if (message.data != null && message.hasOwnProperty("data"))
                object.data =
                  options.bytes === String
                    ? $util.base64.encode(message.data, 0, message.data.length)
                    : options.bytes === Array
                    ? Array.prototype.slice.call(message.data)
                    : message.data;
              if (message.log != null && message.hasOwnProperty("log")) object.log = message.log;
              if (message.events && message.events.length) {
                object.events = [];
                for (var j = 0; j < message.events.length; ++j)
                  object.events[j] = $root.tendermint.abci.Event.toObject(message.events[j], options);
              }
              return object;
            };

            /**
             * Converts this Result to JSON.
             * @function toJSON
             * @memberof cosmos.base.abci.v1beta1.Result
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Result.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Result;
          })();

          v1beta1.SimulationResponse = (function () {
            /**
             * Properties of a SimulationResponse.
             * @memberof cosmos.base.abci.v1beta1
             * @interface ISimulationResponse
             * @property {cosmos.base.abci.v1beta1.IGasInfo|null} [gasInfo] SimulationResponse gasInfo
             * @property {cosmos.base.abci.v1beta1.IResult|null} [result] SimulationResponse result
             */

            /**
             * Constructs a new SimulationResponse.
             * @memberof cosmos.base.abci.v1beta1
             * @classdesc Represents a SimulationResponse.
             * @implements ISimulationResponse
             * @constructor
             * @param {cosmos.base.abci.v1beta1.ISimulationResponse=} [properties] Properties to set
             */
            function SimulationResponse(properties) {
              if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                  if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
            }

            /**
             * SimulationResponse gasInfo.
             * @member {cosmos.base.abci.v1beta1.IGasInfo|null|undefined} gasInfo
             * @memberof cosmos.base.abci.v1beta1.SimulationResponse
             * @instance
             */
            SimulationResponse.prototype.gasInfo = null;

            /**
             * SimulationResponse result.
             * @member {cosmos.base.abci.v1beta1.IResult|null|undefined} result
             * @memberof cosmos.base.abci.v1beta1.SimulationResponse
             * @instance
             */
            SimulationResponse.prototype.result = null;

            /**
             * Creates a new SimulationResponse instance using the specified properties.
             * @function create
             * @memberof cosmos.base.abci.v1beta1.SimulationResponse
             * @static
             * @param {cosmos.base.abci.v1beta1.ISimulationResponse=} [properties] Properties to set
             * @returns {cosmos.base.abci.v1beta1.SimulationResponse} SimulationResponse instance
             */
            SimulationResponse.create = function create(properties) {
              return new SimulationResponse(properties);
            };

            /**
             * Encodes the specified SimulationResponse message. Does not implicitly {@link cosmos.base.abci.v1beta1.SimulationResponse.verify|verify} messages.
             * @function encode
             * @memberof cosmos.base.abci.v1beta1.SimulationResponse
             * @static
             * @param {cosmos.base.abci.v1beta1.ISimulationResponse} message SimulationResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SimulationResponse.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.gasInfo != null && Object.hasOwnProperty.call(message, "gasInfo"))
                $root.cosmos.base.abci.v1beta1.GasInfo.encode(
                  message.gasInfo,
                  writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
                ).ldelim();
              if (message.result != null && Object.hasOwnProperty.call(message, "result"))
                $root.cosmos.base.abci.v1beta1.Result.encode(
                  message.result,
                  writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
                ).ldelim();
              return writer;
            };

            /**
             * Encodes the specified SimulationResponse message, length delimited. Does not implicitly {@link cosmos.base.abci.v1beta1.SimulationResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof cosmos.base.abci.v1beta1.SimulationResponse
             * @static
             * @param {cosmos.base.abci.v1beta1.ISimulationResponse} message SimulationResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SimulationResponse.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SimulationResponse message from the specified reader or buffer.
             * @function decode
             * @memberof cosmos.base.abci.v1beta1.SimulationResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {cosmos.base.abci.v1beta1.SimulationResponse} SimulationResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SimulationResponse.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                message = new $root.cosmos.base.abci.v1beta1.SimulationResponse();
              while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1:
                    message.gasInfo = $root.cosmos.base.abci.v1beta1.GasInfo.decode(reader, reader.uint32());
                    break;
                  case 2:
                    message.result = $root.cosmos.base.abci.v1beta1.Result.decode(reader, reader.uint32());
                    break;
                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }
              return message;
            };

            /**
             * Decodes a SimulationResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof cosmos.base.abci.v1beta1.SimulationResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {cosmos.base.abci.v1beta1.SimulationResponse} SimulationResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SimulationResponse.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SimulationResponse message.
             * @function verify
             * @memberof cosmos.base.abci.v1beta1.SimulationResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SimulationResponse.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.gasInfo != null && message.hasOwnProperty("gasInfo")) {
                var error = $root.cosmos.base.abci.v1beta1.GasInfo.verify(message.gasInfo);
                if (error) return "gasInfo." + error;
              }
              if (message.result != null && message.hasOwnProperty("result")) {
                var error = $root.cosmos.base.abci.v1beta1.Result.verify(message.result);
                if (error) return "result." + error;
              }
              return null;
            };

            /**
             * Creates a SimulationResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof cosmos.base.abci.v1beta1.SimulationResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {cosmos.base.abci.v1beta1.SimulationResponse} SimulationResponse
             */
            SimulationResponse.fromObject = function fromObject(object) {
              if (object instanceof $root.cosmos.base.abci.v1beta1.SimulationResponse) return object;
              var message = new $root.cosmos.base.abci.v1beta1.SimulationResponse();
              if (object.gasInfo != null) {
                if (typeof object.gasInfo !== "object")
                  throw TypeError(".cosmos.base.abci.v1beta1.SimulationResponse.gasInfo: object expected");
                message.gasInfo = $root.cosmos.base.abci.v1beta1.GasInfo.fromObject(object.gasInfo);
              }
              if (object.result != null) {
                if (typeof object.result !== "object")
                  throw TypeError(".cosmos.base.abci.v1beta1.SimulationResponse.result: object expected");
                message.result = $root.cosmos.base.abci.v1beta1.Result.fromObject(object.result);
              }
              return message;
            };

            /**
             * Creates a plain object from a SimulationResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof cosmos.base.abci.v1beta1.SimulationResponse
             * @static
             * @param {cosmos.base.abci.v1beta1.SimulationResponse} message SimulationResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SimulationResponse.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};
              if (options.defaults) {
                object.gasInfo = null;
                object.result = null;
              }
              if (message.gasInfo != null && message.hasOwnProperty("gasInfo"))
                object.gasInfo = $root.cosmos.base.abci.v1beta1.GasInfo.toObject(message.gasInfo, options);
              if (message.result != null && message.hasOwnProperty("result"))
                object.result = $root.cosmos.base.abci.v1beta1.Result.toObject(message.result, options);
              return object;
            };

            /**
             * Converts this SimulationResponse to JSON.
             * @function toJSON
             * @memberof cosmos.base.abci.v1beta1.SimulationResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SimulationResponse.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return SimulationResponse;
          })();

          v1beta1.MsgData = (function () {
            /**
             * Properties of a MsgData.
             * @memberof cosmos.base.abci.v1beta1
             * @interface IMsgData
             * @property {string|null} [msgType] MsgData msgType
             * @property {Uint8Array|null} [data] MsgData data
             */

            /**
             * Constructs a new MsgData.
             * @memberof cosmos.base.abci.v1beta1
             * @classdesc Represents a MsgData.
             * @implements IMsgData
             * @constructor
             * @param {cosmos.base.abci.v1beta1.IMsgData=} [properties] Properties to set
             */
            function MsgData(properties) {
              if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                  if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
            }

            /**
             * MsgData msgType.
             * @member {string} msgType
             * @memberof cosmos.base.abci.v1beta1.MsgData
             * @instance
             */
            MsgData.prototype.msgType = "";

            /**
             * MsgData data.
             * @member {Uint8Array} data
             * @memberof cosmos.base.abci.v1beta1.MsgData
             * @instance
             */
            MsgData.prototype.data = $util.newBuffer([]);

            /**
             * Creates a new MsgData instance using the specified properties.
             * @function create
             * @memberof cosmos.base.abci.v1beta1.MsgData
             * @static
             * @param {cosmos.base.abci.v1beta1.IMsgData=} [properties] Properties to set
             * @returns {cosmos.base.abci.v1beta1.MsgData} MsgData instance
             */
            MsgData.create = function create(properties) {
              return new MsgData(properties);
            };

            /**
             * Encodes the specified MsgData message. Does not implicitly {@link cosmos.base.abci.v1beta1.MsgData.verify|verify} messages.
             * @function encode
             * @memberof cosmos.base.abci.v1beta1.MsgData
             * @static
             * @param {cosmos.base.abci.v1beta1.IMsgData} message MsgData message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MsgData.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.msgType != null && Object.hasOwnProperty.call(message, "msgType"))
                writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.msgType);
              if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                writer.uint32(/* id 2, wireType 2 =*/ 18).bytes(message.data);
              return writer;
            };

            /**
             * Encodes the specified MsgData message, length delimited. Does not implicitly {@link cosmos.base.abci.v1beta1.MsgData.verify|verify} messages.
             * @function encodeDelimited
             * @memberof cosmos.base.abci.v1beta1.MsgData
             * @static
             * @param {cosmos.base.abci.v1beta1.IMsgData} message MsgData message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MsgData.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MsgData message from the specified reader or buffer.
             * @function decode
             * @memberof cosmos.base.abci.v1beta1.MsgData
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {cosmos.base.abci.v1beta1.MsgData} MsgData
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MsgData.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                message = new $root.cosmos.base.abci.v1beta1.MsgData();
              while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1:
                    message.msgType = reader.string();
                    break;
                  case 2:
                    message.data = reader.bytes();
                    break;
                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }
              return message;
            };

            /**
             * Decodes a MsgData message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof cosmos.base.abci.v1beta1.MsgData
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {cosmos.base.abci.v1beta1.MsgData} MsgData
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MsgData.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MsgData message.
             * @function verify
             * @memberof cosmos.base.abci.v1beta1.MsgData
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MsgData.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.msgType != null && message.hasOwnProperty("msgType"))
                if (!$util.isString(message.msgType)) return "msgType: string expected";
              if (message.data != null && message.hasOwnProperty("data"))
                if (
                  !((message.data && typeof message.data.length === "number") || $util.isString(message.data))
                )
                  return "data: buffer expected";
              return null;
            };

            /**
             * Creates a MsgData message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof cosmos.base.abci.v1beta1.MsgData
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {cosmos.base.abci.v1beta1.MsgData} MsgData
             */
            MsgData.fromObject = function fromObject(object) {
              if (object instanceof $root.cosmos.base.abci.v1beta1.MsgData) return object;
              var message = new $root.cosmos.base.abci.v1beta1.MsgData();
              if (object.msgType != null) message.msgType = String(object.msgType);
              if (object.data != null)
                if (typeof object.data === "string")
                  $util.base64.decode(
                    object.data,
                    (message.data = $util.newBuffer($util.base64.length(object.data))),
                    0,
                  );
                else if (object.data.length) message.data = object.data;
              return message;
            };

            /**
             * Creates a plain object from a MsgData message. Also converts values to other types if specified.
             * @function toObject
             * @memberof cosmos.base.abci.v1beta1.MsgData
             * @static
             * @param {cosmos.base.abci.v1beta1.MsgData} message MsgData
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MsgData.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};
              if (options.defaults) {
                object.msgType = "";
                if (options.bytes === String) object.data = "";
                else {
                  object.data = [];
                  if (options.bytes !== Array) object.data = $util.newBuffer(object.data);
                }
              }
              if (message.msgType != null && message.hasOwnProperty("msgType"))
                object.msgType = message.msgType;
              if (message.data != null && message.hasOwnProperty("data"))
                object.data =
                  options.bytes === String
                    ? $util.base64.encode(message.data, 0, message.data.length)
                    : options.bytes === Array
                    ? Array.prototype.slice.call(message.data)
                    : message.data;
              return object;
            };

            /**
             * Converts this MsgData to JSON.
             * @function toJSON
             * @memberof cosmos.base.abci.v1beta1.MsgData
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MsgData.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MsgData;
          })();

          v1beta1.TxMsgData = (function () {
            /**
             * Properties of a TxMsgData.
             * @memberof cosmos.base.abci.v1beta1
             * @interface ITxMsgData
             * @property {Array.<cosmos.base.abci.v1beta1.IMsgData>|null} [data] TxMsgData data
             */

            /**
             * Constructs a new TxMsgData.
             * @memberof cosmos.base.abci.v1beta1
             * @classdesc Represents a TxMsgData.
             * @implements ITxMsgData
             * @constructor
             * @param {cosmos.base.abci.v1beta1.ITxMsgData=} [properties] Properties to set
             */
            function TxMsgData(properties) {
              this.data = [];
              if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                  if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
            }

            /**
             * TxMsgData data.
             * @member {Array.<cosmos.base.abci.v1beta1.IMsgData>} data
             * @memberof cosmos.base.abci.v1beta1.TxMsgData
             * @instance
             */
            TxMsgData.prototype.data = $util.emptyArray;

            /**
             * Creates a new TxMsgData instance using the specified properties.
             * @function create
             * @memberof cosmos.base.abci.v1beta1.TxMsgData
             * @static
             * @param {cosmos.base.abci.v1beta1.ITxMsgData=} [properties] Properties to set
             * @returns {cosmos.base.abci.v1beta1.TxMsgData} TxMsgData instance
             */
            TxMsgData.create = function create(properties) {
              return new TxMsgData(properties);
            };

            /**
             * Encodes the specified TxMsgData message. Does not implicitly {@link cosmos.base.abci.v1beta1.TxMsgData.verify|verify} messages.
             * @function encode
             * @memberof cosmos.base.abci.v1beta1.TxMsgData
             * @static
             * @param {cosmos.base.abci.v1beta1.ITxMsgData} message TxMsgData message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TxMsgData.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.data != null && message.data.length)
                for (var i = 0; i < message.data.length; ++i)
                  $root.cosmos.base.abci.v1beta1.MsgData.encode(
                    message.data[i],
                    writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
                  ).ldelim();
              return writer;
            };

            /**
             * Encodes the specified TxMsgData message, length delimited. Does not implicitly {@link cosmos.base.abci.v1beta1.TxMsgData.verify|verify} messages.
             * @function encodeDelimited
             * @memberof cosmos.base.abci.v1beta1.TxMsgData
             * @static
             * @param {cosmos.base.abci.v1beta1.ITxMsgData} message TxMsgData message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TxMsgData.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a TxMsgData message from the specified reader or buffer.
             * @function decode
             * @memberof cosmos.base.abci.v1beta1.TxMsgData
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {cosmos.base.abci.v1beta1.TxMsgData} TxMsgData
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TxMsgData.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                message = new $root.cosmos.base.abci.v1beta1.TxMsgData();
              while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1:
                    if (!(message.data && message.data.length)) message.data = [];
                    message.data.push($root.cosmos.base.abci.v1beta1.MsgData.decode(reader, reader.uint32()));
                    break;
                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }
              return message;
            };

            /**
             * Decodes a TxMsgData message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof cosmos.base.abci.v1beta1.TxMsgData
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {cosmos.base.abci.v1beta1.TxMsgData} TxMsgData
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TxMsgData.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a TxMsgData message.
             * @function verify
             * @memberof cosmos.base.abci.v1beta1.TxMsgData
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TxMsgData.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.data != null && message.hasOwnProperty("data")) {
                if (!Array.isArray(message.data)) return "data: array expected";
                for (var i = 0; i < message.data.length; ++i) {
                  var error = $root.cosmos.base.abci.v1beta1.MsgData.verify(message.data[i]);
                  if (error) return "data." + error;
                }
              }
              return null;
            };

            /**
             * Creates a TxMsgData message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof cosmos.base.abci.v1beta1.TxMsgData
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {cosmos.base.abci.v1beta1.TxMsgData} TxMsgData
             */
            TxMsgData.fromObject = function fromObject(object) {
              if (object instanceof $root.cosmos.base.abci.v1beta1.TxMsgData) return object;
              var message = new $root.cosmos.base.abci.v1beta1.TxMsgData();
              if (object.data) {
                if (!Array.isArray(object.data))
                  throw TypeError(".cosmos.base.abci.v1beta1.TxMsgData.data: array expected");
                message.data = [];
                for (var i = 0; i < object.data.length; ++i) {
                  if (typeof object.data[i] !== "object")
                    throw TypeError(".cosmos.base.abci.v1beta1.TxMsgData.data: object expected");
                  message.data[i] = $root.cosmos.base.abci.v1beta1.MsgData.fromObject(object.data[i]);
                }
              }
              return message;
            };

            /**
             * Creates a plain object from a TxMsgData message. Also converts values to other types if specified.
             * @function toObject
             * @memberof cosmos.base.abci.v1beta1.TxMsgData
             * @static
             * @param {cosmos.base.abci.v1beta1.TxMsgData} message TxMsgData
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TxMsgData.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};
              if (options.arrays || options.defaults) object.data = [];
              if (message.data && message.data.length) {
                object.data = [];
                for (var j = 0; j < message.data.length; ++j)
                  object.data[j] = $root.cosmos.base.abci.v1beta1.MsgData.toObject(message.data[j], options);
              }
              return object;
            };

            /**
             * Converts this TxMsgData to JSON.
             * @function toJSON
             * @memberof cosmos.base.abci.v1beta1.TxMsgData
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TxMsgData.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return TxMsgData;
          })();

          v1beta1.SearchTxsResult = (function () {
            /**
             * Properties of a SearchTxsResult.
             * @memberof cosmos.base.abci.v1beta1
             * @interface ISearchTxsResult
             * @property {number|Long|null} [totalCount] SearchTxsResult totalCount
             * @property {number|Long|null} [count] SearchTxsResult count
             * @property {number|Long|null} [pageNumber] SearchTxsResult pageNumber
             * @property {number|Long|null} [pageTotal] SearchTxsResult pageTotal
             * @property {number|Long|null} [limit] SearchTxsResult limit
             * @property {Array.<cosmos.base.abci.v1beta1.ITxResponse>|null} [txs] SearchTxsResult txs
             */

            /**
             * Constructs a new SearchTxsResult.
             * @memberof cosmos.base.abci.v1beta1
             * @classdesc Represents a SearchTxsResult.
             * @implements ISearchTxsResult
             * @constructor
             * @param {cosmos.base.abci.v1beta1.ISearchTxsResult=} [properties] Properties to set
             */
            function SearchTxsResult(properties) {
              this.txs = [];
              if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                  if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
            }

            /**
             * SearchTxsResult totalCount.
             * @member {number|Long} totalCount
             * @memberof cosmos.base.abci.v1beta1.SearchTxsResult
             * @instance
             */
            SearchTxsResult.prototype.totalCount = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

            /**
             * SearchTxsResult count.
             * @member {number|Long} count
             * @memberof cosmos.base.abci.v1beta1.SearchTxsResult
             * @instance
             */
            SearchTxsResult.prototype.count = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

            /**
             * SearchTxsResult pageNumber.
             * @member {number|Long} pageNumber
             * @memberof cosmos.base.abci.v1beta1.SearchTxsResult
             * @instance
             */
            SearchTxsResult.prototype.pageNumber = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

            /**
             * SearchTxsResult pageTotal.
             * @member {number|Long} pageTotal
             * @memberof cosmos.base.abci.v1beta1.SearchTxsResult
             * @instance
             */
            SearchTxsResult.prototype.pageTotal = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

            /**
             * SearchTxsResult limit.
             * @member {number|Long} limit
             * @memberof cosmos.base.abci.v1beta1.SearchTxsResult
             * @instance
             */
            SearchTxsResult.prototype.limit = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

            /**
             * SearchTxsResult txs.
             * @member {Array.<cosmos.base.abci.v1beta1.ITxResponse>} txs
             * @memberof cosmos.base.abci.v1beta1.SearchTxsResult
             * @instance
             */
            SearchTxsResult.prototype.txs = $util.emptyArray;

            /**
             * Creates a new SearchTxsResult instance using the specified properties.
             * @function create
             * @memberof cosmos.base.abci.v1beta1.SearchTxsResult
             * @static
             * @param {cosmos.base.abci.v1beta1.ISearchTxsResult=} [properties] Properties to set
             * @returns {cosmos.base.abci.v1beta1.SearchTxsResult} SearchTxsResult instance
             */
            SearchTxsResult.create = function create(properties) {
              return new SearchTxsResult(properties);
            };

            /**
             * Encodes the specified SearchTxsResult message. Does not implicitly {@link cosmos.base.abci.v1beta1.SearchTxsResult.verify|verify} messages.
             * @function encode
             * @memberof cosmos.base.abci.v1beta1.SearchTxsResult
             * @static
             * @param {cosmos.base.abci.v1beta1.ISearchTxsResult} message SearchTxsResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SearchTxsResult.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.totalCount != null && Object.hasOwnProperty.call(message, "totalCount"))
                writer.uint32(/* id 1, wireType 0 =*/ 8).uint64(message.totalCount);
              if (message.count != null && Object.hasOwnProperty.call(message, "count"))
                writer.uint32(/* id 2, wireType 0 =*/ 16).uint64(message.count);
              if (message.pageNumber != null && Object.hasOwnProperty.call(message, "pageNumber"))
                writer.uint32(/* id 3, wireType 0 =*/ 24).uint64(message.pageNumber);
              if (message.pageTotal != null && Object.hasOwnProperty.call(message, "pageTotal"))
                writer.uint32(/* id 4, wireType 0 =*/ 32).uint64(message.pageTotal);
              if (message.limit != null && Object.hasOwnProperty.call(message, "limit"))
                writer.uint32(/* id 5, wireType 0 =*/ 40).uint64(message.limit);
              if (message.txs != null && message.txs.length)
                for (var i = 0; i < message.txs.length; ++i)
                  $root.cosmos.base.abci.v1beta1.TxResponse.encode(
                    message.txs[i],
                    writer.uint32(/* id 6, wireType 2 =*/ 50).fork(),
                  ).ldelim();
              return writer;
            };

            /**
             * Encodes the specified SearchTxsResult message, length delimited. Does not implicitly {@link cosmos.base.abci.v1beta1.SearchTxsResult.verify|verify} messages.
             * @function encodeDelimited
             * @memberof cosmos.base.abci.v1beta1.SearchTxsResult
             * @static
             * @param {cosmos.base.abci.v1beta1.ISearchTxsResult} message SearchTxsResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SearchTxsResult.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SearchTxsResult message from the specified reader or buffer.
             * @function decode
             * @memberof cosmos.base.abci.v1beta1.SearchTxsResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {cosmos.base.abci.v1beta1.SearchTxsResult} SearchTxsResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SearchTxsResult.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                message = new $root.cosmos.base.abci.v1beta1.SearchTxsResult();
              while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1:
                    message.totalCount = reader.uint64();
                    break;
                  case 2:
                    message.count = reader.uint64();
                    break;
                  case 3:
                    message.pageNumber = reader.uint64();
                    break;
                  case 4:
                    message.pageTotal = reader.uint64();
                    break;
                  case 5:
                    message.limit = reader.uint64();
                    break;
                  case 6:
                    if (!(message.txs && message.txs.length)) message.txs = [];
                    message.txs.push(
                      $root.cosmos.base.abci.v1beta1.TxResponse.decode(reader, reader.uint32()),
                    );
                    break;
                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }
              return message;
            };

            /**
             * Decodes a SearchTxsResult message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof cosmos.base.abci.v1beta1.SearchTxsResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {cosmos.base.abci.v1beta1.SearchTxsResult} SearchTxsResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SearchTxsResult.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SearchTxsResult message.
             * @function verify
             * @memberof cosmos.base.abci.v1beta1.SearchTxsResult
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SearchTxsResult.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.totalCount != null && message.hasOwnProperty("totalCount"))
                if (
                  !$util.isInteger(message.totalCount) &&
                  !(
                    message.totalCount &&
                    $util.isInteger(message.totalCount.low) &&
                    $util.isInteger(message.totalCount.high)
                  )
                )
                  return "totalCount: integer|Long expected";
              if (message.count != null && message.hasOwnProperty("count"))
                if (
                  !$util.isInteger(message.count) &&
                  !(
                    message.count &&
                    $util.isInteger(message.count.low) &&
                    $util.isInteger(message.count.high)
                  )
                )
                  return "count: integer|Long expected";
              if (message.pageNumber != null && message.hasOwnProperty("pageNumber"))
                if (
                  !$util.isInteger(message.pageNumber) &&
                  !(
                    message.pageNumber &&
                    $util.isInteger(message.pageNumber.low) &&
                    $util.isInteger(message.pageNumber.high)
                  )
                )
                  return "pageNumber: integer|Long expected";
              if (message.pageTotal != null && message.hasOwnProperty("pageTotal"))
                if (
                  !$util.isInteger(message.pageTotal) &&
                  !(
                    message.pageTotal &&
                    $util.isInteger(message.pageTotal.low) &&
                    $util.isInteger(message.pageTotal.high)
                  )
                )
                  return "pageTotal: integer|Long expected";
              if (message.limit != null && message.hasOwnProperty("limit"))
                if (
                  !$util.isInteger(message.limit) &&
                  !(
                    message.limit &&
                    $util.isInteger(message.limit.low) &&
                    $util.isInteger(message.limit.high)
                  )
                )
                  return "limit: integer|Long expected";
              if (message.txs != null && message.hasOwnProperty("txs")) {
                if (!Array.isArray(message.txs)) return "txs: array expected";
                for (var i = 0; i < message.txs.length; ++i) {
                  var error = $root.cosmos.base.abci.v1beta1.TxResponse.verify(message.txs[i]);
                  if (error) return "txs." + error;
                }
              }
              return null;
            };

            /**
             * Creates a SearchTxsResult message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof cosmos.base.abci.v1beta1.SearchTxsResult
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {cosmos.base.abci.v1beta1.SearchTxsResult} SearchTxsResult
             */
            SearchTxsResult.fromObject = function fromObject(object) {
              if (object instanceof $root.cosmos.base.abci.v1beta1.SearchTxsResult) return object;
              var message = new $root.cosmos.base.abci.v1beta1.SearchTxsResult();
              if (object.totalCount != null)
                if ($util.Long)
                  (message.totalCount = $util.Long.fromValue(object.totalCount)).unsigned = true;
                else if (typeof object.totalCount === "string")
                  message.totalCount = parseInt(object.totalCount, 10);
                else if (typeof object.totalCount === "number") message.totalCount = object.totalCount;
                else if (typeof object.totalCount === "object")
                  message.totalCount = new $util.LongBits(
                    object.totalCount.low >>> 0,
                    object.totalCount.high >>> 0,
                  ).toNumber(true);
              if (object.count != null)
                if ($util.Long) (message.count = $util.Long.fromValue(object.count)).unsigned = true;
                else if (typeof object.count === "string") message.count = parseInt(object.count, 10);
                else if (typeof object.count === "number") message.count = object.count;
                else if (typeof object.count === "object")
                  message.count = new $util.LongBits(
                    object.count.low >>> 0,
                    object.count.high >>> 0,
                  ).toNumber(true);
              if (object.pageNumber != null)
                if ($util.Long)
                  (message.pageNumber = $util.Long.fromValue(object.pageNumber)).unsigned = true;
                else if (typeof object.pageNumber === "string")
                  message.pageNumber = parseInt(object.pageNumber, 10);
                else if (typeof object.pageNumber === "number") message.pageNumber = object.pageNumber;
                else if (typeof object.pageNumber === "object")
                  message.pageNumber = new $util.LongBits(
                    object.pageNumber.low >>> 0,
                    object.pageNumber.high >>> 0,
                  ).toNumber(true);
              if (object.pageTotal != null)
                if ($util.Long) (message.pageTotal = $util.Long.fromValue(object.pageTotal)).unsigned = true;
                else if (typeof object.pageTotal === "string")
                  message.pageTotal = parseInt(object.pageTotal, 10);
                else if (typeof object.pageTotal === "number") message.pageTotal = object.pageTotal;
                else if (typeof object.pageTotal === "object")
                  message.pageTotal = new $util.LongBits(
                    object.pageTotal.low >>> 0,
                    object.pageTotal.high >>> 0,
                  ).toNumber(true);
              if (object.limit != null)
                if ($util.Long) (message.limit = $util.Long.fromValue(object.limit)).unsigned = true;
                else if (typeof object.limit === "string") message.limit = parseInt(object.limit, 10);
                else if (typeof object.limit === "number") message.limit = object.limit;
                else if (typeof object.limit === "object")
                  message.limit = new $util.LongBits(
                    object.limit.low >>> 0,
                    object.limit.high >>> 0,
                  ).toNumber(true);
              if (object.txs) {
                if (!Array.isArray(object.txs))
                  throw TypeError(".cosmos.base.abci.v1beta1.SearchTxsResult.txs: array expected");
                message.txs = [];
                for (var i = 0; i < object.txs.length; ++i) {
                  if (typeof object.txs[i] !== "object")
                    throw TypeError(".cosmos.base.abci.v1beta1.SearchTxsResult.txs: object expected");
                  message.txs[i] = $root.cosmos.base.abci.v1beta1.TxResponse.fromObject(object.txs[i]);
                }
              }
              return message;
            };

            /**
             * Creates a plain object from a SearchTxsResult message. Also converts values to other types if specified.
             * @function toObject
             * @memberof cosmos.base.abci.v1beta1.SearchTxsResult
             * @static
             * @param {cosmos.base.abci.v1beta1.SearchTxsResult} message SearchTxsResult
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SearchTxsResult.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};
              if (options.arrays || options.defaults) object.txs = [];
              if (options.defaults) {
                if ($util.Long) {
                  var long = new $util.Long(0, 0, true);
                  object.totalCount =
                    options.longs === String
                      ? long.toString()
                      : options.longs === Number
                      ? long.toNumber()
                      : long;
                } else object.totalCount = options.longs === String ? "0" : 0;
                if ($util.Long) {
                  var long = new $util.Long(0, 0, true);
                  object.count =
                    options.longs === String
                      ? long.toString()
                      : options.longs === Number
                      ? long.toNumber()
                      : long;
                } else object.count = options.longs === String ? "0" : 0;
                if ($util.Long) {
                  var long = new $util.Long(0, 0, true);
                  object.pageNumber =
                    options.longs === String
                      ? long.toString()
                      : options.longs === Number
                      ? long.toNumber()
                      : long;
                } else object.pageNumber = options.longs === String ? "0" : 0;
                if ($util.Long) {
                  var long = new $util.Long(0, 0, true);
                  object.pageTotal =
                    options.longs === String
                      ? long.toString()
                      : options.longs === Number
                      ? long.toNumber()
                      : long;
                } else object.pageTotal = options.longs === String ? "0" : 0;
                if ($util.Long) {
                  var long = new $util.Long(0, 0, true);
                  object.limit =
                    options.longs === String
                      ? long.toString()
                      : options.longs === Number
                      ? long.toNumber()
                      : long;
                } else object.limit = options.longs === String ? "0" : 0;
              }
              if (message.totalCount != null && message.hasOwnProperty("totalCount"))
                if (typeof message.totalCount === "number")
                  object.totalCount =
                    options.longs === String ? String(message.totalCount) : message.totalCount;
                else
                  object.totalCount =
                    options.longs === String
                      ? $util.Long.prototype.toString.call(message.totalCount)
                      : options.longs === Number
                      ? new $util.LongBits(
                          message.totalCount.low >>> 0,
                          message.totalCount.high >>> 0,
                        ).toNumber(true)
                      : message.totalCount;
              if (message.count != null && message.hasOwnProperty("count"))
                if (typeof message.count === "number")
                  object.count = options.longs === String ? String(message.count) : message.count;
                else
                  object.count =
                    options.longs === String
                      ? $util.Long.prototype.toString.call(message.count)
                      : options.longs === Number
                      ? new $util.LongBits(message.count.low >>> 0, message.count.high >>> 0).toNumber(true)
                      : message.count;
              if (message.pageNumber != null && message.hasOwnProperty("pageNumber"))
                if (typeof message.pageNumber === "number")
                  object.pageNumber =
                    options.longs === String ? String(message.pageNumber) : message.pageNumber;
                else
                  object.pageNumber =
                    options.longs === String
                      ? $util.Long.prototype.toString.call(message.pageNumber)
                      : options.longs === Number
                      ? new $util.LongBits(
                          message.pageNumber.low >>> 0,
                          message.pageNumber.high >>> 0,
                        ).toNumber(true)
                      : message.pageNumber;
              if (message.pageTotal != null && message.hasOwnProperty("pageTotal"))
                if (typeof message.pageTotal === "number")
                  object.pageTotal = options.longs === String ? String(message.pageTotal) : message.pageTotal;
                else
                  object.pageTotal =
                    options.longs === String
                      ? $util.Long.prototype.toString.call(message.pageTotal)
                      : options.longs === Number
                      ? new $util.LongBits(
                          message.pageTotal.low >>> 0,
                          message.pageTotal.high >>> 0,
                        ).toNumber(true)
                      : message.pageTotal;
              if (message.limit != null && message.hasOwnProperty("limit"))
                if (typeof message.limit === "number")
                  object.limit = options.longs === String ? String(message.limit) : message.limit;
                else
                  object.limit =
                    options.longs === String
                      ? $util.Long.prototype.toString.call(message.limit)
                      : options.longs === Number
                      ? new $util.LongBits(message.limit.low >>> 0, message.limit.high >>> 0).toNumber(true)
                      : message.limit;
              if (message.txs && message.txs.length) {
                object.txs = [];
                for (var j = 0; j < message.txs.length; ++j)
                  object.txs[j] = $root.cosmos.base.abci.v1beta1.TxResponse.toObject(message.txs[j], options);
              }
              return object;
            };

            /**
             * Converts this SearchTxsResult to JSON.
             * @function toJSON
             * @memberof cosmos.base.abci.v1beta1.SearchTxsResult
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SearchTxsResult.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return SearchTxsResult;
          })();

          return v1beta1;
        })();

        return abci;
      })();

      return base;
    })();

    return cosmos;
  })();

  $root.gogoproto = (function () {
    /**
     * Namespace gogoproto.
     * @exports gogoproto
     * @namespace
     */
    var gogoproto = {};

    return gogoproto;
  })();

  $root.google = (function () {
    /**
     * Namespace google.
     * @exports google
     * @namespace
     */
    var google = {};

    google.protobuf = (function () {
      /**
       * Namespace protobuf.
       * @memberof google
       * @namespace
       */
      var protobuf = {};

      protobuf.Any = (function () {
        /**
         * Properties of an Any.
         * @memberof google.protobuf
         * @interface IAny
         * @property {string|null} [type_url] Any type_url
         * @property {Uint8Array|null} [value] Any value
         */

        /**
         * Constructs a new Any.
         * @memberof google.protobuf
         * @classdesc Represents an Any.
         * @implements IAny
         * @constructor
         * @param {google.protobuf.IAny=} [properties] Properties to set
         */
        function Any(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * Any type_url.
         * @member {string} type_url
         * @memberof google.protobuf.Any
         * @instance
         */
        Any.prototype.type_url = "";

        /**
         * Any value.
         * @member {Uint8Array} value
         * @memberof google.protobuf.Any
         * @instance
         */
        Any.prototype.value = $util.newBuffer([]);

        /**
         * Creates a new Any instance using the specified properties.
         * @function create
         * @memberof google.protobuf.Any
         * @static
         * @param {google.protobuf.IAny=} [properties] Properties to set
         * @returns {google.protobuf.Any} Any instance
         */
        Any.create = function create(properties) {
          return new Any(properties);
        };

        /**
         * Encodes the specified Any message. Does not implicitly {@link google.protobuf.Any.verify|verify} messages.
         * @function encode
         * @memberof google.protobuf.Any
         * @static
         * @param {google.protobuf.IAny} message Any message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Any.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.type_url != null && Object.hasOwnProperty.call(message, "type_url"))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.type_url);
          if (message.value != null && Object.hasOwnProperty.call(message, "value"))
            writer.uint32(/* id 2, wireType 2 =*/ 18).bytes(message.value);
          return writer;
        };

        /**
         * Encodes the specified Any message, length delimited. Does not implicitly {@link google.protobuf.Any.verify|verify} messages.
         * @function encodeDelimited
         * @memberof google.protobuf.Any
         * @static
         * @param {google.protobuf.IAny} message Any message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Any.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Any message from the specified reader or buffer.
         * @function decode
         * @memberof google.protobuf.Any
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {google.protobuf.Any} Any
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Any.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.google.protobuf.Any();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.type_url = reader.string();
                break;
              case 2:
                message.value = reader.bytes();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes an Any message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof google.protobuf.Any
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {google.protobuf.Any} Any
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Any.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Any message.
         * @function verify
         * @memberof google.protobuf.Any
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Any.verify = function verify(message) {
          if (typeof message !== "object" || message === null) return "object expected";
          if (message.type_url != null && message.hasOwnProperty("type_url"))
            if (!$util.isString(message.type_url)) return "type_url: string expected";
          if (message.value != null && message.hasOwnProperty("value"))
            if (
              !((message.value && typeof message.value.length === "number") || $util.isString(message.value))
            )
              return "value: buffer expected";
          return null;
        };

        /**
         * Creates an Any message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof google.protobuf.Any
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {google.protobuf.Any} Any
         */
        Any.fromObject = function fromObject(object) {
          if (object instanceof $root.google.protobuf.Any) return object;
          var message = new $root.google.protobuf.Any();
          if (object.type_url != null) message.type_url = String(object.type_url);
          if (object.value != null)
            if (typeof object.value === "string")
              $util.base64.decode(
                object.value,
                (message.value = $util.newBuffer($util.base64.length(object.value))),
                0,
              );
            else if (object.value.length) message.value = object.value;
          return message;
        };

        /**
         * Creates a plain object from an Any message. Also converts values to other types if specified.
         * @function toObject
         * @memberof google.protobuf.Any
         * @static
         * @param {google.protobuf.Any} message Any
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Any.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.type_url = "";
            if (options.bytes === String) object.value = "";
            else {
              object.value = [];
              if (options.bytes !== Array) object.value = $util.newBuffer(object.value);
            }
          }
          if (message.type_url != null && message.hasOwnProperty("type_url"))
            object.type_url = message.type_url;
          if (message.value != null && message.hasOwnProperty("value"))
            object.value =
              options.bytes === String
                ? $util.base64.encode(message.value, 0, message.value.length)
                : options.bytes === Array
                ? Array.prototype.slice.call(message.value)
                : message.value;
          return object;
        };

        /**
         * Converts this Any to JSON.
         * @function toJSON
         * @memberof google.protobuf.Any
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Any.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Any;
      })();

      protobuf.FileDescriptorSet = (function () {
        /**
         * Properties of a FileDescriptorSet.
         * @memberof google.protobuf
         * @interface IFileDescriptorSet
         * @property {Array.<google.protobuf.IFileDescriptorProto>|null} [file] FileDescriptorSet file
         */

        /**
         * Constructs a new FileDescriptorSet.
         * @memberof google.protobuf
         * @classdesc Represents a FileDescriptorSet.
         * @implements IFileDescriptorSet
         * @constructor
         * @param {google.protobuf.IFileDescriptorSet=} [properties] Properties to set
         */
        function FileDescriptorSet(properties) {
          this.file = [];
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * FileDescriptorSet file.
         * @member {Array.<google.protobuf.IFileDescriptorProto>} file
         * @memberof google.protobuf.FileDescriptorSet
         * @instance
         */
        FileDescriptorSet.prototype.file = $util.emptyArray;

        /**
         * Creates a new FileDescriptorSet instance using the specified properties.
         * @function create
         * @memberof google.protobuf.FileDescriptorSet
         * @static
         * @param {google.protobuf.IFileDescriptorSet=} [properties] Properties to set
         * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet instance
         */
        FileDescriptorSet.create = function create(properties) {
          return new FileDescriptorSet(properties);
        };

        /**
         * Encodes the specified FileDescriptorSet message. Does not implicitly {@link google.protobuf.FileDescriptorSet.verify|verify} messages.
         * @function encode
         * @memberof google.protobuf.FileDescriptorSet
         * @static
         * @param {google.protobuf.IFileDescriptorSet} message FileDescriptorSet message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FileDescriptorSet.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.file != null && message.file.length)
            for (var i = 0; i < message.file.length; ++i)
              $root.google.protobuf.FileDescriptorProto.encode(
                message.file[i],
                writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
              ).ldelim();
          return writer;
        };

        /**
         * Encodes the specified FileDescriptorSet message, length delimited. Does not implicitly {@link google.protobuf.FileDescriptorSet.verify|verify} messages.
         * @function encodeDelimited
         * @memberof google.protobuf.FileDescriptorSet
         * @static
         * @param {google.protobuf.IFileDescriptorSet} message FileDescriptorSet message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FileDescriptorSet.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FileDescriptorSet message from the specified reader or buffer.
         * @function decode
         * @memberof google.protobuf.FileDescriptorSet
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FileDescriptorSet.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.google.protobuf.FileDescriptorSet();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                if (!(message.file && message.file.length)) message.file = [];
                message.file.push($root.google.protobuf.FileDescriptorProto.decode(reader, reader.uint32()));
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a FileDescriptorSet message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof google.protobuf.FileDescriptorSet
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FileDescriptorSet.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FileDescriptorSet message.
         * @function verify
         * @memberof google.protobuf.FileDescriptorSet
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FileDescriptorSet.verify = function verify(message) {
          if (typeof message !== "object" || message === null) return "object expected";
          if (message.file != null && message.hasOwnProperty("file")) {
            if (!Array.isArray(message.file)) return "file: array expected";
            for (var i = 0; i < message.file.length; ++i) {
              var error = $root.google.protobuf.FileDescriptorProto.verify(message.file[i]);
              if (error) return "file." + error;
            }
          }
          return null;
        };

        /**
         * Creates a FileDescriptorSet message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof google.protobuf.FileDescriptorSet
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet
         */
        FileDescriptorSet.fromObject = function fromObject(object) {
          if (object instanceof $root.google.protobuf.FileDescriptorSet) return object;
          var message = new $root.google.protobuf.FileDescriptorSet();
          if (object.file) {
            if (!Array.isArray(object.file))
              throw TypeError(".google.protobuf.FileDescriptorSet.file: array expected");
            message.file = [];
            for (var i = 0; i < object.file.length; ++i) {
              if (typeof object.file[i] !== "object")
                throw TypeError(".google.protobuf.FileDescriptorSet.file: object expected");
              message.file[i] = $root.google.protobuf.FileDescriptorProto.fromObject(object.file[i]);
            }
          }
          return message;
        };

        /**
         * Creates a plain object from a FileDescriptorSet message. Also converts values to other types if specified.
         * @function toObject
         * @memberof google.protobuf.FileDescriptorSet
         * @static
         * @param {google.protobuf.FileDescriptorSet} message FileDescriptorSet
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FileDescriptorSet.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.arrays || options.defaults) object.file = [];
          if (message.file && message.file.length) {
            object.file = [];
            for (var j = 0; j < message.file.length; ++j)
              object.file[j] = $root.google.protobuf.FileDescriptorProto.toObject(message.file[j], options);
          }
          return object;
        };

        /**
         * Converts this FileDescriptorSet to JSON.
         * @function toJSON
         * @memberof google.protobuf.FileDescriptorSet
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FileDescriptorSet.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return FileDescriptorSet;
      })();

      protobuf.FileDescriptorProto = (function () {
        /**
         * Properties of a FileDescriptorProto.
         * @memberof google.protobuf
         * @interface IFileDescriptorProto
         * @property {string|null} [name] FileDescriptorProto name
         * @property {string|null} ["package"] FileDescriptorProto package
         * @property {Array.<string>|null} [dependency] FileDescriptorProto dependency
         * @property {Array.<number>|null} [publicDependency] FileDescriptorProto publicDependency
         * @property {Array.<number>|null} [weakDependency] FileDescriptorProto weakDependency
         * @property {Array.<google.protobuf.IDescriptorProto>|null} [messageType] FileDescriptorProto messageType
         * @property {Array.<google.protobuf.IEnumDescriptorProto>|null} [enumType] FileDescriptorProto enumType
         * @property {Array.<google.protobuf.IServiceDescriptorProto>|null} [service] FileDescriptorProto service
         * @property {Array.<google.protobuf.IFieldDescriptorProto>|null} [extension] FileDescriptorProto extension
         * @property {google.protobuf.IFileOptions|null} [options] FileDescriptorProto options
         * @property {google.protobuf.ISourceCodeInfo|null} [sourceCodeInfo] FileDescriptorProto sourceCodeInfo
         * @property {string|null} [syntax] FileDescriptorProto syntax
         */

        /**
         * Constructs a new FileDescriptorProto.
         * @memberof google.protobuf
         * @classdesc Represents a FileDescriptorProto.
         * @implements IFileDescriptorProto
         * @constructor
         * @param {google.protobuf.IFileDescriptorProto=} [properties] Properties to set
         */
        function FileDescriptorProto(properties) {
          this.dependency = [];
          this.publicDependency = [];
          this.weakDependency = [];
          this.messageType = [];
          this.enumType = [];
          this.service = [];
          this.extension = [];
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * FileDescriptorProto name.
         * @member {string} name
         * @memberof google.protobuf.FileDescriptorProto
         * @instance
         */
        FileDescriptorProto.prototype.name = "";

        /**
         * FileDescriptorProto package.
         * @member {string} package
         * @memberof google.protobuf.FileDescriptorProto
         * @instance
         */
        FileDescriptorProto.prototype["package"] = "";

        /**
         * FileDescriptorProto dependency.
         * @member {Array.<string>} dependency
         * @memberof google.protobuf.FileDescriptorProto
         * @instance
         */
        FileDescriptorProto.prototype.dependency = $util.emptyArray;

        /**
         * FileDescriptorProto publicDependency.
         * @member {Array.<number>} publicDependency
         * @memberof google.protobuf.FileDescriptorProto
         * @instance
         */
        FileDescriptorProto.prototype.publicDependency = $util.emptyArray;

        /**
         * FileDescriptorProto weakDependency.
         * @member {Array.<number>} weakDependency
         * @memberof google.protobuf.FileDescriptorProto
         * @instance
         */
        FileDescriptorProto.prototype.weakDependency = $util.emptyArray;

        /**
         * FileDescriptorProto messageType.
         * @member {Array.<google.protobuf.IDescriptorProto>} messageType
         * @memberof google.protobuf.FileDescriptorProto
         * @instance
         */
        FileDescriptorProto.prototype.messageType = $util.emptyArray;

        /**
         * FileDescriptorProto enumType.
         * @member {Array.<google.protobuf.IEnumDescriptorProto>} enumType
         * @memberof google.protobuf.FileDescriptorProto
         * @instance
         */
        FileDescriptorProto.prototype.enumType = $util.emptyArray;

        /**
         * FileDescriptorProto service.
         * @member {Array.<google.protobuf.IServiceDescriptorProto>} service
         * @memberof google.protobuf.FileDescriptorProto
         * @instance
         */
        FileDescriptorProto.prototype.service = $util.emptyArray;

        /**
         * FileDescriptorProto extension.
         * @member {Array.<google.protobuf.IFieldDescriptorProto>} extension
         * @memberof google.protobuf.FileDescriptorProto
         * @instance
         */
        FileDescriptorProto.prototype.extension = $util.emptyArray;

        /**
         * FileDescriptorProto options.
         * @member {google.protobuf.IFileOptions|null|undefined} options
         * @memberof google.protobuf.FileDescriptorProto
         * @instance
         */
        FileDescriptorProto.prototype.options = null;

        /**
         * FileDescriptorProto sourceCodeInfo.
         * @member {google.protobuf.ISourceCodeInfo|null|undefined} sourceCodeInfo
         * @memberof google.protobuf.FileDescriptorProto
         * @instance
         */
        FileDescriptorProto.prototype.sourceCodeInfo = null;

        /**
         * FileDescriptorProto syntax.
         * @member {string} syntax
         * @memberof google.protobuf.FileDescriptorProto
         * @instance
         */
        FileDescriptorProto.prototype.syntax = "";

        /**
         * Creates a new FileDescriptorProto instance using the specified properties.
         * @function create
         * @memberof google.protobuf.FileDescriptorProto
         * @static
         * @param {google.protobuf.IFileDescriptorProto=} [properties] Properties to set
         * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto instance
         */
        FileDescriptorProto.create = function create(properties) {
          return new FileDescriptorProto(properties);
        };

        /**
         * Encodes the specified FileDescriptorProto message. Does not implicitly {@link google.protobuf.FileDescriptorProto.verify|verify} messages.
         * @function encode
         * @memberof google.protobuf.FileDescriptorProto
         * @static
         * @param {google.protobuf.IFileDescriptorProto} message FileDescriptorProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FileDescriptorProto.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.name != null && Object.hasOwnProperty.call(message, "name"))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.name);
          if (message["package"] != null && Object.hasOwnProperty.call(message, "package"))
            writer.uint32(/* id 2, wireType 2 =*/ 18).string(message["package"]);
          if (message.dependency != null && message.dependency.length)
            for (var i = 0; i < message.dependency.length; ++i)
              writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.dependency[i]);
          if (message.messageType != null && message.messageType.length)
            for (var i = 0; i < message.messageType.length; ++i)
              $root.google.protobuf.DescriptorProto.encode(
                message.messageType[i],
                writer.uint32(/* id 4, wireType 2 =*/ 34).fork(),
              ).ldelim();
          if (message.enumType != null && message.enumType.length)
            for (var i = 0; i < message.enumType.length; ++i)
              $root.google.protobuf.EnumDescriptorProto.encode(
                message.enumType[i],
                writer.uint32(/* id 5, wireType 2 =*/ 42).fork(),
              ).ldelim();
          if (message.service != null && message.service.length)
            for (var i = 0; i < message.service.length; ++i)
              $root.google.protobuf.ServiceDescriptorProto.encode(
                message.service[i],
                writer.uint32(/* id 6, wireType 2 =*/ 50).fork(),
              ).ldelim();
          if (message.extension != null && message.extension.length)
            for (var i = 0; i < message.extension.length; ++i)
              $root.google.protobuf.FieldDescriptorProto.encode(
                message.extension[i],
                writer.uint32(/* id 7, wireType 2 =*/ 58).fork(),
              ).ldelim();
          if (message.options != null && Object.hasOwnProperty.call(message, "options"))
            $root.google.protobuf.FileOptions.encode(
              message.options,
              writer.uint32(/* id 8, wireType 2 =*/ 66).fork(),
            ).ldelim();
          if (message.sourceCodeInfo != null && Object.hasOwnProperty.call(message, "sourceCodeInfo"))
            $root.google.protobuf.SourceCodeInfo.encode(
              message.sourceCodeInfo,
              writer.uint32(/* id 9, wireType 2 =*/ 74).fork(),
            ).ldelim();
          if (message.publicDependency != null && message.publicDependency.length)
            for (var i = 0; i < message.publicDependency.length; ++i)
              writer.uint32(/* id 10, wireType 0 =*/ 80).int32(message.publicDependency[i]);
          if (message.weakDependency != null && message.weakDependency.length)
            for (var i = 0; i < message.weakDependency.length; ++i)
              writer.uint32(/* id 11, wireType 0 =*/ 88).int32(message.weakDependency[i]);
          if (message.syntax != null && Object.hasOwnProperty.call(message, "syntax"))
            writer.uint32(/* id 12, wireType 2 =*/ 98).string(message.syntax);
          return writer;
        };

        /**
         * Encodes the specified FileDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.FileDescriptorProto.verify|verify} messages.
         * @function encodeDelimited
         * @memberof google.protobuf.FileDescriptorProto
         * @static
         * @param {google.protobuf.IFileDescriptorProto} message FileDescriptorProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FileDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FileDescriptorProto message from the specified reader or buffer.
         * @function decode
         * @memberof google.protobuf.FileDescriptorProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FileDescriptorProto.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.google.protobuf.FileDescriptorProto();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.name = reader.string();
                break;
              case 2:
                message["package"] = reader.string();
                break;
              case 3:
                if (!(message.dependency && message.dependency.length)) message.dependency = [];
                message.dependency.push(reader.string());
                break;
              case 10:
                if (!(message.publicDependency && message.publicDependency.length))
                  message.publicDependency = [];
                if ((tag & 7) === 2) {
                  var end2 = reader.uint32() + reader.pos;
                  while (reader.pos < end2) message.publicDependency.push(reader.int32());
                } else message.publicDependency.push(reader.int32());
                break;
              case 11:
                if (!(message.weakDependency && message.weakDependency.length)) message.weakDependency = [];
                if ((tag & 7) === 2) {
                  var end2 = reader.uint32() + reader.pos;
                  while (reader.pos < end2) message.weakDependency.push(reader.int32());
                } else message.weakDependency.push(reader.int32());
                break;
              case 4:
                if (!(message.messageType && message.messageType.length)) message.messageType = [];
                message.messageType.push(
                  $root.google.protobuf.DescriptorProto.decode(reader, reader.uint32()),
                );
                break;
              case 5:
                if (!(message.enumType && message.enumType.length)) message.enumType = [];
                message.enumType.push(
                  $root.google.protobuf.EnumDescriptorProto.decode(reader, reader.uint32()),
                );
                break;
              case 6:
                if (!(message.service && message.service.length)) message.service = [];
                message.service.push(
                  $root.google.protobuf.ServiceDescriptorProto.decode(reader, reader.uint32()),
                );
                break;
              case 7:
                if (!(message.extension && message.extension.length)) message.extension = [];
                message.extension.push(
                  $root.google.protobuf.FieldDescriptorProto.decode(reader, reader.uint32()),
                );
                break;
              case 8:
                message.options = $root.google.protobuf.FileOptions.decode(reader, reader.uint32());
                break;
              case 9:
                message.sourceCodeInfo = $root.google.protobuf.SourceCodeInfo.decode(reader, reader.uint32());
                break;
              case 12:
                message.syntax = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a FileDescriptorProto message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof google.protobuf.FileDescriptorProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FileDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FileDescriptorProto message.
         * @function verify
         * @memberof google.protobuf.FileDescriptorProto
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FileDescriptorProto.verify = function verify(message) {
          if (typeof message !== "object" || message === null) return "object expected";
          if (message.name != null && message.hasOwnProperty("name"))
            if (!$util.isString(message.name)) return "name: string expected";
          if (message["package"] != null && message.hasOwnProperty("package"))
            if (!$util.isString(message["package"])) return "package: string expected";
          if (message.dependency != null && message.hasOwnProperty("dependency")) {
            if (!Array.isArray(message.dependency)) return "dependency: array expected";
            for (var i = 0; i < message.dependency.length; ++i)
              if (!$util.isString(message.dependency[i])) return "dependency: string[] expected";
          }
          if (message.publicDependency != null && message.hasOwnProperty("publicDependency")) {
            if (!Array.isArray(message.publicDependency)) return "publicDependency: array expected";
            for (var i = 0; i < message.publicDependency.length; ++i)
              if (!$util.isInteger(message.publicDependency[i]))
                return "publicDependency: integer[] expected";
          }
          if (message.weakDependency != null && message.hasOwnProperty("weakDependency")) {
            if (!Array.isArray(message.weakDependency)) return "weakDependency: array expected";
            for (var i = 0; i < message.weakDependency.length; ++i)
              if (!$util.isInteger(message.weakDependency[i])) return "weakDependency: integer[] expected";
          }
          if (message.messageType != null && message.hasOwnProperty("messageType")) {
            if (!Array.isArray(message.messageType)) return "messageType: array expected";
            for (var i = 0; i < message.messageType.length; ++i) {
              var error = $root.google.protobuf.DescriptorProto.verify(message.messageType[i]);
              if (error) return "messageType." + error;
            }
          }
          if (message.enumType != null && message.hasOwnProperty("enumType")) {
            if (!Array.isArray(message.enumType)) return "enumType: array expected";
            for (var i = 0; i < message.enumType.length; ++i) {
              var error = $root.google.protobuf.EnumDescriptorProto.verify(message.enumType[i]);
              if (error) return "enumType." + error;
            }
          }
          if (message.service != null && message.hasOwnProperty("service")) {
            if (!Array.isArray(message.service)) return "service: array expected";
            for (var i = 0; i < message.service.length; ++i) {
              var error = $root.google.protobuf.ServiceDescriptorProto.verify(message.service[i]);
              if (error) return "service." + error;
            }
          }
          if (message.extension != null && message.hasOwnProperty("extension")) {
            if (!Array.isArray(message.extension)) return "extension: array expected";
            for (var i = 0; i < message.extension.length; ++i) {
              var error = $root.google.protobuf.FieldDescriptorProto.verify(message.extension[i]);
              if (error) return "extension." + error;
            }
          }
          if (message.options != null && message.hasOwnProperty("options")) {
            var error = $root.google.protobuf.FileOptions.verify(message.options);
            if (error) return "options." + error;
          }
          if (message.sourceCodeInfo != null && message.hasOwnProperty("sourceCodeInfo")) {
            var error = $root.google.protobuf.SourceCodeInfo.verify(message.sourceCodeInfo);
            if (error) return "sourceCodeInfo." + error;
          }
          if (message.syntax != null && message.hasOwnProperty("syntax"))
            if (!$util.isString(message.syntax)) return "syntax: string expected";
          return null;
        };

        /**
         * Creates a FileDescriptorProto message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof google.protobuf.FileDescriptorProto
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto
         */
        FileDescriptorProto.fromObject = function fromObject(object) {
          if (object instanceof $root.google.protobuf.FileDescriptorProto) return object;
          var message = new $root.google.protobuf.FileDescriptorProto();
          if (object.name != null) message.name = String(object.name);
          if (object["package"] != null) message["package"] = String(object["package"]);
          if (object.dependency) {
            if (!Array.isArray(object.dependency))
              throw TypeError(".google.protobuf.FileDescriptorProto.dependency: array expected");
            message.dependency = [];
            for (var i = 0; i < object.dependency.length; ++i)
              message.dependency[i] = String(object.dependency[i]);
          }
          if (object.publicDependency) {
            if (!Array.isArray(object.publicDependency))
              throw TypeError(".google.protobuf.FileDescriptorProto.publicDependency: array expected");
            message.publicDependency = [];
            for (var i = 0; i < object.publicDependency.length; ++i)
              message.publicDependency[i] = object.publicDependency[i] | 0;
          }
          if (object.weakDependency) {
            if (!Array.isArray(object.weakDependency))
              throw TypeError(".google.protobuf.FileDescriptorProto.weakDependency: array expected");
            message.weakDependency = [];
            for (var i = 0; i < object.weakDependency.length; ++i)
              message.weakDependency[i] = object.weakDependency[i] | 0;
          }
          if (object.messageType) {
            if (!Array.isArray(object.messageType))
              throw TypeError(".google.protobuf.FileDescriptorProto.messageType: array expected");
            message.messageType = [];
            for (var i = 0; i < object.messageType.length; ++i) {
              if (typeof object.messageType[i] !== "object")
                throw TypeError(".google.protobuf.FileDescriptorProto.messageType: object expected");
              message.messageType[i] = $root.google.protobuf.DescriptorProto.fromObject(
                object.messageType[i],
              );
            }
          }
          if (object.enumType) {
            if (!Array.isArray(object.enumType))
              throw TypeError(".google.protobuf.FileDescriptorProto.enumType: array expected");
            message.enumType = [];
            for (var i = 0; i < object.enumType.length; ++i) {
              if (typeof object.enumType[i] !== "object")
                throw TypeError(".google.protobuf.FileDescriptorProto.enumType: object expected");
              message.enumType[i] = $root.google.protobuf.EnumDescriptorProto.fromObject(object.enumType[i]);
            }
          }
          if (object.service) {
            if (!Array.isArray(object.service))
              throw TypeError(".google.protobuf.FileDescriptorProto.service: array expected");
            message.service = [];
            for (var i = 0; i < object.service.length; ++i) {
              if (typeof object.service[i] !== "object")
                throw TypeError(".google.protobuf.FileDescriptorProto.service: object expected");
              message.service[i] = $root.google.protobuf.ServiceDescriptorProto.fromObject(object.service[i]);
            }
          }
          if (object.extension) {
            if (!Array.isArray(object.extension))
              throw TypeError(".google.protobuf.FileDescriptorProto.extension: array expected");
            message.extension = [];
            for (var i = 0; i < object.extension.length; ++i) {
              if (typeof object.extension[i] !== "object")
                throw TypeError(".google.protobuf.FileDescriptorProto.extension: object expected");
              message.extension[i] = $root.google.protobuf.FieldDescriptorProto.fromObject(
                object.extension[i],
              );
            }
          }
          if (object.options != null) {
            if (typeof object.options !== "object")
              throw TypeError(".google.protobuf.FileDescriptorProto.options: object expected");
            message.options = $root.google.protobuf.FileOptions.fromObject(object.options);
          }
          if (object.sourceCodeInfo != null) {
            if (typeof object.sourceCodeInfo !== "object")
              throw TypeError(".google.protobuf.FileDescriptorProto.sourceCodeInfo: object expected");
            message.sourceCodeInfo = $root.google.protobuf.SourceCodeInfo.fromObject(object.sourceCodeInfo);
          }
          if (object.syntax != null) message.syntax = String(object.syntax);
          return message;
        };

        /**
         * Creates a plain object from a FileDescriptorProto message. Also converts values to other types if specified.
         * @function toObject
         * @memberof google.protobuf.FileDescriptorProto
         * @static
         * @param {google.protobuf.FileDescriptorProto} message FileDescriptorProto
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FileDescriptorProto.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.arrays || options.defaults) {
            object.dependency = [];
            object.messageType = [];
            object.enumType = [];
            object.service = [];
            object.extension = [];
            object.publicDependency = [];
            object.weakDependency = [];
          }
          if (options.defaults) {
            object.name = "";
            object["package"] = "";
            object.options = null;
            object.sourceCodeInfo = null;
            object.syntax = "";
          }
          if (message.name != null && message.hasOwnProperty("name")) object.name = message.name;
          if (message["package"] != null && message.hasOwnProperty("package"))
            object["package"] = message["package"];
          if (message.dependency && message.dependency.length) {
            object.dependency = [];
            for (var j = 0; j < message.dependency.length; ++j) object.dependency[j] = message.dependency[j];
          }
          if (message.messageType && message.messageType.length) {
            object.messageType = [];
            for (var j = 0; j < message.messageType.length; ++j)
              object.messageType[j] = $root.google.protobuf.DescriptorProto.toObject(
                message.messageType[j],
                options,
              );
          }
          if (message.enumType && message.enumType.length) {
            object.enumType = [];
            for (var j = 0; j < message.enumType.length; ++j)
              object.enumType[j] = $root.google.protobuf.EnumDescriptorProto.toObject(
                message.enumType[j],
                options,
              );
          }
          if (message.service && message.service.length) {
            object.service = [];
            for (var j = 0; j < message.service.length; ++j)
              object.service[j] = $root.google.protobuf.ServiceDescriptorProto.toObject(
                message.service[j],
                options,
              );
          }
          if (message.extension && message.extension.length) {
            object.extension = [];
            for (var j = 0; j < message.extension.length; ++j)
              object.extension[j] = $root.google.protobuf.FieldDescriptorProto.toObject(
                message.extension[j],
                options,
              );
          }
          if (message.options != null && message.hasOwnProperty("options"))
            object.options = $root.google.protobuf.FileOptions.toObject(message.options, options);
          if (message.sourceCodeInfo != null && message.hasOwnProperty("sourceCodeInfo"))
            object.sourceCodeInfo = $root.google.protobuf.SourceCodeInfo.toObject(
              message.sourceCodeInfo,
              options,
            );
          if (message.publicDependency && message.publicDependency.length) {
            object.publicDependency = [];
            for (var j = 0; j < message.publicDependency.length; ++j)
              object.publicDependency[j] = message.publicDependency[j];
          }
          if (message.weakDependency && message.weakDependency.length) {
            object.weakDependency = [];
            for (var j = 0; j < message.weakDependency.length; ++j)
              object.weakDependency[j] = message.weakDependency[j];
          }
          if (message.syntax != null && message.hasOwnProperty("syntax")) object.syntax = message.syntax;
          return object;
        };

        /**
         * Converts this FileDescriptorProto to JSON.
         * @function toJSON
         * @memberof google.protobuf.FileDescriptorProto
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FileDescriptorProto.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return FileDescriptorProto;
      })();

      protobuf.DescriptorProto = (function () {
        /**
         * Properties of a DescriptorProto.
         * @memberof google.protobuf
         * @interface IDescriptorProto
         * @property {string|null} [name] DescriptorProto name
         * @property {Array.<google.protobuf.IFieldDescriptorProto>|null} [field] DescriptorProto field
         * @property {Array.<google.protobuf.IFieldDescriptorProto>|null} [extension] DescriptorProto extension
         * @property {Array.<google.protobuf.IDescriptorProto>|null} [nestedType] DescriptorProto nestedType
         * @property {Array.<google.protobuf.IEnumDescriptorProto>|null} [enumType] DescriptorProto enumType
         * @property {Array.<google.protobuf.DescriptorProto.IExtensionRange>|null} [extensionRange] DescriptorProto extensionRange
         * @property {Array.<google.protobuf.IOneofDescriptorProto>|null} [oneofDecl] DescriptorProto oneofDecl
         * @property {google.protobuf.IMessageOptions|null} [options] DescriptorProto options
         * @property {Array.<google.protobuf.DescriptorProto.IReservedRange>|null} [reservedRange] DescriptorProto reservedRange
         * @property {Array.<string>|null} [reservedName] DescriptorProto reservedName
         */

        /**
         * Constructs a new DescriptorProto.
         * @memberof google.protobuf
         * @classdesc Represents a DescriptorProto.
         * @implements IDescriptorProto
         * @constructor
         * @param {google.protobuf.IDescriptorProto=} [properties] Properties to set
         */
        function DescriptorProto(properties) {
          this.field = [];
          this.extension = [];
          this.nestedType = [];
          this.enumType = [];
          this.extensionRange = [];
          this.oneofDecl = [];
          this.reservedRange = [];
          this.reservedName = [];
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * DescriptorProto name.
         * @member {string} name
         * @memberof google.protobuf.DescriptorProto
         * @instance
         */
        DescriptorProto.prototype.name = "";

        /**
         * DescriptorProto field.
         * @member {Array.<google.protobuf.IFieldDescriptorProto>} field
         * @memberof google.protobuf.DescriptorProto
         * @instance
         */
        DescriptorProto.prototype.field = $util.emptyArray;

        /**
         * DescriptorProto extension.
         * @member {Array.<google.protobuf.IFieldDescriptorProto>} extension
         * @memberof google.protobuf.DescriptorProto
         * @instance
         */
        DescriptorProto.prototype.extension = $util.emptyArray;

        /**
         * DescriptorProto nestedType.
         * @member {Array.<google.protobuf.IDescriptorProto>} nestedType
         * @memberof google.protobuf.DescriptorProto
         * @instance
         */
        DescriptorProto.prototype.nestedType = $util.emptyArray;

        /**
         * DescriptorProto enumType.
         * @member {Array.<google.protobuf.IEnumDescriptorProto>} enumType
         * @memberof google.protobuf.DescriptorProto
         * @instance
         */
        DescriptorProto.prototype.enumType = $util.emptyArray;

        /**
         * DescriptorProto extensionRange.
         * @member {Array.<google.protobuf.DescriptorProto.IExtensionRange>} extensionRange
         * @memberof google.protobuf.DescriptorProto
         * @instance
         */
        DescriptorProto.prototype.extensionRange = $util.emptyArray;

        /**
         * DescriptorProto oneofDecl.
         * @member {Array.<google.protobuf.IOneofDescriptorProto>} oneofDecl
         * @memberof google.protobuf.DescriptorProto
         * @instance
         */
        DescriptorProto.prototype.oneofDecl = $util.emptyArray;

        /**
         * DescriptorProto options.
         * @member {google.protobuf.IMessageOptions|null|undefined} options
         * @memberof google.protobuf.DescriptorProto
         * @instance
         */
        DescriptorProto.prototype.options = null;

        /**
         * DescriptorProto reservedRange.
         * @member {Array.<google.protobuf.DescriptorProto.IReservedRange>} reservedRange
         * @memberof google.protobuf.DescriptorProto
         * @instance
         */
        DescriptorProto.prototype.reservedRange = $util.emptyArray;

        /**
         * DescriptorProto reservedName.
         * @member {Array.<string>} reservedName
         * @memberof google.protobuf.DescriptorProto
         * @instance
         */
        DescriptorProto.prototype.reservedName = $util.emptyArray;

        /**
         * Creates a new DescriptorProto instance using the specified properties.
         * @function create
         * @memberof google.protobuf.DescriptorProto
         * @static
         * @param {google.protobuf.IDescriptorProto=} [properties] Properties to set
         * @returns {google.protobuf.DescriptorProto} DescriptorProto instance
         */
        DescriptorProto.create = function create(properties) {
          return new DescriptorProto(properties);
        };

        /**
         * Encodes the specified DescriptorProto message. Does not implicitly {@link google.protobuf.DescriptorProto.verify|verify} messages.
         * @function encode
         * @memberof google.protobuf.DescriptorProto
         * @static
         * @param {google.protobuf.IDescriptorProto} message DescriptorProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DescriptorProto.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.name != null && Object.hasOwnProperty.call(message, "name"))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.name);
          if (message.field != null && message.field.length)
            for (var i = 0; i < message.field.length; ++i)
              $root.google.protobuf.FieldDescriptorProto.encode(
                message.field[i],
                writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
              ).ldelim();
          if (message.nestedType != null && message.nestedType.length)
            for (var i = 0; i < message.nestedType.length; ++i)
              $root.google.protobuf.DescriptorProto.encode(
                message.nestedType[i],
                writer.uint32(/* id 3, wireType 2 =*/ 26).fork(),
              ).ldelim();
          if (message.enumType != null && message.enumType.length)
            for (var i = 0; i < message.enumType.length; ++i)
              $root.google.protobuf.EnumDescriptorProto.encode(
                message.enumType[i],
                writer.uint32(/* id 4, wireType 2 =*/ 34).fork(),
              ).ldelim();
          if (message.extensionRange != null && message.extensionRange.length)
            for (var i = 0; i < message.extensionRange.length; ++i)
              $root.google.protobuf.DescriptorProto.ExtensionRange.encode(
                message.extensionRange[i],
                writer.uint32(/* id 5, wireType 2 =*/ 42).fork(),
              ).ldelim();
          if (message.extension != null && message.extension.length)
            for (var i = 0; i < message.extension.length; ++i)
              $root.google.protobuf.FieldDescriptorProto.encode(
                message.extension[i],
                writer.uint32(/* id 6, wireType 2 =*/ 50).fork(),
              ).ldelim();
          if (message.options != null && Object.hasOwnProperty.call(message, "options"))
            $root.google.protobuf.MessageOptions.encode(
              message.options,
              writer.uint32(/* id 7, wireType 2 =*/ 58).fork(),
            ).ldelim();
          if (message.oneofDecl != null && message.oneofDecl.length)
            for (var i = 0; i < message.oneofDecl.length; ++i)
              $root.google.protobuf.OneofDescriptorProto.encode(
                message.oneofDecl[i],
                writer.uint32(/* id 8, wireType 2 =*/ 66).fork(),
              ).ldelim();
          if (message.reservedRange != null && message.reservedRange.length)
            for (var i = 0; i < message.reservedRange.length; ++i)
              $root.google.protobuf.DescriptorProto.ReservedRange.encode(
                message.reservedRange[i],
                writer.uint32(/* id 9, wireType 2 =*/ 74).fork(),
              ).ldelim();
          if (message.reservedName != null && message.reservedName.length)
            for (var i = 0; i < message.reservedName.length; ++i)
              writer.uint32(/* id 10, wireType 2 =*/ 82).string(message.reservedName[i]);
          return writer;
        };

        /**
         * Encodes the specified DescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.DescriptorProto.verify|verify} messages.
         * @function encodeDelimited
         * @memberof google.protobuf.DescriptorProto
         * @static
         * @param {google.protobuf.IDescriptorProto} message DescriptorProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DescriptorProto message from the specified reader or buffer.
         * @function decode
         * @memberof google.protobuf.DescriptorProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {google.protobuf.DescriptorProto} DescriptorProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DescriptorProto.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.google.protobuf.DescriptorProto();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.name = reader.string();
                break;
              case 2:
                if (!(message.field && message.field.length)) message.field = [];
                message.field.push(
                  $root.google.protobuf.FieldDescriptorProto.decode(reader, reader.uint32()),
                );
                break;
              case 6:
                if (!(message.extension && message.extension.length)) message.extension = [];
                message.extension.push(
                  $root.google.protobuf.FieldDescriptorProto.decode(reader, reader.uint32()),
                );
                break;
              case 3:
                if (!(message.nestedType && message.nestedType.length)) message.nestedType = [];
                message.nestedType.push(
                  $root.google.protobuf.DescriptorProto.decode(reader, reader.uint32()),
                );
                break;
              case 4:
                if (!(message.enumType && message.enumType.length)) message.enumType = [];
                message.enumType.push(
                  $root.google.protobuf.EnumDescriptorProto.decode(reader, reader.uint32()),
                );
                break;
              case 5:
                if (!(message.extensionRange && message.extensionRange.length)) message.extensionRange = [];
                message.extensionRange.push(
                  $root.google.protobuf.DescriptorProto.ExtensionRange.decode(reader, reader.uint32()),
                );
                break;
              case 8:
                if (!(message.oneofDecl && message.oneofDecl.length)) message.oneofDecl = [];
                message.oneofDecl.push(
                  $root.google.protobuf.OneofDescriptorProto.decode(reader, reader.uint32()),
                );
                break;
              case 7:
                message.options = $root.google.protobuf.MessageOptions.decode(reader, reader.uint32());
                break;
              case 9:
                if (!(message.reservedRange && message.reservedRange.length)) message.reservedRange = [];
                message.reservedRange.push(
                  $root.google.protobuf.DescriptorProto.ReservedRange.decode(reader, reader.uint32()),
                );
                break;
              case 10:
                if (!(message.reservedName && message.reservedName.length)) message.reservedName = [];
                message.reservedName.push(reader.string());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a DescriptorProto message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof google.protobuf.DescriptorProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {google.protobuf.DescriptorProto} DescriptorProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DescriptorProto.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DescriptorProto message.
         * @function verify
         * @memberof google.protobuf.DescriptorProto
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DescriptorProto.verify = function verify(message) {
          if (typeof message !== "object" || message === null) return "object expected";
          if (message.name != null && message.hasOwnProperty("name"))
            if (!$util.isString(message.name)) return "name: string expected";
          if (message.field != null && message.hasOwnProperty("field")) {
            if (!Array.isArray(message.field)) return "field: array expected";
            for (var i = 0; i < message.field.length; ++i) {
              var error = $root.google.protobuf.FieldDescriptorProto.verify(message.field[i]);
              if (error) return "field." + error;
            }
          }
          if (message.extension != null && message.hasOwnProperty("extension")) {
            if (!Array.isArray(message.extension)) return "extension: array expected";
            for (var i = 0; i < message.extension.length; ++i) {
              var error = $root.google.protobuf.FieldDescriptorProto.verify(message.extension[i]);
              if (error) return "extension." + error;
            }
          }
          if (message.nestedType != null && message.hasOwnProperty("nestedType")) {
            if (!Array.isArray(message.nestedType)) return "nestedType: array expected";
            for (var i = 0; i < message.nestedType.length; ++i) {
              var error = $root.google.protobuf.DescriptorProto.verify(message.nestedType[i]);
              if (error) return "nestedType." + error;
            }
          }
          if (message.enumType != null && message.hasOwnProperty("enumType")) {
            if (!Array.isArray(message.enumType)) return "enumType: array expected";
            for (var i = 0; i < message.enumType.length; ++i) {
              var error = $root.google.protobuf.EnumDescriptorProto.verify(message.enumType[i]);
              if (error) return "enumType." + error;
            }
          }
          if (message.extensionRange != null && message.hasOwnProperty("extensionRange")) {
            if (!Array.isArray(message.extensionRange)) return "extensionRange: array expected";
            for (var i = 0; i < message.extensionRange.length; ++i) {
              var error = $root.google.protobuf.DescriptorProto.ExtensionRange.verify(
                message.extensionRange[i],
              );
              if (error) return "extensionRange." + error;
            }
          }
          if (message.oneofDecl != null && message.hasOwnProperty("oneofDecl")) {
            if (!Array.isArray(message.oneofDecl)) return "oneofDecl: array expected";
            for (var i = 0; i < message.oneofDecl.length; ++i) {
              var error = $root.google.protobuf.OneofDescriptorProto.verify(message.oneofDecl[i]);
              if (error) return "oneofDecl." + error;
            }
          }
          if (message.options != null && message.hasOwnProperty("options")) {
            var error = $root.google.protobuf.MessageOptions.verify(message.options);
            if (error) return "options." + error;
          }
          if (message.reservedRange != null && message.hasOwnProperty("reservedRange")) {
            if (!Array.isArray(message.reservedRange)) return "reservedRange: array expected";
            for (var i = 0; i < message.reservedRange.length; ++i) {
              var error = $root.google.protobuf.DescriptorProto.ReservedRange.verify(
                message.reservedRange[i],
              );
              if (error) return "reservedRange." + error;
            }
          }
          if (message.reservedName != null && message.hasOwnProperty("reservedName")) {
            if (!Array.isArray(message.reservedName)) return "reservedName: array expected";
            for (var i = 0; i < message.reservedName.length; ++i)
              if (!$util.isString(message.reservedName[i])) return "reservedName: string[] expected";
          }
          return null;
        };

        /**
         * Creates a DescriptorProto message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof google.protobuf.DescriptorProto
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {google.protobuf.DescriptorProto} DescriptorProto
         */
        DescriptorProto.fromObject = function fromObject(object) {
          if (object instanceof $root.google.protobuf.DescriptorProto) return object;
          var message = new $root.google.protobuf.DescriptorProto();
          if (object.name != null) message.name = String(object.name);
          if (object.field) {
            if (!Array.isArray(object.field))
              throw TypeError(".google.protobuf.DescriptorProto.field: array expected");
            message.field = [];
            for (var i = 0; i < object.field.length; ++i) {
              if (typeof object.field[i] !== "object")
                throw TypeError(".google.protobuf.DescriptorProto.field: object expected");
              message.field[i] = $root.google.protobuf.FieldDescriptorProto.fromObject(object.field[i]);
            }
          }
          if (object.extension) {
            if (!Array.isArray(object.extension))
              throw TypeError(".google.protobuf.DescriptorProto.extension: array expected");
            message.extension = [];
            for (var i = 0; i < object.extension.length; ++i) {
              if (typeof object.extension[i] !== "object")
                throw TypeError(".google.protobuf.DescriptorProto.extension: object expected");
              message.extension[i] = $root.google.protobuf.FieldDescriptorProto.fromObject(
                object.extension[i],
              );
            }
          }
          if (object.nestedType) {
            if (!Array.isArray(object.nestedType))
              throw TypeError(".google.protobuf.DescriptorProto.nestedType: array expected");
            message.nestedType = [];
            for (var i = 0; i < object.nestedType.length; ++i) {
              if (typeof object.nestedType[i] !== "object")
                throw TypeError(".google.protobuf.DescriptorProto.nestedType: object expected");
              message.nestedType[i] = $root.google.protobuf.DescriptorProto.fromObject(object.nestedType[i]);
            }
          }
          if (object.enumType) {
            if (!Array.isArray(object.enumType))
              throw TypeError(".google.protobuf.DescriptorProto.enumType: array expected");
            message.enumType = [];
            for (var i = 0; i < object.enumType.length; ++i) {
              if (typeof object.enumType[i] !== "object")
                throw TypeError(".google.protobuf.DescriptorProto.enumType: object expected");
              message.enumType[i] = $root.google.protobuf.EnumDescriptorProto.fromObject(object.enumType[i]);
            }
          }
          if (object.extensionRange) {
            if (!Array.isArray(object.extensionRange))
              throw TypeError(".google.protobuf.DescriptorProto.extensionRange: array expected");
            message.extensionRange = [];
            for (var i = 0; i < object.extensionRange.length; ++i) {
              if (typeof object.extensionRange[i] !== "object")
                throw TypeError(".google.protobuf.DescriptorProto.extensionRange: object expected");
              message.extensionRange[i] = $root.google.protobuf.DescriptorProto.ExtensionRange.fromObject(
                object.extensionRange[i],
              );
            }
          }
          if (object.oneofDecl) {
            if (!Array.isArray(object.oneofDecl))
              throw TypeError(".google.protobuf.DescriptorProto.oneofDecl: array expected");
            message.oneofDecl = [];
            for (var i = 0; i < object.oneofDecl.length; ++i) {
              if (typeof object.oneofDecl[i] !== "object")
                throw TypeError(".google.protobuf.DescriptorProto.oneofDecl: object expected");
              message.oneofDecl[i] = $root.google.protobuf.OneofDescriptorProto.fromObject(
                object.oneofDecl[i],
              );
            }
          }
          if (object.options != null) {
            if (typeof object.options !== "object")
              throw TypeError(".google.protobuf.DescriptorProto.options: object expected");
            message.options = $root.google.protobuf.MessageOptions.fromObject(object.options);
          }
          if (object.reservedRange) {
            if (!Array.isArray(object.reservedRange))
              throw TypeError(".google.protobuf.DescriptorProto.reservedRange: array expected");
            message.reservedRange = [];
            for (var i = 0; i < object.reservedRange.length; ++i) {
              if (typeof object.reservedRange[i] !== "object")
                throw TypeError(".google.protobuf.DescriptorProto.reservedRange: object expected");
              message.reservedRange[i] = $root.google.protobuf.DescriptorProto.ReservedRange.fromObject(
                object.reservedRange[i],
              );
            }
          }
          if (object.reservedName) {
            if (!Array.isArray(object.reservedName))
              throw TypeError(".google.protobuf.DescriptorProto.reservedName: array expected");
            message.reservedName = [];
            for (var i = 0; i < object.reservedName.length; ++i)
              message.reservedName[i] = String(object.reservedName[i]);
          }
          return message;
        };

        /**
         * Creates a plain object from a DescriptorProto message. Also converts values to other types if specified.
         * @function toObject
         * @memberof google.protobuf.DescriptorProto
         * @static
         * @param {google.protobuf.DescriptorProto} message DescriptorProto
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DescriptorProto.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.arrays || options.defaults) {
            object.field = [];
            object.nestedType = [];
            object.enumType = [];
            object.extensionRange = [];
            object.extension = [];
            object.oneofDecl = [];
            object.reservedRange = [];
            object.reservedName = [];
          }
          if (options.defaults) {
            object.name = "";
            object.options = null;
          }
          if (message.name != null && message.hasOwnProperty("name")) object.name = message.name;
          if (message.field && message.field.length) {
            object.field = [];
            for (var j = 0; j < message.field.length; ++j)
              object.field[j] = $root.google.protobuf.FieldDescriptorProto.toObject(
                message.field[j],
                options,
              );
          }
          if (message.nestedType && message.nestedType.length) {
            object.nestedType = [];
            for (var j = 0; j < message.nestedType.length; ++j)
              object.nestedType[j] = $root.google.protobuf.DescriptorProto.toObject(
                message.nestedType[j],
                options,
              );
          }
          if (message.enumType && message.enumType.length) {
            object.enumType = [];
            for (var j = 0; j < message.enumType.length; ++j)
              object.enumType[j] = $root.google.protobuf.EnumDescriptorProto.toObject(
                message.enumType[j],
                options,
              );
          }
          if (message.extensionRange && message.extensionRange.length) {
            object.extensionRange = [];
            for (var j = 0; j < message.extensionRange.length; ++j)
              object.extensionRange[j] = $root.google.protobuf.DescriptorProto.ExtensionRange.toObject(
                message.extensionRange[j],
                options,
              );
          }
          if (message.extension && message.extension.length) {
            object.extension = [];
            for (var j = 0; j < message.extension.length; ++j)
              object.extension[j] = $root.google.protobuf.FieldDescriptorProto.toObject(
                message.extension[j],
                options,
              );
          }
          if (message.options != null && message.hasOwnProperty("options"))
            object.options = $root.google.protobuf.MessageOptions.toObject(message.options, options);
          if (message.oneofDecl && message.oneofDecl.length) {
            object.oneofDecl = [];
            for (var j = 0; j < message.oneofDecl.length; ++j)
              object.oneofDecl[j] = $root.google.protobuf.OneofDescriptorProto.toObject(
                message.oneofDecl[j],
                options,
              );
          }
          if (message.reservedRange && message.reservedRange.length) {
            object.reservedRange = [];
            for (var j = 0; j < message.reservedRange.length; ++j)
              object.reservedRange[j] = $root.google.protobuf.DescriptorProto.ReservedRange.toObject(
                message.reservedRange[j],
                options,
              );
          }
          if (message.reservedName && message.reservedName.length) {
            object.reservedName = [];
            for (var j = 0; j < message.reservedName.length; ++j)
              object.reservedName[j] = message.reservedName[j];
          }
          return object;
        };

        /**
         * Converts this DescriptorProto to JSON.
         * @function toJSON
         * @memberof google.protobuf.DescriptorProto
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DescriptorProto.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        DescriptorProto.ExtensionRange = (function () {
          /**
           * Properties of an ExtensionRange.
           * @memberof google.protobuf.DescriptorProto
           * @interface IExtensionRange
           * @property {number|null} [start] ExtensionRange start
           * @property {number|null} [end] ExtensionRange end
           */

          /**
           * Constructs a new ExtensionRange.
           * @memberof google.protobuf.DescriptorProto
           * @classdesc Represents an ExtensionRange.
           * @implements IExtensionRange
           * @constructor
           * @param {google.protobuf.DescriptorProto.IExtensionRange=} [properties] Properties to set
           */
          function ExtensionRange(properties) {
            if (properties)
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
          }

          /**
           * ExtensionRange start.
           * @member {number} start
           * @memberof google.protobuf.DescriptorProto.ExtensionRange
           * @instance
           */
          ExtensionRange.prototype.start = 0;

          /**
           * ExtensionRange end.
           * @member {number} end
           * @memberof google.protobuf.DescriptorProto.ExtensionRange
           * @instance
           */
          ExtensionRange.prototype.end = 0;

          /**
           * Creates a new ExtensionRange instance using the specified properties.
           * @function create
           * @memberof google.protobuf.DescriptorProto.ExtensionRange
           * @static
           * @param {google.protobuf.DescriptorProto.IExtensionRange=} [properties] Properties to set
           * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange instance
           */
          ExtensionRange.create = function create(properties) {
            return new ExtensionRange(properties);
          };

          /**
           * Encodes the specified ExtensionRange message. Does not implicitly {@link google.protobuf.DescriptorProto.ExtensionRange.verify|verify} messages.
           * @function encode
           * @memberof google.protobuf.DescriptorProto.ExtensionRange
           * @static
           * @param {google.protobuf.DescriptorProto.IExtensionRange} message ExtensionRange message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          ExtensionRange.encode = function encode(message, writer) {
            if (!writer) writer = $Writer.create();
            if (message.start != null && Object.hasOwnProperty.call(message, "start"))
              writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.start);
            if (message.end != null && Object.hasOwnProperty.call(message, "end"))
              writer.uint32(/* id 2, wireType 0 =*/ 16).int32(message.end);
            return writer;
          };

          /**
           * Encodes the specified ExtensionRange message, length delimited. Does not implicitly {@link google.protobuf.DescriptorProto.ExtensionRange.verify|verify} messages.
           * @function encodeDelimited
           * @memberof google.protobuf.DescriptorProto.ExtensionRange
           * @static
           * @param {google.protobuf.DescriptorProto.IExtensionRange} message ExtensionRange message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          ExtensionRange.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes an ExtensionRange message from the specified reader or buffer.
           * @function decode
           * @memberof google.protobuf.DescriptorProto.ExtensionRange
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          ExtensionRange.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length,
              message = new $root.google.protobuf.DescriptorProto.ExtensionRange();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  message.start = reader.int32();
                  break;
                case 2:
                  message.end = reader.int32();
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };

          /**
           * Decodes an ExtensionRange message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof google.protobuf.DescriptorProto.ExtensionRange
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          ExtensionRange.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader)) reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies an ExtensionRange message.
           * @function verify
           * @memberof google.protobuf.DescriptorProto.ExtensionRange
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          ExtensionRange.verify = function verify(message) {
            if (typeof message !== "object" || message === null) return "object expected";
            if (message.start != null && message.hasOwnProperty("start"))
              if (!$util.isInteger(message.start)) return "start: integer expected";
            if (message.end != null && message.hasOwnProperty("end"))
              if (!$util.isInteger(message.end)) return "end: integer expected";
            return null;
          };

          /**
           * Creates an ExtensionRange message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof google.protobuf.DescriptorProto.ExtensionRange
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange
           */
          ExtensionRange.fromObject = function fromObject(object) {
            if (object instanceof $root.google.protobuf.DescriptorProto.ExtensionRange) return object;
            var message = new $root.google.protobuf.DescriptorProto.ExtensionRange();
            if (object.start != null) message.start = object.start | 0;
            if (object.end != null) message.end = object.end | 0;
            return message;
          };

          /**
           * Creates a plain object from an ExtensionRange message. Also converts values to other types if specified.
           * @function toObject
           * @memberof google.protobuf.DescriptorProto.ExtensionRange
           * @static
           * @param {google.protobuf.DescriptorProto.ExtensionRange} message ExtensionRange
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          ExtensionRange.toObject = function toObject(message, options) {
            if (!options) options = {};
            var object = {};
            if (options.defaults) {
              object.start = 0;
              object.end = 0;
            }
            if (message.start != null && message.hasOwnProperty("start")) object.start = message.start;
            if (message.end != null && message.hasOwnProperty("end")) object.end = message.end;
            return object;
          };

          /**
           * Converts this ExtensionRange to JSON.
           * @function toJSON
           * @memberof google.protobuf.DescriptorProto.ExtensionRange
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          ExtensionRange.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };

          return ExtensionRange;
        })();

        DescriptorProto.ReservedRange = (function () {
          /**
           * Properties of a ReservedRange.
           * @memberof google.protobuf.DescriptorProto
           * @interface IReservedRange
           * @property {number|null} [start] ReservedRange start
           * @property {number|null} [end] ReservedRange end
           */

          /**
           * Constructs a new ReservedRange.
           * @memberof google.protobuf.DescriptorProto
           * @classdesc Represents a ReservedRange.
           * @implements IReservedRange
           * @constructor
           * @param {google.protobuf.DescriptorProto.IReservedRange=} [properties] Properties to set
           */
          function ReservedRange(properties) {
            if (properties)
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
          }

          /**
           * ReservedRange start.
           * @member {number} start
           * @memberof google.protobuf.DescriptorProto.ReservedRange
           * @instance
           */
          ReservedRange.prototype.start = 0;

          /**
           * ReservedRange end.
           * @member {number} end
           * @memberof google.protobuf.DescriptorProto.ReservedRange
           * @instance
           */
          ReservedRange.prototype.end = 0;

          /**
           * Creates a new ReservedRange instance using the specified properties.
           * @function create
           * @memberof google.protobuf.DescriptorProto.ReservedRange
           * @static
           * @param {google.protobuf.DescriptorProto.IReservedRange=} [properties] Properties to set
           * @returns {google.protobuf.DescriptorProto.ReservedRange} ReservedRange instance
           */
          ReservedRange.create = function create(properties) {
            return new ReservedRange(properties);
          };

          /**
           * Encodes the specified ReservedRange message. Does not implicitly {@link google.protobuf.DescriptorProto.ReservedRange.verify|verify} messages.
           * @function encode
           * @memberof google.protobuf.DescriptorProto.ReservedRange
           * @static
           * @param {google.protobuf.DescriptorProto.IReservedRange} message ReservedRange message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          ReservedRange.encode = function encode(message, writer) {
            if (!writer) writer = $Writer.create();
            if (message.start != null && Object.hasOwnProperty.call(message, "start"))
              writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.start);
            if (message.end != null && Object.hasOwnProperty.call(message, "end"))
              writer.uint32(/* id 2, wireType 0 =*/ 16).int32(message.end);
            return writer;
          };

          /**
           * Encodes the specified ReservedRange message, length delimited. Does not implicitly {@link google.protobuf.DescriptorProto.ReservedRange.verify|verify} messages.
           * @function encodeDelimited
           * @memberof google.protobuf.DescriptorProto.ReservedRange
           * @static
           * @param {google.protobuf.DescriptorProto.IReservedRange} message ReservedRange message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          ReservedRange.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a ReservedRange message from the specified reader or buffer.
           * @function decode
           * @memberof google.protobuf.DescriptorProto.ReservedRange
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {google.protobuf.DescriptorProto.ReservedRange} ReservedRange
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          ReservedRange.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length,
              message = new $root.google.protobuf.DescriptorProto.ReservedRange();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  message.start = reader.int32();
                  break;
                case 2:
                  message.end = reader.int32();
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };

          /**
           * Decodes a ReservedRange message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof google.protobuf.DescriptorProto.ReservedRange
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {google.protobuf.DescriptorProto.ReservedRange} ReservedRange
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          ReservedRange.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader)) reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a ReservedRange message.
           * @function verify
           * @memberof google.protobuf.DescriptorProto.ReservedRange
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          ReservedRange.verify = function verify(message) {
            if (typeof message !== "object" || message === null) return "object expected";
            if (message.start != null && message.hasOwnProperty("start"))
              if (!$util.isInteger(message.start)) return "start: integer expected";
            if (message.end != null && message.hasOwnProperty("end"))
              if (!$util.isInteger(message.end)) return "end: integer expected";
            return null;
          };

          /**
           * Creates a ReservedRange message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof google.protobuf.DescriptorProto.ReservedRange
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {google.protobuf.DescriptorProto.ReservedRange} ReservedRange
           */
          ReservedRange.fromObject = function fromObject(object) {
            if (object instanceof $root.google.protobuf.DescriptorProto.ReservedRange) return object;
            var message = new $root.google.protobuf.DescriptorProto.ReservedRange();
            if (object.start != null) message.start = object.start | 0;
            if (object.end != null) message.end = object.end | 0;
            return message;
          };

          /**
           * Creates a plain object from a ReservedRange message. Also converts values to other types if specified.
           * @function toObject
           * @memberof google.protobuf.DescriptorProto.ReservedRange
           * @static
           * @param {google.protobuf.DescriptorProto.ReservedRange} message ReservedRange
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          ReservedRange.toObject = function toObject(message, options) {
            if (!options) options = {};
            var object = {};
            if (options.defaults) {
              object.start = 0;
              object.end = 0;
            }
            if (message.start != null && message.hasOwnProperty("start")) object.start = message.start;
            if (message.end != null && message.hasOwnProperty("end")) object.end = message.end;
            return object;
          };

          /**
           * Converts this ReservedRange to JSON.
           * @function toJSON
           * @memberof google.protobuf.DescriptorProto.ReservedRange
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          ReservedRange.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };

          return ReservedRange;
        })();

        return DescriptorProto;
      })();

      protobuf.FieldDescriptorProto = (function () {
        /**
         * Properties of a FieldDescriptorProto.
         * @memberof google.protobuf
         * @interface IFieldDescriptorProto
         * @property {string|null} [name] FieldDescriptorProto name
         * @property {number|null} [number] FieldDescriptorProto number
         * @property {google.protobuf.FieldDescriptorProto.Label|null} [label] FieldDescriptorProto label
         * @property {google.protobuf.FieldDescriptorProto.Type|null} [type] FieldDescriptorProto type
         * @property {string|null} [typeName] FieldDescriptorProto typeName
         * @property {string|null} [extendee] FieldDescriptorProto extendee
         * @property {string|null} [defaultValue] FieldDescriptorProto defaultValue
         * @property {number|null} [oneofIndex] FieldDescriptorProto oneofIndex
         * @property {string|null} [jsonName] FieldDescriptorProto jsonName
         * @property {google.protobuf.IFieldOptions|null} [options] FieldDescriptorProto options
         */

        /**
         * Constructs a new FieldDescriptorProto.
         * @memberof google.protobuf
         * @classdesc Represents a FieldDescriptorProto.
         * @implements IFieldDescriptorProto
         * @constructor
         * @param {google.protobuf.IFieldDescriptorProto=} [properties] Properties to set
         */
        function FieldDescriptorProto(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * FieldDescriptorProto name.
         * @member {string} name
         * @memberof google.protobuf.FieldDescriptorProto
         * @instance
         */
        FieldDescriptorProto.prototype.name = "";

        /**
         * FieldDescriptorProto number.
         * @member {number} number
         * @memberof google.protobuf.FieldDescriptorProto
         * @instance
         */
        FieldDescriptorProto.prototype.number = 0;

        /**
         * FieldDescriptorProto label.
         * @member {google.protobuf.FieldDescriptorProto.Label} label
         * @memberof google.protobuf.FieldDescriptorProto
         * @instance
         */
        FieldDescriptorProto.prototype.label = 1;

        /**
         * FieldDescriptorProto type.
         * @member {google.protobuf.FieldDescriptorProto.Type} type
         * @memberof google.protobuf.FieldDescriptorProto
         * @instance
         */
        FieldDescriptorProto.prototype.type = 1;

        /**
         * FieldDescriptorProto typeName.
         * @member {string} typeName
         * @memberof google.protobuf.FieldDescriptorProto
         * @instance
         */
        FieldDescriptorProto.prototype.typeName = "";

        /**
         * FieldDescriptorProto extendee.
         * @member {string} extendee
         * @memberof google.protobuf.FieldDescriptorProto
         * @instance
         */
        FieldDescriptorProto.prototype.extendee = "";

        /**
         * FieldDescriptorProto defaultValue.
         * @member {string} defaultValue
         * @memberof google.protobuf.FieldDescriptorProto
         * @instance
         */
        FieldDescriptorProto.prototype.defaultValue = "";

        /**
         * FieldDescriptorProto oneofIndex.
         * @member {number} oneofIndex
         * @memberof google.protobuf.FieldDescriptorProto
         * @instance
         */
        FieldDescriptorProto.prototype.oneofIndex = 0;

        /**
         * FieldDescriptorProto jsonName.
         * @member {string} jsonName
         * @memberof google.protobuf.FieldDescriptorProto
         * @instance
         */
        FieldDescriptorProto.prototype.jsonName = "";

        /**
         * FieldDescriptorProto options.
         * @member {google.protobuf.IFieldOptions|null|undefined} options
         * @memberof google.protobuf.FieldDescriptorProto
         * @instance
         */
        FieldDescriptorProto.prototype.options = null;

        /**
         * Creates a new FieldDescriptorProto instance using the specified properties.
         * @function create
         * @memberof google.protobuf.FieldDescriptorProto
         * @static
         * @param {google.protobuf.IFieldDescriptorProto=} [properties] Properties to set
         * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto instance
         */
        FieldDescriptorProto.create = function create(properties) {
          return new FieldDescriptorProto(properties);
        };

        /**
         * Encodes the specified FieldDescriptorProto message. Does not implicitly {@link google.protobuf.FieldDescriptorProto.verify|verify} messages.
         * @function encode
         * @memberof google.protobuf.FieldDescriptorProto
         * @static
         * @param {google.protobuf.IFieldDescriptorProto} message FieldDescriptorProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FieldDescriptorProto.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.name != null && Object.hasOwnProperty.call(message, "name"))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.name);
          if (message.extendee != null && Object.hasOwnProperty.call(message, "extendee"))
            writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.extendee);
          if (message.number != null && Object.hasOwnProperty.call(message, "number"))
            writer.uint32(/* id 3, wireType 0 =*/ 24).int32(message.number);
          if (message.label != null && Object.hasOwnProperty.call(message, "label"))
            writer.uint32(/* id 4, wireType 0 =*/ 32).int32(message.label);
          if (message.type != null && Object.hasOwnProperty.call(message, "type"))
            writer.uint32(/* id 5, wireType 0 =*/ 40).int32(message.type);
          if (message.typeName != null && Object.hasOwnProperty.call(message, "typeName"))
            writer.uint32(/* id 6, wireType 2 =*/ 50).string(message.typeName);
          if (message.defaultValue != null && Object.hasOwnProperty.call(message, "defaultValue"))
            writer.uint32(/* id 7, wireType 2 =*/ 58).string(message.defaultValue);
          if (message.options != null && Object.hasOwnProperty.call(message, "options"))
            $root.google.protobuf.FieldOptions.encode(
              message.options,
              writer.uint32(/* id 8, wireType 2 =*/ 66).fork(),
            ).ldelim();
          if (message.oneofIndex != null && Object.hasOwnProperty.call(message, "oneofIndex"))
            writer.uint32(/* id 9, wireType 0 =*/ 72).int32(message.oneofIndex);
          if (message.jsonName != null && Object.hasOwnProperty.call(message, "jsonName"))
            writer.uint32(/* id 10, wireType 2 =*/ 82).string(message.jsonName);
          return writer;
        };

        /**
         * Encodes the specified FieldDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.FieldDescriptorProto.verify|verify} messages.
         * @function encodeDelimited
         * @memberof google.protobuf.FieldDescriptorProto
         * @static
         * @param {google.protobuf.IFieldDescriptorProto} message FieldDescriptorProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FieldDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FieldDescriptorProto message from the specified reader or buffer.
         * @function decode
         * @memberof google.protobuf.FieldDescriptorProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FieldDescriptorProto.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.google.protobuf.FieldDescriptorProto();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.name = reader.string();
                break;
              case 3:
                message.number = reader.int32();
                break;
              case 4:
                message.label = reader.int32();
                break;
              case 5:
                message.type = reader.int32();
                break;
              case 6:
                message.typeName = reader.string();
                break;
              case 2:
                message.extendee = reader.string();
                break;
              case 7:
                message.defaultValue = reader.string();
                break;
              case 9:
                message.oneofIndex = reader.int32();
                break;
              case 10:
                message.jsonName = reader.string();
                break;
              case 8:
                message.options = $root.google.protobuf.FieldOptions.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a FieldDescriptorProto message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof google.protobuf.FieldDescriptorProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FieldDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FieldDescriptorProto message.
         * @function verify
         * @memberof google.protobuf.FieldDescriptorProto
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FieldDescriptorProto.verify = function verify(message) {
          if (typeof message !== "object" || message === null) return "object expected";
          if (message.name != null && message.hasOwnProperty("name"))
            if (!$util.isString(message.name)) return "name: string expected";
          if (message.number != null && message.hasOwnProperty("number"))
            if (!$util.isInteger(message.number)) return "number: integer expected";
          if (message.label != null && message.hasOwnProperty("label"))
            switch (message.label) {
              default:
                return "label: enum value expected";
              case 1:
              case 2:
              case 3:
                break;
            }
          if (message.type != null && message.hasOwnProperty("type"))
            switch (message.type) {
              default:
                return "type: enum value expected";
              case 1:
              case 2:
              case 3:
              case 4:
              case 5:
              case 6:
              case 7:
              case 8:
              case 9:
              case 10:
              case 11:
              case 12:
              case 13:
              case 14:
              case 15:
              case 16:
              case 17:
              case 18:
                break;
            }
          if (message.typeName != null && message.hasOwnProperty("typeName"))
            if (!$util.isString(message.typeName)) return "typeName: string expected";
          if (message.extendee != null && message.hasOwnProperty("extendee"))
            if (!$util.isString(message.extendee)) return "extendee: string expected";
          if (message.defaultValue != null && message.hasOwnProperty("defaultValue"))
            if (!$util.isString(message.defaultValue)) return "defaultValue: string expected";
          if (message.oneofIndex != null && message.hasOwnProperty("oneofIndex"))
            if (!$util.isInteger(message.oneofIndex)) return "oneofIndex: integer expected";
          if (message.jsonName != null && message.hasOwnProperty("jsonName"))
            if (!$util.isString(message.jsonName)) return "jsonName: string expected";
          if (message.options != null && message.hasOwnProperty("options")) {
            var error = $root.google.protobuf.FieldOptions.verify(message.options);
            if (error) return "options." + error;
          }
          return null;
        };

        /**
         * Creates a FieldDescriptorProto message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof google.protobuf.FieldDescriptorProto
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto
         */
        FieldDescriptorProto.fromObject = function fromObject(object) {
          if (object instanceof $root.google.protobuf.FieldDescriptorProto) return object;
          var message = new $root.google.protobuf.FieldDescriptorProto();
          if (object.name != null) message.name = String(object.name);
          if (object.number != null) message.number = object.number | 0;
          switch (object.label) {
            case "LABEL_OPTIONAL":
            case 1:
              message.label = 1;
              break;
            case "LABEL_REQUIRED":
            case 2:
              message.label = 2;
              break;
            case "LABEL_REPEATED":
            case 3:
              message.label = 3;
              break;
          }
          switch (object.type) {
            case "TYPE_DOUBLE":
            case 1:
              message.type = 1;
              break;
            case "TYPE_FLOAT":
            case 2:
              message.type = 2;
              break;
            case "TYPE_INT64":
            case 3:
              message.type = 3;
              break;
            case "TYPE_UINT64":
            case 4:
              message.type = 4;
              break;
            case "TYPE_INT32":
            case 5:
              message.type = 5;
              break;
            case "TYPE_FIXED64":
            case 6:
              message.type = 6;
              break;
            case "TYPE_FIXED32":
            case 7:
              message.type = 7;
              break;
            case "TYPE_BOOL":
            case 8:
              message.type = 8;
              break;
            case "TYPE_STRING":
            case 9:
              message.type = 9;
              break;
            case "TYPE_GROUP":
            case 10:
              message.type = 10;
              break;
            case "TYPE_MESSAGE":
            case 11:
              message.type = 11;
              break;
            case "TYPE_BYTES":
            case 12:
              message.type = 12;
              break;
            case "TYPE_UINT32":
            case 13:
              message.type = 13;
              break;
            case "TYPE_ENUM":
            case 14:
              message.type = 14;
              break;
            case "TYPE_SFIXED32":
            case 15:
              message.type = 15;
              break;
            case "TYPE_SFIXED64":
            case 16:
              message.type = 16;
              break;
            case "TYPE_SINT32":
            case 17:
              message.type = 17;
              break;
            case "TYPE_SINT64":
            case 18:
              message.type = 18;
              break;
          }
          if (object.typeName != null) message.typeName = String(object.typeName);
          if (object.extendee != null) message.extendee = String(object.extendee);
          if (object.defaultValue != null) message.defaultValue = String(object.defaultValue);
          if (object.oneofIndex != null) message.oneofIndex = object.oneofIndex | 0;
          if (object.jsonName != null) message.jsonName = String(object.jsonName);
          if (object.options != null) {
            if (typeof object.options !== "object")
              throw TypeError(".google.protobuf.FieldDescriptorProto.options: object expected");
            message.options = $root.google.protobuf.FieldOptions.fromObject(object.options);
          }
          return message;
        };

        /**
         * Creates a plain object from a FieldDescriptorProto message. Also converts values to other types if specified.
         * @function toObject
         * @memberof google.protobuf.FieldDescriptorProto
         * @static
         * @param {google.protobuf.FieldDescriptorProto} message FieldDescriptorProto
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FieldDescriptorProto.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.name = "";
            object.extendee = "";
            object.number = 0;
            object.label = options.enums === String ? "LABEL_OPTIONAL" : 1;
            object.type = options.enums === String ? "TYPE_DOUBLE" : 1;
            object.typeName = "";
            object.defaultValue = "";
            object.options = null;
            object.oneofIndex = 0;
            object.jsonName = "";
          }
          if (message.name != null && message.hasOwnProperty("name")) object.name = message.name;
          if (message.extendee != null && message.hasOwnProperty("extendee"))
            object.extendee = message.extendee;
          if (message.number != null && message.hasOwnProperty("number")) object.number = message.number;
          if (message.label != null && message.hasOwnProperty("label"))
            object.label =
              options.enums === String
                ? $root.google.protobuf.FieldDescriptorProto.Label[message.label]
                : message.label;
          if (message.type != null && message.hasOwnProperty("type"))
            object.type =
              options.enums === String
                ? $root.google.protobuf.FieldDescriptorProto.Type[message.type]
                : message.type;
          if (message.typeName != null && message.hasOwnProperty("typeName"))
            object.typeName = message.typeName;
          if (message.defaultValue != null && message.hasOwnProperty("defaultValue"))
            object.defaultValue = message.defaultValue;
          if (message.options != null && message.hasOwnProperty("options"))
            object.options = $root.google.protobuf.FieldOptions.toObject(message.options, options);
          if (message.oneofIndex != null && message.hasOwnProperty("oneofIndex"))
            object.oneofIndex = message.oneofIndex;
          if (message.jsonName != null && message.hasOwnProperty("jsonName"))
            object.jsonName = message.jsonName;
          return object;
        };

        /**
         * Converts this FieldDescriptorProto to JSON.
         * @function toJSON
         * @memberof google.protobuf.FieldDescriptorProto
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FieldDescriptorProto.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Type enum.
         * @name google.protobuf.FieldDescriptorProto.Type
         * @enum {number}
         * @property {number} TYPE_DOUBLE=1 TYPE_DOUBLE value
         * @property {number} TYPE_FLOAT=2 TYPE_FLOAT value
         * @property {number} TYPE_INT64=3 TYPE_INT64 value
         * @property {number} TYPE_UINT64=4 TYPE_UINT64 value
         * @property {number} TYPE_INT32=5 TYPE_INT32 value
         * @property {number} TYPE_FIXED64=6 TYPE_FIXED64 value
         * @property {number} TYPE_FIXED32=7 TYPE_FIXED32 value
         * @property {number} TYPE_BOOL=8 TYPE_BOOL value
         * @property {number} TYPE_STRING=9 TYPE_STRING value
         * @property {number} TYPE_GROUP=10 TYPE_GROUP value
         * @property {number} TYPE_MESSAGE=11 TYPE_MESSAGE value
         * @property {number} TYPE_BYTES=12 TYPE_BYTES value
         * @property {number} TYPE_UINT32=13 TYPE_UINT32 value
         * @property {number} TYPE_ENUM=14 TYPE_ENUM value
         * @property {number} TYPE_SFIXED32=15 TYPE_SFIXED32 value
         * @property {number} TYPE_SFIXED64=16 TYPE_SFIXED64 value
         * @property {number} TYPE_SINT32=17 TYPE_SINT32 value
         * @property {number} TYPE_SINT64=18 TYPE_SINT64 value
         */
        FieldDescriptorProto.Type = (function () {
          var valuesById = {},
            values = Object.create(valuesById);
          values[(valuesById[1] = "TYPE_DOUBLE")] = 1;
          values[(valuesById[2] = "TYPE_FLOAT")] = 2;
          values[(valuesById[3] = "TYPE_INT64")] = 3;
          values[(valuesById[4] = "TYPE_UINT64")] = 4;
          values[(valuesById[5] = "TYPE_INT32")] = 5;
          values[(valuesById[6] = "TYPE_FIXED64")] = 6;
          values[(valuesById[7] = "TYPE_FIXED32")] = 7;
          values[(valuesById[8] = "TYPE_BOOL")] = 8;
          values[(valuesById[9] = "TYPE_STRING")] = 9;
          values[(valuesById[10] = "TYPE_GROUP")] = 10;
          values[(valuesById[11] = "TYPE_MESSAGE")] = 11;
          values[(valuesById[12] = "TYPE_BYTES")] = 12;
          values[(valuesById[13] = "TYPE_UINT32")] = 13;
          values[(valuesById[14] = "TYPE_ENUM")] = 14;
          values[(valuesById[15] = "TYPE_SFIXED32")] = 15;
          values[(valuesById[16] = "TYPE_SFIXED64")] = 16;
          values[(valuesById[17] = "TYPE_SINT32")] = 17;
          values[(valuesById[18] = "TYPE_SINT64")] = 18;
          return values;
        })();

        /**
         * Label enum.
         * @name google.protobuf.FieldDescriptorProto.Label
         * @enum {number}
         * @property {number} LABEL_OPTIONAL=1 LABEL_OPTIONAL value
         * @property {number} LABEL_REQUIRED=2 LABEL_REQUIRED value
         * @property {number} LABEL_REPEATED=3 LABEL_REPEATED value
         */
        FieldDescriptorProto.Label = (function () {
          var valuesById = {},
            values = Object.create(valuesById);
          values[(valuesById[1] = "LABEL_OPTIONAL")] = 1;
          values[(valuesById[2] = "LABEL_REQUIRED")] = 2;
          values[(valuesById[3] = "LABEL_REPEATED")] = 3;
          return values;
        })();

        return FieldDescriptorProto;
      })();

      protobuf.OneofDescriptorProto = (function () {
        /**
         * Properties of an OneofDescriptorProto.
         * @memberof google.protobuf
         * @interface IOneofDescriptorProto
         * @property {string|null} [name] OneofDescriptorProto name
         * @property {google.protobuf.IOneofOptions|null} [options] OneofDescriptorProto options
         */

        /**
         * Constructs a new OneofDescriptorProto.
         * @memberof google.protobuf
         * @classdesc Represents an OneofDescriptorProto.
         * @implements IOneofDescriptorProto
         * @constructor
         * @param {google.protobuf.IOneofDescriptorProto=} [properties] Properties to set
         */
        function OneofDescriptorProto(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * OneofDescriptorProto name.
         * @member {string} name
         * @memberof google.protobuf.OneofDescriptorProto
         * @instance
         */
        OneofDescriptorProto.prototype.name = "";

        /**
         * OneofDescriptorProto options.
         * @member {google.protobuf.IOneofOptions|null|undefined} options
         * @memberof google.protobuf.OneofDescriptorProto
         * @instance
         */
        OneofDescriptorProto.prototype.options = null;

        /**
         * Creates a new OneofDescriptorProto instance using the specified properties.
         * @function create
         * @memberof google.protobuf.OneofDescriptorProto
         * @static
         * @param {google.protobuf.IOneofDescriptorProto=} [properties] Properties to set
         * @returns {google.protobuf.OneofDescriptorProto} OneofDescriptorProto instance
         */
        OneofDescriptorProto.create = function create(properties) {
          return new OneofDescriptorProto(properties);
        };

        /**
         * Encodes the specified OneofDescriptorProto message. Does not implicitly {@link google.protobuf.OneofDescriptorProto.verify|verify} messages.
         * @function encode
         * @memberof google.protobuf.OneofDescriptorProto
         * @static
         * @param {google.protobuf.IOneofDescriptorProto} message OneofDescriptorProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OneofDescriptorProto.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.name != null && Object.hasOwnProperty.call(message, "name"))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.name);
          if (message.options != null && Object.hasOwnProperty.call(message, "options"))
            $root.google.protobuf.OneofOptions.encode(
              message.options,
              writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
            ).ldelim();
          return writer;
        };

        /**
         * Encodes the specified OneofDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.OneofDescriptorProto.verify|verify} messages.
         * @function encodeDelimited
         * @memberof google.protobuf.OneofDescriptorProto
         * @static
         * @param {google.protobuf.IOneofDescriptorProto} message OneofDescriptorProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OneofDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an OneofDescriptorProto message from the specified reader or buffer.
         * @function decode
         * @memberof google.protobuf.OneofDescriptorProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {google.protobuf.OneofDescriptorProto} OneofDescriptorProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OneofDescriptorProto.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.google.protobuf.OneofDescriptorProto();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.name = reader.string();
                break;
              case 2:
                message.options = $root.google.protobuf.OneofOptions.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes an OneofDescriptorProto message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof google.protobuf.OneofDescriptorProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {google.protobuf.OneofDescriptorProto} OneofDescriptorProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OneofDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an OneofDescriptorProto message.
         * @function verify
         * @memberof google.protobuf.OneofDescriptorProto
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        OneofDescriptorProto.verify = function verify(message) {
          if (typeof message !== "object" || message === null) return "object expected";
          if (message.name != null && message.hasOwnProperty("name"))
            if (!$util.isString(message.name)) return "name: string expected";
          if (message.options != null && message.hasOwnProperty("options")) {
            var error = $root.google.protobuf.OneofOptions.verify(message.options);
            if (error) return "options." + error;
          }
          return null;
        };

        /**
         * Creates an OneofDescriptorProto message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof google.protobuf.OneofDescriptorProto
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {google.protobuf.OneofDescriptorProto} OneofDescriptorProto
         */
        OneofDescriptorProto.fromObject = function fromObject(object) {
          if (object instanceof $root.google.protobuf.OneofDescriptorProto) return object;
          var message = new $root.google.protobuf.OneofDescriptorProto();
          if (object.name != null) message.name = String(object.name);
          if (object.options != null) {
            if (typeof object.options !== "object")
              throw TypeError(".google.protobuf.OneofDescriptorProto.options: object expected");
            message.options = $root.google.protobuf.OneofOptions.fromObject(object.options);
          }
          return message;
        };

        /**
         * Creates a plain object from an OneofDescriptorProto message. Also converts values to other types if specified.
         * @function toObject
         * @memberof google.protobuf.OneofDescriptorProto
         * @static
         * @param {google.protobuf.OneofDescriptorProto} message OneofDescriptorProto
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        OneofDescriptorProto.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.name = "";
            object.options = null;
          }
          if (message.name != null && message.hasOwnProperty("name")) object.name = message.name;
          if (message.options != null && message.hasOwnProperty("options"))
            object.options = $root.google.protobuf.OneofOptions.toObject(message.options, options);
          return object;
        };

        /**
         * Converts this OneofDescriptorProto to JSON.
         * @function toJSON
         * @memberof google.protobuf.OneofDescriptorProto
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        OneofDescriptorProto.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return OneofDescriptorProto;
      })();

      protobuf.EnumDescriptorProto = (function () {
        /**
         * Properties of an EnumDescriptorProto.
         * @memberof google.protobuf
         * @interface IEnumDescriptorProto
         * @property {string|null} [name] EnumDescriptorProto name
         * @property {Array.<google.protobuf.IEnumValueDescriptorProto>|null} [value] EnumDescriptorProto value
         * @property {google.protobuf.IEnumOptions|null} [options] EnumDescriptorProto options
         */

        /**
         * Constructs a new EnumDescriptorProto.
         * @memberof google.protobuf
         * @classdesc Represents an EnumDescriptorProto.
         * @implements IEnumDescriptorProto
         * @constructor
         * @param {google.protobuf.IEnumDescriptorProto=} [properties] Properties to set
         */
        function EnumDescriptorProto(properties) {
          this.value = [];
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * EnumDescriptorProto name.
         * @member {string} name
         * @memberof google.protobuf.EnumDescriptorProto
         * @instance
         */
        EnumDescriptorProto.prototype.name = "";

        /**
         * EnumDescriptorProto value.
         * @member {Array.<google.protobuf.IEnumValueDescriptorProto>} value
         * @memberof google.protobuf.EnumDescriptorProto
         * @instance
         */
        EnumDescriptorProto.prototype.value = $util.emptyArray;

        /**
         * EnumDescriptorProto options.
         * @member {google.protobuf.IEnumOptions|null|undefined} options
         * @memberof google.protobuf.EnumDescriptorProto
         * @instance
         */
        EnumDescriptorProto.prototype.options = null;

        /**
         * Creates a new EnumDescriptorProto instance using the specified properties.
         * @function create
         * @memberof google.protobuf.EnumDescriptorProto
         * @static
         * @param {google.protobuf.IEnumDescriptorProto=} [properties] Properties to set
         * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto instance
         */
        EnumDescriptorProto.create = function create(properties) {
          return new EnumDescriptorProto(properties);
        };

        /**
         * Encodes the specified EnumDescriptorProto message. Does not implicitly {@link google.protobuf.EnumDescriptorProto.verify|verify} messages.
         * @function encode
         * @memberof google.protobuf.EnumDescriptorProto
         * @static
         * @param {google.protobuf.IEnumDescriptorProto} message EnumDescriptorProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EnumDescriptorProto.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.name != null && Object.hasOwnProperty.call(message, "name"))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.name);
          if (message.value != null && message.value.length)
            for (var i = 0; i < message.value.length; ++i)
              $root.google.protobuf.EnumValueDescriptorProto.encode(
                message.value[i],
                writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
              ).ldelim();
          if (message.options != null && Object.hasOwnProperty.call(message, "options"))
            $root.google.protobuf.EnumOptions.encode(
              message.options,
              writer.uint32(/* id 3, wireType 2 =*/ 26).fork(),
            ).ldelim();
          return writer;
        };

        /**
         * Encodes the specified EnumDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.EnumDescriptorProto.verify|verify} messages.
         * @function encodeDelimited
         * @memberof google.protobuf.EnumDescriptorProto
         * @static
         * @param {google.protobuf.IEnumDescriptorProto} message EnumDescriptorProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EnumDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EnumDescriptorProto message from the specified reader or buffer.
         * @function decode
         * @memberof google.protobuf.EnumDescriptorProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EnumDescriptorProto.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.google.protobuf.EnumDescriptorProto();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.name = reader.string();
                break;
              case 2:
                if (!(message.value && message.value.length)) message.value = [];
                message.value.push(
                  $root.google.protobuf.EnumValueDescriptorProto.decode(reader, reader.uint32()),
                );
                break;
              case 3:
                message.options = $root.google.protobuf.EnumOptions.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes an EnumDescriptorProto message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof google.protobuf.EnumDescriptorProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EnumDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EnumDescriptorProto message.
         * @function verify
         * @memberof google.protobuf.EnumDescriptorProto
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EnumDescriptorProto.verify = function verify(message) {
          if (typeof message !== "object" || message === null) return "object expected";
          if (message.name != null && message.hasOwnProperty("name"))
            if (!$util.isString(message.name)) return "name: string expected";
          if (message.value != null && message.hasOwnProperty("value")) {
            if (!Array.isArray(message.value)) return "value: array expected";
            for (var i = 0; i < message.value.length; ++i) {
              var error = $root.google.protobuf.EnumValueDescriptorProto.verify(message.value[i]);
              if (error) return "value." + error;
            }
          }
          if (message.options != null && message.hasOwnProperty("options")) {
            var error = $root.google.protobuf.EnumOptions.verify(message.options);
            if (error) return "options." + error;
          }
          return null;
        };

        /**
         * Creates an EnumDescriptorProto message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof google.protobuf.EnumDescriptorProto
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto
         */
        EnumDescriptorProto.fromObject = function fromObject(object) {
          if (object instanceof $root.google.protobuf.EnumDescriptorProto) return object;
          var message = new $root.google.protobuf.EnumDescriptorProto();
          if (object.name != null) message.name = String(object.name);
          if (object.value) {
            if (!Array.isArray(object.value))
              throw TypeError(".google.protobuf.EnumDescriptorProto.value: array expected");
            message.value = [];
            for (var i = 0; i < object.value.length; ++i) {
              if (typeof object.value[i] !== "object")
                throw TypeError(".google.protobuf.EnumDescriptorProto.value: object expected");
              message.value[i] = $root.google.protobuf.EnumValueDescriptorProto.fromObject(object.value[i]);
            }
          }
          if (object.options != null) {
            if (typeof object.options !== "object")
              throw TypeError(".google.protobuf.EnumDescriptorProto.options: object expected");
            message.options = $root.google.protobuf.EnumOptions.fromObject(object.options);
          }
          return message;
        };

        /**
         * Creates a plain object from an EnumDescriptorProto message. Also converts values to other types if specified.
         * @function toObject
         * @memberof google.protobuf.EnumDescriptorProto
         * @static
         * @param {google.protobuf.EnumDescriptorProto} message EnumDescriptorProto
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EnumDescriptorProto.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.arrays || options.defaults) object.value = [];
          if (options.defaults) {
            object.name = "";
            object.options = null;
          }
          if (message.name != null && message.hasOwnProperty("name")) object.name = message.name;
          if (message.value && message.value.length) {
            object.value = [];
            for (var j = 0; j < message.value.length; ++j)
              object.value[j] = $root.google.protobuf.EnumValueDescriptorProto.toObject(
                message.value[j],
                options,
              );
          }
          if (message.options != null && message.hasOwnProperty("options"))
            object.options = $root.google.protobuf.EnumOptions.toObject(message.options, options);
          return object;
        };

        /**
         * Converts this EnumDescriptorProto to JSON.
         * @function toJSON
         * @memberof google.protobuf.EnumDescriptorProto
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EnumDescriptorProto.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return EnumDescriptorProto;
      })();

      protobuf.EnumValueDescriptorProto = (function () {
        /**
         * Properties of an EnumValueDescriptorProto.
         * @memberof google.protobuf
         * @interface IEnumValueDescriptorProto
         * @property {string|null} [name] EnumValueDescriptorProto name
         * @property {number|null} [number] EnumValueDescriptorProto number
         * @property {google.protobuf.IEnumValueOptions|null} [options] EnumValueDescriptorProto options
         */

        /**
         * Constructs a new EnumValueDescriptorProto.
         * @memberof google.protobuf
         * @classdesc Represents an EnumValueDescriptorProto.
         * @implements IEnumValueDescriptorProto
         * @constructor
         * @param {google.protobuf.IEnumValueDescriptorProto=} [properties] Properties to set
         */
        function EnumValueDescriptorProto(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * EnumValueDescriptorProto name.
         * @member {string} name
         * @memberof google.protobuf.EnumValueDescriptorProto
         * @instance
         */
        EnumValueDescriptorProto.prototype.name = "";

        /**
         * EnumValueDescriptorProto number.
         * @member {number} number
         * @memberof google.protobuf.EnumValueDescriptorProto
         * @instance
         */
        EnumValueDescriptorProto.prototype.number = 0;

        /**
         * EnumValueDescriptorProto options.
         * @member {google.protobuf.IEnumValueOptions|null|undefined} options
         * @memberof google.protobuf.EnumValueDescriptorProto
         * @instance
         */
        EnumValueDescriptorProto.prototype.options = null;

        /**
         * Creates a new EnumValueDescriptorProto instance using the specified properties.
         * @function create
         * @memberof google.protobuf.EnumValueDescriptorProto
         * @static
         * @param {google.protobuf.IEnumValueDescriptorProto=} [properties] Properties to set
         * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto instance
         */
        EnumValueDescriptorProto.create = function create(properties) {
          return new EnumValueDescriptorProto(properties);
        };

        /**
         * Encodes the specified EnumValueDescriptorProto message. Does not implicitly {@link google.protobuf.EnumValueDescriptorProto.verify|verify} messages.
         * @function encode
         * @memberof google.protobuf.EnumValueDescriptorProto
         * @static
         * @param {google.protobuf.IEnumValueDescriptorProto} message EnumValueDescriptorProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EnumValueDescriptorProto.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.name != null && Object.hasOwnProperty.call(message, "name"))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.name);
          if (message.number != null && Object.hasOwnProperty.call(message, "number"))
            writer.uint32(/* id 2, wireType 0 =*/ 16).int32(message.number);
          if (message.options != null && Object.hasOwnProperty.call(message, "options"))
            $root.google.protobuf.EnumValueOptions.encode(
              message.options,
              writer.uint32(/* id 3, wireType 2 =*/ 26).fork(),
            ).ldelim();
          return writer;
        };

        /**
         * Encodes the specified EnumValueDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.EnumValueDescriptorProto.verify|verify} messages.
         * @function encodeDelimited
         * @memberof google.protobuf.EnumValueDescriptorProto
         * @static
         * @param {google.protobuf.IEnumValueDescriptorProto} message EnumValueDescriptorProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EnumValueDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EnumValueDescriptorProto message from the specified reader or buffer.
         * @function decode
         * @memberof google.protobuf.EnumValueDescriptorProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EnumValueDescriptorProto.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.google.protobuf.EnumValueDescriptorProto();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.name = reader.string();
                break;
              case 2:
                message.number = reader.int32();
                break;
              case 3:
                message.options = $root.google.protobuf.EnumValueOptions.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes an EnumValueDescriptorProto message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof google.protobuf.EnumValueDescriptorProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EnumValueDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EnumValueDescriptorProto message.
         * @function verify
         * @memberof google.protobuf.EnumValueDescriptorProto
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EnumValueDescriptorProto.verify = function verify(message) {
          if (typeof message !== "object" || message === null) return "object expected";
          if (message.name != null && message.hasOwnProperty("name"))
            if (!$util.isString(message.name)) return "name: string expected";
          if (message.number != null && message.hasOwnProperty("number"))
            if (!$util.isInteger(message.number)) return "number: integer expected";
          if (message.options != null && message.hasOwnProperty("options")) {
            var error = $root.google.protobuf.EnumValueOptions.verify(message.options);
            if (error) return "options." + error;
          }
          return null;
        };

        /**
         * Creates an EnumValueDescriptorProto message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof google.protobuf.EnumValueDescriptorProto
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto
         */
        EnumValueDescriptorProto.fromObject = function fromObject(object) {
          if (object instanceof $root.google.protobuf.EnumValueDescriptorProto) return object;
          var message = new $root.google.protobuf.EnumValueDescriptorProto();
          if (object.name != null) message.name = String(object.name);
          if (object.number != null) message.number = object.number | 0;
          if (object.options != null) {
            if (typeof object.options !== "object")
              throw TypeError(".google.protobuf.EnumValueDescriptorProto.options: object expected");
            message.options = $root.google.protobuf.EnumValueOptions.fromObject(object.options);
          }
          return message;
        };

        /**
         * Creates a plain object from an EnumValueDescriptorProto message. Also converts values to other types if specified.
         * @function toObject
         * @memberof google.protobuf.EnumValueDescriptorProto
         * @static
         * @param {google.protobuf.EnumValueDescriptorProto} message EnumValueDescriptorProto
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EnumValueDescriptorProto.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.name = "";
            object.number = 0;
            object.options = null;
          }
          if (message.name != null && message.hasOwnProperty("name")) object.name = message.name;
          if (message.number != null && message.hasOwnProperty("number")) object.number = message.number;
          if (message.options != null && message.hasOwnProperty("options"))
            object.options = $root.google.protobuf.EnumValueOptions.toObject(message.options, options);
          return object;
        };

        /**
         * Converts this EnumValueDescriptorProto to JSON.
         * @function toJSON
         * @memberof google.protobuf.EnumValueDescriptorProto
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EnumValueDescriptorProto.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return EnumValueDescriptorProto;
      })();

      protobuf.ServiceDescriptorProto = (function () {
        /**
         * Properties of a ServiceDescriptorProto.
         * @memberof google.protobuf
         * @interface IServiceDescriptorProto
         * @property {string|null} [name] ServiceDescriptorProto name
         * @property {Array.<google.protobuf.IMethodDescriptorProto>|null} [method] ServiceDescriptorProto method
         * @property {google.protobuf.IServiceOptions|null} [options] ServiceDescriptorProto options
         */

        /**
         * Constructs a new ServiceDescriptorProto.
         * @memberof google.protobuf
         * @classdesc Represents a ServiceDescriptorProto.
         * @implements IServiceDescriptorProto
         * @constructor
         * @param {google.protobuf.IServiceDescriptorProto=} [properties] Properties to set
         */
        function ServiceDescriptorProto(properties) {
          this.method = [];
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * ServiceDescriptorProto name.
         * @member {string} name
         * @memberof google.protobuf.ServiceDescriptorProto
         * @instance
         */
        ServiceDescriptorProto.prototype.name = "";

        /**
         * ServiceDescriptorProto method.
         * @member {Array.<google.protobuf.IMethodDescriptorProto>} method
         * @memberof google.protobuf.ServiceDescriptorProto
         * @instance
         */
        ServiceDescriptorProto.prototype.method = $util.emptyArray;

        /**
         * ServiceDescriptorProto options.
         * @member {google.protobuf.IServiceOptions|null|undefined} options
         * @memberof google.protobuf.ServiceDescriptorProto
         * @instance
         */
        ServiceDescriptorProto.prototype.options = null;

        /**
         * Creates a new ServiceDescriptorProto instance using the specified properties.
         * @function create
         * @memberof google.protobuf.ServiceDescriptorProto
         * @static
         * @param {google.protobuf.IServiceDescriptorProto=} [properties] Properties to set
         * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto instance
         */
        ServiceDescriptorProto.create = function create(properties) {
          return new ServiceDescriptorProto(properties);
        };

        /**
         * Encodes the specified ServiceDescriptorProto message. Does not implicitly {@link google.protobuf.ServiceDescriptorProto.verify|verify} messages.
         * @function encode
         * @memberof google.protobuf.ServiceDescriptorProto
         * @static
         * @param {google.protobuf.IServiceDescriptorProto} message ServiceDescriptorProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServiceDescriptorProto.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.name != null && Object.hasOwnProperty.call(message, "name"))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.name);
          if (message.method != null && message.method.length)
            for (var i = 0; i < message.method.length; ++i)
              $root.google.protobuf.MethodDescriptorProto.encode(
                message.method[i],
                writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
              ).ldelim();
          if (message.options != null && Object.hasOwnProperty.call(message, "options"))
            $root.google.protobuf.ServiceOptions.encode(
              message.options,
              writer.uint32(/* id 3, wireType 2 =*/ 26).fork(),
            ).ldelim();
          return writer;
        };

        /**
         * Encodes the specified ServiceDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.ServiceDescriptorProto.verify|verify} messages.
         * @function encodeDelimited
         * @memberof google.protobuf.ServiceDescriptorProto
         * @static
         * @param {google.protobuf.IServiceDescriptorProto} message ServiceDescriptorProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServiceDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ServiceDescriptorProto message from the specified reader or buffer.
         * @function decode
         * @memberof google.protobuf.ServiceDescriptorProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServiceDescriptorProto.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.google.protobuf.ServiceDescriptorProto();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.name = reader.string();
                break;
              case 2:
                if (!(message.method && message.method.length)) message.method = [];
                message.method.push(
                  $root.google.protobuf.MethodDescriptorProto.decode(reader, reader.uint32()),
                );
                break;
              case 3:
                message.options = $root.google.protobuf.ServiceOptions.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a ServiceDescriptorProto message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof google.protobuf.ServiceDescriptorProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServiceDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ServiceDescriptorProto message.
         * @function verify
         * @memberof google.protobuf.ServiceDescriptorProto
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ServiceDescriptorProto.verify = function verify(message) {
          if (typeof message !== "object" || message === null) return "object expected";
          if (message.name != null && message.hasOwnProperty("name"))
            if (!$util.isString(message.name)) return "name: string expected";
          if (message.method != null && message.hasOwnProperty("method")) {
            if (!Array.isArray(message.method)) return "method: array expected";
            for (var i = 0; i < message.method.length; ++i) {
              var error = $root.google.protobuf.MethodDescriptorProto.verify(message.method[i]);
              if (error) return "method." + error;
            }
          }
          if (message.options != null && message.hasOwnProperty("options")) {
            var error = $root.google.protobuf.ServiceOptions.verify(message.options);
            if (error) return "options." + error;
          }
          return null;
        };

        /**
         * Creates a ServiceDescriptorProto message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof google.protobuf.ServiceDescriptorProto
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto
         */
        ServiceDescriptorProto.fromObject = function fromObject(object) {
          if (object instanceof $root.google.protobuf.ServiceDescriptorProto) return object;
          var message = new $root.google.protobuf.ServiceDescriptorProto();
          if (object.name != null) message.name = String(object.name);
          if (object.method) {
            if (!Array.isArray(object.method))
              throw TypeError(".google.protobuf.ServiceDescriptorProto.method: array expected");
            message.method = [];
            for (var i = 0; i < object.method.length; ++i) {
              if (typeof object.method[i] !== "object")
                throw TypeError(".google.protobuf.ServiceDescriptorProto.method: object expected");
              message.method[i] = $root.google.protobuf.MethodDescriptorProto.fromObject(object.method[i]);
            }
          }
          if (object.options != null) {
            if (typeof object.options !== "object")
              throw TypeError(".google.protobuf.ServiceDescriptorProto.options: object expected");
            message.options = $root.google.protobuf.ServiceOptions.fromObject(object.options);
          }
          return message;
        };

        /**
         * Creates a plain object from a ServiceDescriptorProto message. Also converts values to other types if specified.
         * @function toObject
         * @memberof google.protobuf.ServiceDescriptorProto
         * @static
         * @param {google.protobuf.ServiceDescriptorProto} message ServiceDescriptorProto
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ServiceDescriptorProto.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.arrays || options.defaults) object.method = [];
          if (options.defaults) {
            object.name = "";
            object.options = null;
          }
          if (message.name != null && message.hasOwnProperty("name")) object.name = message.name;
          if (message.method && message.method.length) {
            object.method = [];
            for (var j = 0; j < message.method.length; ++j)
              object.method[j] = $root.google.protobuf.MethodDescriptorProto.toObject(
                message.method[j],
                options,
              );
          }
          if (message.options != null && message.hasOwnProperty("options"))
            object.options = $root.google.protobuf.ServiceOptions.toObject(message.options, options);
          return object;
        };

        /**
         * Converts this ServiceDescriptorProto to JSON.
         * @function toJSON
         * @memberof google.protobuf.ServiceDescriptorProto
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ServiceDescriptorProto.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ServiceDescriptorProto;
      })();

      protobuf.MethodDescriptorProto = (function () {
        /**
         * Properties of a MethodDescriptorProto.
         * @memberof google.protobuf
         * @interface IMethodDescriptorProto
         * @property {string|null} [name] MethodDescriptorProto name
         * @property {string|null} [inputType] MethodDescriptorProto inputType
         * @property {string|null} [outputType] MethodDescriptorProto outputType
         * @property {google.protobuf.IMethodOptions|null} [options] MethodDescriptorProto options
         * @property {boolean|null} [clientStreaming] MethodDescriptorProto clientStreaming
         * @property {boolean|null} [serverStreaming] MethodDescriptorProto serverStreaming
         */

        /**
         * Constructs a new MethodDescriptorProto.
         * @memberof google.protobuf
         * @classdesc Represents a MethodDescriptorProto.
         * @implements IMethodDescriptorProto
         * @constructor
         * @param {google.protobuf.IMethodDescriptorProto=} [properties] Properties to set
         */
        function MethodDescriptorProto(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * MethodDescriptorProto name.
         * @member {string} name
         * @memberof google.protobuf.MethodDescriptorProto
         * @instance
         */
        MethodDescriptorProto.prototype.name = "";

        /**
         * MethodDescriptorProto inputType.
         * @member {string} inputType
         * @memberof google.protobuf.MethodDescriptorProto
         * @instance
         */
        MethodDescriptorProto.prototype.inputType = "";

        /**
         * MethodDescriptorProto outputType.
         * @member {string} outputType
         * @memberof google.protobuf.MethodDescriptorProto
         * @instance
         */
        MethodDescriptorProto.prototype.outputType = "";

        /**
         * MethodDescriptorProto options.
         * @member {google.protobuf.IMethodOptions|null|undefined} options
         * @memberof google.protobuf.MethodDescriptorProto
         * @instance
         */
        MethodDescriptorProto.prototype.options = null;

        /**
         * MethodDescriptorProto clientStreaming.
         * @member {boolean} clientStreaming
         * @memberof google.protobuf.MethodDescriptorProto
         * @instance
         */
        MethodDescriptorProto.prototype.clientStreaming = false;

        /**
         * MethodDescriptorProto serverStreaming.
         * @member {boolean} serverStreaming
         * @memberof google.protobuf.MethodDescriptorProto
         * @instance
         */
        MethodDescriptorProto.prototype.serverStreaming = false;

        /**
         * Creates a new MethodDescriptorProto instance using the specified properties.
         * @function create
         * @memberof google.protobuf.MethodDescriptorProto
         * @static
         * @param {google.protobuf.IMethodDescriptorProto=} [properties] Properties to set
         * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto instance
         */
        MethodDescriptorProto.create = function create(properties) {
          return new MethodDescriptorProto(properties);
        };

        /**
         * Encodes the specified MethodDescriptorProto message. Does not implicitly {@link google.protobuf.MethodDescriptorProto.verify|verify} messages.
         * @function encode
         * @memberof google.protobuf.MethodDescriptorProto
         * @static
         * @param {google.protobuf.IMethodDescriptorProto} message MethodDescriptorProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MethodDescriptorProto.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.name != null && Object.hasOwnProperty.call(message, "name"))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.name);
          if (message.inputType != null && Object.hasOwnProperty.call(message, "inputType"))
            writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.inputType);
          if (message.outputType != null && Object.hasOwnProperty.call(message, "outputType"))
            writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.outputType);
          if (message.options != null && Object.hasOwnProperty.call(message, "options"))
            $root.google.protobuf.MethodOptions.encode(
              message.options,
              writer.uint32(/* id 4, wireType 2 =*/ 34).fork(),
            ).ldelim();
          if (message.clientStreaming != null && Object.hasOwnProperty.call(message, "clientStreaming"))
            writer.uint32(/* id 5, wireType 0 =*/ 40).bool(message.clientStreaming);
          if (message.serverStreaming != null && Object.hasOwnProperty.call(message, "serverStreaming"))
            writer.uint32(/* id 6, wireType 0 =*/ 48).bool(message.serverStreaming);
          return writer;
        };

        /**
         * Encodes the specified MethodDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.MethodDescriptorProto.verify|verify} messages.
         * @function encodeDelimited
         * @memberof google.protobuf.MethodDescriptorProto
         * @static
         * @param {google.protobuf.IMethodDescriptorProto} message MethodDescriptorProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MethodDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MethodDescriptorProto message from the specified reader or buffer.
         * @function decode
         * @memberof google.protobuf.MethodDescriptorProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MethodDescriptorProto.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.google.protobuf.MethodDescriptorProto();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.name = reader.string();
                break;
              case 2:
                message.inputType = reader.string();
                break;
              case 3:
                message.outputType = reader.string();
                break;
              case 4:
                message.options = $root.google.protobuf.MethodOptions.decode(reader, reader.uint32());
                break;
              case 5:
                message.clientStreaming = reader.bool();
                break;
              case 6:
                message.serverStreaming = reader.bool();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a MethodDescriptorProto message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof google.protobuf.MethodDescriptorProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MethodDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MethodDescriptorProto message.
         * @function verify
         * @memberof google.protobuf.MethodDescriptorProto
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MethodDescriptorProto.verify = function verify(message) {
          if (typeof message !== "object" || message === null) return "object expected";
          if (message.name != null && message.hasOwnProperty("name"))
            if (!$util.isString(message.name)) return "name: string expected";
          if (message.inputType != null && message.hasOwnProperty("inputType"))
            if (!$util.isString(message.inputType)) return "inputType: string expected";
          if (message.outputType != null && message.hasOwnProperty("outputType"))
            if (!$util.isString(message.outputType)) return "outputType: string expected";
          if (message.options != null && message.hasOwnProperty("options")) {
            var error = $root.google.protobuf.MethodOptions.verify(message.options);
            if (error) return "options." + error;
          }
          if (message.clientStreaming != null && message.hasOwnProperty("clientStreaming"))
            if (typeof message.clientStreaming !== "boolean") return "clientStreaming: boolean expected";
          if (message.serverStreaming != null && message.hasOwnProperty("serverStreaming"))
            if (typeof message.serverStreaming !== "boolean") return "serverStreaming: boolean expected";
          return null;
        };

        /**
         * Creates a MethodDescriptorProto message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof google.protobuf.MethodDescriptorProto
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto
         */
        MethodDescriptorProto.fromObject = function fromObject(object) {
          if (object instanceof $root.google.protobuf.MethodDescriptorProto) return object;
          var message = new $root.google.protobuf.MethodDescriptorProto();
          if (object.name != null) message.name = String(object.name);
          if (object.inputType != null) message.inputType = String(object.inputType);
          if (object.outputType != null) message.outputType = String(object.outputType);
          if (object.options != null) {
            if (typeof object.options !== "object")
              throw TypeError(".google.protobuf.MethodDescriptorProto.options: object expected");
            message.options = $root.google.protobuf.MethodOptions.fromObject(object.options);
          }
          if (object.clientStreaming != null) message.clientStreaming = Boolean(object.clientStreaming);
          if (object.serverStreaming != null) message.serverStreaming = Boolean(object.serverStreaming);
          return message;
        };

        /**
         * Creates a plain object from a MethodDescriptorProto message. Also converts values to other types if specified.
         * @function toObject
         * @memberof google.protobuf.MethodDescriptorProto
         * @static
         * @param {google.protobuf.MethodDescriptorProto} message MethodDescriptorProto
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MethodDescriptorProto.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            object.name = "";
            object.inputType = "";
            object.outputType = "";
            object.options = null;
            object.clientStreaming = false;
            object.serverStreaming = false;
          }
          if (message.name != null && message.hasOwnProperty("name")) object.name = message.name;
          if (message.inputType != null && message.hasOwnProperty("inputType"))
            object.inputType = message.inputType;
          if (message.outputType != null && message.hasOwnProperty("outputType"))
            object.outputType = message.outputType;
          if (message.options != null && message.hasOwnProperty("options"))
            object.options = $root.google.protobuf.MethodOptions.toObject(message.options, options);
          if (message.clientStreaming != null && message.hasOwnProperty("clientStreaming"))
            object.clientStreaming = message.clientStreaming;
          if (message.serverStreaming != null && message.hasOwnProperty("serverStreaming"))
            object.serverStreaming = message.serverStreaming;
          return object;
        };

        /**
         * Converts this MethodDescriptorProto to JSON.
         * @function toJSON
         * @memberof google.protobuf.MethodDescriptorProto
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MethodDescriptorProto.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MethodDescriptorProto;
      })();

      protobuf.FileOptions = (function () {
        /**
         * Properties of a FileOptions.
         * @memberof google.protobuf
         * @interface IFileOptions
         * @property {string|null} [javaPackage] FileOptions javaPackage
         * @property {string|null} [javaOuterClassname] FileOptions javaOuterClassname
         * @property {boolean|null} [javaMultipleFiles] FileOptions javaMultipleFiles
         * @property {boolean|null} [javaGenerateEqualsAndHash] FileOptions javaGenerateEqualsAndHash
         * @property {boolean|null} [javaStringCheckUtf8] FileOptions javaStringCheckUtf8
         * @property {google.protobuf.FileOptions.OptimizeMode|null} [optimizeFor] FileOptions optimizeFor
         * @property {string|null} [goPackage] FileOptions goPackage
         * @property {boolean|null} [ccGenericServices] FileOptions ccGenericServices
         * @property {boolean|null} [javaGenericServices] FileOptions javaGenericServices
         * @property {boolean|null} [pyGenericServices] FileOptions pyGenericServices
         * @property {boolean|null} [deprecated] FileOptions deprecated
         * @property {boolean|null} [ccEnableArenas] FileOptions ccEnableArenas
         * @property {string|null} [objcClassPrefix] FileOptions objcClassPrefix
         * @property {string|null} [csharpNamespace] FileOptions csharpNamespace
         * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] FileOptions uninterpretedOption
         * @property {boolean|null} [".gogoproto.goprotoGettersAll"] FileOptions .gogoproto.goprotoGettersAll
         * @property {boolean|null} [".gogoproto.goprotoEnumPrefixAll"] FileOptions .gogoproto.goprotoEnumPrefixAll
         * @property {boolean|null} [".gogoproto.goprotoStringerAll"] FileOptions .gogoproto.goprotoStringerAll
         * @property {boolean|null} [".gogoproto.verboseEqualAll"] FileOptions .gogoproto.verboseEqualAll
         * @property {boolean|null} [".gogoproto.faceAll"] FileOptions .gogoproto.faceAll
         * @property {boolean|null} [".gogoproto.gostringAll"] FileOptions .gogoproto.gostringAll
         * @property {boolean|null} [".gogoproto.populateAll"] FileOptions .gogoproto.populateAll
         * @property {boolean|null} [".gogoproto.stringerAll"] FileOptions .gogoproto.stringerAll
         * @property {boolean|null} [".gogoproto.onlyoneAll"] FileOptions .gogoproto.onlyoneAll
         * @property {boolean|null} [".gogoproto.equalAll"] FileOptions .gogoproto.equalAll
         * @property {boolean|null} [".gogoproto.descriptionAll"] FileOptions .gogoproto.descriptionAll
         * @property {boolean|null} [".gogoproto.testgenAll"] FileOptions .gogoproto.testgenAll
         * @property {boolean|null} [".gogoproto.benchgenAll"] FileOptions .gogoproto.benchgenAll
         * @property {boolean|null} [".gogoproto.marshalerAll"] FileOptions .gogoproto.marshalerAll
         * @property {boolean|null} [".gogoproto.unmarshalerAll"] FileOptions .gogoproto.unmarshalerAll
         * @property {boolean|null} [".gogoproto.stableMarshalerAll"] FileOptions .gogoproto.stableMarshalerAll
         * @property {boolean|null} [".gogoproto.sizerAll"] FileOptions .gogoproto.sizerAll
         * @property {boolean|null} [".gogoproto.goprotoEnumStringerAll"] FileOptions .gogoproto.goprotoEnumStringerAll
         * @property {boolean|null} [".gogoproto.enumStringerAll"] FileOptions .gogoproto.enumStringerAll
         * @property {boolean|null} [".gogoproto.unsafeMarshalerAll"] FileOptions .gogoproto.unsafeMarshalerAll
         * @property {boolean|null} [".gogoproto.unsafeUnmarshalerAll"] FileOptions .gogoproto.unsafeUnmarshalerAll
         * @property {boolean|null} [".gogoproto.goprotoExtensionsMapAll"] FileOptions .gogoproto.goprotoExtensionsMapAll
         * @property {boolean|null} [".gogoproto.goprotoUnrecognizedAll"] FileOptions .gogoproto.goprotoUnrecognizedAll
         * @property {boolean|null} [".gogoproto.gogoprotoImport"] FileOptions .gogoproto.gogoprotoImport
         * @property {boolean|null} [".gogoproto.protosizerAll"] FileOptions .gogoproto.protosizerAll
         * @property {boolean|null} [".gogoproto.compareAll"] FileOptions .gogoproto.compareAll
         * @property {boolean|null} [".gogoproto.typedeclAll"] FileOptions .gogoproto.typedeclAll
         * @property {boolean|null} [".gogoproto.enumdeclAll"] FileOptions .gogoproto.enumdeclAll
         * @property {boolean|null} [".gogoproto.goprotoRegistration"] FileOptions .gogoproto.goprotoRegistration
         * @property {boolean|null} [".gogoproto.messagenameAll"] FileOptions .gogoproto.messagenameAll
         * @property {boolean|null} [".gogoproto.goprotoSizecacheAll"] FileOptions .gogoproto.goprotoSizecacheAll
         * @property {boolean|null} [".gogoproto.goprotoUnkeyedAll"] FileOptions .gogoproto.goprotoUnkeyedAll
         */

        /**
         * Constructs a new FileOptions.
         * @memberof google.protobuf
         * @classdesc Represents a FileOptions.
         * @implements IFileOptions
         * @constructor
         * @param {google.protobuf.IFileOptions=} [properties] Properties to set
         */
        function FileOptions(properties) {
          this.uninterpretedOption = [];
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * FileOptions javaPackage.
         * @member {string} javaPackage
         * @memberof google.protobuf.FileOptions
         * @instance
         */
        FileOptions.prototype.javaPackage = "";

        /**
         * FileOptions javaOuterClassname.
         * @member {string} javaOuterClassname
         * @memberof google.protobuf.FileOptions
         * @instance
         */
        FileOptions.prototype.javaOuterClassname = "";

        /**
         * FileOptions javaMultipleFiles.
         * @member {boolean} javaMultipleFiles
         * @memberof google.protobuf.FileOptions
         * @instance
         */
        FileOptions.prototype.javaMultipleFiles = false;

        /**
         * FileOptions javaGenerateEqualsAndHash.
         * @member {boolean} javaGenerateEqualsAndHash
         * @memberof google.protobuf.FileOptions
         * @instance
         */
        FileOptions.prototype.javaGenerateEqualsAndHash = false;

        /**
         * FileOptions javaStringCheckUtf8.
         * @member {boolean} javaStringCheckUtf8
         * @memberof google.protobuf.FileOptions
         * @instance
         */
        FileOptions.prototype.javaStringCheckUtf8 = false;

        /**
         * FileOptions optimizeFor.
         * @member {google.protobuf.FileOptions.OptimizeMode} optimizeFor
         * @memberof google.protobuf.FileOptions
         * @instance
         */
        FileOptions.prototype.optimizeFor = 1;

        /**
         * FileOptions goPackage.
         * @member {string} goPackage
         * @memberof google.protobuf.FileOptions
         * @instance
         */
        FileOptions.prototype.goPackage = "";

        /**
         * FileOptions ccGenericServices.
         * @member {boolean} ccGenericServices
         * @memberof google.protobuf.FileOptions
         * @instance
         */
        FileOptions.prototype.ccGenericServices = false;

        /**
         * FileOptions javaGenericServices.
         * @member {boolean} javaGenericServices
         * @memberof google.protobuf.FileOptions
         * @instance
         */
        FileOptions.prototype.javaGenericServices = false;

        /**
         * FileOptions pyGenericServices.
         * @member {boolean} pyGenericServices
         * @memberof google.protobuf.FileOptions
         * @instance
         */
        FileOptions.prototype.pyGenericServices = false;

        /**
         * FileOptions deprecated.
         * @member {boolean} deprecated
         * @memberof google.protobuf.FileOptions
         * @instance
         */
        FileOptions.prototype.deprecated = false;

        /**
         * FileOptions ccEnableArenas.
         * @member {boolean} ccEnableArenas
         * @memberof google.protobuf.FileOptions
         * @instance
         */
        FileOptions.prototype.ccEnableArenas = false;

        /**
         * FileOptions objcClassPrefix.
         * @member {string} objcClassPrefix
         * @memberof google.protobuf.FileOptions
         * @instance
         */
        FileOptions.prototype.objcClassPrefix = "";

        /**
         * FileOptions csharpNamespace.
         * @member {string} csharpNamespace
         * @memberof google.protobuf.FileOptions
         * @instance
         */
        FileOptions.prototype.csharpNamespace = "";

        /**
         * FileOptions uninterpretedOption.
         * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
         * @memberof google.protobuf.FileOptions
         * @instance
         */
        FileOptions.prototype.uninterpretedOption = $util.emptyArray;

        /**
         * FileOptions .gogoproto.goprotoGettersAll.
         * @member {boolean} .gogoproto.goprotoGettersAll
         * @memberof google.protobuf.FileOptions
         * @instance
         */
        FileOptions.prototype[".gogoproto.goprotoGettersAll"] = false;

        /**
         * FileOptions .gogoproto.goprotoEnumPrefixAll.
         * @member {boolean} .gogoproto.goprotoEnumPrefixAll
         * @memberof google.protobuf.FileOptions
         * @instance
         */
        FileOptions.prototype[".gogoproto.goprotoEnumPrefixAll"] = false;

        /**
         * FileOptions .gogoproto.goprotoStringerAll.
         * @member {boolean} .gogoproto.goprotoStringerAll
         * @memberof google.protobuf.FileOptions
         * @instance
         */
        FileOptions.prototype[".gogoproto.goprotoStringerAll"] = false;

        /**
         * FileOptions .gogoproto.verboseEqualAll.
         * @member {boolean} .gogoproto.verboseEqualAll
         * @memberof google.protobuf.FileOptions
         * @instance
         */
        FileOptions.prototype[".gogoproto.verboseEqualAll"] = false;

        /**
         * FileOptions .gogoproto.faceAll.
         * @member {boolean} .gogoproto.faceAll
         * @memberof google.protobuf.FileOptions
         * @instance
         */
        FileOptions.prototype[".gogoproto.faceAll"] = false;

        /**
         * FileOptions .gogoproto.gostringAll.
         * @member {boolean} .gogoproto.gostringAll
         * @memberof google.protobuf.FileOptions
         * @instance
         */
        FileOptions.prototype[".gogoproto.gostringAll"] = false;

        /**
         * FileOptions .gogoproto.populateAll.
         * @member {boolean} .gogoproto.populateAll
         * @memberof google.protobuf.FileOptions
         * @instance
         */
        FileOptions.prototype[".gogoproto.populateAll"] = false;

        /**
         * FileOptions .gogoproto.stringerAll.
         * @member {boolean} .gogoproto.stringerAll
         * @memberof google.protobuf.FileOptions
         * @instance
         */
        FileOptions.prototype[".gogoproto.stringerAll"] = false;

        /**
         * FileOptions .gogoproto.onlyoneAll.
         * @member {boolean} .gogoproto.onlyoneAll
         * @memberof google.protobuf.FileOptions
         * @instance
         */
        FileOptions.prototype[".gogoproto.onlyoneAll"] = false;

        /**
         * FileOptions .gogoproto.equalAll.
         * @member {boolean} .gogoproto.equalAll
         * @memberof google.protobuf.FileOptions
         * @instance
         */
        FileOptions.prototype[".gogoproto.equalAll"] = false;

        /**
         * FileOptions .gogoproto.descriptionAll.
         * @member {boolean} .gogoproto.descriptionAll
         * @memberof google.protobuf.FileOptions
         * @instance
         */
        FileOptions.prototype[".gogoproto.descriptionAll"] = false;

        /**
         * FileOptions .gogoproto.testgenAll.
         * @member {boolean} .gogoproto.testgenAll
         * @memberof google.protobuf.FileOptions
         * @instance
         */
        FileOptions.prototype[".gogoproto.testgenAll"] = false;

        /**
         * FileOptions .gogoproto.benchgenAll.
         * @member {boolean} .gogoproto.benchgenAll
         * @memberof google.protobuf.FileOptions
         * @instance
         */
        FileOptions.prototype[".gogoproto.benchgenAll"] = false;

        /**
         * FileOptions .gogoproto.marshalerAll.
         * @member {boolean} .gogoproto.marshalerAll
         * @memberof google.protobuf.FileOptions
         * @instance
         */
        FileOptions.prototype[".gogoproto.marshalerAll"] = false;

        /**
         * FileOptions .gogoproto.unmarshalerAll.
         * @member {boolean} .gogoproto.unmarshalerAll
         * @memberof google.protobuf.FileOptions
         * @instance
         */
        FileOptions.prototype[".gogoproto.unmarshalerAll"] = false;

        /**
         * FileOptions .gogoproto.stableMarshalerAll.
         * @member {boolean} .gogoproto.stableMarshalerAll
         * @memberof google.protobuf.FileOptions
         * @instance
         */
        FileOptions.prototype[".gogoproto.stableMarshalerAll"] = false;

        /**
         * FileOptions .gogoproto.sizerAll.
         * @member {boolean} .gogoproto.sizerAll
         * @memberof google.protobuf.FileOptions
         * @instance
         */
        FileOptions.prototype[".gogoproto.sizerAll"] = false;

        /**
         * FileOptions .gogoproto.goprotoEnumStringerAll.
         * @member {boolean} .gogoproto.goprotoEnumStringerAll
         * @memberof google.protobuf.FileOptions
         * @instance
         */
        FileOptions.prototype[".gogoproto.goprotoEnumStringerAll"] = false;

        /**
         * FileOptions .gogoproto.enumStringerAll.
         * @member {boolean} .gogoproto.enumStringerAll
         * @memberof google.protobuf.FileOptions
         * @instance
         */
        FileOptions.prototype[".gogoproto.enumStringerAll"] = false;

        /**
         * FileOptions .gogoproto.unsafeMarshalerAll.
         * @member {boolean} .gogoproto.unsafeMarshalerAll
         * @memberof google.protobuf.FileOptions
         * @instance
         */
        FileOptions.prototype[".gogoproto.unsafeMarshalerAll"] = false;

        /**
         * FileOptions .gogoproto.unsafeUnmarshalerAll.
         * @member {boolean} .gogoproto.unsafeUnmarshalerAll
         * @memberof google.protobuf.FileOptions
         * @instance
         */
        FileOptions.prototype[".gogoproto.unsafeUnmarshalerAll"] = false;

        /**
         * FileOptions .gogoproto.goprotoExtensionsMapAll.
         * @member {boolean} .gogoproto.goprotoExtensionsMapAll
         * @memberof google.protobuf.FileOptions
         * @instance
         */
        FileOptions.prototype[".gogoproto.goprotoExtensionsMapAll"] = false;

        /**
         * FileOptions .gogoproto.goprotoUnrecognizedAll.
         * @member {boolean} .gogoproto.goprotoUnrecognizedAll
         * @memberof google.protobuf.FileOptions
         * @instance
         */
        FileOptions.prototype[".gogoproto.goprotoUnrecognizedAll"] = false;

        /**
         * FileOptions .gogoproto.gogoprotoImport.
         * @member {boolean} .gogoproto.gogoprotoImport
         * @memberof google.protobuf.FileOptions
         * @instance
         */
        FileOptions.prototype[".gogoproto.gogoprotoImport"] = false;

        /**
         * FileOptions .gogoproto.protosizerAll.
         * @member {boolean} .gogoproto.protosizerAll
         * @memberof google.protobuf.FileOptions
         * @instance
         */
        FileOptions.prototype[".gogoproto.protosizerAll"] = false;

        /**
         * FileOptions .gogoproto.compareAll.
         * @member {boolean} .gogoproto.compareAll
         * @memberof google.protobuf.FileOptions
         * @instance
         */
        FileOptions.prototype[".gogoproto.compareAll"] = false;

        /**
         * FileOptions .gogoproto.typedeclAll.
         * @member {boolean} .gogoproto.typedeclAll
         * @memberof google.protobuf.FileOptions
         * @instance
         */
        FileOptions.prototype[".gogoproto.typedeclAll"] = false;

        /**
         * FileOptions .gogoproto.enumdeclAll.
         * @member {boolean} .gogoproto.enumdeclAll
         * @memberof google.protobuf.FileOptions
         * @instance
         */
        FileOptions.prototype[".gogoproto.enumdeclAll"] = false;

        /**
         * FileOptions .gogoproto.goprotoRegistration.
         * @member {boolean} .gogoproto.goprotoRegistration
         * @memberof google.protobuf.FileOptions
         * @instance
         */
        FileOptions.prototype[".gogoproto.goprotoRegistration"] = false;

        /**
         * FileOptions .gogoproto.messagenameAll.
         * @member {boolean} .gogoproto.messagenameAll
         * @memberof google.protobuf.FileOptions
         * @instance
         */
        FileOptions.prototype[".gogoproto.messagenameAll"] = false;

        /**
         * FileOptions .gogoproto.goprotoSizecacheAll.
         * @member {boolean} .gogoproto.goprotoSizecacheAll
         * @memberof google.protobuf.FileOptions
         * @instance
         */
        FileOptions.prototype[".gogoproto.goprotoSizecacheAll"] = false;

        /**
         * FileOptions .gogoproto.goprotoUnkeyedAll.
         * @member {boolean} .gogoproto.goprotoUnkeyedAll
         * @memberof google.protobuf.FileOptions
         * @instance
         */
        FileOptions.prototype[".gogoproto.goprotoUnkeyedAll"] = false;

        /**
         * Creates a new FileOptions instance using the specified properties.
         * @function create
         * @memberof google.protobuf.FileOptions
         * @static
         * @param {google.protobuf.IFileOptions=} [properties] Properties to set
         * @returns {google.protobuf.FileOptions} FileOptions instance
         */
        FileOptions.create = function create(properties) {
          return new FileOptions(properties);
        };

        /**
         * Encodes the specified FileOptions message. Does not implicitly {@link google.protobuf.FileOptions.verify|verify} messages.
         * @function encode
         * @memberof google.protobuf.FileOptions
         * @static
         * @param {google.protobuf.IFileOptions} message FileOptions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FileOptions.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.javaPackage != null && Object.hasOwnProperty.call(message, "javaPackage"))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.javaPackage);
          if (message.javaOuterClassname != null && Object.hasOwnProperty.call(message, "javaOuterClassname"))
            writer.uint32(/* id 8, wireType 2 =*/ 66).string(message.javaOuterClassname);
          if (message.optimizeFor != null && Object.hasOwnProperty.call(message, "optimizeFor"))
            writer.uint32(/* id 9, wireType 0 =*/ 72).int32(message.optimizeFor);
          if (message.javaMultipleFiles != null && Object.hasOwnProperty.call(message, "javaMultipleFiles"))
            writer.uint32(/* id 10, wireType 0 =*/ 80).bool(message.javaMultipleFiles);
          if (message.goPackage != null && Object.hasOwnProperty.call(message, "goPackage"))
            writer.uint32(/* id 11, wireType 2 =*/ 90).string(message.goPackage);
          if (message.ccGenericServices != null && Object.hasOwnProperty.call(message, "ccGenericServices"))
            writer.uint32(/* id 16, wireType 0 =*/ 128).bool(message.ccGenericServices);
          if (
            message.javaGenericServices != null &&
            Object.hasOwnProperty.call(message, "javaGenericServices")
          )
            writer.uint32(/* id 17, wireType 0 =*/ 136).bool(message.javaGenericServices);
          if (message.pyGenericServices != null && Object.hasOwnProperty.call(message, "pyGenericServices"))
            writer.uint32(/* id 18, wireType 0 =*/ 144).bool(message.pyGenericServices);
          if (
            message.javaGenerateEqualsAndHash != null &&
            Object.hasOwnProperty.call(message, "javaGenerateEqualsAndHash")
          )
            writer.uint32(/* id 20, wireType 0 =*/ 160).bool(message.javaGenerateEqualsAndHash);
          if (message.deprecated != null && Object.hasOwnProperty.call(message, "deprecated"))
            writer.uint32(/* id 23, wireType 0 =*/ 184).bool(message.deprecated);
          if (
            message.javaStringCheckUtf8 != null &&
            Object.hasOwnProperty.call(message, "javaStringCheckUtf8")
          )
            writer.uint32(/* id 27, wireType 0 =*/ 216).bool(message.javaStringCheckUtf8);
          if (message.ccEnableArenas != null && Object.hasOwnProperty.call(message, "ccEnableArenas"))
            writer.uint32(/* id 31, wireType 0 =*/ 248).bool(message.ccEnableArenas);
          if (message.objcClassPrefix != null && Object.hasOwnProperty.call(message, "objcClassPrefix"))
            writer.uint32(/* id 36, wireType 2 =*/ 290).string(message.objcClassPrefix);
          if (message.csharpNamespace != null && Object.hasOwnProperty.call(message, "csharpNamespace"))
            writer.uint32(/* id 37, wireType 2 =*/ 298).string(message.csharpNamespace);
          if (message.uninterpretedOption != null && message.uninterpretedOption.length)
            for (var i = 0; i < message.uninterpretedOption.length; ++i)
              $root.google.protobuf.UninterpretedOption.encode(
                message.uninterpretedOption[i],
                writer.uint32(/* id 999, wireType 2 =*/ 7994).fork(),
              ).ldelim();
          if (
            message[".gogoproto.goprotoGettersAll"] != null &&
            Object.hasOwnProperty.call(message, ".gogoproto.goprotoGettersAll")
          )
            writer.uint32(/* id 63001, wireType 0 =*/ 504008).bool(message[".gogoproto.goprotoGettersAll"]);
          if (
            message[".gogoproto.goprotoEnumPrefixAll"] != null &&
            Object.hasOwnProperty.call(message, ".gogoproto.goprotoEnumPrefixAll")
          )
            writer
              .uint32(/* id 63002, wireType 0 =*/ 504016)
              .bool(message[".gogoproto.goprotoEnumPrefixAll"]);
          if (
            message[".gogoproto.goprotoStringerAll"] != null &&
            Object.hasOwnProperty.call(message, ".gogoproto.goprotoStringerAll")
          )
            writer.uint32(/* id 63003, wireType 0 =*/ 504024).bool(message[".gogoproto.goprotoStringerAll"]);
          if (
            message[".gogoproto.verboseEqualAll"] != null &&
            Object.hasOwnProperty.call(message, ".gogoproto.verboseEqualAll")
          )
            writer.uint32(/* id 63004, wireType 0 =*/ 504032).bool(message[".gogoproto.verboseEqualAll"]);
          if (
            message[".gogoproto.faceAll"] != null &&
            Object.hasOwnProperty.call(message, ".gogoproto.faceAll")
          )
            writer.uint32(/* id 63005, wireType 0 =*/ 504040).bool(message[".gogoproto.faceAll"]);
          if (
            message[".gogoproto.gostringAll"] != null &&
            Object.hasOwnProperty.call(message, ".gogoproto.gostringAll")
          )
            writer.uint32(/* id 63006, wireType 0 =*/ 504048).bool(message[".gogoproto.gostringAll"]);
          if (
            message[".gogoproto.populateAll"] != null &&
            Object.hasOwnProperty.call(message, ".gogoproto.populateAll")
          )
            writer.uint32(/* id 63007, wireType 0 =*/ 504056).bool(message[".gogoproto.populateAll"]);
          if (
            message[".gogoproto.stringerAll"] != null &&
            Object.hasOwnProperty.call(message, ".gogoproto.stringerAll")
          )
            writer.uint32(/* id 63008, wireType 0 =*/ 504064).bool(message[".gogoproto.stringerAll"]);
          if (
            message[".gogoproto.onlyoneAll"] != null &&
            Object.hasOwnProperty.call(message, ".gogoproto.onlyoneAll")
          )
            writer.uint32(/* id 63009, wireType 0 =*/ 504072).bool(message[".gogoproto.onlyoneAll"]);
          if (
            message[".gogoproto.equalAll"] != null &&
            Object.hasOwnProperty.call(message, ".gogoproto.equalAll")
          )
            writer.uint32(/* id 63013, wireType 0 =*/ 504104).bool(message[".gogoproto.equalAll"]);
          if (
            message[".gogoproto.descriptionAll"] != null &&
            Object.hasOwnProperty.call(message, ".gogoproto.descriptionAll")
          )
            writer.uint32(/* id 63014, wireType 0 =*/ 504112).bool(message[".gogoproto.descriptionAll"]);
          if (
            message[".gogoproto.testgenAll"] != null &&
            Object.hasOwnProperty.call(message, ".gogoproto.testgenAll")
          )
            writer.uint32(/* id 63015, wireType 0 =*/ 504120).bool(message[".gogoproto.testgenAll"]);
          if (
            message[".gogoproto.benchgenAll"] != null &&
            Object.hasOwnProperty.call(message, ".gogoproto.benchgenAll")
          )
            writer.uint32(/* id 63016, wireType 0 =*/ 504128).bool(message[".gogoproto.benchgenAll"]);
          if (
            message[".gogoproto.marshalerAll"] != null &&
            Object.hasOwnProperty.call(message, ".gogoproto.marshalerAll")
          )
            writer.uint32(/* id 63017, wireType 0 =*/ 504136).bool(message[".gogoproto.marshalerAll"]);
          if (
            message[".gogoproto.unmarshalerAll"] != null &&
            Object.hasOwnProperty.call(message, ".gogoproto.unmarshalerAll")
          )
            writer.uint32(/* id 63018, wireType 0 =*/ 504144).bool(message[".gogoproto.unmarshalerAll"]);
          if (
            message[".gogoproto.stableMarshalerAll"] != null &&
            Object.hasOwnProperty.call(message, ".gogoproto.stableMarshalerAll")
          )
            writer.uint32(/* id 63019, wireType 0 =*/ 504152).bool(message[".gogoproto.stableMarshalerAll"]);
          if (
            message[".gogoproto.sizerAll"] != null &&
            Object.hasOwnProperty.call(message, ".gogoproto.sizerAll")
          )
            writer.uint32(/* id 63020, wireType 0 =*/ 504160).bool(message[".gogoproto.sizerAll"]);
          if (
            message[".gogoproto.goprotoEnumStringerAll"] != null &&
            Object.hasOwnProperty.call(message, ".gogoproto.goprotoEnumStringerAll")
          )
            writer
              .uint32(/* id 63021, wireType 0 =*/ 504168)
              .bool(message[".gogoproto.goprotoEnumStringerAll"]);
          if (
            message[".gogoproto.enumStringerAll"] != null &&
            Object.hasOwnProperty.call(message, ".gogoproto.enumStringerAll")
          )
            writer.uint32(/* id 63022, wireType 0 =*/ 504176).bool(message[".gogoproto.enumStringerAll"]);
          if (
            message[".gogoproto.unsafeMarshalerAll"] != null &&
            Object.hasOwnProperty.call(message, ".gogoproto.unsafeMarshalerAll")
          )
            writer.uint32(/* id 63023, wireType 0 =*/ 504184).bool(message[".gogoproto.unsafeMarshalerAll"]);
          if (
            message[".gogoproto.unsafeUnmarshalerAll"] != null &&
            Object.hasOwnProperty.call(message, ".gogoproto.unsafeUnmarshalerAll")
          )
            writer
              .uint32(/* id 63024, wireType 0 =*/ 504192)
              .bool(message[".gogoproto.unsafeUnmarshalerAll"]);
          if (
            message[".gogoproto.goprotoExtensionsMapAll"] != null &&
            Object.hasOwnProperty.call(message, ".gogoproto.goprotoExtensionsMapAll")
          )
            writer
              .uint32(/* id 63025, wireType 0 =*/ 504200)
              .bool(message[".gogoproto.goprotoExtensionsMapAll"]);
          if (
            message[".gogoproto.goprotoUnrecognizedAll"] != null &&
            Object.hasOwnProperty.call(message, ".gogoproto.goprotoUnrecognizedAll")
          )
            writer
              .uint32(/* id 63026, wireType 0 =*/ 504208)
              .bool(message[".gogoproto.goprotoUnrecognizedAll"]);
          if (
            message[".gogoproto.gogoprotoImport"] != null &&
            Object.hasOwnProperty.call(message, ".gogoproto.gogoprotoImport")
          )
            writer.uint32(/* id 63027, wireType 0 =*/ 504216).bool(message[".gogoproto.gogoprotoImport"]);
          if (
            message[".gogoproto.protosizerAll"] != null &&
            Object.hasOwnProperty.call(message, ".gogoproto.protosizerAll")
          )
            writer.uint32(/* id 63028, wireType 0 =*/ 504224).bool(message[".gogoproto.protosizerAll"]);
          if (
            message[".gogoproto.compareAll"] != null &&
            Object.hasOwnProperty.call(message, ".gogoproto.compareAll")
          )
            writer.uint32(/* id 63029, wireType 0 =*/ 504232).bool(message[".gogoproto.compareAll"]);
          if (
            message[".gogoproto.typedeclAll"] != null &&
            Object.hasOwnProperty.call(message, ".gogoproto.typedeclAll")
          )
            writer.uint32(/* id 63030, wireType 0 =*/ 504240).bool(message[".gogoproto.typedeclAll"]);
          if (
            message[".gogoproto.enumdeclAll"] != null &&
            Object.hasOwnProperty.call(message, ".gogoproto.enumdeclAll")
          )
            writer.uint32(/* id 63031, wireType 0 =*/ 504248).bool(message[".gogoproto.enumdeclAll"]);
          if (
            message[".gogoproto.goprotoRegistration"] != null &&
            Object.hasOwnProperty.call(message, ".gogoproto.goprotoRegistration")
          )
            writer.uint32(/* id 63032, wireType 0 =*/ 504256).bool(message[".gogoproto.goprotoRegistration"]);
          if (
            message[".gogoproto.messagenameAll"] != null &&
            Object.hasOwnProperty.call(message, ".gogoproto.messagenameAll")
          )
            writer.uint32(/* id 63033, wireType 0 =*/ 504264).bool(message[".gogoproto.messagenameAll"]);
          if (
            message[".gogoproto.goprotoSizecacheAll"] != null &&
            Object.hasOwnProperty.call(message, ".gogoproto.goprotoSizecacheAll")
          )
            writer.uint32(/* id 63034, wireType 0 =*/ 504272).bool(message[".gogoproto.goprotoSizecacheAll"]);
          if (
            message[".gogoproto.goprotoUnkeyedAll"] != null &&
            Object.hasOwnProperty.call(message, ".gogoproto.goprotoUnkeyedAll")
          )
            writer.uint32(/* id 63035, wireType 0 =*/ 504280).bool(message[".gogoproto.goprotoUnkeyedAll"]);
          return writer;
        };

        /**
         * Encodes the specified FileOptions message, length delimited. Does not implicitly {@link google.protobuf.FileOptions.verify|verify} messages.
         * @function encodeDelimited
         * @memberof google.protobuf.FileOptions
         * @static
         * @param {google.protobuf.IFileOptions} message FileOptions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FileOptions.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FileOptions message from the specified reader or buffer.
         * @function decode
         * @memberof google.protobuf.FileOptions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {google.protobuf.FileOptions} FileOptions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FileOptions.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.google.protobuf.FileOptions();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.javaPackage = reader.string();
                break;
              case 8:
                message.javaOuterClassname = reader.string();
                break;
              case 10:
                message.javaMultipleFiles = reader.bool();
                break;
              case 20:
                message.javaGenerateEqualsAndHash = reader.bool();
                break;
              case 27:
                message.javaStringCheckUtf8 = reader.bool();
                break;
              case 9:
                message.optimizeFor = reader.int32();
                break;
              case 11:
                message.goPackage = reader.string();
                break;
              case 16:
                message.ccGenericServices = reader.bool();
                break;
              case 17:
                message.javaGenericServices = reader.bool();
                break;
              case 18:
                message.pyGenericServices = reader.bool();
                break;
              case 23:
                message.deprecated = reader.bool();
                break;
              case 31:
                message.ccEnableArenas = reader.bool();
                break;
              case 36:
                message.objcClassPrefix = reader.string();
                break;
              case 37:
                message.csharpNamespace = reader.string();
                break;
              case 999:
                if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                  message.uninterpretedOption = [];
                message.uninterpretedOption.push(
                  $root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()),
                );
                break;
              case 63001:
                message[".gogoproto.goprotoGettersAll"] = reader.bool();
                break;
              case 63002:
                message[".gogoproto.goprotoEnumPrefixAll"] = reader.bool();
                break;
              case 63003:
                message[".gogoproto.goprotoStringerAll"] = reader.bool();
                break;
              case 63004:
                message[".gogoproto.verboseEqualAll"] = reader.bool();
                break;
              case 63005:
                message[".gogoproto.faceAll"] = reader.bool();
                break;
              case 63006:
                message[".gogoproto.gostringAll"] = reader.bool();
                break;
              case 63007:
                message[".gogoproto.populateAll"] = reader.bool();
                break;
              case 63008:
                message[".gogoproto.stringerAll"] = reader.bool();
                break;
              case 63009:
                message[".gogoproto.onlyoneAll"] = reader.bool();
                break;
              case 63013:
                message[".gogoproto.equalAll"] = reader.bool();
                break;
              case 63014:
                message[".gogoproto.descriptionAll"] = reader.bool();
                break;
              case 63015:
                message[".gogoproto.testgenAll"] = reader.bool();
                break;
              case 63016:
                message[".gogoproto.benchgenAll"] = reader.bool();
                break;
              case 63017:
                message[".gogoproto.marshalerAll"] = reader.bool();
                break;
              case 63018:
                message[".gogoproto.unmarshalerAll"] = reader.bool();
                break;
              case 63019:
                message[".gogoproto.stableMarshalerAll"] = reader.bool();
                break;
              case 63020:
                message[".gogoproto.sizerAll"] = reader.bool();
                break;
              case 63021:
                message[".gogoproto.goprotoEnumStringerAll"] = reader.bool();
                break;
              case 63022:
                message[".gogoproto.enumStringerAll"] = reader.bool();
                break;
              case 63023:
                message[".gogoproto.unsafeMarshalerAll"] = reader.bool();
                break;
              case 63024:
                message[".gogoproto.unsafeUnmarshalerAll"] = reader.bool();
                break;
              case 63025:
                message[".gogoproto.goprotoExtensionsMapAll"] = reader.bool();
                break;
              case 63026:
                message[".gogoproto.goprotoUnrecognizedAll"] = reader.bool();
                break;
              case 63027:
                message[".gogoproto.gogoprotoImport"] = reader.bool();
                break;
              case 63028:
                message[".gogoproto.protosizerAll"] = reader.bool();
                break;
              case 63029:
                message[".gogoproto.compareAll"] = reader.bool();
                break;
              case 63030:
                message[".gogoproto.typedeclAll"] = reader.bool();
                break;
              case 63031:
                message[".gogoproto.enumdeclAll"] = reader.bool();
                break;
              case 63032:
                message[".gogoproto.goprotoRegistration"] = reader.bool();
                break;
              case 63033:
                message[".gogoproto.messagenameAll"] = reader.bool();
                break;
              case 63034:
                message[".gogoproto.goprotoSizecacheAll"] = reader.bool();
                break;
              case 63035:
                message[".gogoproto.goprotoUnkeyedAll"] = reader.bool();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a FileOptions message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof google.protobuf.FileOptions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {google.protobuf.FileOptions} FileOptions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FileOptions.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FileOptions message.
         * @function verify
         * @memberof google.protobuf.FileOptions
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FileOptions.verify = function verify(message) {
          if (typeof message !== "object" || message === null) return "object expected";
          if (message.javaPackage != null && message.hasOwnProperty("javaPackage"))
            if (!$util.isString(message.javaPackage)) return "javaPackage: string expected";
          if (message.javaOuterClassname != null && message.hasOwnProperty("javaOuterClassname"))
            if (!$util.isString(message.javaOuterClassname)) return "javaOuterClassname: string expected";
          if (message.javaMultipleFiles != null && message.hasOwnProperty("javaMultipleFiles"))
            if (typeof message.javaMultipleFiles !== "boolean") return "javaMultipleFiles: boolean expected";
          if (
            message.javaGenerateEqualsAndHash != null &&
            message.hasOwnProperty("javaGenerateEqualsAndHash")
          )
            if (typeof message.javaGenerateEqualsAndHash !== "boolean")
              return "javaGenerateEqualsAndHash: boolean expected";
          if (message.javaStringCheckUtf8 != null && message.hasOwnProperty("javaStringCheckUtf8"))
            if (typeof message.javaStringCheckUtf8 !== "boolean")
              return "javaStringCheckUtf8: boolean expected";
          if (message.optimizeFor != null && message.hasOwnProperty("optimizeFor"))
            switch (message.optimizeFor) {
              default:
                return "optimizeFor: enum value expected";
              case 1:
              case 2:
              case 3:
                break;
            }
          if (message.goPackage != null && message.hasOwnProperty("goPackage"))
            if (!$util.isString(message.goPackage)) return "goPackage: string expected";
          if (message.ccGenericServices != null && message.hasOwnProperty("ccGenericServices"))
            if (typeof message.ccGenericServices !== "boolean") return "ccGenericServices: boolean expected";
          if (message.javaGenericServices != null && message.hasOwnProperty("javaGenericServices"))
            if (typeof message.javaGenericServices !== "boolean")
              return "javaGenericServices: boolean expected";
          if (message.pyGenericServices != null && message.hasOwnProperty("pyGenericServices"))
            if (typeof message.pyGenericServices !== "boolean") return "pyGenericServices: boolean expected";
          if (message.deprecated != null && message.hasOwnProperty("deprecated"))
            if (typeof message.deprecated !== "boolean") return "deprecated: boolean expected";
          if (message.ccEnableArenas != null && message.hasOwnProperty("ccEnableArenas"))
            if (typeof message.ccEnableArenas !== "boolean") return "ccEnableArenas: boolean expected";
          if (message.objcClassPrefix != null && message.hasOwnProperty("objcClassPrefix"))
            if (!$util.isString(message.objcClassPrefix)) return "objcClassPrefix: string expected";
          if (message.csharpNamespace != null && message.hasOwnProperty("csharpNamespace"))
            if (!$util.isString(message.csharpNamespace)) return "csharpNamespace: string expected";
          if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
            if (!Array.isArray(message.uninterpretedOption)) return "uninterpretedOption: array expected";
            for (var i = 0; i < message.uninterpretedOption.length; ++i) {
              var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
              if (error) return "uninterpretedOption." + error;
            }
          }
          if (
            message[".gogoproto.goprotoGettersAll"] != null &&
            message.hasOwnProperty(".gogoproto.goprotoGettersAll")
          )
            if (typeof message[".gogoproto.goprotoGettersAll"] !== "boolean")
              return ".gogoproto.goprotoGettersAll: boolean expected";
          if (
            message[".gogoproto.goprotoEnumPrefixAll"] != null &&
            message.hasOwnProperty(".gogoproto.goprotoEnumPrefixAll")
          )
            if (typeof message[".gogoproto.goprotoEnumPrefixAll"] !== "boolean")
              return ".gogoproto.goprotoEnumPrefixAll: boolean expected";
          if (
            message[".gogoproto.goprotoStringerAll"] != null &&
            message.hasOwnProperty(".gogoproto.goprotoStringerAll")
          )
            if (typeof message[".gogoproto.goprotoStringerAll"] !== "boolean")
              return ".gogoproto.goprotoStringerAll: boolean expected";
          if (
            message[".gogoproto.verboseEqualAll"] != null &&
            message.hasOwnProperty(".gogoproto.verboseEqualAll")
          )
            if (typeof message[".gogoproto.verboseEqualAll"] !== "boolean")
              return ".gogoproto.verboseEqualAll: boolean expected";
          if (message[".gogoproto.faceAll"] != null && message.hasOwnProperty(".gogoproto.faceAll"))
            if (typeof message[".gogoproto.faceAll"] !== "boolean")
              return ".gogoproto.faceAll: boolean expected";
          if (message[".gogoproto.gostringAll"] != null && message.hasOwnProperty(".gogoproto.gostringAll"))
            if (typeof message[".gogoproto.gostringAll"] !== "boolean")
              return ".gogoproto.gostringAll: boolean expected";
          if (message[".gogoproto.populateAll"] != null && message.hasOwnProperty(".gogoproto.populateAll"))
            if (typeof message[".gogoproto.populateAll"] !== "boolean")
              return ".gogoproto.populateAll: boolean expected";
          if (message[".gogoproto.stringerAll"] != null && message.hasOwnProperty(".gogoproto.stringerAll"))
            if (typeof message[".gogoproto.stringerAll"] !== "boolean")
              return ".gogoproto.stringerAll: boolean expected";
          if (message[".gogoproto.onlyoneAll"] != null && message.hasOwnProperty(".gogoproto.onlyoneAll"))
            if (typeof message[".gogoproto.onlyoneAll"] !== "boolean")
              return ".gogoproto.onlyoneAll: boolean expected";
          if (message[".gogoproto.equalAll"] != null && message.hasOwnProperty(".gogoproto.equalAll"))
            if (typeof message[".gogoproto.equalAll"] !== "boolean")
              return ".gogoproto.equalAll: boolean expected";
          if (
            message[".gogoproto.descriptionAll"] != null &&
            message.hasOwnProperty(".gogoproto.descriptionAll")
          )
            if (typeof message[".gogoproto.descriptionAll"] !== "boolean")
              return ".gogoproto.descriptionAll: boolean expected";
          if (message[".gogoproto.testgenAll"] != null && message.hasOwnProperty(".gogoproto.testgenAll"))
            if (typeof message[".gogoproto.testgenAll"] !== "boolean")
              return ".gogoproto.testgenAll: boolean expected";
          if (message[".gogoproto.benchgenAll"] != null && message.hasOwnProperty(".gogoproto.benchgenAll"))
            if (typeof message[".gogoproto.benchgenAll"] !== "boolean")
              return ".gogoproto.benchgenAll: boolean expected";
          if (message[".gogoproto.marshalerAll"] != null && message.hasOwnProperty(".gogoproto.marshalerAll"))
            if (typeof message[".gogoproto.marshalerAll"] !== "boolean")
              return ".gogoproto.marshalerAll: boolean expected";
          if (
            message[".gogoproto.unmarshalerAll"] != null &&
            message.hasOwnProperty(".gogoproto.unmarshalerAll")
          )
            if (typeof message[".gogoproto.unmarshalerAll"] !== "boolean")
              return ".gogoproto.unmarshalerAll: boolean expected";
          if (
            message[".gogoproto.stableMarshalerAll"] != null &&
            message.hasOwnProperty(".gogoproto.stableMarshalerAll")
          )
            if (typeof message[".gogoproto.stableMarshalerAll"] !== "boolean")
              return ".gogoproto.stableMarshalerAll: boolean expected";
          if (message[".gogoproto.sizerAll"] != null && message.hasOwnProperty(".gogoproto.sizerAll"))
            if (typeof message[".gogoproto.sizerAll"] !== "boolean")
              return ".gogoproto.sizerAll: boolean expected";
          if (
            message[".gogoproto.goprotoEnumStringerAll"] != null &&
            message.hasOwnProperty(".gogoproto.goprotoEnumStringerAll")
          )
            if (typeof message[".gogoproto.goprotoEnumStringerAll"] !== "boolean")
              return ".gogoproto.goprotoEnumStringerAll: boolean expected";
          if (
            message[".gogoproto.enumStringerAll"] != null &&
            message.hasOwnProperty(".gogoproto.enumStringerAll")
          )
            if (typeof message[".gogoproto.enumStringerAll"] !== "boolean")
              return ".gogoproto.enumStringerAll: boolean expected";
          if (
            message[".gogoproto.unsafeMarshalerAll"] != null &&
            message.hasOwnProperty(".gogoproto.unsafeMarshalerAll")
          )
            if (typeof message[".gogoproto.unsafeMarshalerAll"] !== "boolean")
              return ".gogoproto.unsafeMarshalerAll: boolean expected";
          if (
            message[".gogoproto.unsafeUnmarshalerAll"] != null &&
            message.hasOwnProperty(".gogoproto.unsafeUnmarshalerAll")
          )
            if (typeof message[".gogoproto.unsafeUnmarshalerAll"] !== "boolean")
              return ".gogoproto.unsafeUnmarshalerAll: boolean expected";
          if (
            message[".gogoproto.goprotoExtensionsMapAll"] != null &&
            message.hasOwnProperty(".gogoproto.goprotoExtensionsMapAll")
          )
            if (typeof message[".gogoproto.goprotoExtensionsMapAll"] !== "boolean")
              return ".gogoproto.goprotoExtensionsMapAll: boolean expected";
          if (
            message[".gogoproto.goprotoUnrecognizedAll"] != null &&
            message.hasOwnProperty(".gogoproto.goprotoUnrecognizedAll")
          )
            if (typeof message[".gogoproto.goprotoUnrecognizedAll"] !== "boolean")
              return ".gogoproto.goprotoUnrecognizedAll: boolean expected";
          if (
            message[".gogoproto.gogoprotoImport"] != null &&
            message.hasOwnProperty(".gogoproto.gogoprotoImport")
          )
            if (typeof message[".gogoproto.gogoprotoImport"] !== "boolean")
              return ".gogoproto.gogoprotoImport: boolean expected";
          if (
            message[".gogoproto.protosizerAll"] != null &&
            message.hasOwnProperty(".gogoproto.protosizerAll")
          )
            if (typeof message[".gogoproto.protosizerAll"] !== "boolean")
              return ".gogoproto.protosizerAll: boolean expected";
          if (message[".gogoproto.compareAll"] != null && message.hasOwnProperty(".gogoproto.compareAll"))
            if (typeof message[".gogoproto.compareAll"] !== "boolean")
              return ".gogoproto.compareAll: boolean expected";
          if (message[".gogoproto.typedeclAll"] != null && message.hasOwnProperty(".gogoproto.typedeclAll"))
            if (typeof message[".gogoproto.typedeclAll"] !== "boolean")
              return ".gogoproto.typedeclAll: boolean expected";
          if (message[".gogoproto.enumdeclAll"] != null && message.hasOwnProperty(".gogoproto.enumdeclAll"))
            if (typeof message[".gogoproto.enumdeclAll"] !== "boolean")
              return ".gogoproto.enumdeclAll: boolean expected";
          if (
            message[".gogoproto.goprotoRegistration"] != null &&
            message.hasOwnProperty(".gogoproto.goprotoRegistration")
          )
            if (typeof message[".gogoproto.goprotoRegistration"] !== "boolean")
              return ".gogoproto.goprotoRegistration: boolean expected";
          if (
            message[".gogoproto.messagenameAll"] != null &&
            message.hasOwnProperty(".gogoproto.messagenameAll")
          )
            if (typeof message[".gogoproto.messagenameAll"] !== "boolean")
              return ".gogoproto.messagenameAll: boolean expected";
          if (
            message[".gogoproto.goprotoSizecacheAll"] != null &&
            message.hasOwnProperty(".gogoproto.goprotoSizecacheAll")
          )
            if (typeof message[".gogoproto.goprotoSizecacheAll"] !== "boolean")
              return ".gogoproto.goprotoSizecacheAll: boolean expected";
          if (
            message[".gogoproto.goprotoUnkeyedAll"] != null &&
            message.hasOwnProperty(".gogoproto.goprotoUnkeyedAll")
          )
            if (typeof message[".gogoproto.goprotoUnkeyedAll"] !== "boolean")
              return ".gogoproto.goprotoUnkeyedAll: boolean expected";
          return null;
        };

        /**
         * Creates a FileOptions message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof google.protobuf.FileOptions
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {google.protobuf.FileOptions} FileOptions
         */
        FileOptions.fromObject = function fromObject(object) {
          if (object instanceof $root.google.protobuf.FileOptions) return object;
          var message = new $root.google.protobuf.FileOptions();
          if (object.javaPackage != null) message.javaPackage = String(object.javaPackage);
          if (object.javaOuterClassname != null)
            message.javaOuterClassname = String(object.javaOuterClassname);
          if (object.javaMultipleFiles != null) message.javaMultipleFiles = Boolean(object.javaMultipleFiles);
          if (object.javaGenerateEqualsAndHash != null)
            message.javaGenerateEqualsAndHash = Boolean(object.javaGenerateEqualsAndHash);
          if (object.javaStringCheckUtf8 != null)
            message.javaStringCheckUtf8 = Boolean(object.javaStringCheckUtf8);
          switch (object.optimizeFor) {
            case "SPEED":
            case 1:
              message.optimizeFor = 1;
              break;
            case "CODE_SIZE":
            case 2:
              message.optimizeFor = 2;
              break;
            case "LITE_RUNTIME":
            case 3:
              message.optimizeFor = 3;
              break;
          }
          if (object.goPackage != null) message.goPackage = String(object.goPackage);
          if (object.ccGenericServices != null) message.ccGenericServices = Boolean(object.ccGenericServices);
          if (object.javaGenericServices != null)
            message.javaGenericServices = Boolean(object.javaGenericServices);
          if (object.pyGenericServices != null) message.pyGenericServices = Boolean(object.pyGenericServices);
          if (object.deprecated != null) message.deprecated = Boolean(object.deprecated);
          if (object.ccEnableArenas != null) message.ccEnableArenas = Boolean(object.ccEnableArenas);
          if (object.objcClassPrefix != null) message.objcClassPrefix = String(object.objcClassPrefix);
          if (object.csharpNamespace != null) message.csharpNamespace = String(object.csharpNamespace);
          if (object.uninterpretedOption) {
            if (!Array.isArray(object.uninterpretedOption))
              throw TypeError(".google.protobuf.FileOptions.uninterpretedOption: array expected");
            message.uninterpretedOption = [];
            for (var i = 0; i < object.uninterpretedOption.length; ++i) {
              if (typeof object.uninterpretedOption[i] !== "object")
                throw TypeError(".google.protobuf.FileOptions.uninterpretedOption: object expected");
              message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(
                object.uninterpretedOption[i],
              );
            }
          }
          if (object[".gogoproto.goprotoGettersAll"] != null)
            message[".gogoproto.goprotoGettersAll"] = Boolean(object[".gogoproto.goprotoGettersAll"]);
          if (object[".gogoproto.goprotoEnumPrefixAll"] != null)
            message[".gogoproto.goprotoEnumPrefixAll"] = Boolean(object[".gogoproto.goprotoEnumPrefixAll"]);
          if (object[".gogoproto.goprotoStringerAll"] != null)
            message[".gogoproto.goprotoStringerAll"] = Boolean(object[".gogoproto.goprotoStringerAll"]);
          if (object[".gogoproto.verboseEqualAll"] != null)
            message[".gogoproto.verboseEqualAll"] = Boolean(object[".gogoproto.verboseEqualAll"]);
          if (object[".gogoproto.faceAll"] != null)
            message[".gogoproto.faceAll"] = Boolean(object[".gogoproto.faceAll"]);
          if (object[".gogoproto.gostringAll"] != null)
            message[".gogoproto.gostringAll"] = Boolean(object[".gogoproto.gostringAll"]);
          if (object[".gogoproto.populateAll"] != null)
            message[".gogoproto.populateAll"] = Boolean(object[".gogoproto.populateAll"]);
          if (object[".gogoproto.stringerAll"] != null)
            message[".gogoproto.stringerAll"] = Boolean(object[".gogoproto.stringerAll"]);
          if (object[".gogoproto.onlyoneAll"] != null)
            message[".gogoproto.onlyoneAll"] = Boolean(object[".gogoproto.onlyoneAll"]);
          if (object[".gogoproto.equalAll"] != null)
            message[".gogoproto.equalAll"] = Boolean(object[".gogoproto.equalAll"]);
          if (object[".gogoproto.descriptionAll"] != null)
            message[".gogoproto.descriptionAll"] = Boolean(object[".gogoproto.descriptionAll"]);
          if (object[".gogoproto.testgenAll"] != null)
            message[".gogoproto.testgenAll"] = Boolean(object[".gogoproto.testgenAll"]);
          if (object[".gogoproto.benchgenAll"] != null)
            message[".gogoproto.benchgenAll"] = Boolean(object[".gogoproto.benchgenAll"]);
          if (object[".gogoproto.marshalerAll"] != null)
            message[".gogoproto.marshalerAll"] = Boolean(object[".gogoproto.marshalerAll"]);
          if (object[".gogoproto.unmarshalerAll"] != null)
            message[".gogoproto.unmarshalerAll"] = Boolean(object[".gogoproto.unmarshalerAll"]);
          if (object[".gogoproto.stableMarshalerAll"] != null)
            message[".gogoproto.stableMarshalerAll"] = Boolean(object[".gogoproto.stableMarshalerAll"]);
          if (object[".gogoproto.sizerAll"] != null)
            message[".gogoproto.sizerAll"] = Boolean(object[".gogoproto.sizerAll"]);
          if (object[".gogoproto.goprotoEnumStringerAll"] != null)
            message[".gogoproto.goprotoEnumStringerAll"] = Boolean(
              object[".gogoproto.goprotoEnumStringerAll"],
            );
          if (object[".gogoproto.enumStringerAll"] != null)
            message[".gogoproto.enumStringerAll"] = Boolean(object[".gogoproto.enumStringerAll"]);
          if (object[".gogoproto.unsafeMarshalerAll"] != null)
            message[".gogoproto.unsafeMarshalerAll"] = Boolean(object[".gogoproto.unsafeMarshalerAll"]);
          if (object[".gogoproto.unsafeUnmarshalerAll"] != null)
            message[".gogoproto.unsafeUnmarshalerAll"] = Boolean(object[".gogoproto.unsafeUnmarshalerAll"]);
          if (object[".gogoproto.goprotoExtensionsMapAll"] != null)
            message[".gogoproto.goprotoExtensionsMapAll"] = Boolean(
              object[".gogoproto.goprotoExtensionsMapAll"],
            );
          if (object[".gogoproto.goprotoUnrecognizedAll"] != null)
            message[".gogoproto.goprotoUnrecognizedAll"] = Boolean(
              object[".gogoproto.goprotoUnrecognizedAll"],
            );
          if (object[".gogoproto.gogoprotoImport"] != null)
            message[".gogoproto.gogoprotoImport"] = Boolean(object[".gogoproto.gogoprotoImport"]);
          if (object[".gogoproto.protosizerAll"] != null)
            message[".gogoproto.protosizerAll"] = Boolean(object[".gogoproto.protosizerAll"]);
          if (object[".gogoproto.compareAll"] != null)
            message[".gogoproto.compareAll"] = Boolean(object[".gogoproto.compareAll"]);
          if (object[".gogoproto.typedeclAll"] != null)
            message[".gogoproto.typedeclAll"] = Boolean(object[".gogoproto.typedeclAll"]);
          if (object[".gogoproto.enumdeclAll"] != null)
            message[".gogoproto.enumdeclAll"] = Boolean(object[".gogoproto.enumdeclAll"]);
          if (object[".gogoproto.goprotoRegistration"] != null)
            message[".gogoproto.goprotoRegistration"] = Boolean(object[".gogoproto.goprotoRegistration"]);
          if (object[".gogoproto.messagenameAll"] != null)
            message[".gogoproto.messagenameAll"] = Boolean(object[".gogoproto.messagenameAll"]);
          if (object[".gogoproto.goprotoSizecacheAll"] != null)
            message[".gogoproto.goprotoSizecacheAll"] = Boolean(object[".gogoproto.goprotoSizecacheAll"]);
          if (object[".gogoproto.goprotoUnkeyedAll"] != null)
            message[".gogoproto.goprotoUnkeyedAll"] = Boolean(object[".gogoproto.goprotoUnkeyedAll"]);
          return message;
        };

        /**
         * Creates a plain object from a FileOptions message. Also converts values to other types if specified.
         * @function toObject
         * @memberof google.protobuf.FileOptions
         * @static
         * @param {google.protobuf.FileOptions} message FileOptions
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FileOptions.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.arrays || options.defaults) object.uninterpretedOption = [];
          if (options.defaults) {
            object.javaPackage = "";
            object.javaOuterClassname = "";
            object.optimizeFor = options.enums === String ? "SPEED" : 1;
            object.javaMultipleFiles = false;
            object.goPackage = "";
            object.ccGenericServices = false;
            object.javaGenericServices = false;
            object.pyGenericServices = false;
            object.javaGenerateEqualsAndHash = false;
            object.deprecated = false;
            object.javaStringCheckUtf8 = false;
            object.ccEnableArenas = false;
            object.objcClassPrefix = "";
            object.csharpNamespace = "";
            object[".gogoproto.goprotoGettersAll"] = false;
            object[".gogoproto.goprotoEnumPrefixAll"] = false;
            object[".gogoproto.goprotoStringerAll"] = false;
            object[".gogoproto.verboseEqualAll"] = false;
            object[".gogoproto.faceAll"] = false;
            object[".gogoproto.gostringAll"] = false;
            object[".gogoproto.populateAll"] = false;
            object[".gogoproto.stringerAll"] = false;
            object[".gogoproto.onlyoneAll"] = false;
            object[".gogoproto.equalAll"] = false;
            object[".gogoproto.descriptionAll"] = false;
            object[".gogoproto.testgenAll"] = false;
            object[".gogoproto.benchgenAll"] = false;
            object[".gogoproto.marshalerAll"] = false;
            object[".gogoproto.unmarshalerAll"] = false;
            object[".gogoproto.stableMarshalerAll"] = false;
            object[".gogoproto.sizerAll"] = false;
            object[".gogoproto.goprotoEnumStringerAll"] = false;
            object[".gogoproto.enumStringerAll"] = false;
            object[".gogoproto.unsafeMarshalerAll"] = false;
            object[".gogoproto.unsafeUnmarshalerAll"] = false;
            object[".gogoproto.goprotoExtensionsMapAll"] = false;
            object[".gogoproto.goprotoUnrecognizedAll"] = false;
            object[".gogoproto.gogoprotoImport"] = false;
            object[".gogoproto.protosizerAll"] = false;
            object[".gogoproto.compareAll"] = false;
            object[".gogoproto.typedeclAll"] = false;
            object[".gogoproto.enumdeclAll"] = false;
            object[".gogoproto.goprotoRegistration"] = false;
            object[".gogoproto.messagenameAll"] = false;
            object[".gogoproto.goprotoSizecacheAll"] = false;
            object[".gogoproto.goprotoUnkeyedAll"] = false;
          }
          if (message.javaPackage != null && message.hasOwnProperty("javaPackage"))
            object.javaPackage = message.javaPackage;
          if (message.javaOuterClassname != null && message.hasOwnProperty("javaOuterClassname"))
            object.javaOuterClassname = message.javaOuterClassname;
          if (message.optimizeFor != null && message.hasOwnProperty("optimizeFor"))
            object.optimizeFor =
              options.enums === String
                ? $root.google.protobuf.FileOptions.OptimizeMode[message.optimizeFor]
                : message.optimizeFor;
          if (message.javaMultipleFiles != null && message.hasOwnProperty("javaMultipleFiles"))
            object.javaMultipleFiles = message.javaMultipleFiles;
          if (message.goPackage != null && message.hasOwnProperty("goPackage"))
            object.goPackage = message.goPackage;
          if (message.ccGenericServices != null && message.hasOwnProperty("ccGenericServices"))
            object.ccGenericServices = message.ccGenericServices;
          if (message.javaGenericServices != null && message.hasOwnProperty("javaGenericServices"))
            object.javaGenericServices = message.javaGenericServices;
          if (message.pyGenericServices != null && message.hasOwnProperty("pyGenericServices"))
            object.pyGenericServices = message.pyGenericServices;
          if (
            message.javaGenerateEqualsAndHash != null &&
            message.hasOwnProperty("javaGenerateEqualsAndHash")
          )
            object.javaGenerateEqualsAndHash = message.javaGenerateEqualsAndHash;
          if (message.deprecated != null && message.hasOwnProperty("deprecated"))
            object.deprecated = message.deprecated;
          if (message.javaStringCheckUtf8 != null && message.hasOwnProperty("javaStringCheckUtf8"))
            object.javaStringCheckUtf8 = message.javaStringCheckUtf8;
          if (message.ccEnableArenas != null && message.hasOwnProperty("ccEnableArenas"))
            object.ccEnableArenas = message.ccEnableArenas;
          if (message.objcClassPrefix != null && message.hasOwnProperty("objcClassPrefix"))
            object.objcClassPrefix = message.objcClassPrefix;
          if (message.csharpNamespace != null && message.hasOwnProperty("csharpNamespace"))
            object.csharpNamespace = message.csharpNamespace;
          if (message.uninterpretedOption && message.uninterpretedOption.length) {
            object.uninterpretedOption = [];
            for (var j = 0; j < message.uninterpretedOption.length; ++j)
              object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(
                message.uninterpretedOption[j],
                options,
              );
          }
          if (
            message[".gogoproto.goprotoGettersAll"] != null &&
            message.hasOwnProperty(".gogoproto.goprotoGettersAll")
          )
            object[".gogoproto.goprotoGettersAll"] = message[".gogoproto.goprotoGettersAll"];
          if (
            message[".gogoproto.goprotoEnumPrefixAll"] != null &&
            message.hasOwnProperty(".gogoproto.goprotoEnumPrefixAll")
          )
            object[".gogoproto.goprotoEnumPrefixAll"] = message[".gogoproto.goprotoEnumPrefixAll"];
          if (
            message[".gogoproto.goprotoStringerAll"] != null &&
            message.hasOwnProperty(".gogoproto.goprotoStringerAll")
          )
            object[".gogoproto.goprotoStringerAll"] = message[".gogoproto.goprotoStringerAll"];
          if (
            message[".gogoproto.verboseEqualAll"] != null &&
            message.hasOwnProperty(".gogoproto.verboseEqualAll")
          )
            object[".gogoproto.verboseEqualAll"] = message[".gogoproto.verboseEqualAll"];
          if (message[".gogoproto.faceAll"] != null && message.hasOwnProperty(".gogoproto.faceAll"))
            object[".gogoproto.faceAll"] = message[".gogoproto.faceAll"];
          if (message[".gogoproto.gostringAll"] != null && message.hasOwnProperty(".gogoproto.gostringAll"))
            object[".gogoproto.gostringAll"] = message[".gogoproto.gostringAll"];
          if (message[".gogoproto.populateAll"] != null && message.hasOwnProperty(".gogoproto.populateAll"))
            object[".gogoproto.populateAll"] = message[".gogoproto.populateAll"];
          if (message[".gogoproto.stringerAll"] != null && message.hasOwnProperty(".gogoproto.stringerAll"))
            object[".gogoproto.stringerAll"] = message[".gogoproto.stringerAll"];
          if (message[".gogoproto.onlyoneAll"] != null && message.hasOwnProperty(".gogoproto.onlyoneAll"))
            object[".gogoproto.onlyoneAll"] = message[".gogoproto.onlyoneAll"];
          if (message[".gogoproto.equalAll"] != null && message.hasOwnProperty(".gogoproto.equalAll"))
            object[".gogoproto.equalAll"] = message[".gogoproto.equalAll"];
          if (
            message[".gogoproto.descriptionAll"] != null &&
            message.hasOwnProperty(".gogoproto.descriptionAll")
          )
            object[".gogoproto.descriptionAll"] = message[".gogoproto.descriptionAll"];
          if (message[".gogoproto.testgenAll"] != null && message.hasOwnProperty(".gogoproto.testgenAll"))
            object[".gogoproto.testgenAll"] = message[".gogoproto.testgenAll"];
          if (message[".gogoproto.benchgenAll"] != null && message.hasOwnProperty(".gogoproto.benchgenAll"))
            object[".gogoproto.benchgenAll"] = message[".gogoproto.benchgenAll"];
          if (message[".gogoproto.marshalerAll"] != null && message.hasOwnProperty(".gogoproto.marshalerAll"))
            object[".gogoproto.marshalerAll"] = message[".gogoproto.marshalerAll"];
          if (
            message[".gogoproto.unmarshalerAll"] != null &&
            message.hasOwnProperty(".gogoproto.unmarshalerAll")
          )
            object[".gogoproto.unmarshalerAll"] = message[".gogoproto.unmarshalerAll"];
          if (
            message[".gogoproto.stableMarshalerAll"] != null &&
            message.hasOwnProperty(".gogoproto.stableMarshalerAll")
          )
            object[".gogoproto.stableMarshalerAll"] = message[".gogoproto.stableMarshalerAll"];
          if (message[".gogoproto.sizerAll"] != null && message.hasOwnProperty(".gogoproto.sizerAll"))
            object[".gogoproto.sizerAll"] = message[".gogoproto.sizerAll"];
          if (
            message[".gogoproto.goprotoEnumStringerAll"] != null &&
            message.hasOwnProperty(".gogoproto.goprotoEnumStringerAll")
          )
            object[".gogoproto.goprotoEnumStringerAll"] = message[".gogoproto.goprotoEnumStringerAll"];
          if (
            message[".gogoproto.enumStringerAll"] != null &&
            message.hasOwnProperty(".gogoproto.enumStringerAll")
          )
            object[".gogoproto.enumStringerAll"] = message[".gogoproto.enumStringerAll"];
          if (
            message[".gogoproto.unsafeMarshalerAll"] != null &&
            message.hasOwnProperty(".gogoproto.unsafeMarshalerAll")
          )
            object[".gogoproto.unsafeMarshalerAll"] = message[".gogoproto.unsafeMarshalerAll"];
          if (
            message[".gogoproto.unsafeUnmarshalerAll"] != null &&
            message.hasOwnProperty(".gogoproto.unsafeUnmarshalerAll")
          )
            object[".gogoproto.unsafeUnmarshalerAll"] = message[".gogoproto.unsafeUnmarshalerAll"];
          if (
            message[".gogoproto.goprotoExtensionsMapAll"] != null &&
            message.hasOwnProperty(".gogoproto.goprotoExtensionsMapAll")
          )
            object[".gogoproto.goprotoExtensionsMapAll"] = message[".gogoproto.goprotoExtensionsMapAll"];
          if (
            message[".gogoproto.goprotoUnrecognizedAll"] != null &&
            message.hasOwnProperty(".gogoproto.goprotoUnrecognizedAll")
          )
            object[".gogoproto.goprotoUnrecognizedAll"] = message[".gogoproto.goprotoUnrecognizedAll"];
          if (
            message[".gogoproto.gogoprotoImport"] != null &&
            message.hasOwnProperty(".gogoproto.gogoprotoImport")
          )
            object[".gogoproto.gogoprotoImport"] = message[".gogoproto.gogoprotoImport"];
          if (
            message[".gogoproto.protosizerAll"] != null &&
            message.hasOwnProperty(".gogoproto.protosizerAll")
          )
            object[".gogoproto.protosizerAll"] = message[".gogoproto.protosizerAll"];
          if (message[".gogoproto.compareAll"] != null && message.hasOwnProperty(".gogoproto.compareAll"))
            object[".gogoproto.compareAll"] = message[".gogoproto.compareAll"];
          if (message[".gogoproto.typedeclAll"] != null && message.hasOwnProperty(".gogoproto.typedeclAll"))
            object[".gogoproto.typedeclAll"] = message[".gogoproto.typedeclAll"];
          if (message[".gogoproto.enumdeclAll"] != null && message.hasOwnProperty(".gogoproto.enumdeclAll"))
            object[".gogoproto.enumdeclAll"] = message[".gogoproto.enumdeclAll"];
          if (
            message[".gogoproto.goprotoRegistration"] != null &&
            message.hasOwnProperty(".gogoproto.goprotoRegistration")
          )
            object[".gogoproto.goprotoRegistration"] = message[".gogoproto.goprotoRegistration"];
          if (
            message[".gogoproto.messagenameAll"] != null &&
            message.hasOwnProperty(".gogoproto.messagenameAll")
          )
            object[".gogoproto.messagenameAll"] = message[".gogoproto.messagenameAll"];
          if (
            message[".gogoproto.goprotoSizecacheAll"] != null &&
            message.hasOwnProperty(".gogoproto.goprotoSizecacheAll")
          )
            object[".gogoproto.goprotoSizecacheAll"] = message[".gogoproto.goprotoSizecacheAll"];
          if (
            message[".gogoproto.goprotoUnkeyedAll"] != null &&
            message.hasOwnProperty(".gogoproto.goprotoUnkeyedAll")
          )
            object[".gogoproto.goprotoUnkeyedAll"] = message[".gogoproto.goprotoUnkeyedAll"];
          return object;
        };

        /**
         * Converts this FileOptions to JSON.
         * @function toJSON
         * @memberof google.protobuf.FileOptions
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FileOptions.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * OptimizeMode enum.
         * @name google.protobuf.FileOptions.OptimizeMode
         * @enum {number}
         * @property {number} SPEED=1 SPEED value
         * @property {number} CODE_SIZE=2 CODE_SIZE value
         * @property {number} LITE_RUNTIME=3 LITE_RUNTIME value
         */
        FileOptions.OptimizeMode = (function () {
          var valuesById = {},
            values = Object.create(valuesById);
          values[(valuesById[1] = "SPEED")] = 1;
          values[(valuesById[2] = "CODE_SIZE")] = 2;
          values[(valuesById[3] = "LITE_RUNTIME")] = 3;
          return values;
        })();

        return FileOptions;
      })();

      protobuf.MessageOptions = (function () {
        /**
         * Properties of a MessageOptions.
         * @memberof google.protobuf
         * @interface IMessageOptions
         * @property {boolean|null} [messageSetWireFormat] MessageOptions messageSetWireFormat
         * @property {boolean|null} [noStandardDescriptorAccessor] MessageOptions noStandardDescriptorAccessor
         * @property {boolean|null} [deprecated] MessageOptions deprecated
         * @property {boolean|null} [mapEntry] MessageOptions mapEntry
         * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] MessageOptions uninterpretedOption
         * @property {boolean|null} [".gogoproto.goprotoGetters"] MessageOptions .gogoproto.goprotoGetters
         * @property {boolean|null} [".gogoproto.goprotoStringer"] MessageOptions .gogoproto.goprotoStringer
         * @property {boolean|null} [".gogoproto.verboseEqual"] MessageOptions .gogoproto.verboseEqual
         * @property {boolean|null} [".gogoproto.face"] MessageOptions .gogoproto.face
         * @property {boolean|null} [".gogoproto.gostring"] MessageOptions .gogoproto.gostring
         * @property {boolean|null} [".gogoproto.populate"] MessageOptions .gogoproto.populate
         * @property {boolean|null} [".gogoproto.stringer"] MessageOptions .gogoproto.stringer
         * @property {boolean|null} [".gogoproto.onlyone"] MessageOptions .gogoproto.onlyone
         * @property {boolean|null} [".gogoproto.equal"] MessageOptions .gogoproto.equal
         * @property {boolean|null} [".gogoproto.description"] MessageOptions .gogoproto.description
         * @property {boolean|null} [".gogoproto.testgen"] MessageOptions .gogoproto.testgen
         * @property {boolean|null} [".gogoproto.benchgen"] MessageOptions .gogoproto.benchgen
         * @property {boolean|null} [".gogoproto.marshaler"] MessageOptions .gogoproto.marshaler
         * @property {boolean|null} [".gogoproto.unmarshaler"] MessageOptions .gogoproto.unmarshaler
         * @property {boolean|null} [".gogoproto.stableMarshaler"] MessageOptions .gogoproto.stableMarshaler
         * @property {boolean|null} [".gogoproto.sizer"] MessageOptions .gogoproto.sizer
         * @property {boolean|null} [".gogoproto.unsafeMarshaler"] MessageOptions .gogoproto.unsafeMarshaler
         * @property {boolean|null} [".gogoproto.unsafeUnmarshaler"] MessageOptions .gogoproto.unsafeUnmarshaler
         * @property {boolean|null} [".gogoproto.goprotoExtensionsMap"] MessageOptions .gogoproto.goprotoExtensionsMap
         * @property {boolean|null} [".gogoproto.goprotoUnrecognized"] MessageOptions .gogoproto.goprotoUnrecognized
         * @property {boolean|null} [".gogoproto.protosizer"] MessageOptions .gogoproto.protosizer
         * @property {boolean|null} [".gogoproto.compare"] MessageOptions .gogoproto.compare
         * @property {boolean|null} [".gogoproto.typedecl"] MessageOptions .gogoproto.typedecl
         * @property {boolean|null} [".gogoproto.messagename"] MessageOptions .gogoproto.messagename
         * @property {boolean|null} [".gogoproto.goprotoSizecache"] MessageOptions .gogoproto.goprotoSizecache
         * @property {boolean|null} [".gogoproto.goprotoUnkeyed"] MessageOptions .gogoproto.goprotoUnkeyed
         */

        /**
         * Constructs a new MessageOptions.
         * @memberof google.protobuf
         * @classdesc Represents a MessageOptions.
         * @implements IMessageOptions
         * @constructor
         * @param {google.protobuf.IMessageOptions=} [properties] Properties to set
         */
        function MessageOptions(properties) {
          this.uninterpretedOption = [];
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * MessageOptions messageSetWireFormat.
         * @member {boolean} messageSetWireFormat
         * @memberof google.protobuf.MessageOptions
         * @instance
         */
        MessageOptions.prototype.messageSetWireFormat = false;

        /**
         * MessageOptions noStandardDescriptorAccessor.
         * @member {boolean} noStandardDescriptorAccessor
         * @memberof google.protobuf.MessageOptions
         * @instance
         */
        MessageOptions.prototype.noStandardDescriptorAccessor = false;

        /**
         * MessageOptions deprecated.
         * @member {boolean} deprecated
         * @memberof google.protobuf.MessageOptions
         * @instance
         */
        MessageOptions.prototype.deprecated = false;

        /**
         * MessageOptions mapEntry.
         * @member {boolean} mapEntry
         * @memberof google.protobuf.MessageOptions
         * @instance
         */
        MessageOptions.prototype.mapEntry = false;

        /**
         * MessageOptions uninterpretedOption.
         * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
         * @memberof google.protobuf.MessageOptions
         * @instance
         */
        MessageOptions.prototype.uninterpretedOption = $util.emptyArray;

        /**
         * MessageOptions .gogoproto.goprotoGetters.
         * @member {boolean} .gogoproto.goprotoGetters
         * @memberof google.protobuf.MessageOptions
         * @instance
         */
        MessageOptions.prototype[".gogoproto.goprotoGetters"] = false;

        /**
         * MessageOptions .gogoproto.goprotoStringer.
         * @member {boolean} .gogoproto.goprotoStringer
         * @memberof google.protobuf.MessageOptions
         * @instance
         */
        MessageOptions.prototype[".gogoproto.goprotoStringer"] = false;

        /**
         * MessageOptions .gogoproto.verboseEqual.
         * @member {boolean} .gogoproto.verboseEqual
         * @memberof google.protobuf.MessageOptions
         * @instance
         */
        MessageOptions.prototype[".gogoproto.verboseEqual"] = false;

        /**
         * MessageOptions .gogoproto.face.
         * @member {boolean} .gogoproto.face
         * @memberof google.protobuf.MessageOptions
         * @instance
         */
        MessageOptions.prototype[".gogoproto.face"] = false;

        /**
         * MessageOptions .gogoproto.gostring.
         * @member {boolean} .gogoproto.gostring
         * @memberof google.protobuf.MessageOptions
         * @instance
         */
        MessageOptions.prototype[".gogoproto.gostring"] = false;

        /**
         * MessageOptions .gogoproto.populate.
         * @member {boolean} .gogoproto.populate
         * @memberof google.protobuf.MessageOptions
         * @instance
         */
        MessageOptions.prototype[".gogoproto.populate"] = false;

        /**
         * MessageOptions .gogoproto.stringer.
         * @member {boolean} .gogoproto.stringer
         * @memberof google.protobuf.MessageOptions
         * @instance
         */
        MessageOptions.prototype[".gogoproto.stringer"] = false;

        /**
         * MessageOptions .gogoproto.onlyone.
         * @member {boolean} .gogoproto.onlyone
         * @memberof google.protobuf.MessageOptions
         * @instance
         */
        MessageOptions.prototype[".gogoproto.onlyone"] = false;

        /**
         * MessageOptions .gogoproto.equal.
         * @member {boolean} .gogoproto.equal
         * @memberof google.protobuf.MessageOptions
         * @instance
         */
        MessageOptions.prototype[".gogoproto.equal"] = false;

        /**
         * MessageOptions .gogoproto.description.
         * @member {boolean} .gogoproto.description
         * @memberof google.protobuf.MessageOptions
         * @instance
         */
        MessageOptions.prototype[".gogoproto.description"] = false;

        /**
         * MessageOptions .gogoproto.testgen.
         * @member {boolean} .gogoproto.testgen
         * @memberof google.protobuf.MessageOptions
         * @instance
         */
        MessageOptions.prototype[".gogoproto.testgen"] = false;

        /**
         * MessageOptions .gogoproto.benchgen.
         * @member {boolean} .gogoproto.benchgen
         * @memberof google.protobuf.MessageOptions
         * @instance
         */
        MessageOptions.prototype[".gogoproto.benchgen"] = false;

        /**
         * MessageOptions .gogoproto.marshaler.
         * @member {boolean} .gogoproto.marshaler
         * @memberof google.protobuf.MessageOptions
         * @instance
         */
        MessageOptions.prototype[".gogoproto.marshaler"] = false;

        /**
         * MessageOptions .gogoproto.unmarshaler.
         * @member {boolean} .gogoproto.unmarshaler
         * @memberof google.protobuf.MessageOptions
         * @instance
         */
        MessageOptions.prototype[".gogoproto.unmarshaler"] = false;

        /**
         * MessageOptions .gogoproto.stableMarshaler.
         * @member {boolean} .gogoproto.stableMarshaler
         * @memberof google.protobuf.MessageOptions
         * @instance
         */
        MessageOptions.prototype[".gogoproto.stableMarshaler"] = false;

        /**
         * MessageOptions .gogoproto.sizer.
         * @member {boolean} .gogoproto.sizer
         * @memberof google.protobuf.MessageOptions
         * @instance
         */
        MessageOptions.prototype[".gogoproto.sizer"] = false;

        /**
         * MessageOptions .gogoproto.unsafeMarshaler.
         * @member {boolean} .gogoproto.unsafeMarshaler
         * @memberof google.protobuf.MessageOptions
         * @instance
         */
        MessageOptions.prototype[".gogoproto.unsafeMarshaler"] = false;

        /**
         * MessageOptions .gogoproto.unsafeUnmarshaler.
         * @member {boolean} .gogoproto.unsafeUnmarshaler
         * @memberof google.protobuf.MessageOptions
         * @instance
         */
        MessageOptions.prototype[".gogoproto.unsafeUnmarshaler"] = false;

        /**
         * MessageOptions .gogoproto.goprotoExtensionsMap.
         * @member {boolean} .gogoproto.goprotoExtensionsMap
         * @memberof google.protobuf.MessageOptions
         * @instance
         */
        MessageOptions.prototype[".gogoproto.goprotoExtensionsMap"] = false;

        /**
         * MessageOptions .gogoproto.goprotoUnrecognized.
         * @member {boolean} .gogoproto.goprotoUnrecognized
         * @memberof google.protobuf.MessageOptions
         * @instance
         */
        MessageOptions.prototype[".gogoproto.goprotoUnrecognized"] = false;

        /**
         * MessageOptions .gogoproto.protosizer.
         * @member {boolean} .gogoproto.protosizer
         * @memberof google.protobuf.MessageOptions
         * @instance
         */
        MessageOptions.prototype[".gogoproto.protosizer"] = false;

        /**
         * MessageOptions .gogoproto.compare.
         * @member {boolean} .gogoproto.compare
         * @memberof google.protobuf.MessageOptions
         * @instance
         */
        MessageOptions.prototype[".gogoproto.compare"] = false;

        /**
         * MessageOptions .gogoproto.typedecl.
         * @member {boolean} .gogoproto.typedecl
         * @memberof google.protobuf.MessageOptions
         * @instance
         */
        MessageOptions.prototype[".gogoproto.typedecl"] = false;

        /**
         * MessageOptions .gogoproto.messagename.
         * @member {boolean} .gogoproto.messagename
         * @memberof google.protobuf.MessageOptions
         * @instance
         */
        MessageOptions.prototype[".gogoproto.messagename"] = false;

        /**
         * MessageOptions .gogoproto.goprotoSizecache.
         * @member {boolean} .gogoproto.goprotoSizecache
         * @memberof google.protobuf.MessageOptions
         * @instance
         */
        MessageOptions.prototype[".gogoproto.goprotoSizecache"] = false;

        /**
         * MessageOptions .gogoproto.goprotoUnkeyed.
         * @member {boolean} .gogoproto.goprotoUnkeyed
         * @memberof google.protobuf.MessageOptions
         * @instance
         */
        MessageOptions.prototype[".gogoproto.goprotoUnkeyed"] = false;

        /**
         * Creates a new MessageOptions instance using the specified properties.
         * @function create
         * @memberof google.protobuf.MessageOptions
         * @static
         * @param {google.protobuf.IMessageOptions=} [properties] Properties to set
         * @returns {google.protobuf.MessageOptions} MessageOptions instance
         */
        MessageOptions.create = function create(properties) {
          return new MessageOptions(properties);
        };

        /**
         * Encodes the specified MessageOptions message. Does not implicitly {@link google.protobuf.MessageOptions.verify|verify} messages.
         * @function encode
         * @memberof google.protobuf.MessageOptions
         * @static
         * @param {google.protobuf.IMessageOptions} message MessageOptions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MessageOptions.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (
            message.messageSetWireFormat != null &&
            Object.hasOwnProperty.call(message, "messageSetWireFormat")
          )
            writer.uint32(/* id 1, wireType 0 =*/ 8).bool(message.messageSetWireFormat);
          if (
            message.noStandardDescriptorAccessor != null &&
            Object.hasOwnProperty.call(message, "noStandardDescriptorAccessor")
          )
            writer.uint32(/* id 2, wireType 0 =*/ 16).bool(message.noStandardDescriptorAccessor);
          if (message.deprecated != null && Object.hasOwnProperty.call(message, "deprecated"))
            writer.uint32(/* id 3, wireType 0 =*/ 24).bool(message.deprecated);
          if (message.mapEntry != null && Object.hasOwnProperty.call(message, "mapEntry"))
            writer.uint32(/* id 7, wireType 0 =*/ 56).bool(message.mapEntry);
          if (message.uninterpretedOption != null && message.uninterpretedOption.length)
            for (var i = 0; i < message.uninterpretedOption.length; ++i)
              $root.google.protobuf.UninterpretedOption.encode(
                message.uninterpretedOption[i],
                writer.uint32(/* id 999, wireType 2 =*/ 7994).fork(),
              ).ldelim();
          if (
            message[".gogoproto.goprotoGetters"] != null &&
            Object.hasOwnProperty.call(message, ".gogoproto.goprotoGetters")
          )
            writer.uint32(/* id 64001, wireType 0 =*/ 512008).bool(message[".gogoproto.goprotoGetters"]);
          if (
            message[".gogoproto.goprotoStringer"] != null &&
            Object.hasOwnProperty.call(message, ".gogoproto.goprotoStringer")
          )
            writer.uint32(/* id 64003, wireType 0 =*/ 512024).bool(message[".gogoproto.goprotoStringer"]);
          if (
            message[".gogoproto.verboseEqual"] != null &&
            Object.hasOwnProperty.call(message, ".gogoproto.verboseEqual")
          )
            writer.uint32(/* id 64004, wireType 0 =*/ 512032).bool(message[".gogoproto.verboseEqual"]);
          if (message[".gogoproto.face"] != null && Object.hasOwnProperty.call(message, ".gogoproto.face"))
            writer.uint32(/* id 64005, wireType 0 =*/ 512040).bool(message[".gogoproto.face"]);
          if (
            message[".gogoproto.gostring"] != null &&
            Object.hasOwnProperty.call(message, ".gogoproto.gostring")
          )
            writer.uint32(/* id 64006, wireType 0 =*/ 512048).bool(message[".gogoproto.gostring"]);
          if (
            message[".gogoproto.populate"] != null &&
            Object.hasOwnProperty.call(message, ".gogoproto.populate")
          )
            writer.uint32(/* id 64007, wireType 0 =*/ 512056).bool(message[".gogoproto.populate"]);
          if (
            message[".gogoproto.onlyone"] != null &&
            Object.hasOwnProperty.call(message, ".gogoproto.onlyone")
          )
            writer.uint32(/* id 64009, wireType 0 =*/ 512072).bool(message[".gogoproto.onlyone"]);
          if (message[".gogoproto.equal"] != null && Object.hasOwnProperty.call(message, ".gogoproto.equal"))
            writer.uint32(/* id 64013, wireType 0 =*/ 512104).bool(message[".gogoproto.equal"]);
          if (
            message[".gogoproto.description"] != null &&
            Object.hasOwnProperty.call(message, ".gogoproto.description")
          )
            writer.uint32(/* id 64014, wireType 0 =*/ 512112).bool(message[".gogoproto.description"]);
          if (
            message[".gogoproto.testgen"] != null &&
            Object.hasOwnProperty.call(message, ".gogoproto.testgen")
          )
            writer.uint32(/* id 64015, wireType 0 =*/ 512120).bool(message[".gogoproto.testgen"]);
          if (
            message[".gogoproto.benchgen"] != null &&
            Object.hasOwnProperty.call(message, ".gogoproto.benchgen")
          )
            writer.uint32(/* id 64016, wireType 0 =*/ 512128).bool(message[".gogoproto.benchgen"]);
          if (
            message[".gogoproto.marshaler"] != null &&
            Object.hasOwnProperty.call(message, ".gogoproto.marshaler")
          )
            writer.uint32(/* id 64017, wireType 0 =*/ 512136).bool(message[".gogoproto.marshaler"]);
          if (
            message[".gogoproto.unmarshaler"] != null &&
            Object.hasOwnProperty.call(message, ".gogoproto.unmarshaler")
          )
            writer.uint32(/* id 64018, wireType 0 =*/ 512144).bool(message[".gogoproto.unmarshaler"]);
          if (
            message[".gogoproto.stableMarshaler"] != null &&
            Object.hasOwnProperty.call(message, ".gogoproto.stableMarshaler")
          )
            writer.uint32(/* id 64019, wireType 0 =*/ 512152).bool(message[".gogoproto.stableMarshaler"]);
          if (message[".gogoproto.sizer"] != null && Object.hasOwnProperty.call(message, ".gogoproto.sizer"))
            writer.uint32(/* id 64020, wireType 0 =*/ 512160).bool(message[".gogoproto.sizer"]);
          if (
            message[".gogoproto.unsafeMarshaler"] != null &&
            Object.hasOwnProperty.call(message, ".gogoproto.unsafeMarshaler")
          )
            writer.uint32(/* id 64023, wireType 0 =*/ 512184).bool(message[".gogoproto.unsafeMarshaler"]);
          if (
            message[".gogoproto.unsafeUnmarshaler"] != null &&
            Object.hasOwnProperty.call(message, ".gogoproto.unsafeUnmarshaler")
          )
            writer.uint32(/* id 64024, wireType 0 =*/ 512192).bool(message[".gogoproto.unsafeUnmarshaler"]);
          if (
            message[".gogoproto.goprotoExtensionsMap"] != null &&
            Object.hasOwnProperty.call(message, ".gogoproto.goprotoExtensionsMap")
          )
            writer
              .uint32(/* id 64025, wireType 0 =*/ 512200)
              .bool(message[".gogoproto.goprotoExtensionsMap"]);
          if (
            message[".gogoproto.goprotoUnrecognized"] != null &&
            Object.hasOwnProperty.call(message, ".gogoproto.goprotoUnrecognized")
          )
            writer.uint32(/* id 64026, wireType 0 =*/ 512208).bool(message[".gogoproto.goprotoUnrecognized"]);
          if (
            message[".gogoproto.protosizer"] != null &&
            Object.hasOwnProperty.call(message, ".gogoproto.protosizer")
          )
            writer.uint32(/* id 64028, wireType 0 =*/ 512224).bool(message[".gogoproto.protosizer"]);
          if (
            message[".gogoproto.compare"] != null &&
            Object.hasOwnProperty.call(message, ".gogoproto.compare")
          )
            writer.uint32(/* id 64029, wireType 0 =*/ 512232).bool(message[".gogoproto.compare"]);
          if (
            message[".gogoproto.typedecl"] != null &&
            Object.hasOwnProperty.call(message, ".gogoproto.typedecl")
          )
            writer.uint32(/* id 64030, wireType 0 =*/ 512240).bool(message[".gogoproto.typedecl"]);
          if (
            message[".gogoproto.messagename"] != null &&
            Object.hasOwnProperty.call(message, ".gogoproto.messagename")
          )
            writer.uint32(/* id 64033, wireType 0 =*/ 512264).bool(message[".gogoproto.messagename"]);
          if (
            message[".gogoproto.goprotoSizecache"] != null &&
            Object.hasOwnProperty.call(message, ".gogoproto.goprotoSizecache")
          )
            writer.uint32(/* id 64034, wireType 0 =*/ 512272).bool(message[".gogoproto.goprotoSizecache"]);
          if (
            message[".gogoproto.goprotoUnkeyed"] != null &&
            Object.hasOwnProperty.call(message, ".gogoproto.goprotoUnkeyed")
          )
            writer.uint32(/* id 64035, wireType 0 =*/ 512280).bool(message[".gogoproto.goprotoUnkeyed"]);
          if (
            message[".gogoproto.stringer"] != null &&
            Object.hasOwnProperty.call(message, ".gogoproto.stringer")
          )
            writer.uint32(/* id 67008, wireType 0 =*/ 536064).bool(message[".gogoproto.stringer"]);
          return writer;
        };

        /**
         * Encodes the specified MessageOptions message, length delimited. Does not implicitly {@link google.protobuf.MessageOptions.verify|verify} messages.
         * @function encodeDelimited
         * @memberof google.protobuf.MessageOptions
         * @static
         * @param {google.protobuf.IMessageOptions} message MessageOptions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MessageOptions.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MessageOptions message from the specified reader or buffer.
         * @function decode
         * @memberof google.protobuf.MessageOptions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {google.protobuf.MessageOptions} MessageOptions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MessageOptions.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.google.protobuf.MessageOptions();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.messageSetWireFormat = reader.bool();
                break;
              case 2:
                message.noStandardDescriptorAccessor = reader.bool();
                break;
              case 3:
                message.deprecated = reader.bool();
                break;
              case 7:
                message.mapEntry = reader.bool();
                break;
              case 999:
                if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                  message.uninterpretedOption = [];
                message.uninterpretedOption.push(
                  $root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()),
                );
                break;
              case 64001:
                message[".gogoproto.goprotoGetters"] = reader.bool();
                break;
              case 64003:
                message[".gogoproto.goprotoStringer"] = reader.bool();
                break;
              case 64004:
                message[".gogoproto.verboseEqual"] = reader.bool();
                break;
              case 64005:
                message[".gogoproto.face"] = reader.bool();
                break;
              case 64006:
                message[".gogoproto.gostring"] = reader.bool();
                break;
              case 64007:
                message[".gogoproto.populate"] = reader.bool();
                break;
              case 67008:
                message[".gogoproto.stringer"] = reader.bool();
                break;
              case 64009:
                message[".gogoproto.onlyone"] = reader.bool();
                break;
              case 64013:
                message[".gogoproto.equal"] = reader.bool();
                break;
              case 64014:
                message[".gogoproto.description"] = reader.bool();
                break;
              case 64015:
                message[".gogoproto.testgen"] = reader.bool();
                break;
              case 64016:
                message[".gogoproto.benchgen"] = reader.bool();
                break;
              case 64017:
                message[".gogoproto.marshaler"] = reader.bool();
                break;
              case 64018:
                message[".gogoproto.unmarshaler"] = reader.bool();
                break;
              case 64019:
                message[".gogoproto.stableMarshaler"] = reader.bool();
                break;
              case 64020:
                message[".gogoproto.sizer"] = reader.bool();
                break;
              case 64023:
                message[".gogoproto.unsafeMarshaler"] = reader.bool();
                break;
              case 64024:
                message[".gogoproto.unsafeUnmarshaler"] = reader.bool();
                break;
              case 64025:
                message[".gogoproto.goprotoExtensionsMap"] = reader.bool();
                break;
              case 64026:
                message[".gogoproto.goprotoUnrecognized"] = reader.bool();
                break;
              case 64028:
                message[".gogoproto.protosizer"] = reader.bool();
                break;
              case 64029:
                message[".gogoproto.compare"] = reader.bool();
                break;
              case 64030:
                message[".gogoproto.typedecl"] = reader.bool();
                break;
              case 64033:
                message[".gogoproto.messagename"] = reader.bool();
                break;
              case 64034:
                message[".gogoproto.goprotoSizecache"] = reader.bool();
                break;
              case 64035:
                message[".gogoproto.goprotoUnkeyed"] = reader.bool();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a MessageOptions message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof google.protobuf.MessageOptions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {google.protobuf.MessageOptions} MessageOptions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MessageOptions.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MessageOptions message.
         * @function verify
         * @memberof google.protobuf.MessageOptions
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MessageOptions.verify = function verify(message) {
          if (typeof message !== "object" || message === null) return "object expected";
          if (message.messageSetWireFormat != null && message.hasOwnProperty("messageSetWireFormat"))
            if (typeof message.messageSetWireFormat !== "boolean")
              return "messageSetWireFormat: boolean expected";
          if (
            message.noStandardDescriptorAccessor != null &&
            message.hasOwnProperty("noStandardDescriptorAccessor")
          )
            if (typeof message.noStandardDescriptorAccessor !== "boolean")
              return "noStandardDescriptorAccessor: boolean expected";
          if (message.deprecated != null && message.hasOwnProperty("deprecated"))
            if (typeof message.deprecated !== "boolean") return "deprecated: boolean expected";
          if (message.mapEntry != null && message.hasOwnProperty("mapEntry"))
            if (typeof message.mapEntry !== "boolean") return "mapEntry: boolean expected";
          if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
            if (!Array.isArray(message.uninterpretedOption)) return "uninterpretedOption: array expected";
            for (var i = 0; i < message.uninterpretedOption.length; ++i) {
              var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
              if (error) return "uninterpretedOption." + error;
            }
          }
          if (
            message[".gogoproto.goprotoGetters"] != null &&
            message.hasOwnProperty(".gogoproto.goprotoGetters")
          )
            if (typeof message[".gogoproto.goprotoGetters"] !== "boolean")
              return ".gogoproto.goprotoGetters: boolean expected";
          if (
            message[".gogoproto.goprotoStringer"] != null &&
            message.hasOwnProperty(".gogoproto.goprotoStringer")
          )
            if (typeof message[".gogoproto.goprotoStringer"] !== "boolean")
              return ".gogoproto.goprotoStringer: boolean expected";
          if (message[".gogoproto.verboseEqual"] != null && message.hasOwnProperty(".gogoproto.verboseEqual"))
            if (typeof message[".gogoproto.verboseEqual"] !== "boolean")
              return ".gogoproto.verboseEqual: boolean expected";
          if (message[".gogoproto.face"] != null && message.hasOwnProperty(".gogoproto.face"))
            if (typeof message[".gogoproto.face"] !== "boolean") return ".gogoproto.face: boolean expected";
          if (message[".gogoproto.gostring"] != null && message.hasOwnProperty(".gogoproto.gostring"))
            if (typeof message[".gogoproto.gostring"] !== "boolean")
              return ".gogoproto.gostring: boolean expected";
          if (message[".gogoproto.populate"] != null && message.hasOwnProperty(".gogoproto.populate"))
            if (typeof message[".gogoproto.populate"] !== "boolean")
              return ".gogoproto.populate: boolean expected";
          if (message[".gogoproto.stringer"] != null && message.hasOwnProperty(".gogoproto.stringer"))
            if (typeof message[".gogoproto.stringer"] !== "boolean")
              return ".gogoproto.stringer: boolean expected";
          if (message[".gogoproto.onlyone"] != null && message.hasOwnProperty(".gogoproto.onlyone"))
            if (typeof message[".gogoproto.onlyone"] !== "boolean")
              return ".gogoproto.onlyone: boolean expected";
          if (message[".gogoproto.equal"] != null && message.hasOwnProperty(".gogoproto.equal"))
            if (typeof message[".gogoproto.equal"] !== "boolean") return ".gogoproto.equal: boolean expected";
          if (message[".gogoproto.description"] != null && message.hasOwnProperty(".gogoproto.description"))
            if (typeof message[".gogoproto.description"] !== "boolean")
              return ".gogoproto.description: boolean expected";
          if (message[".gogoproto.testgen"] != null && message.hasOwnProperty(".gogoproto.testgen"))
            if (typeof message[".gogoproto.testgen"] !== "boolean")
              return ".gogoproto.testgen: boolean expected";
          if (message[".gogoproto.benchgen"] != null && message.hasOwnProperty(".gogoproto.benchgen"))
            if (typeof message[".gogoproto.benchgen"] !== "boolean")
              return ".gogoproto.benchgen: boolean expected";
          if (message[".gogoproto.marshaler"] != null && message.hasOwnProperty(".gogoproto.marshaler"))
            if (typeof message[".gogoproto.marshaler"] !== "boolean")
              return ".gogoproto.marshaler: boolean expected";
          if (message[".gogoproto.unmarshaler"] != null && message.hasOwnProperty(".gogoproto.unmarshaler"))
            if (typeof message[".gogoproto.unmarshaler"] !== "boolean")
              return ".gogoproto.unmarshaler: boolean expected";
          if (
            message[".gogoproto.stableMarshaler"] != null &&
            message.hasOwnProperty(".gogoproto.stableMarshaler")
          )
            if (typeof message[".gogoproto.stableMarshaler"] !== "boolean")
              return ".gogoproto.stableMarshaler: boolean expected";
          if (message[".gogoproto.sizer"] != null && message.hasOwnProperty(".gogoproto.sizer"))
            if (typeof message[".gogoproto.sizer"] !== "boolean") return ".gogoproto.sizer: boolean expected";
          if (
            message[".gogoproto.unsafeMarshaler"] != null &&
            message.hasOwnProperty(".gogoproto.unsafeMarshaler")
          )
            if (typeof message[".gogoproto.unsafeMarshaler"] !== "boolean")
              return ".gogoproto.unsafeMarshaler: boolean expected";
          if (
            message[".gogoproto.unsafeUnmarshaler"] != null &&
            message.hasOwnProperty(".gogoproto.unsafeUnmarshaler")
          )
            if (typeof message[".gogoproto.unsafeUnmarshaler"] !== "boolean")
              return ".gogoproto.unsafeUnmarshaler: boolean expected";
          if (
            message[".gogoproto.goprotoExtensionsMap"] != null &&
            message.hasOwnProperty(".gogoproto.goprotoExtensionsMap")
          )
            if (typeof message[".gogoproto.goprotoExtensionsMap"] !== "boolean")
              return ".gogoproto.goprotoExtensionsMap: boolean expected";
          if (
            message[".gogoproto.goprotoUnrecognized"] != null &&
            message.hasOwnProperty(".gogoproto.goprotoUnrecognized")
          )
            if (typeof message[".gogoproto.goprotoUnrecognized"] !== "boolean")
              return ".gogoproto.goprotoUnrecognized: boolean expected";
          if (message[".gogoproto.protosizer"] != null && message.hasOwnProperty(".gogoproto.protosizer"))
            if (typeof message[".gogoproto.protosizer"] !== "boolean")
              return ".gogoproto.protosizer: boolean expected";
          if (message[".gogoproto.compare"] != null && message.hasOwnProperty(".gogoproto.compare"))
            if (typeof message[".gogoproto.compare"] !== "boolean")
              return ".gogoproto.compare: boolean expected";
          if (message[".gogoproto.typedecl"] != null && message.hasOwnProperty(".gogoproto.typedecl"))
            if (typeof message[".gogoproto.typedecl"] !== "boolean")
              return ".gogoproto.typedecl: boolean expected";
          if (message[".gogoproto.messagename"] != null && message.hasOwnProperty(".gogoproto.messagename"))
            if (typeof message[".gogoproto.messagename"] !== "boolean")
              return ".gogoproto.messagename: boolean expected";
          if (
            message[".gogoproto.goprotoSizecache"] != null &&
            message.hasOwnProperty(".gogoproto.goprotoSizecache")
          )
            if (typeof message[".gogoproto.goprotoSizecache"] !== "boolean")
              return ".gogoproto.goprotoSizecache: boolean expected";
          if (
            message[".gogoproto.goprotoUnkeyed"] != null &&
            message.hasOwnProperty(".gogoproto.goprotoUnkeyed")
          )
            if (typeof message[".gogoproto.goprotoUnkeyed"] !== "boolean")
              return ".gogoproto.goprotoUnkeyed: boolean expected";
          return null;
        };

        /**
         * Creates a MessageOptions message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof google.protobuf.MessageOptions
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {google.protobuf.MessageOptions} MessageOptions
         */
        MessageOptions.fromObject = function fromObject(object) {
          if (object instanceof $root.google.protobuf.MessageOptions) return object;
          var message = new $root.google.protobuf.MessageOptions();
          if (object.messageSetWireFormat != null)
            message.messageSetWireFormat = Boolean(object.messageSetWireFormat);
          if (object.noStandardDescriptorAccessor != null)
            message.noStandardDescriptorAccessor = Boolean(object.noStandardDescriptorAccessor);
          if (object.deprecated != null) message.deprecated = Boolean(object.deprecated);
          if (object.mapEntry != null) message.mapEntry = Boolean(object.mapEntry);
          if (object.uninterpretedOption) {
            if (!Array.isArray(object.uninterpretedOption))
              throw TypeError(".google.protobuf.MessageOptions.uninterpretedOption: array expected");
            message.uninterpretedOption = [];
            for (var i = 0; i < object.uninterpretedOption.length; ++i) {
              if (typeof object.uninterpretedOption[i] !== "object")
                throw TypeError(".google.protobuf.MessageOptions.uninterpretedOption: object expected");
              message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(
                object.uninterpretedOption[i],
              );
            }
          }
          if (object[".gogoproto.goprotoGetters"] != null)
            message[".gogoproto.goprotoGetters"] = Boolean(object[".gogoproto.goprotoGetters"]);
          if (object[".gogoproto.goprotoStringer"] != null)
            message[".gogoproto.goprotoStringer"] = Boolean(object[".gogoproto.goprotoStringer"]);
          if (object[".gogoproto.verboseEqual"] != null)
            message[".gogoproto.verboseEqual"] = Boolean(object[".gogoproto.verboseEqual"]);
          if (object[".gogoproto.face"] != null)
            message[".gogoproto.face"] = Boolean(object[".gogoproto.face"]);
          if (object[".gogoproto.gostring"] != null)
            message[".gogoproto.gostring"] = Boolean(object[".gogoproto.gostring"]);
          if (object[".gogoproto.populate"] != null)
            message[".gogoproto.populate"] = Boolean(object[".gogoproto.populate"]);
          if (object[".gogoproto.stringer"] != null)
            message[".gogoproto.stringer"] = Boolean(object[".gogoproto.stringer"]);
          if (object[".gogoproto.onlyone"] != null)
            message[".gogoproto.onlyone"] = Boolean(object[".gogoproto.onlyone"]);
          if (object[".gogoproto.equal"] != null)
            message[".gogoproto.equal"] = Boolean(object[".gogoproto.equal"]);
          if (object[".gogoproto.description"] != null)
            message[".gogoproto.description"] = Boolean(object[".gogoproto.description"]);
          if (object[".gogoproto.testgen"] != null)
            message[".gogoproto.testgen"] = Boolean(object[".gogoproto.testgen"]);
          if (object[".gogoproto.benchgen"] != null)
            message[".gogoproto.benchgen"] = Boolean(object[".gogoproto.benchgen"]);
          if (object[".gogoproto.marshaler"] != null)
            message[".gogoproto.marshaler"] = Boolean(object[".gogoproto.marshaler"]);
          if (object[".gogoproto.unmarshaler"] != null)
            message[".gogoproto.unmarshaler"] = Boolean(object[".gogoproto.unmarshaler"]);
          if (object[".gogoproto.stableMarshaler"] != null)
            message[".gogoproto.stableMarshaler"] = Boolean(object[".gogoproto.stableMarshaler"]);
          if (object[".gogoproto.sizer"] != null)
            message[".gogoproto.sizer"] = Boolean(object[".gogoproto.sizer"]);
          if (object[".gogoproto.unsafeMarshaler"] != null)
            message[".gogoproto.unsafeMarshaler"] = Boolean(object[".gogoproto.unsafeMarshaler"]);
          if (object[".gogoproto.unsafeUnmarshaler"] != null)
            message[".gogoproto.unsafeUnmarshaler"] = Boolean(object[".gogoproto.unsafeUnmarshaler"]);
          if (object[".gogoproto.goprotoExtensionsMap"] != null)
            message[".gogoproto.goprotoExtensionsMap"] = Boolean(object[".gogoproto.goprotoExtensionsMap"]);
          if (object[".gogoproto.goprotoUnrecognized"] != null)
            message[".gogoproto.goprotoUnrecognized"] = Boolean(object[".gogoproto.goprotoUnrecognized"]);
          if (object[".gogoproto.protosizer"] != null)
            message[".gogoproto.protosizer"] = Boolean(object[".gogoproto.protosizer"]);
          if (object[".gogoproto.compare"] != null)
            message[".gogoproto.compare"] = Boolean(object[".gogoproto.compare"]);
          if (object[".gogoproto.typedecl"] != null)
            message[".gogoproto.typedecl"] = Boolean(object[".gogoproto.typedecl"]);
          if (object[".gogoproto.messagename"] != null)
            message[".gogoproto.messagename"] = Boolean(object[".gogoproto.messagename"]);
          if (object[".gogoproto.goprotoSizecache"] != null)
            message[".gogoproto.goprotoSizecache"] = Boolean(object[".gogoproto.goprotoSizecache"]);
          if (object[".gogoproto.goprotoUnkeyed"] != null)
            message[".gogoproto.goprotoUnkeyed"] = Boolean(object[".gogoproto.goprotoUnkeyed"]);
          return message;
        };

        /**
         * Creates a plain object from a MessageOptions message. Also converts values to other types if specified.
         * @function toObject
         * @memberof google.protobuf.MessageOptions
         * @static
         * @param {google.protobuf.MessageOptions} message MessageOptions
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MessageOptions.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.arrays || options.defaults) object.uninterpretedOption = [];
          if (options.defaults) {
            object.messageSetWireFormat = false;
            object.noStandardDescriptorAccessor = false;
            object.deprecated = false;
            object.mapEntry = false;
            object[".gogoproto.goprotoGetters"] = false;
            object[".gogoproto.goprotoStringer"] = false;
            object[".gogoproto.verboseEqual"] = false;
            object[".gogoproto.face"] = false;
            object[".gogoproto.gostring"] = false;
            object[".gogoproto.populate"] = false;
            object[".gogoproto.onlyone"] = false;
            object[".gogoproto.equal"] = false;
            object[".gogoproto.description"] = false;
            object[".gogoproto.testgen"] = false;
            object[".gogoproto.benchgen"] = false;
            object[".gogoproto.marshaler"] = false;
            object[".gogoproto.unmarshaler"] = false;
            object[".gogoproto.stableMarshaler"] = false;
            object[".gogoproto.sizer"] = false;
            object[".gogoproto.unsafeMarshaler"] = false;
            object[".gogoproto.unsafeUnmarshaler"] = false;
            object[".gogoproto.goprotoExtensionsMap"] = false;
            object[".gogoproto.goprotoUnrecognized"] = false;
            object[".gogoproto.protosizer"] = false;
            object[".gogoproto.compare"] = false;
            object[".gogoproto.typedecl"] = false;
            object[".gogoproto.messagename"] = false;
            object[".gogoproto.goprotoSizecache"] = false;
            object[".gogoproto.goprotoUnkeyed"] = false;
            object[".gogoproto.stringer"] = false;
          }
          if (message.messageSetWireFormat != null && message.hasOwnProperty("messageSetWireFormat"))
            object.messageSetWireFormat = message.messageSetWireFormat;
          if (
            message.noStandardDescriptorAccessor != null &&
            message.hasOwnProperty("noStandardDescriptorAccessor")
          )
            object.noStandardDescriptorAccessor = message.noStandardDescriptorAccessor;
          if (message.deprecated != null && message.hasOwnProperty("deprecated"))
            object.deprecated = message.deprecated;
          if (message.mapEntry != null && message.hasOwnProperty("mapEntry"))
            object.mapEntry = message.mapEntry;
          if (message.uninterpretedOption && message.uninterpretedOption.length) {
            object.uninterpretedOption = [];
            for (var j = 0; j < message.uninterpretedOption.length; ++j)
              object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(
                message.uninterpretedOption[j],
                options,
              );
          }
          if (
            message[".gogoproto.goprotoGetters"] != null &&
            message.hasOwnProperty(".gogoproto.goprotoGetters")
          )
            object[".gogoproto.goprotoGetters"] = message[".gogoproto.goprotoGetters"];
          if (
            message[".gogoproto.goprotoStringer"] != null &&
            message.hasOwnProperty(".gogoproto.goprotoStringer")
          )
            object[".gogoproto.goprotoStringer"] = message[".gogoproto.goprotoStringer"];
          if (message[".gogoproto.verboseEqual"] != null && message.hasOwnProperty(".gogoproto.verboseEqual"))
            object[".gogoproto.verboseEqual"] = message[".gogoproto.verboseEqual"];
          if (message[".gogoproto.face"] != null && message.hasOwnProperty(".gogoproto.face"))
            object[".gogoproto.face"] = message[".gogoproto.face"];
          if (message[".gogoproto.gostring"] != null && message.hasOwnProperty(".gogoproto.gostring"))
            object[".gogoproto.gostring"] = message[".gogoproto.gostring"];
          if (message[".gogoproto.populate"] != null && message.hasOwnProperty(".gogoproto.populate"))
            object[".gogoproto.populate"] = message[".gogoproto.populate"];
          if (message[".gogoproto.onlyone"] != null && message.hasOwnProperty(".gogoproto.onlyone"))
            object[".gogoproto.onlyone"] = message[".gogoproto.onlyone"];
          if (message[".gogoproto.equal"] != null && message.hasOwnProperty(".gogoproto.equal"))
            object[".gogoproto.equal"] = message[".gogoproto.equal"];
          if (message[".gogoproto.description"] != null && message.hasOwnProperty(".gogoproto.description"))
            object[".gogoproto.description"] = message[".gogoproto.description"];
          if (message[".gogoproto.testgen"] != null && message.hasOwnProperty(".gogoproto.testgen"))
            object[".gogoproto.testgen"] = message[".gogoproto.testgen"];
          if (message[".gogoproto.benchgen"] != null && message.hasOwnProperty(".gogoproto.benchgen"))
            object[".gogoproto.benchgen"] = message[".gogoproto.benchgen"];
          if (message[".gogoproto.marshaler"] != null && message.hasOwnProperty(".gogoproto.marshaler"))
            object[".gogoproto.marshaler"] = message[".gogoproto.marshaler"];
          if (message[".gogoproto.unmarshaler"] != null && message.hasOwnProperty(".gogoproto.unmarshaler"))
            object[".gogoproto.unmarshaler"] = message[".gogoproto.unmarshaler"];
          if (
            message[".gogoproto.stableMarshaler"] != null &&
            message.hasOwnProperty(".gogoproto.stableMarshaler")
          )
            object[".gogoproto.stableMarshaler"] = message[".gogoproto.stableMarshaler"];
          if (message[".gogoproto.sizer"] != null && message.hasOwnProperty(".gogoproto.sizer"))
            object[".gogoproto.sizer"] = message[".gogoproto.sizer"];
          if (
            message[".gogoproto.unsafeMarshaler"] != null &&
            message.hasOwnProperty(".gogoproto.unsafeMarshaler")
          )
            object[".gogoproto.unsafeMarshaler"] = message[".gogoproto.unsafeMarshaler"];
          if (
            message[".gogoproto.unsafeUnmarshaler"] != null &&
            message.hasOwnProperty(".gogoproto.unsafeUnmarshaler")
          )
            object[".gogoproto.unsafeUnmarshaler"] = message[".gogoproto.unsafeUnmarshaler"];
          if (
            message[".gogoproto.goprotoExtensionsMap"] != null &&
            message.hasOwnProperty(".gogoproto.goprotoExtensionsMap")
          )
            object[".gogoproto.goprotoExtensionsMap"] = message[".gogoproto.goprotoExtensionsMap"];
          if (
            message[".gogoproto.goprotoUnrecognized"] != null &&
            message.hasOwnProperty(".gogoproto.goprotoUnrecognized")
          )
            object[".gogoproto.goprotoUnrecognized"] = message[".gogoproto.goprotoUnrecognized"];
          if (message[".gogoproto.protosizer"] != null && message.hasOwnProperty(".gogoproto.protosizer"))
            object[".gogoproto.protosizer"] = message[".gogoproto.protosizer"];
          if (message[".gogoproto.compare"] != null && message.hasOwnProperty(".gogoproto.compare"))
            object[".gogoproto.compare"] = message[".gogoproto.compare"];
          if (message[".gogoproto.typedecl"] != null && message.hasOwnProperty(".gogoproto.typedecl"))
            object[".gogoproto.typedecl"] = message[".gogoproto.typedecl"];
          if (message[".gogoproto.messagename"] != null && message.hasOwnProperty(".gogoproto.messagename"))
            object[".gogoproto.messagename"] = message[".gogoproto.messagename"];
          if (
            message[".gogoproto.goprotoSizecache"] != null &&
            message.hasOwnProperty(".gogoproto.goprotoSizecache")
          )
            object[".gogoproto.goprotoSizecache"] = message[".gogoproto.goprotoSizecache"];
          if (
            message[".gogoproto.goprotoUnkeyed"] != null &&
            message.hasOwnProperty(".gogoproto.goprotoUnkeyed")
          )
            object[".gogoproto.goprotoUnkeyed"] = message[".gogoproto.goprotoUnkeyed"];
          if (message[".gogoproto.stringer"] != null && message.hasOwnProperty(".gogoproto.stringer"))
            object[".gogoproto.stringer"] = message[".gogoproto.stringer"];
          return object;
        };

        /**
         * Converts this MessageOptions to JSON.
         * @function toJSON
         * @memberof google.protobuf.MessageOptions
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MessageOptions.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MessageOptions;
      })();

      protobuf.FieldOptions = (function () {
        /**
         * Properties of a FieldOptions.
         * @memberof google.protobuf
         * @interface IFieldOptions
         * @property {google.protobuf.FieldOptions.CType|null} [ctype] FieldOptions ctype
         * @property {boolean|null} [packed] FieldOptions packed
         * @property {google.protobuf.FieldOptions.JSType|null} [jstype] FieldOptions jstype
         * @property {boolean|null} [lazy] FieldOptions lazy
         * @property {boolean|null} [deprecated] FieldOptions deprecated
         * @property {boolean|null} [weak] FieldOptions weak
         * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] FieldOptions uninterpretedOption
         * @property {boolean|null} [".gogoproto.nullable"] FieldOptions .gogoproto.nullable
         * @property {boolean|null} [".gogoproto.embed"] FieldOptions .gogoproto.embed
         * @property {string|null} [".gogoproto.customtype"] FieldOptions .gogoproto.customtype
         * @property {string|null} [".gogoproto.customname"] FieldOptions .gogoproto.customname
         * @property {string|null} [".gogoproto.jsontag"] FieldOptions .gogoproto.jsontag
         * @property {string|null} [".gogoproto.moretags"] FieldOptions .gogoproto.moretags
         * @property {string|null} [".gogoproto.casttype"] FieldOptions .gogoproto.casttype
         * @property {string|null} [".gogoproto.castkey"] FieldOptions .gogoproto.castkey
         * @property {string|null} [".gogoproto.castvalue"] FieldOptions .gogoproto.castvalue
         * @property {boolean|null} [".gogoproto.stdtime"] FieldOptions .gogoproto.stdtime
         * @property {boolean|null} [".gogoproto.stdduration"] FieldOptions .gogoproto.stdduration
         * @property {boolean|null} [".gogoproto.wktpointer"] FieldOptions .gogoproto.wktpointer
         * @property {string|null} [".gogoproto.castrepeated"] FieldOptions .gogoproto.castrepeated
         */

        /**
         * Constructs a new FieldOptions.
         * @memberof google.protobuf
         * @classdesc Represents a FieldOptions.
         * @implements IFieldOptions
         * @constructor
         * @param {google.protobuf.IFieldOptions=} [properties] Properties to set
         */
        function FieldOptions(properties) {
          this.uninterpretedOption = [];
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * FieldOptions ctype.
         * @member {google.protobuf.FieldOptions.CType} ctype
         * @memberof google.protobuf.FieldOptions
         * @instance
         */
        FieldOptions.prototype.ctype = 0;

        /**
         * FieldOptions packed.
         * @member {boolean} packed
         * @memberof google.protobuf.FieldOptions
         * @instance
         */
        FieldOptions.prototype.packed = false;

        /**
         * FieldOptions jstype.
         * @member {google.protobuf.FieldOptions.JSType} jstype
         * @memberof google.protobuf.FieldOptions
         * @instance
         */
        FieldOptions.prototype.jstype = 0;

        /**
         * FieldOptions lazy.
         * @member {boolean} lazy
         * @memberof google.protobuf.FieldOptions
         * @instance
         */
        FieldOptions.prototype.lazy = false;

        /**
         * FieldOptions deprecated.
         * @member {boolean} deprecated
         * @memberof google.protobuf.FieldOptions
         * @instance
         */
        FieldOptions.prototype.deprecated = false;

        /**
         * FieldOptions weak.
         * @member {boolean} weak
         * @memberof google.protobuf.FieldOptions
         * @instance
         */
        FieldOptions.prototype.weak = false;

        /**
         * FieldOptions uninterpretedOption.
         * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
         * @memberof google.protobuf.FieldOptions
         * @instance
         */
        FieldOptions.prototype.uninterpretedOption = $util.emptyArray;

        /**
         * FieldOptions .gogoproto.nullable.
         * @member {boolean} .gogoproto.nullable
         * @memberof google.protobuf.FieldOptions
         * @instance
         */
        FieldOptions.prototype[".gogoproto.nullable"] = false;

        /**
         * FieldOptions .gogoproto.embed.
         * @member {boolean} .gogoproto.embed
         * @memberof google.protobuf.FieldOptions
         * @instance
         */
        FieldOptions.prototype[".gogoproto.embed"] = false;

        /**
         * FieldOptions .gogoproto.customtype.
         * @member {string} .gogoproto.customtype
         * @memberof google.protobuf.FieldOptions
         * @instance
         */
        FieldOptions.prototype[".gogoproto.customtype"] = "";

        /**
         * FieldOptions .gogoproto.customname.
         * @member {string} .gogoproto.customname
         * @memberof google.protobuf.FieldOptions
         * @instance
         */
        FieldOptions.prototype[".gogoproto.customname"] = "";

        /**
         * FieldOptions .gogoproto.jsontag.
         * @member {string} .gogoproto.jsontag
         * @memberof google.protobuf.FieldOptions
         * @instance
         */
        FieldOptions.prototype[".gogoproto.jsontag"] = "";

        /**
         * FieldOptions .gogoproto.moretags.
         * @member {string} .gogoproto.moretags
         * @memberof google.protobuf.FieldOptions
         * @instance
         */
        FieldOptions.prototype[".gogoproto.moretags"] = "";

        /**
         * FieldOptions .gogoproto.casttype.
         * @member {string} .gogoproto.casttype
         * @memberof google.protobuf.FieldOptions
         * @instance
         */
        FieldOptions.prototype[".gogoproto.casttype"] = "";

        /**
         * FieldOptions .gogoproto.castkey.
         * @member {string} .gogoproto.castkey
         * @memberof google.protobuf.FieldOptions
         * @instance
         */
        FieldOptions.prototype[".gogoproto.castkey"] = "";

        /**
         * FieldOptions .gogoproto.castvalue.
         * @member {string} .gogoproto.castvalue
         * @memberof google.protobuf.FieldOptions
         * @instance
         */
        FieldOptions.prototype[".gogoproto.castvalue"] = "";

        /**
         * FieldOptions .gogoproto.stdtime.
         * @member {boolean} .gogoproto.stdtime
         * @memberof google.protobuf.FieldOptions
         * @instance
         */
        FieldOptions.prototype[".gogoproto.stdtime"] = false;

        /**
         * FieldOptions .gogoproto.stdduration.
         * @member {boolean} .gogoproto.stdduration
         * @memberof google.protobuf.FieldOptions
         * @instance
         */
        FieldOptions.prototype[".gogoproto.stdduration"] = false;

        /**
         * FieldOptions .gogoproto.wktpointer.
         * @member {boolean} .gogoproto.wktpointer
         * @memberof google.protobuf.FieldOptions
         * @instance
         */
        FieldOptions.prototype[".gogoproto.wktpointer"] = false;

        /**
         * FieldOptions .gogoproto.castrepeated.
         * @member {string} .gogoproto.castrepeated
         * @memberof google.protobuf.FieldOptions
         * @instance
         */
        FieldOptions.prototype[".gogoproto.castrepeated"] = "";

        /**
         * Creates a new FieldOptions instance using the specified properties.
         * @function create
         * @memberof google.protobuf.FieldOptions
         * @static
         * @param {google.protobuf.IFieldOptions=} [properties] Properties to set
         * @returns {google.protobuf.FieldOptions} FieldOptions instance
         */
        FieldOptions.create = function create(properties) {
          return new FieldOptions(properties);
        };

        /**
         * Encodes the specified FieldOptions message. Does not implicitly {@link google.protobuf.FieldOptions.verify|verify} messages.
         * @function encode
         * @memberof google.protobuf.FieldOptions
         * @static
         * @param {google.protobuf.IFieldOptions} message FieldOptions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FieldOptions.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.ctype != null && Object.hasOwnProperty.call(message, "ctype"))
            writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.ctype);
          if (message.packed != null && Object.hasOwnProperty.call(message, "packed"))
            writer.uint32(/* id 2, wireType 0 =*/ 16).bool(message.packed);
          if (message.deprecated != null && Object.hasOwnProperty.call(message, "deprecated"))
            writer.uint32(/* id 3, wireType 0 =*/ 24).bool(message.deprecated);
          if (message.lazy != null && Object.hasOwnProperty.call(message, "lazy"))
            writer.uint32(/* id 5, wireType 0 =*/ 40).bool(message.lazy);
          if (message.jstype != null && Object.hasOwnProperty.call(message, "jstype"))
            writer.uint32(/* id 6, wireType 0 =*/ 48).int32(message.jstype);
          if (message.weak != null && Object.hasOwnProperty.call(message, "weak"))
            writer.uint32(/* id 10, wireType 0 =*/ 80).bool(message.weak);
          if (message.uninterpretedOption != null && message.uninterpretedOption.length)
            for (var i = 0; i < message.uninterpretedOption.length; ++i)
              $root.google.protobuf.UninterpretedOption.encode(
                message.uninterpretedOption[i],
                writer.uint32(/* id 999, wireType 2 =*/ 7994).fork(),
              ).ldelim();
          if (
            message[".gogoproto.nullable"] != null &&
            Object.hasOwnProperty.call(message, ".gogoproto.nullable")
          )
            writer.uint32(/* id 65001, wireType 0 =*/ 520008).bool(message[".gogoproto.nullable"]);
          if (message[".gogoproto.embed"] != null && Object.hasOwnProperty.call(message, ".gogoproto.embed"))
            writer.uint32(/* id 65002, wireType 0 =*/ 520016).bool(message[".gogoproto.embed"]);
          if (
            message[".gogoproto.customtype"] != null &&
            Object.hasOwnProperty.call(message, ".gogoproto.customtype")
          )
            writer.uint32(/* id 65003, wireType 2 =*/ 520026).string(message[".gogoproto.customtype"]);
          if (
            message[".gogoproto.customname"] != null &&
            Object.hasOwnProperty.call(message, ".gogoproto.customname")
          )
            writer.uint32(/* id 65004, wireType 2 =*/ 520034).string(message[".gogoproto.customname"]);
          if (
            message[".gogoproto.jsontag"] != null &&
            Object.hasOwnProperty.call(message, ".gogoproto.jsontag")
          )
            writer.uint32(/* id 65005, wireType 2 =*/ 520042).string(message[".gogoproto.jsontag"]);
          if (
            message[".gogoproto.moretags"] != null &&
            Object.hasOwnProperty.call(message, ".gogoproto.moretags")
          )
            writer.uint32(/* id 65006, wireType 2 =*/ 520050).string(message[".gogoproto.moretags"]);
          if (
            message[".gogoproto.casttype"] != null &&
            Object.hasOwnProperty.call(message, ".gogoproto.casttype")
          )
            writer.uint32(/* id 65007, wireType 2 =*/ 520058).string(message[".gogoproto.casttype"]);
          if (
            message[".gogoproto.castkey"] != null &&
            Object.hasOwnProperty.call(message, ".gogoproto.castkey")
          )
            writer.uint32(/* id 65008, wireType 2 =*/ 520066).string(message[".gogoproto.castkey"]);
          if (
            message[".gogoproto.castvalue"] != null &&
            Object.hasOwnProperty.call(message, ".gogoproto.castvalue")
          )
            writer.uint32(/* id 65009, wireType 2 =*/ 520074).string(message[".gogoproto.castvalue"]);
          if (
            message[".gogoproto.stdtime"] != null &&
            Object.hasOwnProperty.call(message, ".gogoproto.stdtime")
          )
            writer.uint32(/* id 65010, wireType 0 =*/ 520080).bool(message[".gogoproto.stdtime"]);
          if (
            message[".gogoproto.stdduration"] != null &&
            Object.hasOwnProperty.call(message, ".gogoproto.stdduration")
          )
            writer.uint32(/* id 65011, wireType 0 =*/ 520088).bool(message[".gogoproto.stdduration"]);
          if (
            message[".gogoproto.wktpointer"] != null &&
            Object.hasOwnProperty.call(message, ".gogoproto.wktpointer")
          )
            writer.uint32(/* id 65012, wireType 0 =*/ 520096).bool(message[".gogoproto.wktpointer"]);
          if (
            message[".gogoproto.castrepeated"] != null &&
            Object.hasOwnProperty.call(message, ".gogoproto.castrepeated")
          )
            writer.uint32(/* id 65013, wireType 2 =*/ 520106).string(message[".gogoproto.castrepeated"]);
          return writer;
        };

        /**
         * Encodes the specified FieldOptions message, length delimited. Does not implicitly {@link google.protobuf.FieldOptions.verify|verify} messages.
         * @function encodeDelimited
         * @memberof google.protobuf.FieldOptions
         * @static
         * @param {google.protobuf.IFieldOptions} message FieldOptions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FieldOptions.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FieldOptions message from the specified reader or buffer.
         * @function decode
         * @memberof google.protobuf.FieldOptions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {google.protobuf.FieldOptions} FieldOptions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FieldOptions.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.google.protobuf.FieldOptions();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.ctype = reader.int32();
                break;
              case 2:
                message.packed = reader.bool();
                break;
              case 6:
                message.jstype = reader.int32();
                break;
              case 5:
                message.lazy = reader.bool();
                break;
              case 3:
                message.deprecated = reader.bool();
                break;
              case 10:
                message.weak = reader.bool();
                break;
              case 999:
                if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                  message.uninterpretedOption = [];
                message.uninterpretedOption.push(
                  $root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()),
                );
                break;
              case 65001:
                message[".gogoproto.nullable"] = reader.bool();
                break;
              case 65002:
                message[".gogoproto.embed"] = reader.bool();
                break;
              case 65003:
                message[".gogoproto.customtype"] = reader.string();
                break;
              case 65004:
                message[".gogoproto.customname"] = reader.string();
                break;
              case 65005:
                message[".gogoproto.jsontag"] = reader.string();
                break;
              case 65006:
                message[".gogoproto.moretags"] = reader.string();
                break;
              case 65007:
                message[".gogoproto.casttype"] = reader.string();
                break;
              case 65008:
                message[".gogoproto.castkey"] = reader.string();
                break;
              case 65009:
                message[".gogoproto.castvalue"] = reader.string();
                break;
              case 65010:
                message[".gogoproto.stdtime"] = reader.bool();
                break;
              case 65011:
                message[".gogoproto.stdduration"] = reader.bool();
                break;
              case 65012:
                message[".gogoproto.wktpointer"] = reader.bool();
                break;
              case 65013:
                message[".gogoproto.castrepeated"] = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a FieldOptions message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof google.protobuf.FieldOptions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {google.protobuf.FieldOptions} FieldOptions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FieldOptions.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FieldOptions message.
         * @function verify
         * @memberof google.protobuf.FieldOptions
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FieldOptions.verify = function verify(message) {
          if (typeof message !== "object" || message === null) return "object expected";
          if (message.ctype != null && message.hasOwnProperty("ctype"))
            switch (message.ctype) {
              default:
                return "ctype: enum value expected";
              case 0:
              case 1:
              case 2:
                break;
            }
          if (message.packed != null && message.hasOwnProperty("packed"))
            if (typeof message.packed !== "boolean") return "packed: boolean expected";
          if (message.jstype != null && message.hasOwnProperty("jstype"))
            switch (message.jstype) {
              default:
                return "jstype: enum value expected";
              case 0:
              case 1:
              case 2:
                break;
            }
          if (message.lazy != null && message.hasOwnProperty("lazy"))
            if (typeof message.lazy !== "boolean") return "lazy: boolean expected";
          if (message.deprecated != null && message.hasOwnProperty("deprecated"))
            if (typeof message.deprecated !== "boolean") return "deprecated: boolean expected";
          if (message.weak != null && message.hasOwnProperty("weak"))
            if (typeof message.weak !== "boolean") return "weak: boolean expected";
          if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
            if (!Array.isArray(message.uninterpretedOption)) return "uninterpretedOption: array expected";
            for (var i = 0; i < message.uninterpretedOption.length; ++i) {
              var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
              if (error) return "uninterpretedOption." + error;
            }
          }
          if (message[".gogoproto.nullable"] != null && message.hasOwnProperty(".gogoproto.nullable"))
            if (typeof message[".gogoproto.nullable"] !== "boolean")
              return ".gogoproto.nullable: boolean expected";
          if (message[".gogoproto.embed"] != null && message.hasOwnProperty(".gogoproto.embed"))
            if (typeof message[".gogoproto.embed"] !== "boolean") return ".gogoproto.embed: boolean expected";
          if (message[".gogoproto.customtype"] != null && message.hasOwnProperty(".gogoproto.customtype"))
            if (!$util.isString(message[".gogoproto.customtype"]))
              return ".gogoproto.customtype: string expected";
          if (message[".gogoproto.customname"] != null && message.hasOwnProperty(".gogoproto.customname"))
            if (!$util.isString(message[".gogoproto.customname"]))
              return ".gogoproto.customname: string expected";
          if (message[".gogoproto.jsontag"] != null && message.hasOwnProperty(".gogoproto.jsontag"))
            if (!$util.isString(message[".gogoproto.jsontag"])) return ".gogoproto.jsontag: string expected";
          if (message[".gogoproto.moretags"] != null && message.hasOwnProperty(".gogoproto.moretags"))
            if (!$util.isString(message[".gogoproto.moretags"]))
              return ".gogoproto.moretags: string expected";
          if (message[".gogoproto.casttype"] != null && message.hasOwnProperty(".gogoproto.casttype"))
            if (!$util.isString(message[".gogoproto.casttype"]))
              return ".gogoproto.casttype: string expected";
          if (message[".gogoproto.castkey"] != null && message.hasOwnProperty(".gogoproto.castkey"))
            if (!$util.isString(message[".gogoproto.castkey"])) return ".gogoproto.castkey: string expected";
          if (message[".gogoproto.castvalue"] != null && message.hasOwnProperty(".gogoproto.castvalue"))
            if (!$util.isString(message[".gogoproto.castvalue"]))
              return ".gogoproto.castvalue: string expected";
          if (message[".gogoproto.stdtime"] != null && message.hasOwnProperty(".gogoproto.stdtime"))
            if (typeof message[".gogoproto.stdtime"] !== "boolean")
              return ".gogoproto.stdtime: boolean expected";
          if (message[".gogoproto.stdduration"] != null && message.hasOwnProperty(".gogoproto.stdduration"))
            if (typeof message[".gogoproto.stdduration"] !== "boolean")
              return ".gogoproto.stdduration: boolean expected";
          if (message[".gogoproto.wktpointer"] != null && message.hasOwnProperty(".gogoproto.wktpointer"))
            if (typeof message[".gogoproto.wktpointer"] !== "boolean")
              return ".gogoproto.wktpointer: boolean expected";
          if (message[".gogoproto.castrepeated"] != null && message.hasOwnProperty(".gogoproto.castrepeated"))
            if (!$util.isString(message[".gogoproto.castrepeated"]))
              return ".gogoproto.castrepeated: string expected";
          return null;
        };

        /**
         * Creates a FieldOptions message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof google.protobuf.FieldOptions
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {google.protobuf.FieldOptions} FieldOptions
         */
        FieldOptions.fromObject = function fromObject(object) {
          if (object instanceof $root.google.protobuf.FieldOptions) return object;
          var message = new $root.google.protobuf.FieldOptions();
          switch (object.ctype) {
            case "STRING":
            case 0:
              message.ctype = 0;
              break;
            case "CORD":
            case 1:
              message.ctype = 1;
              break;
            case "STRING_PIECE":
            case 2:
              message.ctype = 2;
              break;
          }
          if (object.packed != null) message.packed = Boolean(object.packed);
          switch (object.jstype) {
            case "JS_NORMAL":
            case 0:
              message.jstype = 0;
              break;
            case "JS_STRING":
            case 1:
              message.jstype = 1;
              break;
            case "JS_NUMBER":
            case 2:
              message.jstype = 2;
              break;
          }
          if (object.lazy != null) message.lazy = Boolean(object.lazy);
          if (object.deprecated != null) message.deprecated = Boolean(object.deprecated);
          if (object.weak != null) message.weak = Boolean(object.weak);
          if (object.uninterpretedOption) {
            if (!Array.isArray(object.uninterpretedOption))
              throw TypeError(".google.protobuf.FieldOptions.uninterpretedOption: array expected");
            message.uninterpretedOption = [];
            for (var i = 0; i < object.uninterpretedOption.length; ++i) {
              if (typeof object.uninterpretedOption[i] !== "object")
                throw TypeError(".google.protobuf.FieldOptions.uninterpretedOption: object expected");
              message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(
                object.uninterpretedOption[i],
              );
            }
          }
          if (object[".gogoproto.nullable"] != null)
            message[".gogoproto.nullable"] = Boolean(object[".gogoproto.nullable"]);
          if (object[".gogoproto.embed"] != null)
            message[".gogoproto.embed"] = Boolean(object[".gogoproto.embed"]);
          if (object[".gogoproto.customtype"] != null)
            message[".gogoproto.customtype"] = String(object[".gogoproto.customtype"]);
          if (object[".gogoproto.customname"] != null)
            message[".gogoproto.customname"] = String(object[".gogoproto.customname"]);
          if (object[".gogoproto.jsontag"] != null)
            message[".gogoproto.jsontag"] = String(object[".gogoproto.jsontag"]);
          if (object[".gogoproto.moretags"] != null)
            message[".gogoproto.moretags"] = String(object[".gogoproto.moretags"]);
          if (object[".gogoproto.casttype"] != null)
            message[".gogoproto.casttype"] = String(object[".gogoproto.casttype"]);
          if (object[".gogoproto.castkey"] != null)
            message[".gogoproto.castkey"] = String(object[".gogoproto.castkey"]);
          if (object[".gogoproto.castvalue"] != null)
            message[".gogoproto.castvalue"] = String(object[".gogoproto.castvalue"]);
          if (object[".gogoproto.stdtime"] != null)
            message[".gogoproto.stdtime"] = Boolean(object[".gogoproto.stdtime"]);
          if (object[".gogoproto.stdduration"] != null)
            message[".gogoproto.stdduration"] = Boolean(object[".gogoproto.stdduration"]);
          if (object[".gogoproto.wktpointer"] != null)
            message[".gogoproto.wktpointer"] = Boolean(object[".gogoproto.wktpointer"]);
          if (object[".gogoproto.castrepeated"] != null)
            message[".gogoproto.castrepeated"] = String(object[".gogoproto.castrepeated"]);
          return message;
        };

        /**
         * Creates a plain object from a FieldOptions message. Also converts values to other types if specified.
         * @function toObject
         * @memberof google.protobuf.FieldOptions
         * @static
         * @param {google.protobuf.FieldOptions} message FieldOptions
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FieldOptions.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.arrays || options.defaults) object.uninterpretedOption = [];
          if (options.defaults) {
            object.ctype = options.enums === String ? "STRING" : 0;
            object.packed = false;
            object.deprecated = false;
            object.lazy = false;
            object.jstype = options.enums === String ? "JS_NORMAL" : 0;
            object.weak = false;
            object[".gogoproto.nullable"] = false;
            object[".gogoproto.embed"] = false;
            object[".gogoproto.customtype"] = "";
            object[".gogoproto.customname"] = "";
            object[".gogoproto.jsontag"] = "";
            object[".gogoproto.moretags"] = "";
            object[".gogoproto.casttype"] = "";
            object[".gogoproto.castkey"] = "";
            object[".gogoproto.castvalue"] = "";
            object[".gogoproto.stdtime"] = false;
            object[".gogoproto.stdduration"] = false;
            object[".gogoproto.wktpointer"] = false;
            object[".gogoproto.castrepeated"] = "";
          }
          if (message.ctype != null && message.hasOwnProperty("ctype"))
            object.ctype =
              options.enums === String
                ? $root.google.protobuf.FieldOptions.CType[message.ctype]
                : message.ctype;
          if (message.packed != null && message.hasOwnProperty("packed")) object.packed = message.packed;
          if (message.deprecated != null && message.hasOwnProperty("deprecated"))
            object.deprecated = message.deprecated;
          if (message.lazy != null && message.hasOwnProperty("lazy")) object.lazy = message.lazy;
          if (message.jstype != null && message.hasOwnProperty("jstype"))
            object.jstype =
              options.enums === String
                ? $root.google.protobuf.FieldOptions.JSType[message.jstype]
                : message.jstype;
          if (message.weak != null && message.hasOwnProperty("weak")) object.weak = message.weak;
          if (message.uninterpretedOption && message.uninterpretedOption.length) {
            object.uninterpretedOption = [];
            for (var j = 0; j < message.uninterpretedOption.length; ++j)
              object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(
                message.uninterpretedOption[j],
                options,
              );
          }
          if (message[".gogoproto.nullable"] != null && message.hasOwnProperty(".gogoproto.nullable"))
            object[".gogoproto.nullable"] = message[".gogoproto.nullable"];
          if (message[".gogoproto.embed"] != null && message.hasOwnProperty(".gogoproto.embed"))
            object[".gogoproto.embed"] = message[".gogoproto.embed"];
          if (message[".gogoproto.customtype"] != null && message.hasOwnProperty(".gogoproto.customtype"))
            object[".gogoproto.customtype"] = message[".gogoproto.customtype"];
          if (message[".gogoproto.customname"] != null && message.hasOwnProperty(".gogoproto.customname"))
            object[".gogoproto.customname"] = message[".gogoproto.customname"];
          if (message[".gogoproto.jsontag"] != null && message.hasOwnProperty(".gogoproto.jsontag"))
            object[".gogoproto.jsontag"] = message[".gogoproto.jsontag"];
          if (message[".gogoproto.moretags"] != null && message.hasOwnProperty(".gogoproto.moretags"))
            object[".gogoproto.moretags"] = message[".gogoproto.moretags"];
          if (message[".gogoproto.casttype"] != null && message.hasOwnProperty(".gogoproto.casttype"))
            object[".gogoproto.casttype"] = message[".gogoproto.casttype"];
          if (message[".gogoproto.castkey"] != null && message.hasOwnProperty(".gogoproto.castkey"))
            object[".gogoproto.castkey"] = message[".gogoproto.castkey"];
          if (message[".gogoproto.castvalue"] != null && message.hasOwnProperty(".gogoproto.castvalue"))
            object[".gogoproto.castvalue"] = message[".gogoproto.castvalue"];
          if (message[".gogoproto.stdtime"] != null && message.hasOwnProperty(".gogoproto.stdtime"))
            object[".gogoproto.stdtime"] = message[".gogoproto.stdtime"];
          if (message[".gogoproto.stdduration"] != null && message.hasOwnProperty(".gogoproto.stdduration"))
            object[".gogoproto.stdduration"] = message[".gogoproto.stdduration"];
          if (message[".gogoproto.wktpointer"] != null && message.hasOwnProperty(".gogoproto.wktpointer"))
            object[".gogoproto.wktpointer"] = message[".gogoproto.wktpointer"];
          if (message[".gogoproto.castrepeated"] != null && message.hasOwnProperty(".gogoproto.castrepeated"))
            object[".gogoproto.castrepeated"] = message[".gogoproto.castrepeated"];
          return object;
        };

        /**
         * Converts this FieldOptions to JSON.
         * @function toJSON
         * @memberof google.protobuf.FieldOptions
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FieldOptions.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * CType enum.
         * @name google.protobuf.FieldOptions.CType
         * @enum {number}
         * @property {number} STRING=0 STRING value
         * @property {number} CORD=1 CORD value
         * @property {number} STRING_PIECE=2 STRING_PIECE value
         */
        FieldOptions.CType = (function () {
          var valuesById = {},
            values = Object.create(valuesById);
          values[(valuesById[0] = "STRING")] = 0;
          values[(valuesById[1] = "CORD")] = 1;
          values[(valuesById[2] = "STRING_PIECE")] = 2;
          return values;
        })();

        /**
         * JSType enum.
         * @name google.protobuf.FieldOptions.JSType
         * @enum {number}
         * @property {number} JS_NORMAL=0 JS_NORMAL value
         * @property {number} JS_STRING=1 JS_STRING value
         * @property {number} JS_NUMBER=2 JS_NUMBER value
         */
        FieldOptions.JSType = (function () {
          var valuesById = {},
            values = Object.create(valuesById);
          values[(valuesById[0] = "JS_NORMAL")] = 0;
          values[(valuesById[1] = "JS_STRING")] = 1;
          values[(valuesById[2] = "JS_NUMBER")] = 2;
          return values;
        })();

        return FieldOptions;
      })();

      protobuf.OneofOptions = (function () {
        /**
         * Properties of an OneofOptions.
         * @memberof google.protobuf
         * @interface IOneofOptions
         * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] OneofOptions uninterpretedOption
         */

        /**
         * Constructs a new OneofOptions.
         * @memberof google.protobuf
         * @classdesc Represents an OneofOptions.
         * @implements IOneofOptions
         * @constructor
         * @param {google.protobuf.IOneofOptions=} [properties] Properties to set
         */
        function OneofOptions(properties) {
          this.uninterpretedOption = [];
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * OneofOptions uninterpretedOption.
         * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
         * @memberof google.protobuf.OneofOptions
         * @instance
         */
        OneofOptions.prototype.uninterpretedOption = $util.emptyArray;

        /**
         * Creates a new OneofOptions instance using the specified properties.
         * @function create
         * @memberof google.protobuf.OneofOptions
         * @static
         * @param {google.protobuf.IOneofOptions=} [properties] Properties to set
         * @returns {google.protobuf.OneofOptions} OneofOptions instance
         */
        OneofOptions.create = function create(properties) {
          return new OneofOptions(properties);
        };

        /**
         * Encodes the specified OneofOptions message. Does not implicitly {@link google.protobuf.OneofOptions.verify|verify} messages.
         * @function encode
         * @memberof google.protobuf.OneofOptions
         * @static
         * @param {google.protobuf.IOneofOptions} message OneofOptions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OneofOptions.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.uninterpretedOption != null && message.uninterpretedOption.length)
            for (var i = 0; i < message.uninterpretedOption.length; ++i)
              $root.google.protobuf.UninterpretedOption.encode(
                message.uninterpretedOption[i],
                writer.uint32(/* id 999, wireType 2 =*/ 7994).fork(),
              ).ldelim();
          return writer;
        };

        /**
         * Encodes the specified OneofOptions message, length delimited. Does not implicitly {@link google.protobuf.OneofOptions.verify|verify} messages.
         * @function encodeDelimited
         * @memberof google.protobuf.OneofOptions
         * @static
         * @param {google.protobuf.IOneofOptions} message OneofOptions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OneofOptions.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an OneofOptions message from the specified reader or buffer.
         * @function decode
         * @memberof google.protobuf.OneofOptions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {google.protobuf.OneofOptions} OneofOptions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OneofOptions.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.google.protobuf.OneofOptions();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 999:
                if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                  message.uninterpretedOption = [];
                message.uninterpretedOption.push(
                  $root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()),
                );
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes an OneofOptions message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof google.protobuf.OneofOptions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {google.protobuf.OneofOptions} OneofOptions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OneofOptions.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an OneofOptions message.
         * @function verify
         * @memberof google.protobuf.OneofOptions
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        OneofOptions.verify = function verify(message) {
          if (typeof message !== "object" || message === null) return "object expected";
          if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
            if (!Array.isArray(message.uninterpretedOption)) return "uninterpretedOption: array expected";
            for (var i = 0; i < message.uninterpretedOption.length; ++i) {
              var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
              if (error) return "uninterpretedOption." + error;
            }
          }
          return null;
        };

        /**
         * Creates an OneofOptions message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof google.protobuf.OneofOptions
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {google.protobuf.OneofOptions} OneofOptions
         */
        OneofOptions.fromObject = function fromObject(object) {
          if (object instanceof $root.google.protobuf.OneofOptions) return object;
          var message = new $root.google.protobuf.OneofOptions();
          if (object.uninterpretedOption) {
            if (!Array.isArray(object.uninterpretedOption))
              throw TypeError(".google.protobuf.OneofOptions.uninterpretedOption: array expected");
            message.uninterpretedOption = [];
            for (var i = 0; i < object.uninterpretedOption.length; ++i) {
              if (typeof object.uninterpretedOption[i] !== "object")
                throw TypeError(".google.protobuf.OneofOptions.uninterpretedOption: object expected");
              message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(
                object.uninterpretedOption[i],
              );
            }
          }
          return message;
        };

        /**
         * Creates a plain object from an OneofOptions message. Also converts values to other types if specified.
         * @function toObject
         * @memberof google.protobuf.OneofOptions
         * @static
         * @param {google.protobuf.OneofOptions} message OneofOptions
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        OneofOptions.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.arrays || options.defaults) object.uninterpretedOption = [];
          if (message.uninterpretedOption && message.uninterpretedOption.length) {
            object.uninterpretedOption = [];
            for (var j = 0; j < message.uninterpretedOption.length; ++j)
              object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(
                message.uninterpretedOption[j],
                options,
              );
          }
          return object;
        };

        /**
         * Converts this OneofOptions to JSON.
         * @function toJSON
         * @memberof google.protobuf.OneofOptions
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        OneofOptions.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return OneofOptions;
      })();

      protobuf.EnumOptions = (function () {
        /**
         * Properties of an EnumOptions.
         * @memberof google.protobuf
         * @interface IEnumOptions
         * @property {boolean|null} [allowAlias] EnumOptions allowAlias
         * @property {boolean|null} [deprecated] EnumOptions deprecated
         * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] EnumOptions uninterpretedOption
         * @property {boolean|null} [".gogoproto.goprotoEnumPrefix"] EnumOptions .gogoproto.goprotoEnumPrefix
         * @property {boolean|null} [".gogoproto.goprotoEnumStringer"] EnumOptions .gogoproto.goprotoEnumStringer
         * @property {boolean|null} [".gogoproto.enumStringer"] EnumOptions .gogoproto.enumStringer
         * @property {string|null} [".gogoproto.enumCustomname"] EnumOptions .gogoproto.enumCustomname
         * @property {boolean|null} [".gogoproto.enumdecl"] EnumOptions .gogoproto.enumdecl
         */

        /**
         * Constructs a new EnumOptions.
         * @memberof google.protobuf
         * @classdesc Represents an EnumOptions.
         * @implements IEnumOptions
         * @constructor
         * @param {google.protobuf.IEnumOptions=} [properties] Properties to set
         */
        function EnumOptions(properties) {
          this.uninterpretedOption = [];
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * EnumOptions allowAlias.
         * @member {boolean} allowAlias
         * @memberof google.protobuf.EnumOptions
         * @instance
         */
        EnumOptions.prototype.allowAlias = false;

        /**
         * EnumOptions deprecated.
         * @member {boolean} deprecated
         * @memberof google.protobuf.EnumOptions
         * @instance
         */
        EnumOptions.prototype.deprecated = false;

        /**
         * EnumOptions uninterpretedOption.
         * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
         * @memberof google.protobuf.EnumOptions
         * @instance
         */
        EnumOptions.prototype.uninterpretedOption = $util.emptyArray;

        /**
         * EnumOptions .gogoproto.goprotoEnumPrefix.
         * @member {boolean} .gogoproto.goprotoEnumPrefix
         * @memberof google.protobuf.EnumOptions
         * @instance
         */
        EnumOptions.prototype[".gogoproto.goprotoEnumPrefix"] = false;

        /**
         * EnumOptions .gogoproto.goprotoEnumStringer.
         * @member {boolean} .gogoproto.goprotoEnumStringer
         * @memberof google.protobuf.EnumOptions
         * @instance
         */
        EnumOptions.prototype[".gogoproto.goprotoEnumStringer"] = false;

        /**
         * EnumOptions .gogoproto.enumStringer.
         * @member {boolean} .gogoproto.enumStringer
         * @memberof google.protobuf.EnumOptions
         * @instance
         */
        EnumOptions.prototype[".gogoproto.enumStringer"] = false;

        /**
         * EnumOptions .gogoproto.enumCustomname.
         * @member {string} .gogoproto.enumCustomname
         * @memberof google.protobuf.EnumOptions
         * @instance
         */
        EnumOptions.prototype[".gogoproto.enumCustomname"] = "";

        /**
         * EnumOptions .gogoproto.enumdecl.
         * @member {boolean} .gogoproto.enumdecl
         * @memberof google.protobuf.EnumOptions
         * @instance
         */
        EnumOptions.prototype[".gogoproto.enumdecl"] = false;

        /**
         * Creates a new EnumOptions instance using the specified properties.
         * @function create
         * @memberof google.protobuf.EnumOptions
         * @static
         * @param {google.protobuf.IEnumOptions=} [properties] Properties to set
         * @returns {google.protobuf.EnumOptions} EnumOptions instance
         */
        EnumOptions.create = function create(properties) {
          return new EnumOptions(properties);
        };

        /**
         * Encodes the specified EnumOptions message. Does not implicitly {@link google.protobuf.EnumOptions.verify|verify} messages.
         * @function encode
         * @memberof google.protobuf.EnumOptions
         * @static
         * @param {google.protobuf.IEnumOptions} message EnumOptions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EnumOptions.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.allowAlias != null && Object.hasOwnProperty.call(message, "allowAlias"))
            writer.uint32(/* id 2, wireType 0 =*/ 16).bool(message.allowAlias);
          if (message.deprecated != null && Object.hasOwnProperty.call(message, "deprecated"))
            writer.uint32(/* id 3, wireType 0 =*/ 24).bool(message.deprecated);
          if (message.uninterpretedOption != null && message.uninterpretedOption.length)
            for (var i = 0; i < message.uninterpretedOption.length; ++i)
              $root.google.protobuf.UninterpretedOption.encode(
                message.uninterpretedOption[i],
                writer.uint32(/* id 999, wireType 2 =*/ 7994).fork(),
              ).ldelim();
          if (
            message[".gogoproto.goprotoEnumPrefix"] != null &&
            Object.hasOwnProperty.call(message, ".gogoproto.goprotoEnumPrefix")
          )
            writer.uint32(/* id 62001, wireType 0 =*/ 496008).bool(message[".gogoproto.goprotoEnumPrefix"]);
          if (
            message[".gogoproto.goprotoEnumStringer"] != null &&
            Object.hasOwnProperty.call(message, ".gogoproto.goprotoEnumStringer")
          )
            writer.uint32(/* id 62021, wireType 0 =*/ 496168).bool(message[".gogoproto.goprotoEnumStringer"]);
          if (
            message[".gogoproto.enumStringer"] != null &&
            Object.hasOwnProperty.call(message, ".gogoproto.enumStringer")
          )
            writer.uint32(/* id 62022, wireType 0 =*/ 496176).bool(message[".gogoproto.enumStringer"]);
          if (
            message[".gogoproto.enumCustomname"] != null &&
            Object.hasOwnProperty.call(message, ".gogoproto.enumCustomname")
          )
            writer.uint32(/* id 62023, wireType 2 =*/ 496186).string(message[".gogoproto.enumCustomname"]);
          if (
            message[".gogoproto.enumdecl"] != null &&
            Object.hasOwnProperty.call(message, ".gogoproto.enumdecl")
          )
            writer.uint32(/* id 62024, wireType 0 =*/ 496192).bool(message[".gogoproto.enumdecl"]);
          return writer;
        };

        /**
         * Encodes the specified EnumOptions message, length delimited. Does not implicitly {@link google.protobuf.EnumOptions.verify|verify} messages.
         * @function encodeDelimited
         * @memberof google.protobuf.EnumOptions
         * @static
         * @param {google.protobuf.IEnumOptions} message EnumOptions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EnumOptions.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EnumOptions message from the specified reader or buffer.
         * @function decode
         * @memberof google.protobuf.EnumOptions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {google.protobuf.EnumOptions} EnumOptions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EnumOptions.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.google.protobuf.EnumOptions();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 2:
                message.allowAlias = reader.bool();
                break;
              case 3:
                message.deprecated = reader.bool();
                break;
              case 999:
                if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                  message.uninterpretedOption = [];
                message.uninterpretedOption.push(
                  $root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()),
                );
                break;
              case 62001:
                message[".gogoproto.goprotoEnumPrefix"] = reader.bool();
                break;
              case 62021:
                message[".gogoproto.goprotoEnumStringer"] = reader.bool();
                break;
              case 62022:
                message[".gogoproto.enumStringer"] = reader.bool();
                break;
              case 62023:
                message[".gogoproto.enumCustomname"] = reader.string();
                break;
              case 62024:
                message[".gogoproto.enumdecl"] = reader.bool();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes an EnumOptions message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof google.protobuf.EnumOptions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {google.protobuf.EnumOptions} EnumOptions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EnumOptions.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EnumOptions message.
         * @function verify
         * @memberof google.protobuf.EnumOptions
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EnumOptions.verify = function verify(message) {
          if (typeof message !== "object" || message === null) return "object expected";
          if (message.allowAlias != null && message.hasOwnProperty("allowAlias"))
            if (typeof message.allowAlias !== "boolean") return "allowAlias: boolean expected";
          if (message.deprecated != null && message.hasOwnProperty("deprecated"))
            if (typeof message.deprecated !== "boolean") return "deprecated: boolean expected";
          if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
            if (!Array.isArray(message.uninterpretedOption)) return "uninterpretedOption: array expected";
            for (var i = 0; i < message.uninterpretedOption.length; ++i) {
              var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
              if (error) return "uninterpretedOption." + error;
            }
          }
          if (
            message[".gogoproto.goprotoEnumPrefix"] != null &&
            message.hasOwnProperty(".gogoproto.goprotoEnumPrefix")
          )
            if (typeof message[".gogoproto.goprotoEnumPrefix"] !== "boolean")
              return ".gogoproto.goprotoEnumPrefix: boolean expected";
          if (
            message[".gogoproto.goprotoEnumStringer"] != null &&
            message.hasOwnProperty(".gogoproto.goprotoEnumStringer")
          )
            if (typeof message[".gogoproto.goprotoEnumStringer"] !== "boolean")
              return ".gogoproto.goprotoEnumStringer: boolean expected";
          if (message[".gogoproto.enumStringer"] != null && message.hasOwnProperty(".gogoproto.enumStringer"))
            if (typeof message[".gogoproto.enumStringer"] !== "boolean")
              return ".gogoproto.enumStringer: boolean expected";
          if (
            message[".gogoproto.enumCustomname"] != null &&
            message.hasOwnProperty(".gogoproto.enumCustomname")
          )
            if (!$util.isString(message[".gogoproto.enumCustomname"]))
              return ".gogoproto.enumCustomname: string expected";
          if (message[".gogoproto.enumdecl"] != null && message.hasOwnProperty(".gogoproto.enumdecl"))
            if (typeof message[".gogoproto.enumdecl"] !== "boolean")
              return ".gogoproto.enumdecl: boolean expected";
          return null;
        };

        /**
         * Creates an EnumOptions message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof google.protobuf.EnumOptions
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {google.protobuf.EnumOptions} EnumOptions
         */
        EnumOptions.fromObject = function fromObject(object) {
          if (object instanceof $root.google.protobuf.EnumOptions) return object;
          var message = new $root.google.protobuf.EnumOptions();
          if (object.allowAlias != null) message.allowAlias = Boolean(object.allowAlias);
          if (object.deprecated != null) message.deprecated = Boolean(object.deprecated);
          if (object.uninterpretedOption) {
            if (!Array.isArray(object.uninterpretedOption))
              throw TypeError(".google.protobuf.EnumOptions.uninterpretedOption: array expected");
            message.uninterpretedOption = [];
            for (var i = 0; i < object.uninterpretedOption.length; ++i) {
              if (typeof object.uninterpretedOption[i] !== "object")
                throw TypeError(".google.protobuf.EnumOptions.uninterpretedOption: object expected");
              message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(
                object.uninterpretedOption[i],
              );
            }
          }
          if (object[".gogoproto.goprotoEnumPrefix"] != null)
            message[".gogoproto.goprotoEnumPrefix"] = Boolean(object[".gogoproto.goprotoEnumPrefix"]);
          if (object[".gogoproto.goprotoEnumStringer"] != null)
            message[".gogoproto.goprotoEnumStringer"] = Boolean(object[".gogoproto.goprotoEnumStringer"]);
          if (object[".gogoproto.enumStringer"] != null)
            message[".gogoproto.enumStringer"] = Boolean(object[".gogoproto.enumStringer"]);
          if (object[".gogoproto.enumCustomname"] != null)
            message[".gogoproto.enumCustomname"] = String(object[".gogoproto.enumCustomname"]);
          if (object[".gogoproto.enumdecl"] != null)
            message[".gogoproto.enumdecl"] = Boolean(object[".gogoproto.enumdecl"]);
          return message;
        };

        /**
         * Creates a plain object from an EnumOptions message. Also converts values to other types if specified.
         * @function toObject
         * @memberof google.protobuf.EnumOptions
         * @static
         * @param {google.protobuf.EnumOptions} message EnumOptions
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EnumOptions.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.arrays || options.defaults) object.uninterpretedOption = [];
          if (options.defaults) {
            object.allowAlias = false;
            object.deprecated = false;
            object[".gogoproto.goprotoEnumPrefix"] = false;
            object[".gogoproto.goprotoEnumStringer"] = false;
            object[".gogoproto.enumStringer"] = false;
            object[".gogoproto.enumCustomname"] = "";
            object[".gogoproto.enumdecl"] = false;
          }
          if (message.allowAlias != null && message.hasOwnProperty("allowAlias"))
            object.allowAlias = message.allowAlias;
          if (message.deprecated != null && message.hasOwnProperty("deprecated"))
            object.deprecated = message.deprecated;
          if (message.uninterpretedOption && message.uninterpretedOption.length) {
            object.uninterpretedOption = [];
            for (var j = 0; j < message.uninterpretedOption.length; ++j)
              object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(
                message.uninterpretedOption[j],
                options,
              );
          }
          if (
            message[".gogoproto.goprotoEnumPrefix"] != null &&
            message.hasOwnProperty(".gogoproto.goprotoEnumPrefix")
          )
            object[".gogoproto.goprotoEnumPrefix"] = message[".gogoproto.goprotoEnumPrefix"];
          if (
            message[".gogoproto.goprotoEnumStringer"] != null &&
            message.hasOwnProperty(".gogoproto.goprotoEnumStringer")
          )
            object[".gogoproto.goprotoEnumStringer"] = message[".gogoproto.goprotoEnumStringer"];
          if (message[".gogoproto.enumStringer"] != null && message.hasOwnProperty(".gogoproto.enumStringer"))
            object[".gogoproto.enumStringer"] = message[".gogoproto.enumStringer"];
          if (
            message[".gogoproto.enumCustomname"] != null &&
            message.hasOwnProperty(".gogoproto.enumCustomname")
          )
            object[".gogoproto.enumCustomname"] = message[".gogoproto.enumCustomname"];
          if (message[".gogoproto.enumdecl"] != null && message.hasOwnProperty(".gogoproto.enumdecl"))
            object[".gogoproto.enumdecl"] = message[".gogoproto.enumdecl"];
          return object;
        };

        /**
         * Converts this EnumOptions to JSON.
         * @function toJSON
         * @memberof google.protobuf.EnumOptions
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EnumOptions.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return EnumOptions;
      })();

      protobuf.EnumValueOptions = (function () {
        /**
         * Properties of an EnumValueOptions.
         * @memberof google.protobuf
         * @interface IEnumValueOptions
         * @property {boolean|null} [deprecated] EnumValueOptions deprecated
         * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] EnumValueOptions uninterpretedOption
         * @property {string|null} [".gogoproto.enumvalueCustomname"] EnumValueOptions .gogoproto.enumvalueCustomname
         */

        /**
         * Constructs a new EnumValueOptions.
         * @memberof google.protobuf
         * @classdesc Represents an EnumValueOptions.
         * @implements IEnumValueOptions
         * @constructor
         * @param {google.protobuf.IEnumValueOptions=} [properties] Properties to set
         */
        function EnumValueOptions(properties) {
          this.uninterpretedOption = [];
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * EnumValueOptions deprecated.
         * @member {boolean} deprecated
         * @memberof google.protobuf.EnumValueOptions
         * @instance
         */
        EnumValueOptions.prototype.deprecated = false;

        /**
         * EnumValueOptions uninterpretedOption.
         * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
         * @memberof google.protobuf.EnumValueOptions
         * @instance
         */
        EnumValueOptions.prototype.uninterpretedOption = $util.emptyArray;

        /**
         * EnumValueOptions .gogoproto.enumvalueCustomname.
         * @member {string} .gogoproto.enumvalueCustomname
         * @memberof google.protobuf.EnumValueOptions
         * @instance
         */
        EnumValueOptions.prototype[".gogoproto.enumvalueCustomname"] = "";

        /**
         * Creates a new EnumValueOptions instance using the specified properties.
         * @function create
         * @memberof google.protobuf.EnumValueOptions
         * @static
         * @param {google.protobuf.IEnumValueOptions=} [properties] Properties to set
         * @returns {google.protobuf.EnumValueOptions} EnumValueOptions instance
         */
        EnumValueOptions.create = function create(properties) {
          return new EnumValueOptions(properties);
        };

        /**
         * Encodes the specified EnumValueOptions message. Does not implicitly {@link google.protobuf.EnumValueOptions.verify|verify} messages.
         * @function encode
         * @memberof google.protobuf.EnumValueOptions
         * @static
         * @param {google.protobuf.IEnumValueOptions} message EnumValueOptions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EnumValueOptions.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.deprecated != null && Object.hasOwnProperty.call(message, "deprecated"))
            writer.uint32(/* id 1, wireType 0 =*/ 8).bool(message.deprecated);
          if (message.uninterpretedOption != null && message.uninterpretedOption.length)
            for (var i = 0; i < message.uninterpretedOption.length; ++i)
              $root.google.protobuf.UninterpretedOption.encode(
                message.uninterpretedOption[i],
                writer.uint32(/* id 999, wireType 2 =*/ 7994).fork(),
              ).ldelim();
          if (
            message[".gogoproto.enumvalueCustomname"] != null &&
            Object.hasOwnProperty.call(message, ".gogoproto.enumvalueCustomname")
          )
            writer
              .uint32(/* id 66001, wireType 2 =*/ 528010)
              .string(message[".gogoproto.enumvalueCustomname"]);
          return writer;
        };

        /**
         * Encodes the specified EnumValueOptions message, length delimited. Does not implicitly {@link google.protobuf.EnumValueOptions.verify|verify} messages.
         * @function encodeDelimited
         * @memberof google.protobuf.EnumValueOptions
         * @static
         * @param {google.protobuf.IEnumValueOptions} message EnumValueOptions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EnumValueOptions.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EnumValueOptions message from the specified reader or buffer.
         * @function decode
         * @memberof google.protobuf.EnumValueOptions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {google.protobuf.EnumValueOptions} EnumValueOptions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EnumValueOptions.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.google.protobuf.EnumValueOptions();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.deprecated = reader.bool();
                break;
              case 999:
                if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                  message.uninterpretedOption = [];
                message.uninterpretedOption.push(
                  $root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()),
                );
                break;
              case 66001:
                message[".gogoproto.enumvalueCustomname"] = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes an EnumValueOptions message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof google.protobuf.EnumValueOptions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {google.protobuf.EnumValueOptions} EnumValueOptions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EnumValueOptions.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EnumValueOptions message.
         * @function verify
         * @memberof google.protobuf.EnumValueOptions
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EnumValueOptions.verify = function verify(message) {
          if (typeof message !== "object" || message === null) return "object expected";
          if (message.deprecated != null && message.hasOwnProperty("deprecated"))
            if (typeof message.deprecated !== "boolean") return "deprecated: boolean expected";
          if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
            if (!Array.isArray(message.uninterpretedOption)) return "uninterpretedOption: array expected";
            for (var i = 0; i < message.uninterpretedOption.length; ++i) {
              var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
              if (error) return "uninterpretedOption." + error;
            }
          }
          if (
            message[".gogoproto.enumvalueCustomname"] != null &&
            message.hasOwnProperty(".gogoproto.enumvalueCustomname")
          )
            if (!$util.isString(message[".gogoproto.enumvalueCustomname"]))
              return ".gogoproto.enumvalueCustomname: string expected";
          return null;
        };

        /**
         * Creates an EnumValueOptions message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof google.protobuf.EnumValueOptions
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {google.protobuf.EnumValueOptions} EnumValueOptions
         */
        EnumValueOptions.fromObject = function fromObject(object) {
          if (object instanceof $root.google.protobuf.EnumValueOptions) return object;
          var message = new $root.google.protobuf.EnumValueOptions();
          if (object.deprecated != null) message.deprecated = Boolean(object.deprecated);
          if (object.uninterpretedOption) {
            if (!Array.isArray(object.uninterpretedOption))
              throw TypeError(".google.protobuf.EnumValueOptions.uninterpretedOption: array expected");
            message.uninterpretedOption = [];
            for (var i = 0; i < object.uninterpretedOption.length; ++i) {
              if (typeof object.uninterpretedOption[i] !== "object")
                throw TypeError(".google.protobuf.EnumValueOptions.uninterpretedOption: object expected");
              message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(
                object.uninterpretedOption[i],
              );
            }
          }
          if (object[".gogoproto.enumvalueCustomname"] != null)
            message[".gogoproto.enumvalueCustomname"] = String(object[".gogoproto.enumvalueCustomname"]);
          return message;
        };

        /**
         * Creates a plain object from an EnumValueOptions message. Also converts values to other types if specified.
         * @function toObject
         * @memberof google.protobuf.EnumValueOptions
         * @static
         * @param {google.protobuf.EnumValueOptions} message EnumValueOptions
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EnumValueOptions.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.arrays || options.defaults) object.uninterpretedOption = [];
          if (options.defaults) {
            object.deprecated = false;
            object[".gogoproto.enumvalueCustomname"] = "";
          }
          if (message.deprecated != null && message.hasOwnProperty("deprecated"))
            object.deprecated = message.deprecated;
          if (message.uninterpretedOption && message.uninterpretedOption.length) {
            object.uninterpretedOption = [];
            for (var j = 0; j < message.uninterpretedOption.length; ++j)
              object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(
                message.uninterpretedOption[j],
                options,
              );
          }
          if (
            message[".gogoproto.enumvalueCustomname"] != null &&
            message.hasOwnProperty(".gogoproto.enumvalueCustomname")
          )
            object[".gogoproto.enumvalueCustomname"] = message[".gogoproto.enumvalueCustomname"];
          return object;
        };

        /**
         * Converts this EnumValueOptions to JSON.
         * @function toJSON
         * @memberof google.protobuf.EnumValueOptions
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EnumValueOptions.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return EnumValueOptions;
      })();

      protobuf.ServiceOptions = (function () {
        /**
         * Properties of a ServiceOptions.
         * @memberof google.protobuf
         * @interface IServiceOptions
         * @property {boolean|null} [deprecated] ServiceOptions deprecated
         * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] ServiceOptions uninterpretedOption
         */

        /**
         * Constructs a new ServiceOptions.
         * @memberof google.protobuf
         * @classdesc Represents a ServiceOptions.
         * @implements IServiceOptions
         * @constructor
         * @param {google.protobuf.IServiceOptions=} [properties] Properties to set
         */
        function ServiceOptions(properties) {
          this.uninterpretedOption = [];
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * ServiceOptions deprecated.
         * @member {boolean} deprecated
         * @memberof google.protobuf.ServiceOptions
         * @instance
         */
        ServiceOptions.prototype.deprecated = false;

        /**
         * ServiceOptions uninterpretedOption.
         * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
         * @memberof google.protobuf.ServiceOptions
         * @instance
         */
        ServiceOptions.prototype.uninterpretedOption = $util.emptyArray;

        /**
         * Creates a new ServiceOptions instance using the specified properties.
         * @function create
         * @memberof google.protobuf.ServiceOptions
         * @static
         * @param {google.protobuf.IServiceOptions=} [properties] Properties to set
         * @returns {google.protobuf.ServiceOptions} ServiceOptions instance
         */
        ServiceOptions.create = function create(properties) {
          return new ServiceOptions(properties);
        };

        /**
         * Encodes the specified ServiceOptions message. Does not implicitly {@link google.protobuf.ServiceOptions.verify|verify} messages.
         * @function encode
         * @memberof google.protobuf.ServiceOptions
         * @static
         * @param {google.protobuf.IServiceOptions} message ServiceOptions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServiceOptions.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.deprecated != null && Object.hasOwnProperty.call(message, "deprecated"))
            writer.uint32(/* id 33, wireType 0 =*/ 264).bool(message.deprecated);
          if (message.uninterpretedOption != null && message.uninterpretedOption.length)
            for (var i = 0; i < message.uninterpretedOption.length; ++i)
              $root.google.protobuf.UninterpretedOption.encode(
                message.uninterpretedOption[i],
                writer.uint32(/* id 999, wireType 2 =*/ 7994).fork(),
              ).ldelim();
          return writer;
        };

        /**
         * Encodes the specified ServiceOptions message, length delimited. Does not implicitly {@link google.protobuf.ServiceOptions.verify|verify} messages.
         * @function encodeDelimited
         * @memberof google.protobuf.ServiceOptions
         * @static
         * @param {google.protobuf.IServiceOptions} message ServiceOptions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServiceOptions.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ServiceOptions message from the specified reader or buffer.
         * @function decode
         * @memberof google.protobuf.ServiceOptions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {google.protobuf.ServiceOptions} ServiceOptions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServiceOptions.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.google.protobuf.ServiceOptions();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 33:
                message.deprecated = reader.bool();
                break;
              case 999:
                if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                  message.uninterpretedOption = [];
                message.uninterpretedOption.push(
                  $root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()),
                );
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a ServiceOptions message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof google.protobuf.ServiceOptions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {google.protobuf.ServiceOptions} ServiceOptions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServiceOptions.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ServiceOptions message.
         * @function verify
         * @memberof google.protobuf.ServiceOptions
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ServiceOptions.verify = function verify(message) {
          if (typeof message !== "object" || message === null) return "object expected";
          if (message.deprecated != null && message.hasOwnProperty("deprecated"))
            if (typeof message.deprecated !== "boolean") return "deprecated: boolean expected";
          if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
            if (!Array.isArray(message.uninterpretedOption)) return "uninterpretedOption: array expected";
            for (var i = 0; i < message.uninterpretedOption.length; ++i) {
              var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
              if (error) return "uninterpretedOption." + error;
            }
          }
          return null;
        };

        /**
         * Creates a ServiceOptions message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof google.protobuf.ServiceOptions
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {google.protobuf.ServiceOptions} ServiceOptions
         */
        ServiceOptions.fromObject = function fromObject(object) {
          if (object instanceof $root.google.protobuf.ServiceOptions) return object;
          var message = new $root.google.protobuf.ServiceOptions();
          if (object.deprecated != null) message.deprecated = Boolean(object.deprecated);
          if (object.uninterpretedOption) {
            if (!Array.isArray(object.uninterpretedOption))
              throw TypeError(".google.protobuf.ServiceOptions.uninterpretedOption: array expected");
            message.uninterpretedOption = [];
            for (var i = 0; i < object.uninterpretedOption.length; ++i) {
              if (typeof object.uninterpretedOption[i] !== "object")
                throw TypeError(".google.protobuf.ServiceOptions.uninterpretedOption: object expected");
              message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(
                object.uninterpretedOption[i],
              );
            }
          }
          return message;
        };

        /**
         * Creates a plain object from a ServiceOptions message. Also converts values to other types if specified.
         * @function toObject
         * @memberof google.protobuf.ServiceOptions
         * @static
         * @param {google.protobuf.ServiceOptions} message ServiceOptions
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ServiceOptions.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.arrays || options.defaults) object.uninterpretedOption = [];
          if (options.defaults) object.deprecated = false;
          if (message.deprecated != null && message.hasOwnProperty("deprecated"))
            object.deprecated = message.deprecated;
          if (message.uninterpretedOption && message.uninterpretedOption.length) {
            object.uninterpretedOption = [];
            for (var j = 0; j < message.uninterpretedOption.length; ++j)
              object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(
                message.uninterpretedOption[j],
                options,
              );
          }
          return object;
        };

        /**
         * Converts this ServiceOptions to JSON.
         * @function toJSON
         * @memberof google.protobuf.ServiceOptions
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ServiceOptions.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ServiceOptions;
      })();

      protobuf.MethodOptions = (function () {
        /**
         * Properties of a MethodOptions.
         * @memberof google.protobuf
         * @interface IMethodOptions
         * @property {boolean|null} [deprecated] MethodOptions deprecated
         * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] MethodOptions uninterpretedOption
         */

        /**
         * Constructs a new MethodOptions.
         * @memberof google.protobuf
         * @classdesc Represents a MethodOptions.
         * @implements IMethodOptions
         * @constructor
         * @param {google.protobuf.IMethodOptions=} [properties] Properties to set
         */
        function MethodOptions(properties) {
          this.uninterpretedOption = [];
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * MethodOptions deprecated.
         * @member {boolean} deprecated
         * @memberof google.protobuf.MethodOptions
         * @instance
         */
        MethodOptions.prototype.deprecated = false;

        /**
         * MethodOptions uninterpretedOption.
         * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
         * @memberof google.protobuf.MethodOptions
         * @instance
         */
        MethodOptions.prototype.uninterpretedOption = $util.emptyArray;

        /**
         * Creates a new MethodOptions instance using the specified properties.
         * @function create
         * @memberof google.protobuf.MethodOptions
         * @static
         * @param {google.protobuf.IMethodOptions=} [properties] Properties to set
         * @returns {google.protobuf.MethodOptions} MethodOptions instance
         */
        MethodOptions.create = function create(properties) {
          return new MethodOptions(properties);
        };

        /**
         * Encodes the specified MethodOptions message. Does not implicitly {@link google.protobuf.MethodOptions.verify|verify} messages.
         * @function encode
         * @memberof google.protobuf.MethodOptions
         * @static
         * @param {google.protobuf.IMethodOptions} message MethodOptions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MethodOptions.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.deprecated != null && Object.hasOwnProperty.call(message, "deprecated"))
            writer.uint32(/* id 33, wireType 0 =*/ 264).bool(message.deprecated);
          if (message.uninterpretedOption != null && message.uninterpretedOption.length)
            for (var i = 0; i < message.uninterpretedOption.length; ++i)
              $root.google.protobuf.UninterpretedOption.encode(
                message.uninterpretedOption[i],
                writer.uint32(/* id 999, wireType 2 =*/ 7994).fork(),
              ).ldelim();
          return writer;
        };

        /**
         * Encodes the specified MethodOptions message, length delimited. Does not implicitly {@link google.protobuf.MethodOptions.verify|verify} messages.
         * @function encodeDelimited
         * @memberof google.protobuf.MethodOptions
         * @static
         * @param {google.protobuf.IMethodOptions} message MethodOptions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MethodOptions.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MethodOptions message from the specified reader or buffer.
         * @function decode
         * @memberof google.protobuf.MethodOptions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {google.protobuf.MethodOptions} MethodOptions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MethodOptions.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.google.protobuf.MethodOptions();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 33:
                message.deprecated = reader.bool();
                break;
              case 999:
                if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                  message.uninterpretedOption = [];
                message.uninterpretedOption.push(
                  $root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()),
                );
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a MethodOptions message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof google.protobuf.MethodOptions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {google.protobuf.MethodOptions} MethodOptions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MethodOptions.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MethodOptions message.
         * @function verify
         * @memberof google.protobuf.MethodOptions
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MethodOptions.verify = function verify(message) {
          if (typeof message !== "object" || message === null) return "object expected";
          if (message.deprecated != null && message.hasOwnProperty("deprecated"))
            if (typeof message.deprecated !== "boolean") return "deprecated: boolean expected";
          if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
            if (!Array.isArray(message.uninterpretedOption)) return "uninterpretedOption: array expected";
            for (var i = 0; i < message.uninterpretedOption.length; ++i) {
              var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
              if (error) return "uninterpretedOption." + error;
            }
          }
          return null;
        };

        /**
         * Creates a MethodOptions message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof google.protobuf.MethodOptions
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {google.protobuf.MethodOptions} MethodOptions
         */
        MethodOptions.fromObject = function fromObject(object) {
          if (object instanceof $root.google.protobuf.MethodOptions) return object;
          var message = new $root.google.protobuf.MethodOptions();
          if (object.deprecated != null) message.deprecated = Boolean(object.deprecated);
          if (object.uninterpretedOption) {
            if (!Array.isArray(object.uninterpretedOption))
              throw TypeError(".google.protobuf.MethodOptions.uninterpretedOption: array expected");
            message.uninterpretedOption = [];
            for (var i = 0; i < object.uninterpretedOption.length; ++i) {
              if (typeof object.uninterpretedOption[i] !== "object")
                throw TypeError(".google.protobuf.MethodOptions.uninterpretedOption: object expected");
              message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(
                object.uninterpretedOption[i],
              );
            }
          }
          return message;
        };

        /**
         * Creates a plain object from a MethodOptions message. Also converts values to other types if specified.
         * @function toObject
         * @memberof google.protobuf.MethodOptions
         * @static
         * @param {google.protobuf.MethodOptions} message MethodOptions
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MethodOptions.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.arrays || options.defaults) object.uninterpretedOption = [];
          if (options.defaults) object.deprecated = false;
          if (message.deprecated != null && message.hasOwnProperty("deprecated"))
            object.deprecated = message.deprecated;
          if (message.uninterpretedOption && message.uninterpretedOption.length) {
            object.uninterpretedOption = [];
            for (var j = 0; j < message.uninterpretedOption.length; ++j)
              object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(
                message.uninterpretedOption[j],
                options,
              );
          }
          return object;
        };

        /**
         * Converts this MethodOptions to JSON.
         * @function toJSON
         * @memberof google.protobuf.MethodOptions
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MethodOptions.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MethodOptions;
      })();

      protobuf.UninterpretedOption = (function () {
        /**
         * Properties of an UninterpretedOption.
         * @memberof google.protobuf
         * @interface IUninterpretedOption
         * @property {Array.<google.protobuf.UninterpretedOption.INamePart>|null} [name] UninterpretedOption name
         * @property {string|null} [identifierValue] UninterpretedOption identifierValue
         * @property {number|Long|null} [positiveIntValue] UninterpretedOption positiveIntValue
         * @property {number|Long|null} [negativeIntValue] UninterpretedOption negativeIntValue
         * @property {number|null} [doubleValue] UninterpretedOption doubleValue
         * @property {Uint8Array|null} [stringValue] UninterpretedOption stringValue
         * @property {string|null} [aggregateValue] UninterpretedOption aggregateValue
         */

        /**
         * Constructs a new UninterpretedOption.
         * @memberof google.protobuf
         * @classdesc Represents an UninterpretedOption.
         * @implements IUninterpretedOption
         * @constructor
         * @param {google.protobuf.IUninterpretedOption=} [properties] Properties to set
         */
        function UninterpretedOption(properties) {
          this.name = [];
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * UninterpretedOption name.
         * @member {Array.<google.protobuf.UninterpretedOption.INamePart>} name
         * @memberof google.protobuf.UninterpretedOption
         * @instance
         */
        UninterpretedOption.prototype.name = $util.emptyArray;

        /**
         * UninterpretedOption identifierValue.
         * @member {string} identifierValue
         * @memberof google.protobuf.UninterpretedOption
         * @instance
         */
        UninterpretedOption.prototype.identifierValue = "";

        /**
         * UninterpretedOption positiveIntValue.
         * @member {number|Long} positiveIntValue
         * @memberof google.protobuf.UninterpretedOption
         * @instance
         */
        UninterpretedOption.prototype.positiveIntValue = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

        /**
         * UninterpretedOption negativeIntValue.
         * @member {number|Long} negativeIntValue
         * @memberof google.protobuf.UninterpretedOption
         * @instance
         */
        UninterpretedOption.prototype.negativeIntValue = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * UninterpretedOption doubleValue.
         * @member {number} doubleValue
         * @memberof google.protobuf.UninterpretedOption
         * @instance
         */
        UninterpretedOption.prototype.doubleValue = 0;

        /**
         * UninterpretedOption stringValue.
         * @member {Uint8Array} stringValue
         * @memberof google.protobuf.UninterpretedOption
         * @instance
         */
        UninterpretedOption.prototype.stringValue = $util.newBuffer([]);

        /**
         * UninterpretedOption aggregateValue.
         * @member {string} aggregateValue
         * @memberof google.protobuf.UninterpretedOption
         * @instance
         */
        UninterpretedOption.prototype.aggregateValue = "";

        /**
         * Creates a new UninterpretedOption instance using the specified properties.
         * @function create
         * @memberof google.protobuf.UninterpretedOption
         * @static
         * @param {google.protobuf.IUninterpretedOption=} [properties] Properties to set
         * @returns {google.protobuf.UninterpretedOption} UninterpretedOption instance
         */
        UninterpretedOption.create = function create(properties) {
          return new UninterpretedOption(properties);
        };

        /**
         * Encodes the specified UninterpretedOption message. Does not implicitly {@link google.protobuf.UninterpretedOption.verify|verify} messages.
         * @function encode
         * @memberof google.protobuf.UninterpretedOption
         * @static
         * @param {google.protobuf.IUninterpretedOption} message UninterpretedOption message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UninterpretedOption.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.name != null && message.name.length)
            for (var i = 0; i < message.name.length; ++i)
              $root.google.protobuf.UninterpretedOption.NamePart.encode(
                message.name[i],
                writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
              ).ldelim();
          if (message.identifierValue != null && Object.hasOwnProperty.call(message, "identifierValue"))
            writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.identifierValue);
          if (message.positiveIntValue != null && Object.hasOwnProperty.call(message, "positiveIntValue"))
            writer.uint32(/* id 4, wireType 0 =*/ 32).uint64(message.positiveIntValue);
          if (message.negativeIntValue != null && Object.hasOwnProperty.call(message, "negativeIntValue"))
            writer.uint32(/* id 5, wireType 0 =*/ 40).int64(message.negativeIntValue);
          if (message.doubleValue != null && Object.hasOwnProperty.call(message, "doubleValue"))
            writer.uint32(/* id 6, wireType 1 =*/ 49).double(message.doubleValue);
          if (message.stringValue != null && Object.hasOwnProperty.call(message, "stringValue"))
            writer.uint32(/* id 7, wireType 2 =*/ 58).bytes(message.stringValue);
          if (message.aggregateValue != null && Object.hasOwnProperty.call(message, "aggregateValue"))
            writer.uint32(/* id 8, wireType 2 =*/ 66).string(message.aggregateValue);
          return writer;
        };

        /**
         * Encodes the specified UninterpretedOption message, length delimited. Does not implicitly {@link google.protobuf.UninterpretedOption.verify|verify} messages.
         * @function encodeDelimited
         * @memberof google.protobuf.UninterpretedOption
         * @static
         * @param {google.protobuf.IUninterpretedOption} message UninterpretedOption message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UninterpretedOption.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UninterpretedOption message from the specified reader or buffer.
         * @function decode
         * @memberof google.protobuf.UninterpretedOption
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {google.protobuf.UninterpretedOption} UninterpretedOption
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UninterpretedOption.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.google.protobuf.UninterpretedOption();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 2:
                if (!(message.name && message.name.length)) message.name = [];
                message.name.push(
                  $root.google.protobuf.UninterpretedOption.NamePart.decode(reader, reader.uint32()),
                );
                break;
              case 3:
                message.identifierValue = reader.string();
                break;
              case 4:
                message.positiveIntValue = reader.uint64();
                break;
              case 5:
                message.negativeIntValue = reader.int64();
                break;
              case 6:
                message.doubleValue = reader.double();
                break;
              case 7:
                message.stringValue = reader.bytes();
                break;
              case 8:
                message.aggregateValue = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes an UninterpretedOption message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof google.protobuf.UninterpretedOption
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {google.protobuf.UninterpretedOption} UninterpretedOption
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UninterpretedOption.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UninterpretedOption message.
         * @function verify
         * @memberof google.protobuf.UninterpretedOption
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UninterpretedOption.verify = function verify(message) {
          if (typeof message !== "object" || message === null) return "object expected";
          if (message.name != null && message.hasOwnProperty("name")) {
            if (!Array.isArray(message.name)) return "name: array expected";
            for (var i = 0; i < message.name.length; ++i) {
              var error = $root.google.protobuf.UninterpretedOption.NamePart.verify(message.name[i]);
              if (error) return "name." + error;
            }
          }
          if (message.identifierValue != null && message.hasOwnProperty("identifierValue"))
            if (!$util.isString(message.identifierValue)) return "identifierValue: string expected";
          if (message.positiveIntValue != null && message.hasOwnProperty("positiveIntValue"))
            if (
              !$util.isInteger(message.positiveIntValue) &&
              !(
                message.positiveIntValue &&
                $util.isInteger(message.positiveIntValue.low) &&
                $util.isInteger(message.positiveIntValue.high)
              )
            )
              return "positiveIntValue: integer|Long expected";
          if (message.negativeIntValue != null && message.hasOwnProperty("negativeIntValue"))
            if (
              !$util.isInteger(message.negativeIntValue) &&
              !(
                message.negativeIntValue &&
                $util.isInteger(message.negativeIntValue.low) &&
                $util.isInteger(message.negativeIntValue.high)
              )
            )
              return "negativeIntValue: integer|Long expected";
          if (message.doubleValue != null && message.hasOwnProperty("doubleValue"))
            if (typeof message.doubleValue !== "number") return "doubleValue: number expected";
          if (message.stringValue != null && message.hasOwnProperty("stringValue"))
            if (
              !(
                (message.stringValue && typeof message.stringValue.length === "number") ||
                $util.isString(message.stringValue)
              )
            )
              return "stringValue: buffer expected";
          if (message.aggregateValue != null && message.hasOwnProperty("aggregateValue"))
            if (!$util.isString(message.aggregateValue)) return "aggregateValue: string expected";
          return null;
        };

        /**
         * Creates an UninterpretedOption message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof google.protobuf.UninterpretedOption
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {google.protobuf.UninterpretedOption} UninterpretedOption
         */
        UninterpretedOption.fromObject = function fromObject(object) {
          if (object instanceof $root.google.protobuf.UninterpretedOption) return object;
          var message = new $root.google.protobuf.UninterpretedOption();
          if (object.name) {
            if (!Array.isArray(object.name))
              throw TypeError(".google.protobuf.UninterpretedOption.name: array expected");
            message.name = [];
            for (var i = 0; i < object.name.length; ++i) {
              if (typeof object.name[i] !== "object")
                throw TypeError(".google.protobuf.UninterpretedOption.name: object expected");
              message.name[i] = $root.google.protobuf.UninterpretedOption.NamePart.fromObject(object.name[i]);
            }
          }
          if (object.identifierValue != null) message.identifierValue = String(object.identifierValue);
          if (object.positiveIntValue != null)
            if ($util.Long)
              (message.positiveIntValue = $util.Long.fromValue(object.positiveIntValue)).unsigned = true;
            else if (typeof object.positiveIntValue === "string")
              message.positiveIntValue = parseInt(object.positiveIntValue, 10);
            else if (typeof object.positiveIntValue === "number")
              message.positiveIntValue = object.positiveIntValue;
            else if (typeof object.positiveIntValue === "object")
              message.positiveIntValue = new $util.LongBits(
                object.positiveIntValue.low >>> 0,
                object.positiveIntValue.high >>> 0,
              ).toNumber(true);
          if (object.negativeIntValue != null)
            if ($util.Long)
              (message.negativeIntValue = $util.Long.fromValue(object.negativeIntValue)).unsigned = false;
            else if (typeof object.negativeIntValue === "string")
              message.negativeIntValue = parseInt(object.negativeIntValue, 10);
            else if (typeof object.negativeIntValue === "number")
              message.negativeIntValue = object.negativeIntValue;
            else if (typeof object.negativeIntValue === "object")
              message.negativeIntValue = new $util.LongBits(
                object.negativeIntValue.low >>> 0,
                object.negativeIntValue.high >>> 0,
              ).toNumber();
          if (object.doubleValue != null) message.doubleValue = Number(object.doubleValue);
          if (object.stringValue != null)
            if (typeof object.stringValue === "string")
              $util.base64.decode(
                object.stringValue,
                (message.stringValue = $util.newBuffer($util.base64.length(object.stringValue))),
                0,
              );
            else if (object.stringValue.length) message.stringValue = object.stringValue;
          if (object.aggregateValue != null) message.aggregateValue = String(object.aggregateValue);
          return message;
        };

        /**
         * Creates a plain object from an UninterpretedOption message. Also converts values to other types if specified.
         * @function toObject
         * @memberof google.protobuf.UninterpretedOption
         * @static
         * @param {google.protobuf.UninterpretedOption} message UninterpretedOption
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UninterpretedOption.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.arrays || options.defaults) object.name = [];
          if (options.defaults) {
            object.identifierValue = "";
            if ($util.Long) {
              var long = new $util.Long(0, 0, true);
              object.positiveIntValue =
                options.longs === String
                  ? long.toString()
                  : options.longs === Number
                  ? long.toNumber()
                  : long;
            } else object.positiveIntValue = options.longs === String ? "0" : 0;
            if ($util.Long) {
              var long = new $util.Long(0, 0, false);
              object.negativeIntValue =
                options.longs === String
                  ? long.toString()
                  : options.longs === Number
                  ? long.toNumber()
                  : long;
            } else object.negativeIntValue = options.longs === String ? "0" : 0;
            object.doubleValue = 0;
            if (options.bytes === String) object.stringValue = "";
            else {
              object.stringValue = [];
              if (options.bytes !== Array) object.stringValue = $util.newBuffer(object.stringValue);
            }
            object.aggregateValue = "";
          }
          if (message.name && message.name.length) {
            object.name = [];
            for (var j = 0; j < message.name.length; ++j)
              object.name[j] = $root.google.protobuf.UninterpretedOption.NamePart.toObject(
                message.name[j],
                options,
              );
          }
          if (message.identifierValue != null && message.hasOwnProperty("identifierValue"))
            object.identifierValue = message.identifierValue;
          if (message.positiveIntValue != null && message.hasOwnProperty("positiveIntValue"))
            if (typeof message.positiveIntValue === "number")
              object.positiveIntValue =
                options.longs === String ? String(message.positiveIntValue) : message.positiveIntValue;
            else
              object.positiveIntValue =
                options.longs === String
                  ? $util.Long.prototype.toString.call(message.positiveIntValue)
                  : options.longs === Number
                  ? new $util.LongBits(
                      message.positiveIntValue.low >>> 0,
                      message.positiveIntValue.high >>> 0,
                    ).toNumber(true)
                  : message.positiveIntValue;
          if (message.negativeIntValue != null && message.hasOwnProperty("negativeIntValue"))
            if (typeof message.negativeIntValue === "number")
              object.negativeIntValue =
                options.longs === String ? String(message.negativeIntValue) : message.negativeIntValue;
            else
              object.negativeIntValue =
                options.longs === String
                  ? $util.Long.prototype.toString.call(message.negativeIntValue)
                  : options.longs === Number
                  ? new $util.LongBits(
                      message.negativeIntValue.low >>> 0,
                      message.negativeIntValue.high >>> 0,
                    ).toNumber()
                  : message.negativeIntValue;
          if (message.doubleValue != null && message.hasOwnProperty("doubleValue"))
            object.doubleValue =
              options.json && !isFinite(message.doubleValue)
                ? String(message.doubleValue)
                : message.doubleValue;
          if (message.stringValue != null && message.hasOwnProperty("stringValue"))
            object.stringValue =
              options.bytes === String
                ? $util.base64.encode(message.stringValue, 0, message.stringValue.length)
                : options.bytes === Array
                ? Array.prototype.slice.call(message.stringValue)
                : message.stringValue;
          if (message.aggregateValue != null && message.hasOwnProperty("aggregateValue"))
            object.aggregateValue = message.aggregateValue;
          return object;
        };

        /**
         * Converts this UninterpretedOption to JSON.
         * @function toJSON
         * @memberof google.protobuf.UninterpretedOption
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UninterpretedOption.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        UninterpretedOption.NamePart = (function () {
          /**
           * Properties of a NamePart.
           * @memberof google.protobuf.UninterpretedOption
           * @interface INamePart
           * @property {string} namePart NamePart namePart
           * @property {boolean} isExtension NamePart isExtension
           */

          /**
           * Constructs a new NamePart.
           * @memberof google.protobuf.UninterpretedOption
           * @classdesc Represents a NamePart.
           * @implements INamePart
           * @constructor
           * @param {google.protobuf.UninterpretedOption.INamePart=} [properties] Properties to set
           */
          function NamePart(properties) {
            if (properties)
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
          }

          /**
           * NamePart namePart.
           * @member {string} namePart
           * @memberof google.protobuf.UninterpretedOption.NamePart
           * @instance
           */
          NamePart.prototype.namePart = "";

          /**
           * NamePart isExtension.
           * @member {boolean} isExtension
           * @memberof google.protobuf.UninterpretedOption.NamePart
           * @instance
           */
          NamePart.prototype.isExtension = false;

          /**
           * Creates a new NamePart instance using the specified properties.
           * @function create
           * @memberof google.protobuf.UninterpretedOption.NamePart
           * @static
           * @param {google.protobuf.UninterpretedOption.INamePart=} [properties] Properties to set
           * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart instance
           */
          NamePart.create = function create(properties) {
            return new NamePart(properties);
          };

          /**
           * Encodes the specified NamePart message. Does not implicitly {@link google.protobuf.UninterpretedOption.NamePart.verify|verify} messages.
           * @function encode
           * @memberof google.protobuf.UninterpretedOption.NamePart
           * @static
           * @param {google.protobuf.UninterpretedOption.INamePart} message NamePart message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          NamePart.encode = function encode(message, writer) {
            if (!writer) writer = $Writer.create();
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.namePart);
            writer.uint32(/* id 2, wireType 0 =*/ 16).bool(message.isExtension);
            return writer;
          };

          /**
           * Encodes the specified NamePart message, length delimited. Does not implicitly {@link google.protobuf.UninterpretedOption.NamePart.verify|verify} messages.
           * @function encodeDelimited
           * @memberof google.protobuf.UninterpretedOption.NamePart
           * @static
           * @param {google.protobuf.UninterpretedOption.INamePart} message NamePart message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          NamePart.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a NamePart message from the specified reader or buffer.
           * @function decode
           * @memberof google.protobuf.UninterpretedOption.NamePart
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          NamePart.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length,
              message = new $root.google.protobuf.UninterpretedOption.NamePart();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  message.namePart = reader.string();
                  break;
                case 2:
                  message.isExtension = reader.bool();
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            if (!message.hasOwnProperty("namePart"))
              throw $util.ProtocolError("missing required 'namePart'", { instance: message });
            if (!message.hasOwnProperty("isExtension"))
              throw $util.ProtocolError("missing required 'isExtension'", { instance: message });
            return message;
          };

          /**
           * Decodes a NamePart message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof google.protobuf.UninterpretedOption.NamePart
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          NamePart.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader)) reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a NamePart message.
           * @function verify
           * @memberof google.protobuf.UninterpretedOption.NamePart
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          NamePart.verify = function verify(message) {
            if (typeof message !== "object" || message === null) return "object expected";
            if (!$util.isString(message.namePart)) return "namePart: string expected";
            if (typeof message.isExtension !== "boolean") return "isExtension: boolean expected";
            return null;
          };

          /**
           * Creates a NamePart message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof google.protobuf.UninterpretedOption.NamePart
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart
           */
          NamePart.fromObject = function fromObject(object) {
            if (object instanceof $root.google.protobuf.UninterpretedOption.NamePart) return object;
            var message = new $root.google.protobuf.UninterpretedOption.NamePart();
            if (object.namePart != null) message.namePart = String(object.namePart);
            if (object.isExtension != null) message.isExtension = Boolean(object.isExtension);
            return message;
          };

          /**
           * Creates a plain object from a NamePart message. Also converts values to other types if specified.
           * @function toObject
           * @memberof google.protobuf.UninterpretedOption.NamePart
           * @static
           * @param {google.protobuf.UninterpretedOption.NamePart} message NamePart
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          NamePart.toObject = function toObject(message, options) {
            if (!options) options = {};
            var object = {};
            if (options.defaults) {
              object.namePart = "";
              object.isExtension = false;
            }
            if (message.namePart != null && message.hasOwnProperty("namePart"))
              object.namePart = message.namePart;
            if (message.isExtension != null && message.hasOwnProperty("isExtension"))
              object.isExtension = message.isExtension;
            return object;
          };

          /**
           * Converts this NamePart to JSON.
           * @function toJSON
           * @memberof google.protobuf.UninterpretedOption.NamePart
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          NamePart.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };

          return NamePart;
        })();

        return UninterpretedOption;
      })();

      protobuf.SourceCodeInfo = (function () {
        /**
         * Properties of a SourceCodeInfo.
         * @memberof google.protobuf
         * @interface ISourceCodeInfo
         * @property {Array.<google.protobuf.SourceCodeInfo.ILocation>|null} [location] SourceCodeInfo location
         */

        /**
         * Constructs a new SourceCodeInfo.
         * @memberof google.protobuf
         * @classdesc Represents a SourceCodeInfo.
         * @implements ISourceCodeInfo
         * @constructor
         * @param {google.protobuf.ISourceCodeInfo=} [properties] Properties to set
         */
        function SourceCodeInfo(properties) {
          this.location = [];
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * SourceCodeInfo location.
         * @member {Array.<google.protobuf.SourceCodeInfo.ILocation>} location
         * @memberof google.protobuf.SourceCodeInfo
         * @instance
         */
        SourceCodeInfo.prototype.location = $util.emptyArray;

        /**
         * Creates a new SourceCodeInfo instance using the specified properties.
         * @function create
         * @memberof google.protobuf.SourceCodeInfo
         * @static
         * @param {google.protobuf.ISourceCodeInfo=} [properties] Properties to set
         * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo instance
         */
        SourceCodeInfo.create = function create(properties) {
          return new SourceCodeInfo(properties);
        };

        /**
         * Encodes the specified SourceCodeInfo message. Does not implicitly {@link google.protobuf.SourceCodeInfo.verify|verify} messages.
         * @function encode
         * @memberof google.protobuf.SourceCodeInfo
         * @static
         * @param {google.protobuf.ISourceCodeInfo} message SourceCodeInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SourceCodeInfo.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.location != null && message.location.length)
            for (var i = 0; i < message.location.length; ++i)
              $root.google.protobuf.SourceCodeInfo.Location.encode(
                message.location[i],
                writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
              ).ldelim();
          return writer;
        };

        /**
         * Encodes the specified SourceCodeInfo message, length delimited. Does not implicitly {@link google.protobuf.SourceCodeInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof google.protobuf.SourceCodeInfo
         * @static
         * @param {google.protobuf.ISourceCodeInfo} message SourceCodeInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SourceCodeInfo.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SourceCodeInfo message from the specified reader or buffer.
         * @function decode
         * @memberof google.protobuf.SourceCodeInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SourceCodeInfo.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.google.protobuf.SourceCodeInfo();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                if (!(message.location && message.location.length)) message.location = [];
                message.location.push(
                  $root.google.protobuf.SourceCodeInfo.Location.decode(reader, reader.uint32()),
                );
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a SourceCodeInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof google.protobuf.SourceCodeInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SourceCodeInfo.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SourceCodeInfo message.
         * @function verify
         * @memberof google.protobuf.SourceCodeInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SourceCodeInfo.verify = function verify(message) {
          if (typeof message !== "object" || message === null) return "object expected";
          if (message.location != null && message.hasOwnProperty("location")) {
            if (!Array.isArray(message.location)) return "location: array expected";
            for (var i = 0; i < message.location.length; ++i) {
              var error = $root.google.protobuf.SourceCodeInfo.Location.verify(message.location[i]);
              if (error) return "location." + error;
            }
          }
          return null;
        };

        /**
         * Creates a SourceCodeInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof google.protobuf.SourceCodeInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo
         */
        SourceCodeInfo.fromObject = function fromObject(object) {
          if (object instanceof $root.google.protobuf.SourceCodeInfo) return object;
          var message = new $root.google.protobuf.SourceCodeInfo();
          if (object.location) {
            if (!Array.isArray(object.location))
              throw TypeError(".google.protobuf.SourceCodeInfo.location: array expected");
            message.location = [];
            for (var i = 0; i < object.location.length; ++i) {
              if (typeof object.location[i] !== "object")
                throw TypeError(".google.protobuf.SourceCodeInfo.location: object expected");
              message.location[i] = $root.google.protobuf.SourceCodeInfo.Location.fromObject(
                object.location[i],
              );
            }
          }
          return message;
        };

        /**
         * Creates a plain object from a SourceCodeInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof google.protobuf.SourceCodeInfo
         * @static
         * @param {google.protobuf.SourceCodeInfo} message SourceCodeInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SourceCodeInfo.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.arrays || options.defaults) object.location = [];
          if (message.location && message.location.length) {
            object.location = [];
            for (var j = 0; j < message.location.length; ++j)
              object.location[j] = $root.google.protobuf.SourceCodeInfo.Location.toObject(
                message.location[j],
                options,
              );
          }
          return object;
        };

        /**
         * Converts this SourceCodeInfo to JSON.
         * @function toJSON
         * @memberof google.protobuf.SourceCodeInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SourceCodeInfo.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        SourceCodeInfo.Location = (function () {
          /**
           * Properties of a Location.
           * @memberof google.protobuf.SourceCodeInfo
           * @interface ILocation
           * @property {Array.<number>|null} [path] Location path
           * @property {Array.<number>|null} [span] Location span
           * @property {string|null} [leadingComments] Location leadingComments
           * @property {string|null} [trailingComments] Location trailingComments
           * @property {Array.<string>|null} [leadingDetachedComments] Location leadingDetachedComments
           */

          /**
           * Constructs a new Location.
           * @memberof google.protobuf.SourceCodeInfo
           * @classdesc Represents a Location.
           * @implements ILocation
           * @constructor
           * @param {google.protobuf.SourceCodeInfo.ILocation=} [properties] Properties to set
           */
          function Location(properties) {
            this.path = [];
            this.span = [];
            this.leadingDetachedComments = [];
            if (properties)
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
          }

          /**
           * Location path.
           * @member {Array.<number>} path
           * @memberof google.protobuf.SourceCodeInfo.Location
           * @instance
           */
          Location.prototype.path = $util.emptyArray;

          /**
           * Location span.
           * @member {Array.<number>} span
           * @memberof google.protobuf.SourceCodeInfo.Location
           * @instance
           */
          Location.prototype.span = $util.emptyArray;

          /**
           * Location leadingComments.
           * @member {string} leadingComments
           * @memberof google.protobuf.SourceCodeInfo.Location
           * @instance
           */
          Location.prototype.leadingComments = "";

          /**
           * Location trailingComments.
           * @member {string} trailingComments
           * @memberof google.protobuf.SourceCodeInfo.Location
           * @instance
           */
          Location.prototype.trailingComments = "";

          /**
           * Location leadingDetachedComments.
           * @member {Array.<string>} leadingDetachedComments
           * @memberof google.protobuf.SourceCodeInfo.Location
           * @instance
           */
          Location.prototype.leadingDetachedComments = $util.emptyArray;

          /**
           * Creates a new Location instance using the specified properties.
           * @function create
           * @memberof google.protobuf.SourceCodeInfo.Location
           * @static
           * @param {google.protobuf.SourceCodeInfo.ILocation=} [properties] Properties to set
           * @returns {google.protobuf.SourceCodeInfo.Location} Location instance
           */
          Location.create = function create(properties) {
            return new Location(properties);
          };

          /**
           * Encodes the specified Location message. Does not implicitly {@link google.protobuf.SourceCodeInfo.Location.verify|verify} messages.
           * @function encode
           * @memberof google.protobuf.SourceCodeInfo.Location
           * @static
           * @param {google.protobuf.SourceCodeInfo.ILocation} message Location message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          Location.encode = function encode(message, writer) {
            if (!writer) writer = $Writer.create();
            if (message.path != null && message.path.length) {
              writer.uint32(/* id 1, wireType 2 =*/ 10).fork();
              for (var i = 0; i < message.path.length; ++i) writer.int32(message.path[i]);
              writer.ldelim();
            }
            if (message.span != null && message.span.length) {
              writer.uint32(/* id 2, wireType 2 =*/ 18).fork();
              for (var i = 0; i < message.span.length; ++i) writer.int32(message.span[i]);
              writer.ldelim();
            }
            if (message.leadingComments != null && Object.hasOwnProperty.call(message, "leadingComments"))
              writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.leadingComments);
            if (message.trailingComments != null && Object.hasOwnProperty.call(message, "trailingComments"))
              writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.trailingComments);
            if (message.leadingDetachedComments != null && message.leadingDetachedComments.length)
              for (var i = 0; i < message.leadingDetachedComments.length; ++i)
                writer.uint32(/* id 6, wireType 2 =*/ 50).string(message.leadingDetachedComments[i]);
            return writer;
          };

          /**
           * Encodes the specified Location message, length delimited. Does not implicitly {@link google.protobuf.SourceCodeInfo.Location.verify|verify} messages.
           * @function encodeDelimited
           * @memberof google.protobuf.SourceCodeInfo.Location
           * @static
           * @param {google.protobuf.SourceCodeInfo.ILocation} message Location message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          Location.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a Location message from the specified reader or buffer.
           * @function decode
           * @memberof google.protobuf.SourceCodeInfo.Location
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {google.protobuf.SourceCodeInfo.Location} Location
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          Location.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length,
              message = new $root.google.protobuf.SourceCodeInfo.Location();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  if (!(message.path && message.path.length)) message.path = [];
                  if ((tag & 7) === 2) {
                    var end2 = reader.uint32() + reader.pos;
                    while (reader.pos < end2) message.path.push(reader.int32());
                  } else message.path.push(reader.int32());
                  break;
                case 2:
                  if (!(message.span && message.span.length)) message.span = [];
                  if ((tag & 7) === 2) {
                    var end2 = reader.uint32() + reader.pos;
                    while (reader.pos < end2) message.span.push(reader.int32());
                  } else message.span.push(reader.int32());
                  break;
                case 3:
                  message.leadingComments = reader.string();
                  break;
                case 4:
                  message.trailingComments = reader.string();
                  break;
                case 6:
                  if (!(message.leadingDetachedComments && message.leadingDetachedComments.length))
                    message.leadingDetachedComments = [];
                  message.leadingDetachedComments.push(reader.string());
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };

          /**
           * Decodes a Location message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof google.protobuf.SourceCodeInfo.Location
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {google.protobuf.SourceCodeInfo.Location} Location
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          Location.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader)) reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a Location message.
           * @function verify
           * @memberof google.protobuf.SourceCodeInfo.Location
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          Location.verify = function verify(message) {
            if (typeof message !== "object" || message === null) return "object expected";
            if (message.path != null && message.hasOwnProperty("path")) {
              if (!Array.isArray(message.path)) return "path: array expected";
              for (var i = 0; i < message.path.length; ++i)
                if (!$util.isInteger(message.path[i])) return "path: integer[] expected";
            }
            if (message.span != null && message.hasOwnProperty("span")) {
              if (!Array.isArray(message.span)) return "span: array expected";
              for (var i = 0; i < message.span.length; ++i)
                if (!$util.isInteger(message.span[i])) return "span: integer[] expected";
            }
            if (message.leadingComments != null && message.hasOwnProperty("leadingComments"))
              if (!$util.isString(message.leadingComments)) return "leadingComments: string expected";
            if (message.trailingComments != null && message.hasOwnProperty("trailingComments"))
              if (!$util.isString(message.trailingComments)) return "trailingComments: string expected";
            if (
              message.leadingDetachedComments != null &&
              message.hasOwnProperty("leadingDetachedComments")
            ) {
              if (!Array.isArray(message.leadingDetachedComments))
                return "leadingDetachedComments: array expected";
              for (var i = 0; i < message.leadingDetachedComments.length; ++i)
                if (!$util.isString(message.leadingDetachedComments[i]))
                  return "leadingDetachedComments: string[] expected";
            }
            return null;
          };

          /**
           * Creates a Location message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof google.protobuf.SourceCodeInfo.Location
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {google.protobuf.SourceCodeInfo.Location} Location
           */
          Location.fromObject = function fromObject(object) {
            if (object instanceof $root.google.protobuf.SourceCodeInfo.Location) return object;
            var message = new $root.google.protobuf.SourceCodeInfo.Location();
            if (object.path) {
              if (!Array.isArray(object.path))
                throw TypeError(".google.protobuf.SourceCodeInfo.Location.path: array expected");
              message.path = [];
              for (var i = 0; i < object.path.length; ++i) message.path[i] = object.path[i] | 0;
            }
            if (object.span) {
              if (!Array.isArray(object.span))
                throw TypeError(".google.protobuf.SourceCodeInfo.Location.span: array expected");
              message.span = [];
              for (var i = 0; i < object.span.length; ++i) message.span[i] = object.span[i] | 0;
            }
            if (object.leadingComments != null) message.leadingComments = String(object.leadingComments);
            if (object.trailingComments != null) message.trailingComments = String(object.trailingComments);
            if (object.leadingDetachedComments) {
              if (!Array.isArray(object.leadingDetachedComments))
                throw TypeError(
                  ".google.protobuf.SourceCodeInfo.Location.leadingDetachedComments: array expected",
                );
              message.leadingDetachedComments = [];
              for (var i = 0; i < object.leadingDetachedComments.length; ++i)
                message.leadingDetachedComments[i] = String(object.leadingDetachedComments[i]);
            }
            return message;
          };

          /**
           * Creates a plain object from a Location message. Also converts values to other types if specified.
           * @function toObject
           * @memberof google.protobuf.SourceCodeInfo.Location
           * @static
           * @param {google.protobuf.SourceCodeInfo.Location} message Location
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          Location.toObject = function toObject(message, options) {
            if (!options) options = {};
            var object = {};
            if (options.arrays || options.defaults) {
              object.path = [];
              object.span = [];
              object.leadingDetachedComments = [];
            }
            if (options.defaults) {
              object.leadingComments = "";
              object.trailingComments = "";
            }
            if (message.path && message.path.length) {
              object.path = [];
              for (var j = 0; j < message.path.length; ++j) object.path[j] = message.path[j];
            }
            if (message.span && message.span.length) {
              object.span = [];
              for (var j = 0; j < message.span.length; ++j) object.span[j] = message.span[j];
            }
            if (message.leadingComments != null && message.hasOwnProperty("leadingComments"))
              object.leadingComments = message.leadingComments;
            if (message.trailingComments != null && message.hasOwnProperty("trailingComments"))
              object.trailingComments = message.trailingComments;
            if (message.leadingDetachedComments && message.leadingDetachedComments.length) {
              object.leadingDetachedComments = [];
              for (var j = 0; j < message.leadingDetachedComments.length; ++j)
                object.leadingDetachedComments[j] = message.leadingDetachedComments[j];
            }
            return object;
          };

          /**
           * Converts this Location to JSON.
           * @function toJSON
           * @memberof google.protobuf.SourceCodeInfo.Location
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          Location.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };

          return Location;
        })();

        return SourceCodeInfo;
      })();

      protobuf.GeneratedCodeInfo = (function () {
        /**
         * Properties of a GeneratedCodeInfo.
         * @memberof google.protobuf
         * @interface IGeneratedCodeInfo
         * @property {Array.<google.protobuf.GeneratedCodeInfo.IAnnotation>|null} [annotation] GeneratedCodeInfo annotation
         */

        /**
         * Constructs a new GeneratedCodeInfo.
         * @memberof google.protobuf
         * @classdesc Represents a GeneratedCodeInfo.
         * @implements IGeneratedCodeInfo
         * @constructor
         * @param {google.protobuf.IGeneratedCodeInfo=} [properties] Properties to set
         */
        function GeneratedCodeInfo(properties) {
          this.annotation = [];
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * GeneratedCodeInfo annotation.
         * @member {Array.<google.protobuf.GeneratedCodeInfo.IAnnotation>} annotation
         * @memberof google.protobuf.GeneratedCodeInfo
         * @instance
         */
        GeneratedCodeInfo.prototype.annotation = $util.emptyArray;

        /**
         * Creates a new GeneratedCodeInfo instance using the specified properties.
         * @function create
         * @memberof google.protobuf.GeneratedCodeInfo
         * @static
         * @param {google.protobuf.IGeneratedCodeInfo=} [properties] Properties to set
         * @returns {google.protobuf.GeneratedCodeInfo} GeneratedCodeInfo instance
         */
        GeneratedCodeInfo.create = function create(properties) {
          return new GeneratedCodeInfo(properties);
        };

        /**
         * Encodes the specified GeneratedCodeInfo message. Does not implicitly {@link google.protobuf.GeneratedCodeInfo.verify|verify} messages.
         * @function encode
         * @memberof google.protobuf.GeneratedCodeInfo
         * @static
         * @param {google.protobuf.IGeneratedCodeInfo} message GeneratedCodeInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GeneratedCodeInfo.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.annotation != null && message.annotation.length)
            for (var i = 0; i < message.annotation.length; ++i)
              $root.google.protobuf.GeneratedCodeInfo.Annotation.encode(
                message.annotation[i],
                writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
              ).ldelim();
          return writer;
        };

        /**
         * Encodes the specified GeneratedCodeInfo message, length delimited. Does not implicitly {@link google.protobuf.GeneratedCodeInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof google.protobuf.GeneratedCodeInfo
         * @static
         * @param {google.protobuf.IGeneratedCodeInfo} message GeneratedCodeInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GeneratedCodeInfo.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GeneratedCodeInfo message from the specified reader or buffer.
         * @function decode
         * @memberof google.protobuf.GeneratedCodeInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {google.protobuf.GeneratedCodeInfo} GeneratedCodeInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GeneratedCodeInfo.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.google.protobuf.GeneratedCodeInfo();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                if (!(message.annotation && message.annotation.length)) message.annotation = [];
                message.annotation.push(
                  $root.google.protobuf.GeneratedCodeInfo.Annotation.decode(reader, reader.uint32()),
                );
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a GeneratedCodeInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof google.protobuf.GeneratedCodeInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {google.protobuf.GeneratedCodeInfo} GeneratedCodeInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GeneratedCodeInfo.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GeneratedCodeInfo message.
         * @function verify
         * @memberof google.protobuf.GeneratedCodeInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GeneratedCodeInfo.verify = function verify(message) {
          if (typeof message !== "object" || message === null) return "object expected";
          if (message.annotation != null && message.hasOwnProperty("annotation")) {
            if (!Array.isArray(message.annotation)) return "annotation: array expected";
            for (var i = 0; i < message.annotation.length; ++i) {
              var error = $root.google.protobuf.GeneratedCodeInfo.Annotation.verify(message.annotation[i]);
              if (error) return "annotation." + error;
            }
          }
          return null;
        };

        /**
         * Creates a GeneratedCodeInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof google.protobuf.GeneratedCodeInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {google.protobuf.GeneratedCodeInfo} GeneratedCodeInfo
         */
        GeneratedCodeInfo.fromObject = function fromObject(object) {
          if (object instanceof $root.google.protobuf.GeneratedCodeInfo) return object;
          var message = new $root.google.protobuf.GeneratedCodeInfo();
          if (object.annotation) {
            if (!Array.isArray(object.annotation))
              throw TypeError(".google.protobuf.GeneratedCodeInfo.annotation: array expected");
            message.annotation = [];
            for (var i = 0; i < object.annotation.length; ++i) {
              if (typeof object.annotation[i] !== "object")
                throw TypeError(".google.protobuf.GeneratedCodeInfo.annotation: object expected");
              message.annotation[i] = $root.google.protobuf.GeneratedCodeInfo.Annotation.fromObject(
                object.annotation[i],
              );
            }
          }
          return message;
        };

        /**
         * Creates a plain object from a GeneratedCodeInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof google.protobuf.GeneratedCodeInfo
         * @static
         * @param {google.protobuf.GeneratedCodeInfo} message GeneratedCodeInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GeneratedCodeInfo.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.arrays || options.defaults) object.annotation = [];
          if (message.annotation && message.annotation.length) {
            object.annotation = [];
            for (var j = 0; j < message.annotation.length; ++j)
              object.annotation[j] = $root.google.protobuf.GeneratedCodeInfo.Annotation.toObject(
                message.annotation[j],
                options,
              );
          }
          return object;
        };

        /**
         * Converts this GeneratedCodeInfo to JSON.
         * @function toJSON
         * @memberof google.protobuf.GeneratedCodeInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GeneratedCodeInfo.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        GeneratedCodeInfo.Annotation = (function () {
          /**
           * Properties of an Annotation.
           * @memberof google.protobuf.GeneratedCodeInfo
           * @interface IAnnotation
           * @property {Array.<number>|null} [path] Annotation path
           * @property {string|null} [sourceFile] Annotation sourceFile
           * @property {number|null} [begin] Annotation begin
           * @property {number|null} [end] Annotation end
           */

          /**
           * Constructs a new Annotation.
           * @memberof google.protobuf.GeneratedCodeInfo
           * @classdesc Represents an Annotation.
           * @implements IAnnotation
           * @constructor
           * @param {google.protobuf.GeneratedCodeInfo.IAnnotation=} [properties] Properties to set
           */
          function Annotation(properties) {
            this.path = [];
            if (properties)
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
          }

          /**
           * Annotation path.
           * @member {Array.<number>} path
           * @memberof google.protobuf.GeneratedCodeInfo.Annotation
           * @instance
           */
          Annotation.prototype.path = $util.emptyArray;

          /**
           * Annotation sourceFile.
           * @member {string} sourceFile
           * @memberof google.protobuf.GeneratedCodeInfo.Annotation
           * @instance
           */
          Annotation.prototype.sourceFile = "";

          /**
           * Annotation begin.
           * @member {number} begin
           * @memberof google.protobuf.GeneratedCodeInfo.Annotation
           * @instance
           */
          Annotation.prototype.begin = 0;

          /**
           * Annotation end.
           * @member {number} end
           * @memberof google.protobuf.GeneratedCodeInfo.Annotation
           * @instance
           */
          Annotation.prototype.end = 0;

          /**
           * Creates a new Annotation instance using the specified properties.
           * @function create
           * @memberof google.protobuf.GeneratedCodeInfo.Annotation
           * @static
           * @param {google.protobuf.GeneratedCodeInfo.IAnnotation=} [properties] Properties to set
           * @returns {google.protobuf.GeneratedCodeInfo.Annotation} Annotation instance
           */
          Annotation.create = function create(properties) {
            return new Annotation(properties);
          };

          /**
           * Encodes the specified Annotation message. Does not implicitly {@link google.protobuf.GeneratedCodeInfo.Annotation.verify|verify} messages.
           * @function encode
           * @memberof google.protobuf.GeneratedCodeInfo.Annotation
           * @static
           * @param {google.protobuf.GeneratedCodeInfo.IAnnotation} message Annotation message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          Annotation.encode = function encode(message, writer) {
            if (!writer) writer = $Writer.create();
            if (message.path != null && message.path.length) {
              writer.uint32(/* id 1, wireType 2 =*/ 10).fork();
              for (var i = 0; i < message.path.length; ++i) writer.int32(message.path[i]);
              writer.ldelim();
            }
            if (message.sourceFile != null && Object.hasOwnProperty.call(message, "sourceFile"))
              writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.sourceFile);
            if (message.begin != null && Object.hasOwnProperty.call(message, "begin"))
              writer.uint32(/* id 3, wireType 0 =*/ 24).int32(message.begin);
            if (message.end != null && Object.hasOwnProperty.call(message, "end"))
              writer.uint32(/* id 4, wireType 0 =*/ 32).int32(message.end);
            return writer;
          };

          /**
           * Encodes the specified Annotation message, length delimited. Does not implicitly {@link google.protobuf.GeneratedCodeInfo.Annotation.verify|verify} messages.
           * @function encodeDelimited
           * @memberof google.protobuf.GeneratedCodeInfo.Annotation
           * @static
           * @param {google.protobuf.GeneratedCodeInfo.IAnnotation} message Annotation message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          Annotation.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes an Annotation message from the specified reader or buffer.
           * @function decode
           * @memberof google.protobuf.GeneratedCodeInfo.Annotation
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {google.protobuf.GeneratedCodeInfo.Annotation} Annotation
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          Annotation.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length,
              message = new $root.google.protobuf.GeneratedCodeInfo.Annotation();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  if (!(message.path && message.path.length)) message.path = [];
                  if ((tag & 7) === 2) {
                    var end2 = reader.uint32() + reader.pos;
                    while (reader.pos < end2) message.path.push(reader.int32());
                  } else message.path.push(reader.int32());
                  break;
                case 2:
                  message.sourceFile = reader.string();
                  break;
                case 3:
                  message.begin = reader.int32();
                  break;
                case 4:
                  message.end = reader.int32();
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };

          /**
           * Decodes an Annotation message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof google.protobuf.GeneratedCodeInfo.Annotation
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {google.protobuf.GeneratedCodeInfo.Annotation} Annotation
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          Annotation.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader)) reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies an Annotation message.
           * @function verify
           * @memberof google.protobuf.GeneratedCodeInfo.Annotation
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          Annotation.verify = function verify(message) {
            if (typeof message !== "object" || message === null) return "object expected";
            if (message.path != null && message.hasOwnProperty("path")) {
              if (!Array.isArray(message.path)) return "path: array expected";
              for (var i = 0; i < message.path.length; ++i)
                if (!$util.isInteger(message.path[i])) return "path: integer[] expected";
            }
            if (message.sourceFile != null && message.hasOwnProperty("sourceFile"))
              if (!$util.isString(message.sourceFile)) return "sourceFile: string expected";
            if (message.begin != null && message.hasOwnProperty("begin"))
              if (!$util.isInteger(message.begin)) return "begin: integer expected";
            if (message.end != null && message.hasOwnProperty("end"))
              if (!$util.isInteger(message.end)) return "end: integer expected";
            return null;
          };

          /**
           * Creates an Annotation message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof google.protobuf.GeneratedCodeInfo.Annotation
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {google.protobuf.GeneratedCodeInfo.Annotation} Annotation
           */
          Annotation.fromObject = function fromObject(object) {
            if (object instanceof $root.google.protobuf.GeneratedCodeInfo.Annotation) return object;
            var message = new $root.google.protobuf.GeneratedCodeInfo.Annotation();
            if (object.path) {
              if (!Array.isArray(object.path))
                throw TypeError(".google.protobuf.GeneratedCodeInfo.Annotation.path: array expected");
              message.path = [];
              for (var i = 0; i < object.path.length; ++i) message.path[i] = object.path[i] | 0;
            }
            if (object.sourceFile != null) message.sourceFile = String(object.sourceFile);
            if (object.begin != null) message.begin = object.begin | 0;
            if (object.end != null) message.end = object.end | 0;
            return message;
          };

          /**
           * Creates a plain object from an Annotation message. Also converts values to other types if specified.
           * @function toObject
           * @memberof google.protobuf.GeneratedCodeInfo.Annotation
           * @static
           * @param {google.protobuf.GeneratedCodeInfo.Annotation} message Annotation
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          Annotation.toObject = function toObject(message, options) {
            if (!options) options = {};
            var object = {};
            if (options.arrays || options.defaults) object.path = [];
            if (options.defaults) {
              object.sourceFile = "";
              object.begin = 0;
              object.end = 0;
            }
            if (message.path && message.path.length) {
              object.path = [];
              for (var j = 0; j < message.path.length; ++j) object.path[j] = message.path[j];
            }
            if (message.sourceFile != null && message.hasOwnProperty("sourceFile"))
              object.sourceFile = message.sourceFile;
            if (message.begin != null && message.hasOwnProperty("begin")) object.begin = message.begin;
            if (message.end != null && message.hasOwnProperty("end")) object.end = message.end;
            return object;
          };

          /**
           * Converts this Annotation to JSON.
           * @function toJSON
           * @memberof google.protobuf.GeneratedCodeInfo.Annotation
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          Annotation.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };

          return Annotation;
        })();

        return GeneratedCodeInfo;
      })();

      protobuf.Timestamp = (function () {
        /**
         * Properties of a Timestamp.
         * @memberof google.protobuf
         * @interface ITimestamp
         * @property {number|Long|null} [seconds] Timestamp seconds
         * @property {number|null} [nanos] Timestamp nanos
         */

        /**
         * Constructs a new Timestamp.
         * @memberof google.protobuf
         * @classdesc Represents a Timestamp.
         * @implements ITimestamp
         * @constructor
         * @param {google.protobuf.ITimestamp=} [properties] Properties to set
         */
        function Timestamp(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * Timestamp seconds.
         * @member {number|Long} seconds
         * @memberof google.protobuf.Timestamp
         * @instance
         */
        Timestamp.prototype.seconds = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * Timestamp nanos.
         * @member {number} nanos
         * @memberof google.protobuf.Timestamp
         * @instance
         */
        Timestamp.prototype.nanos = 0;

        /**
         * Creates a new Timestamp instance using the specified properties.
         * @function create
         * @memberof google.protobuf.Timestamp
         * @static
         * @param {google.protobuf.ITimestamp=} [properties] Properties to set
         * @returns {google.protobuf.Timestamp} Timestamp instance
         */
        Timestamp.create = function create(properties) {
          return new Timestamp(properties);
        };

        /**
         * Encodes the specified Timestamp message. Does not implicitly {@link google.protobuf.Timestamp.verify|verify} messages.
         * @function encode
         * @memberof google.protobuf.Timestamp
         * @static
         * @param {google.protobuf.ITimestamp} message Timestamp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Timestamp.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.seconds != null && Object.hasOwnProperty.call(message, "seconds"))
            writer.uint32(/* id 1, wireType 0 =*/ 8).int64(message.seconds);
          if (message.nanos != null && Object.hasOwnProperty.call(message, "nanos"))
            writer.uint32(/* id 2, wireType 0 =*/ 16).int32(message.nanos);
          return writer;
        };

        /**
         * Encodes the specified Timestamp message, length delimited. Does not implicitly {@link google.protobuf.Timestamp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof google.protobuf.Timestamp
         * @static
         * @param {google.protobuf.ITimestamp} message Timestamp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Timestamp.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Timestamp message from the specified reader or buffer.
         * @function decode
         * @memberof google.protobuf.Timestamp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {google.protobuf.Timestamp} Timestamp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Timestamp.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.google.protobuf.Timestamp();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.seconds = reader.int64();
                break;
              case 2:
                message.nanos = reader.int32();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a Timestamp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof google.protobuf.Timestamp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {google.protobuf.Timestamp} Timestamp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Timestamp.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Timestamp message.
         * @function verify
         * @memberof google.protobuf.Timestamp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Timestamp.verify = function verify(message) {
          if (typeof message !== "object" || message === null) return "object expected";
          if (message.seconds != null && message.hasOwnProperty("seconds"))
            if (
              !$util.isInteger(message.seconds) &&
              !(
                message.seconds &&
                $util.isInteger(message.seconds.low) &&
                $util.isInteger(message.seconds.high)
              )
            )
              return "seconds: integer|Long expected";
          if (message.nanos != null && message.hasOwnProperty("nanos"))
            if (!$util.isInteger(message.nanos)) return "nanos: integer expected";
          return null;
        };

        /**
         * Creates a Timestamp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof google.protobuf.Timestamp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {google.protobuf.Timestamp} Timestamp
         */
        Timestamp.fromObject = function fromObject(object) {
          if (object instanceof $root.google.protobuf.Timestamp) return object;
          var message = new $root.google.protobuf.Timestamp();
          if (object.seconds != null)
            if ($util.Long) (message.seconds = $util.Long.fromValue(object.seconds)).unsigned = false;
            else if (typeof object.seconds === "string") message.seconds = parseInt(object.seconds, 10);
            else if (typeof object.seconds === "number") message.seconds = object.seconds;
            else if (typeof object.seconds === "object")
              message.seconds = new $util.LongBits(
                object.seconds.low >>> 0,
                object.seconds.high >>> 0,
              ).toNumber();
          if (object.nanos != null) message.nanos = object.nanos | 0;
          return message;
        };

        /**
         * Creates a plain object from a Timestamp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof google.protobuf.Timestamp
         * @static
         * @param {google.protobuf.Timestamp} message Timestamp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Timestamp.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            if ($util.Long) {
              var long = new $util.Long(0, 0, false);
              object.seconds =
                options.longs === String
                  ? long.toString()
                  : options.longs === Number
                  ? long.toNumber()
                  : long;
            } else object.seconds = options.longs === String ? "0" : 0;
            object.nanos = 0;
          }
          if (message.seconds != null && message.hasOwnProperty("seconds"))
            if (typeof message.seconds === "number")
              object.seconds = options.longs === String ? String(message.seconds) : message.seconds;
            else
              object.seconds =
                options.longs === String
                  ? $util.Long.prototype.toString.call(message.seconds)
                  : options.longs === Number
                  ? new $util.LongBits(message.seconds.low >>> 0, message.seconds.high >>> 0).toNumber()
                  : message.seconds;
          if (message.nanos != null && message.hasOwnProperty("nanos")) object.nanos = message.nanos;
          return object;
        };

        /**
         * Converts this Timestamp to JSON.
         * @function toJSON
         * @memberof google.protobuf.Timestamp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Timestamp.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Timestamp;
      })();

      protobuf.Duration = (function () {
        /**
         * Properties of a Duration.
         * @memberof google.protobuf
         * @interface IDuration
         * @property {number|Long|null} [seconds] Duration seconds
         * @property {number|null} [nanos] Duration nanos
         */

        /**
         * Constructs a new Duration.
         * @memberof google.protobuf
         * @classdesc Represents a Duration.
         * @implements IDuration
         * @constructor
         * @param {google.protobuf.IDuration=} [properties] Properties to set
         */
        function Duration(properties) {
          if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * Duration seconds.
         * @member {number|Long} seconds
         * @memberof google.protobuf.Duration
         * @instance
         */
        Duration.prototype.seconds = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

        /**
         * Duration nanos.
         * @member {number} nanos
         * @memberof google.protobuf.Duration
         * @instance
         */
        Duration.prototype.nanos = 0;

        /**
         * Creates a new Duration instance using the specified properties.
         * @function create
         * @memberof google.protobuf.Duration
         * @static
         * @param {google.protobuf.IDuration=} [properties] Properties to set
         * @returns {google.protobuf.Duration} Duration instance
         */
        Duration.create = function create(properties) {
          return new Duration(properties);
        };

        /**
         * Encodes the specified Duration message. Does not implicitly {@link google.protobuf.Duration.verify|verify} messages.
         * @function encode
         * @memberof google.protobuf.Duration
         * @static
         * @param {google.protobuf.IDuration} message Duration message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Duration.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.seconds != null && Object.hasOwnProperty.call(message, "seconds"))
            writer.uint32(/* id 1, wireType 0 =*/ 8).int64(message.seconds);
          if (message.nanos != null && Object.hasOwnProperty.call(message, "nanos"))
            writer.uint32(/* id 2, wireType 0 =*/ 16).int32(message.nanos);
          return writer;
        };

        /**
         * Encodes the specified Duration message, length delimited. Does not implicitly {@link google.protobuf.Duration.verify|verify} messages.
         * @function encodeDelimited
         * @memberof google.protobuf.Duration
         * @static
         * @param {google.protobuf.IDuration} message Duration message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Duration.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Duration message from the specified reader or buffer.
         * @function decode
         * @memberof google.protobuf.Duration
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {google.protobuf.Duration} Duration
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Duration.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.google.protobuf.Duration();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.seconds = reader.int64();
                break;
              case 2:
                message.nanos = reader.int32();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a Duration message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof google.protobuf.Duration
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {google.protobuf.Duration} Duration
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Duration.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Duration message.
         * @function verify
         * @memberof google.protobuf.Duration
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Duration.verify = function verify(message) {
          if (typeof message !== "object" || message === null) return "object expected";
          if (message.seconds != null && message.hasOwnProperty("seconds"))
            if (
              !$util.isInteger(message.seconds) &&
              !(
                message.seconds &&
                $util.isInteger(message.seconds.low) &&
                $util.isInteger(message.seconds.high)
              )
            )
              return "seconds: integer|Long expected";
          if (message.nanos != null && message.hasOwnProperty("nanos"))
            if (!$util.isInteger(message.nanos)) return "nanos: integer expected";
          return null;
        };

        /**
         * Creates a Duration message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof google.protobuf.Duration
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {google.protobuf.Duration} Duration
         */
        Duration.fromObject = function fromObject(object) {
          if (object instanceof $root.google.protobuf.Duration) return object;
          var message = new $root.google.protobuf.Duration();
          if (object.seconds != null)
            if ($util.Long) (message.seconds = $util.Long.fromValue(object.seconds)).unsigned = false;
            else if (typeof object.seconds === "string") message.seconds = parseInt(object.seconds, 10);
            else if (typeof object.seconds === "number") message.seconds = object.seconds;
            else if (typeof object.seconds === "object")
              message.seconds = new $util.LongBits(
                object.seconds.low >>> 0,
                object.seconds.high >>> 0,
              ).toNumber();
          if (object.nanos != null) message.nanos = object.nanos | 0;
          return message;
        };

        /**
         * Creates a plain object from a Duration message. Also converts values to other types if specified.
         * @function toObject
         * @memberof google.protobuf.Duration
         * @static
         * @param {google.protobuf.Duration} message Duration
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Duration.toObject = function toObject(message, options) {
          if (!options) options = {};
          var object = {};
          if (options.defaults) {
            if ($util.Long) {
              var long = new $util.Long(0, 0, false);
              object.seconds =
                options.longs === String
                  ? long.toString()
                  : options.longs === Number
                  ? long.toNumber()
                  : long;
            } else object.seconds = options.longs === String ? "0" : 0;
            object.nanos = 0;
          }
          if (message.seconds != null && message.hasOwnProperty("seconds"))
            if (typeof message.seconds === "number")
              object.seconds = options.longs === String ? String(message.seconds) : message.seconds;
            else
              object.seconds =
                options.longs === String
                  ? $util.Long.prototype.toString.call(message.seconds)
                  : options.longs === Number
                  ? new $util.LongBits(message.seconds.low >>> 0, message.seconds.high >>> 0).toNumber()
                  : message.seconds;
          if (message.nanos != null && message.hasOwnProperty("nanos")) object.nanos = message.nanos;
          return object;
        };

        /**
         * Converts this Duration to JSON.
         * @function toJSON
         * @memberof google.protobuf.Duration
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Duration.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Duration;
      })();

      return protobuf;
    })();

    return google;
  })();

  return $root;
});


/***/ }),

/***/ 116:
/***/ (function(module, exports, __webpack_require__) {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Stream;

var EE = __webpack_require__(87).EventEmitter;
var inherits = __webpack_require__(18);

inherits(Stream, EE);
Stream.Readable = __webpack_require__(174);
Stream.Writable = __webpack_require__(719);
Stream.Duplex = __webpack_require__(720);
Stream.Transform = __webpack_require__(721);
Stream.PassThrough = __webpack_require__(722);

// Backwards-compat with node 0.4.x
Stream.Stream = Stream;



// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function(dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest.end();
  }


  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;

    if (typeof dest.destroy === 'function') dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);

    source.removeListener('end', onend);
    source.removeListener('close', onclose);

    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);

    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);

    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);

  dest.on('close', cleanup);

  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};


/***/ }),

/***/ 1160:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const crypto_1 = __webpack_require__(184);
const signature_1 = __webpack_require__(357);
function prehash(bytes, type) {
    switch (type) {
        case null:
            return new Uint8Array([...bytes]);
        case "sha256":
            return new crypto_1.Sha256(bytes).digest();
        case "sha512":
            return new crypto_1.Sha512(bytes).digest();
        default:
            throw new Error("Unknown prehash type");
    }
}
/**
 * The Cosmoshub derivation path in the form `m/44'/118'/0'/0/a`
 * with 0-based account index `a`.
 * The Secret Network derivation path in the form `m/44'/529'/0'/0/a`
 * with 0-based account index `a`.
 */
function makeSecretNetworkPath(a) {
    return [
        crypto_1.Slip10RawIndex.hardened(44),
        crypto_1.Slip10RawIndex.hardened(529),
        crypto_1.Slip10RawIndex.hardened(0),
        crypto_1.Slip10RawIndex.normal(0),
        crypto_1.Slip10RawIndex.normal(a),
    ];
}
exports.makeSecretNetworkPath = makeSecretNetworkPath;
class Secp256k1Pen {
    constructor(privkey, pubkey) {
        this.privkey = privkey;
        this.pubkey = pubkey;
    }
    static async fromMnemonic(mnemonic, hdPath = makeSecretNetworkPath(0)) {
        const seed = await crypto_1.Bip39.mnemonicToSeed(new crypto_1.EnglishMnemonic(mnemonic));
        const { privkey } = crypto_1.Slip10.derivePath(crypto_1.Slip10Curve.Secp256k1, seed, hdPath);
        const uncompressed = (await crypto_1.Secp256k1.makeKeypair(privkey)).pubkey;
        return new Secp256k1Pen(privkey, crypto_1.Secp256k1.compressPubkey(uncompressed));
    }
    /**
     * Creates and returns a signature
     */
    async sign(signBytes, prehashType = "sha256") {
        const message = prehash(signBytes, prehashType);
        const signature = await crypto_1.Secp256k1.createSignature(message, this.privkey);
        const fixedLengthSignature = new Uint8Array([...signature.r(32), ...signature.s(32)]);
        return signature_1.encodeSecp256k1Signature(this.pubkey, fixedLengthSignature);
    }
}
exports.Secp256k1Pen = Secp256k1Pen;
//# sourceMappingURL=pen.js.map

/***/ }),

/***/ 1162:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const crypto_1 = __webpack_require__(184);
const encoding_1 = __webpack_require__(350);
const signature_1 = __webpack_require__(357);
/**
 * Serach for sequence s with `min` <= `s` < `upperBound` to find the sequence that was used to sign the transaction
 *
 * @param tx The signed transaction
 * @param chainId The chain ID for which this transaction was signed
 * @param accountNumber The account number for which this transaction was signed
 * @param upperBound The upper bound for the testing, i.e. sequence must be lower than this value
 * @param min The lowest sequence that is tested
 *
 * @returns the sequence if a match was found and undefined otherwise
 */
async function findSequenceForSignedTx(tx, chainId, accountNumber, upperBound, min = 0) {
    const firstSignature = tx.value.signatures.find(() => true);
    if (!firstSignature)
        throw new Error("Signature missing in tx");
    const { pubkey, signature } = signature_1.decodeSignature(firstSignature);
    const secp256keSignature = crypto_1.Secp256k1Signature.fromFixedLength(signature);
    for (let s = min; s < upperBound; s++) {
        // console.log(`Trying sequence ${s}`);
        const signBytes = encoding_1.makeSignBytes(tx.value.msg, tx.value.fee, chainId, tx.value.memo || "", accountNumber, s);
        const prehashed = new crypto_1.Sha256(signBytes).digest();
        const valid = await crypto_1.Secp256k1.verifySignature(secp256keSignature, prehashed, pubkey);
        if (valid)
            return s;
    }
    return undefined;
}
exports.findSequenceForSignedTx = findSequenceForSignedTx;
//# sourceMappingURL=sequence.js.map

/***/ }),

/***/ 1163:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const crypto_1 = __webpack_require__(184);
const encoding_1 = __webpack_require__(86);
const pako_1 = __importDefault(__webpack_require__(1164));
const builder_1 = __webpack_require__(1168);
const cosmwasmclient_1 = __webpack_require__(575);
const encoding_2 = __webpack_require__(350);
const logs_1 = __webpack_require__(348);
const restclient_1 = __webpack_require__(351);
const v1_4_protos_1 = __webpack_require__(574);
function singleAmount(amount, denom) {
    return [{ amount: amount.toString(), denom: denom }];
}
function prepareBuilder(buider) {
    if (buider === undefined) {
        return undefined; // normalization needed by backend
    }
    else {
        if (!builder_1.isValidBuilder(buider))
            throw new Error("The builder (Docker Hub image with tag) is not valid");
        return buider;
    }
}
const defaultFees = {
    upload: {
        amount: singleAmount(250000, "uscrt"),
        gas: String(1000000),
    },
    init: {
        amount: singleAmount(125000, "uscrt"),
        gas: String(500000),
    },
    exec: {
        amount: singleAmount(50000, "uscrt"),
        gas: String(200000),
    },
    send: {
        amount: singleAmount(20000, "uscrt"),
        gas: String(80000),
    },
};
class SigningCosmWasmClient extends cosmwasmclient_1.CosmWasmClient {
    /**
     * Creates a new client with signing capability to interact with a CosmWasm blockchain. This is the bigger brother of CosmWasmClient.
     *
     * This instance does a lot of caching. In order to benefit from that you should try to use one instance
     * for the lifetime of your application. When switching backends, a new instance must be created.
     *
     * @param apiUrl The URL of a Cosmos SDK light client daemon API (sometimes called REST server or REST API)
     * @param senderAddress The address that will sign and send transactions using this instance
     * @param signer An asynchronous callback to create a signature for a given transaction. This can be implemented using secure key stores that require user interaction. Or a newer OfflineSigner type that handles that stuff
     * @param seedOrEnigmaUtils
     * @param customFees The fees that are paid for transactions
     * @param broadcastMode Defines at which point of the transaction processing the postTx method (i.e. transaction broadcasting) returns
     */
    constructor(apiUrl, senderAddress, signer, seedOrEnigmaUtils, customFees, broadcastMode = restclient_1.BroadcastMode.Block) {
        if (seedOrEnigmaUtils instanceof Uint8Array) {
            super(apiUrl, seedOrEnigmaUtils, broadcastMode);
        }
        else {
            super(apiUrl, undefined, broadcastMode);
        }
        this.anyValidAddress = senderAddress;
        this.senderAddress = senderAddress;
        //this.signCallback = signCallback ? signCallback : undefined;
        this.signer = signer;
        if (seedOrEnigmaUtils && !(seedOrEnigmaUtils instanceof Uint8Array)) {
            this.restClient.enigmautils = seedOrEnigmaUtils;
        }
        this.fees = Object.assign(Object.assign({}, defaultFees), (customFees || {}));
        // // Setup contract->hash cache
        // // This is only needed here and not in CosmWasmClient because we
        // // need code hashes before sending txs
        // this.restClient.listCodeInfo().then(async (codes) => {
        //   for (const code of codes) {
        //     this.restClient.codeHashCache.set(code.id, code.data_hash);
        //     const contracts = await this.restClient.listContractsByCodeId(code.id);
        //     for (const contract of contracts) {
        //       this.restClient.codeHashCache.set(contract.address, code.data_hash);
        //     }
        //   }
        // });
    }
    async getNonce(address) {
        return super.getNonce(address || this.senderAddress);
    }
    async getAccount(address) {
        return super.getAccount(address || this.senderAddress);
    }
    async signAdapter(msgs, fee, chainId, memo, accountNumber, sequence) {
        // offline signer interface
        if ("sign" in this.signer) {
            const signResponse = await this.signer.sign(this.senderAddress, {
                chain_id: chainId,
                account_number: String(accountNumber),
                sequence: String(sequence),
                fee: fee,
                msgs: msgs,
                memo: memo,
            });
            return {
                msg: msgs,
                fee: signResponse.signed.fee,
                memo: signResponse.signed.memo,
                signatures: [signResponse.signature],
            };
        }
        else {
            // legacy interface
            const signBytes = encoding_2.makeSignBytes(msgs, fee, chainId, memo, accountNumber, sequence);
            const signature = await this.signer(signBytes);
            return {
                msg: msgs,
                fee: fee,
                memo: memo,
                signatures: [signature],
            };
        }
    }
    /** Uploads code and returns a receipt, including the code ID */
    async upload(wasmCode, meta = {}, memo = "", fee = this.fees.upload) {
        if (!memo) {
            memo = "";
        }
        if (!meta) {
            meta = {};
        }
        const source = meta.source || undefined;
        const builder = prepareBuilder(meta.builder);
        const compressed = pako_1.default.gzip(wasmCode, { level: 9 });
        const storeCodeMsg = {
            type: "wasm/MsgStoreCode",
            value: {
                sender: this.senderAddress,
                // eslint-disable-next-line @typescript-eslint/camelcase
                wasm_byte_code: encoding_1.Encoding.toBase64(compressed),
            },
        };
        if (source && source.length > 0) {
            storeCodeMsg.value.source = source;
        }
        if (builder && builder.length > 0) {
            storeCodeMsg.value.builder = builder;
        }
        const { accountNumber, sequence } = await this.getNonce();
        const chainId = await this.getChainId();
        const signedTx = await this.signAdapter([storeCodeMsg], fee, chainId, memo, accountNumber, sequence);
        const result = await this.postTx(signedTx);
        let codeIdAttr;
        if (this.restClient.broadcastMode == restclient_1.BroadcastMode.Block) {
            codeIdAttr = logs_1.findAttribute(result.logs, "message", "code_id");
        }
        return {
            originalSize: wasmCode.length,
            originalChecksum: encoding_1.Encoding.toHex(new crypto_1.Sha256(wasmCode).digest()),
            compressedSize: compressed.length,
            compressedChecksum: encoding_1.Encoding.toHex(new crypto_1.Sha256(compressed).digest()),
            codeId: this.restClient.broadcastMode == restclient_1.BroadcastMode.Block
                ? Number.parseInt(codeIdAttr.value, 10)
                : -1,
            logs: result.logs,
            transactionHash: result.transactionHash,
        };
    }
    async instantiate(codeId, initMsg, label, memo = "", transferAmount, fee = this.fees.init, contractCodeHash) {
        var _a;
        if (!contractCodeHash) {
            contractCodeHash = await this.restClient.getCodeHashByCodeId(codeId);
        }
        else {
            this.restClient.codeHashCache.set(codeId, contractCodeHash);
        }
        if (!memo) {
            memo = "";
        }
        const instantiateMsg = {
            type: "wasm/MsgInstantiateContract",
            value: {
                sender: this.senderAddress,
                code_id: String(codeId),
                label: label,
                init_msg: encoding_1.Encoding.toBase64(await this.restClient.enigmautils.encrypt(contractCodeHash, initMsg)),
                init_funds: (transferAmount !== null && transferAmount !== void 0 ? transferAmount : []),
            },
        };
        const { accountNumber, sequence } = await this.getNonce();
        const chainId = await this.getChainId();
        const signedTx = await this.signAdapter([instantiateMsg], fee, chainId, memo, accountNumber, sequence);
        const nonce = encoding_1.Encoding.fromBase64(instantiateMsg.value.init_msg).slice(0, 32);
        let result;
        try {
            result = await this.postTx(signedTx);
        }
        catch (err) {
            try {
                const errorMessageRgx = /failed to execute message; message index: 0:(?: dispatch: submessages:)* encrypted: (.+?): (?:instantiate|execute|query) contract failed/g;
                // @ts-ignore
                const rgxMatches = errorMessageRgx.exec(err.message);
                if (rgxMatches == null || rgxMatches.length != 2) {
                    throw err;
                }
                const errorCipherB64 = rgxMatches[1];
                const errorCipherBz = encoding_1.Encoding.fromBase64(errorCipherB64);
                const errorPlainBz = await this.restClient.enigmautils.decrypt(errorCipherBz, nonce);
                // @ts-ignore
                err.message = err.message.replace(errorCipherB64, encoding_1.Encoding.fromUtf8(errorPlainBz));
            }
            catch (decryptionError) {
                throw new Error(
                // @ts-ignore
                `Failed to decrypt the following error message: ${err.message}. Decryption error of the error message: ${decryptionError.message}`);
            }
            throw err;
        }
        let contractAddress = "";
        if (this.restClient.broadcastMode == restclient_1.BroadcastMode.Block) {
            contractAddress = (_a = logs_1.findAttribute(result.logs, "message", "contract_address")) === null || _a === void 0 ? void 0 : _a.value;
        }
        const logs = this.restClient.broadcastMode == restclient_1.BroadcastMode.Block
            ? await this.restClient.decryptLogs(result.logs, [nonce])
            : [];
        const txDatas = v1_4_protos_1.TxMsgData.decode(encoding_1.Encoding.fromHex(result.data));
        const decoded = v1_4_protos_1.MsgInstantiateContractResponse.decode(txDatas.data[0].data);
        const decrypted = await this.restClient.decryptDataField(encoding_1.Encoding.toHex(decoded.data), [nonce]);
        return {
            contractAddress,
            logs: logs,
            transactionHash: result.transactionHash,
            data: decrypted,
        };
    }
    async multiExecute(inputMsgs, memo = "", totalFee) {
        var _a, _b, _c, _d;
        if (!memo) {
            memo = "";
        }
        const msgs = [];
        for (const inputMsg of inputMsgs) {
            let { contractCodeHash } = inputMsg;
            if (!contractCodeHash) {
                contractCodeHash = await this.restClient.getCodeHashByContractAddr(inputMsg.contractAddress);
            }
            else {
                this.restClient.codeHashCache.set(inputMsg.contractAddress, contractCodeHash);
            }
            const msg = {
                type: "wasm/MsgExecuteContract",
                value: {
                    sender: this.senderAddress,
                    contract: inputMsg.contractAddress,
                    //callback_code_hash: "",
                    msg: encoding_1.Encoding.toBase64(await this.restClient.enigmautils.encrypt(contractCodeHash, inputMsg.handleMsg)),
                    sent_funds: (_a = inputMsg.transferAmount, (_a !== null && _a !== void 0 ? _a : [])),
                },
            };
            msgs.push(msg);
        }
        const { accountNumber, sequence } = await this.getNonce();
        const fee = (totalFee !== null && totalFee !== void 0 ? totalFee : {
            gas: String(Number(this.fees.exec.gas) * inputMsgs.length),
            amount: this.fees.exec.amount,
        });
        const chainId = await this.getChainId();
        const signedTx = await this.signAdapter(msgs, fee, chainId, memo, accountNumber, sequence);
        let result;
        try {
            result = await this.postTx(signedTx);
        }
        catch (err) {
            try {
                const errorMessageRgx = /failed to execute message; message index: (\d+):(?: dispatch: submessages:)* encrypted: (.+?): (?:instantiate|execute|query) contract failed/g;
                // @ts-ignore
                const rgxMatches = errorMessageRgx.exec(err.message);
                if (rgxMatches == null || rgxMatches.length != 3) {
                    throw err;
                }
                const errorCipherB64 = rgxMatches[1];
                const errorCipherBz = encoding_1.Encoding.fromBase64(errorCipherB64);
                const msgIndex = Number(rgxMatches[2]);
                const nonce = encoding_1.Encoding.fromBase64(msgs[msgIndex].value.msg).slice(0, 32);
                const errorPlainBz = await this.restClient.enigmautils.decrypt(errorCipherBz, nonce);
                // @ts-ignore
                err.message = err.message.replace(errorCipherB64, encoding_1.Encoding.fromUtf8(errorPlainBz));
            }
            catch (decryptionError) {
                throw new Error(
                // @ts-ignore
                `Failed to decrypt the following error message: ${err.message}. Decryption error of the error message: ${decryptionError.message}`);
            }
            throw err;
        }
        const nonces = msgs.map((msg) => encoding_1.Encoding.fromBase64(msg.value.msg).slice(0, 32));
        // //const data = await this.restClient.decryptDataField(result.data, nonces);
        // const dataFields: MsgData[] = decodeTxData(Encoding.fromHex(result.data));
        //
        // let data = Uint8Array.from([]);
        // if (dataFields[0].data) {
        //   // dataFields[0].data = JSON.parse(decryptedData.toString());
        //   // @ts-ignore
        //   data = await this.restClient.decryptDataField(Encoding.toHex(Encoding.fromBase64(dataFields[0].data)), nonces);
        // }
        //
        // const logs = await this.restClient.decryptLogs(result.logs, nonces);
        let data = Uint8Array.from([]);
        if (this.restClient.broadcastMode == restclient_1.BroadcastMode.Block) {
            const txDatas = v1_4_protos_1.TxMsgData.decode(encoding_1.Encoding.fromHex(result.data));
            if ((_d = (_c = (_b = txDatas) === null || _b === void 0 ? void 0 : _b.data) === null || _c === void 0 ? void 0 : _c[0]) === null || _d === void 0 ? void 0 : _d.data) {
                const decoded = v1_4_protos_1.MsgExecuteContractResponse.decode(txDatas.data[0].data);
                data = await this.restClient.decryptDataField(encoding_1.Encoding.toHex(decoded.data), nonces);
            }
        }
        const logs = this.restClient.broadcastMode == restclient_1.BroadcastMode.Block
            ? await this.restClient.decryptLogs(result.logs, nonces)
            : [];
        return {
            logs: logs,
            transactionHash: result.transactionHash,
            // @ts-ignore
            data: data,
        };
    }
    async execute(contractAddress, handleMsg, memo = "", transferAmount, fee = this.fees.exec, contractCodeHash) {
        var _a, _b, _c;
        if (!contractCodeHash) {
            contractCodeHash = await this.restClient.getCodeHashByContractAddr(contractAddress);
        }
        else {
            this.restClient.codeHashCache.set(contractAddress, contractCodeHash);
        }
        if (!memo) {
            memo = "";
        }
        const executeMsg = {
            type: "wasm/MsgExecuteContract",
            value: {
                sender: this.senderAddress,
                contract: contractAddress,
                msg: encoding_1.Encoding.toBase64(await this.restClient.enigmautils.encrypt(contractCodeHash, handleMsg)),
                sent_funds: (transferAmount !== null && transferAmount !== void 0 ? transferAmount : []),
            },
        };
        const { accountNumber, sequence } = await this.getNonce();
        const chainId = await this.getChainId();
        const signedTx = await this.signAdapter([executeMsg], fee, chainId, memo, accountNumber, sequence);
        const encryptionNonce = encoding_1.Encoding.fromBase64(executeMsg.value.msg).slice(0, 32);
        let result;
        try {
            result = await this.postTx(signedTx);
        }
        catch (err) {
            try {
                const errorMessageRgx = /failed to execute message; message index: 0:(?: dispatch: submessages:)* encrypted: (.+?): (?:instantiate|execute|query) contract failed/g;
                // console.log(`Got error message: ${err.message}`);
                // @ts-ignore
                const rgxMatches = errorMessageRgx.exec(err.message);
                if (rgxMatches == null || rgxMatches.length != 2) {
                    throw err;
                }
                const errorCipherB64 = rgxMatches[1];
                // console.log(`Got error message: ${errorCipherB64}`);
                const errorCipherBz = encoding_1.Encoding.fromBase64(errorCipherB64);
                const errorPlainBz = await this.restClient.enigmautils.decrypt(errorCipherBz, encryptionNonce);
                // @ts-ignore
                err.message = err.message.replace(errorCipherB64, encoding_1.Encoding.fromUtf8(errorPlainBz));
            }
            catch (decryptionError) {
                throw new Error(
                // @ts-ignore
                `Failed to decrypt the following error message: ${err.message}. Decryption error of the error message: ${decryptionError.message}`);
            }
            throw err;
        }
        let data = Uint8Array.from([]);
        if (this.restClient.broadcastMode == restclient_1.BroadcastMode.Block) {
            const txDatas = v1_4_protos_1.TxMsgData.decode(encoding_1.Encoding.fromHex(result.data));
            if ((_c = (_b = (_a = txDatas) === null || _a === void 0 ? void 0 : _a.data) === null || _b === void 0 ? void 0 : _b[0]) === null || _c === void 0 ? void 0 : _c.data) {
                const decoded = v1_4_protos_1.MsgExecuteContractResponse.decode(txDatas.data[0].data);
                data = await this.restClient.decryptDataField(encoding_1.Encoding.toHex(decoded.data), [encryptionNonce]);
            }
        }
        const logs = this.restClient.broadcastMode == restclient_1.BroadcastMode.Block
            ? await this.restClient.decryptLogs(result.logs, [encryptionNonce])
            : [];
        return {
            logs,
            transactionHash: result.transactionHash,
            // @ts-ignore
            data,
        };
    }
    async sendTokens(recipientAddress, transferAmount, memo = "", fee = this.fees.send) {
        const sendMsg = {
            type: "cosmos-sdk/MsgSend",
            value: {
                // eslint-disable-next-line @typescript-eslint/camelcase
                from_address: this.senderAddress,
                // eslint-disable-next-line @typescript-eslint/camelcase
                to_address: recipientAddress,
                amount: transferAmount,
            },
        };
        if (!memo) {
            memo = "";
        }
        const { accountNumber, sequence } = await this.getNonce();
        const chainId = await this.getChainId();
        const signedTx = await this.signAdapter([sendMsg], fee, chainId, memo, accountNumber, sequence);
        return this.postTx(signedTx);
    }
}
exports.SigningCosmWasmClient = SigningCosmWasmClient;
//# sourceMappingURL=signingcosmwasmclient.js.map

/***/ }),

/***/ 1168:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
// A docker image regexp. We remove support for non-standard registries for simplicity.
// https://docs.docker.com/engine/reference/commandline/tag/#extended-description
//
// An image name is made up of slash-separated name components (optionally prefixed by a registry hostname).
// Name components may contain lowercase characters, digits and separators.
// A separator is defined as a period, one or two underscores, or one or more dashes. A name component may not start or end with a separator.
//
// A tag name must be valid ASCII and may contain lowercase and uppercase letters, digits, underscores, periods and dashes.
// A tag name may not start with a period or a dash and may contain a maximum of 128 characters.
const dockerImagePattern = new RegExp("^[a-z0-9][a-z0-9._-]*[a-z0-9](/[a-z0-9][a-z0-9._-]*[a-z0-9])+:[a-zA-Z0-9_][a-zA-Z0-9_.-]{0,127}$");
/** Max length in bytes/characters (regexp enforces all ASCII, even if that is not required by the standard) */
const builderMaxLength = 128;
function isValidBuilder(builder) {
    if (builder.length > builderMaxLength)
        return false;
    return !!builder.match(dockerImagePattern);
}
exports.isValidBuilder = isValidBuilder;
//# sourceMappingURL=builder.js.map

/***/ }),

/***/ 123:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



/*<replacement>*/

var Buffer = __webpack_require__(22).Buffer;
/*</replacement>*/

var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
      return true;
    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;
  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return; // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
};

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.StringDecoder = StringDecoder;
function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return byte >> 6 === 0x02 ? -1 : -2;
}

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\ufffd';
  }
  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\ufffd';
    }
    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\ufffd';
      }
    }
  }
}

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
}

// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\ufffd';
  return r;
}

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);
    if (r) {
      var c = r.charCodeAt(r.length - 1);
      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
}

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }
  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
}

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}

/***/ }),

/***/ 124:
/***/ (function(module, exports, __webpack_require__) {

var exports = module.exports = function SHA (algorithm) {
  algorithm = algorithm.toLowerCase()

  var Algorithm = exports[algorithm]
  if (!Algorithm) throw new Error(algorithm + ' is not supported (we accept pull requests)')

  return new Algorithm()
}

exports.sha = __webpack_require__(710)
exports.sha1 = __webpack_require__(711)
exports.sha224 = __webpack_require__(712)
exports.sha256 = __webpack_require__(412)
exports.sha384 = __webpack_require__(713)
exports.sha512 = __webpack_require__(413)


/***/ }),

/***/ 1275:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = (string, separator) => {
	if (!(typeof string === 'string' && typeof separator === 'string')) {
		throw new TypeError('Expected the arguments to be of type `string`');
	}

	if (separator === '') {
		return [string];
	}

	const separatorIndex = string.indexOf(separator);

	if (separatorIndex === -1) {
		return [string];
	}

	return [
		string.slice(0, separatorIndex),
		string.slice(separatorIndex + separator.length)
	];
};


/***/ }),

/***/ 14:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "a", function() { return /* binding */ alpha; });
__webpack_require__.d(__webpack_exports__, "b", function() { return /* binding */ color; });
__webpack_require__.d(__webpack_exports__, "c", function() { return /* binding */ complex; });
__webpack_require__.d(__webpack_exports__, "d", function() { return /* binding */ degrees; });
__webpack_require__.d(__webpack_exports__, "e", function() { return /* binding */ hex; });
__webpack_require__.d(__webpack_exports__, "f", function() { return /* binding */ hsla; });
__webpack_require__.d(__webpack_exports__, "g", function() { return /* binding */ number; });
__webpack_require__.d(__webpack_exports__, "h", function() { return /* binding */ percent; });
__webpack_require__.d(__webpack_exports__, "i", function() { return /* binding */ progressPercentage; });
__webpack_require__.d(__webpack_exports__, "j", function() { return /* binding */ px; });
__webpack_require__.d(__webpack_exports__, "k", function() { return /* binding */ rgba; });
__webpack_require__.d(__webpack_exports__, "l", function() { return /* binding */ scale; });
__webpack_require__.d(__webpack_exports__, "m", function() { return /* binding */ vh; });
__webpack_require__.d(__webpack_exports__, "n", function() { return /* binding */ vw; });

// UNUSED EXPORTS: rgbUnit

// CONCATENATED MODULE: /Volumes/GameDrive/code/a-mises/mises-wallet/node_modules/style-value-types/node_modules/tslib/tslib.es6.js
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    }
    return __assign.apply(this, arguments);
}

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
}

function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

function __createBinding(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}

function __exportStar(m, exports) {
    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) exports[p] = m[p];
}

function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
    return ar;
}

function __spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};

function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

function __asyncDelegator(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
}

function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
}

function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};

function __importStar(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result.default = mod;
    return result;
}

function __importDefault(mod) {
    return (mod && mod.__esModule) ? mod : { default: mod };
}

function __classPrivateFieldGet(receiver, privateMap) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
    }
    return privateMap.get(receiver);
}

function __classPrivateFieldSet(receiver, privateMap, value) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to set private field on non-instance");
    }
    privateMap.set(receiver, value);
    return value;
}

// CONCATENATED MODULE: /Volumes/GameDrive/code/a-mises/mises-wallet/node_modules/style-value-types/dist/style-value-types.es.js


var clamp = function (min, max) { return function (v) {
    return Math.max(Math.min(v, max), min);
}; };
var sanitize = function (v) { return (v % 1 ? Number(v.toFixed(5)) : v); };
var floatRegex = /(-)?(\d[\d\.]*)/g;
var colorRegex = /(#[0-9a-f]{6}|#[0-9a-f]{3}|#(?:[0-9a-f]{2}){2,4}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2,3}\s*\/*\s*[\d\.]+%?\))/gi;
var singleColorRegex = /^(#[0-9a-f]{3}|#(?:[0-9a-f]{2}){2,4}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2,3}\s*\/*\s*[\d\.]+%?\))$/i;

var number = {
    test: function (v) { return typeof v === 'number'; },
    parse: parseFloat,
    transform: function (v) { return v; }
};
var alpha = __assign(__assign({}, number), { transform: clamp(0, 1) });
var scale = __assign(__assign({}, number), { default: 1 });

var createUnitType = function (unit) { return ({
    test: function (v) {
        return typeof v === 'string' && v.endsWith(unit) && v.split(' ').length === 1;
    },
    parse: parseFloat,
    transform: function (v) { return "" + v + unit; }
}); };
var degrees = createUnitType('deg');
var percent = createUnitType('%');
var px = createUnitType('px');
var vh = createUnitType('vh');
var vw = createUnitType('vw');
var progressPercentage = __assign(__assign({}, percent), { parse: function (v) { return percent.parse(v) / 100; }, transform: function (v) { return percent.transform(v * 100); } });

var getValueFromFunctionString = function (value) {
    return value.substring(value.indexOf('(') + 1, value.lastIndexOf(')'));
};
var clampRgbUnit = clamp(0, 255);
var isRgba = function (v) { return v.red !== undefined; };
var isHsla = function (v) { return v.hue !== undefined; };
function getValuesAsArray(value) {
    return getValueFromFunctionString(value)
        .replace(/(,|\/)/g, ' ')
        .split(/ \s*/);
}
var splitColorValues = function (terms) {
    return function (v) {
        if (typeof v !== 'string')
            return v;
        var values = {};
        var valuesArray = getValuesAsArray(v);
        for (var i = 0; i < 4; i++) {
            values[terms[i]] =
                valuesArray[i] !== undefined ? parseFloat(valuesArray[i]) : 1;
        }
        return values;
    };
};
var rgbaTemplate = function (_a) {
    var red = _a.red, green = _a.green, blue = _a.blue, _b = _a.alpha, alpha = _b === void 0 ? 1 : _b;
    return "rgba(" + red + ", " + green + ", " + blue + ", " + alpha + ")";
};
var hslaTemplate = function (_a) {
    var hue = _a.hue, saturation = _a.saturation, lightness = _a.lightness, _b = _a.alpha, alpha = _b === void 0 ? 1 : _b;
    return "hsla(" + hue + ", " + saturation + ", " + lightness + ", " + alpha + ")";
};
var rgbUnit = __assign(__assign({}, number), { transform: function (v) { return Math.round(clampRgbUnit(v)); } });
function isColorString(color, colorType) {
    return color.startsWith(colorType) && singleColorRegex.test(color);
}
var rgba = {
    test: function (v) { return (typeof v === 'string' ? isColorString(v, 'rgb') : isRgba(v)); },
    parse: splitColorValues(['red', 'green', 'blue', 'alpha']),
    transform: function (_a) {
        var red = _a.red, green = _a.green, blue = _a.blue, _b = _a.alpha, alpha$1 = _b === void 0 ? 1 : _b;
        return rgbaTemplate({
            red: rgbUnit.transform(red),
            green: rgbUnit.transform(green),
            blue: rgbUnit.transform(blue),
            alpha: sanitize(alpha.transform(alpha$1))
        });
    }
};
var hsla = {
    test: function (v) { return (typeof v === 'string' ? isColorString(v, 'hsl') : isHsla(v)); },
    parse: splitColorValues(['hue', 'saturation', 'lightness', 'alpha']),
    transform: function (_a) {
        var hue = _a.hue, saturation = _a.saturation, lightness = _a.lightness, _b = _a.alpha, alpha$1 = _b === void 0 ? 1 : _b;
        return hslaTemplate({
            hue: Math.round(hue),
            saturation: percent.transform(sanitize(saturation)),
            lightness: percent.transform(sanitize(lightness)),
            alpha: sanitize(alpha.transform(alpha$1))
        });
    }
};
var hex = __assign(__assign({}, rgba), { test: function (v) { return typeof v === 'string' && isColorString(v, '#'); }, parse: function (v) {
        var r = '';
        var g = '';
        var b = '';
        if (v.length > 4) {
            r = v.substr(1, 2);
            g = v.substr(3, 2);
            b = v.substr(5, 2);
        }
        else {
            r = v.substr(1, 1);
            g = v.substr(2, 1);
            b = v.substr(3, 1);
            r += r;
            g += g;
            b += b;
        }
        return {
            red: parseInt(r, 16),
            green: parseInt(g, 16),
            blue: parseInt(b, 16),
            alpha: 1
        };
    } });
var color = {
    test: function (v) {
        return (typeof v === 'string' && singleColorRegex.test(v)) ||
            isRgba(v) ||
            isHsla(v);
    },
    parse: function (v) {
        if (rgba.test(v)) {
            return rgba.parse(v);
        }
        else if (hsla.test(v)) {
            return hsla.parse(v);
        }
        else if (hex.test(v)) {
            return hex.parse(v);
        }
        return v;
    },
    transform: function (v) {
        if (isRgba(v)) {
            return rgba.transform(v);
        }
        else if (isHsla(v)) {
            return hsla.transform(v);
        }
        return v;
    }
};

var COLOR_TOKEN = '${c}';
var NUMBER_TOKEN = '${n}';
var convertNumbersToZero = function (v) {
    return typeof v === 'number' ? 0 : v;
};
var complex = {
    test: function (v) {
        if (typeof v !== 'string' || !isNaN(v))
            return false;
        var numValues = 0;
        var foundNumbers = v.match(floatRegex);
        var foundColors = v.match(colorRegex);
        if (foundNumbers)
            numValues += foundNumbers.length;
        if (foundColors)
            numValues += foundColors.length;
        return numValues > 0;
    },
    parse: function (v) {
        var input = v;
        var parsed = [];
        var foundColors = input.match(colorRegex);
        if (foundColors) {
            input = input.replace(colorRegex, COLOR_TOKEN);
            parsed.push.apply(parsed, foundColors.map(color.parse));
        }
        var foundNumbers = input.match(floatRegex);
        if (foundNumbers) {
            parsed.push.apply(parsed, foundNumbers.map(number.parse));
        }
        return parsed;
    },
    createTransformer: function (prop) {
        var template = prop;
        var token = 0;
        var foundColors = prop.match(colorRegex);
        var numColors = foundColors ? foundColors.length : 0;
        if (foundColors) {
            for (var i = 0; i < numColors; i++) {
                template = template.replace(foundColors[i], COLOR_TOKEN);
                token++;
            }
        }
        var foundNumbers = template.match(floatRegex);
        var numNumbers = foundNumbers ? foundNumbers.length : 0;
        if (foundNumbers) {
            for (var i = 0; i < numNumbers; i++) {
                template = template.replace(foundNumbers[i], NUMBER_TOKEN);
                token++;
            }
        }
        return function (v) {
            var output = template;
            for (var i = 0; i < token; i++) {
                output = output.replace(i < numColors ? COLOR_TOKEN : NUMBER_TOKEN, i < numColors ? color.transform(v[i]) : sanitize(v[i]));
            }
            return output;
        };
    },
    getAnimatableNone: function (target) {
        var parsedTarget = complex.parse(target);
        var targetTransformer = complex.createTransformer(target);
        return targetTransformer(parsedTarget.map(convertNumbersToZero));
    }
};




/***/ }),

/***/ 144:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Buffer = __webpack_require__(4).Buffer
var inherits = __webpack_require__(18)
var HashBase = __webpack_require__(405)

var ARRAY16 = new Array(16)

var zl = [
  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
  7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
  3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,
  1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,
  4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13
]

var zr = [
  5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,
  6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,
  15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,
  8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,
  12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
]

var sl = [
  11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,
  7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,
  11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,
  11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,
  9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6
]

var sr = [
  8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,
  9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,
  9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,
  15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,
  8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11
]

var hl = [0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e]
var hr = [0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000]

function RIPEMD160 () {
  HashBase.call(this, 64)

  // state
  this._a = 0x67452301
  this._b = 0xefcdab89
  this._c = 0x98badcfe
  this._d = 0x10325476
  this._e = 0xc3d2e1f0
}

inherits(RIPEMD160, HashBase)

RIPEMD160.prototype._update = function () {
  var words = ARRAY16
  for (var j = 0; j < 16; ++j) words[j] = this._block.readInt32LE(j * 4)

  var al = this._a | 0
  var bl = this._b | 0
  var cl = this._c | 0
  var dl = this._d | 0
  var el = this._e | 0

  var ar = this._a | 0
  var br = this._b | 0
  var cr = this._c | 0
  var dr = this._d | 0
  var er = this._e | 0

  // computation
  for (var i = 0; i < 80; i += 1) {
    var tl
    var tr
    if (i < 16) {
      tl = fn1(al, bl, cl, dl, el, words[zl[i]], hl[0], sl[i])
      tr = fn5(ar, br, cr, dr, er, words[zr[i]], hr[0], sr[i])
    } else if (i < 32) {
      tl = fn2(al, bl, cl, dl, el, words[zl[i]], hl[1], sl[i])
      tr = fn4(ar, br, cr, dr, er, words[zr[i]], hr[1], sr[i])
    } else if (i < 48) {
      tl = fn3(al, bl, cl, dl, el, words[zl[i]], hl[2], sl[i])
      tr = fn3(ar, br, cr, dr, er, words[zr[i]], hr[2], sr[i])
    } else if (i < 64) {
      tl = fn4(al, bl, cl, dl, el, words[zl[i]], hl[3], sl[i])
      tr = fn2(ar, br, cr, dr, er, words[zr[i]], hr[3], sr[i])
    } else { // if (i<80) {
      tl = fn5(al, bl, cl, dl, el, words[zl[i]], hl[4], sl[i])
      tr = fn1(ar, br, cr, dr, er, words[zr[i]], hr[4], sr[i])
    }

    al = el
    el = dl
    dl = rotl(cl, 10)
    cl = bl
    bl = tl

    ar = er
    er = dr
    dr = rotl(cr, 10)
    cr = br
    br = tr
  }

  // update state
  var t = (this._b + cl + dr) | 0
  this._b = (this._c + dl + er) | 0
  this._c = (this._d + el + ar) | 0
  this._d = (this._e + al + br) | 0
  this._e = (this._a + bl + cr) | 0
  this._a = t
}

RIPEMD160.prototype._digest = function () {
  // create padding and handle blocks
  this._block[this._blockOffset++] = 0x80
  if (this._blockOffset > 56) {
    this._block.fill(0, this._blockOffset, 64)
    this._update()
    this._blockOffset = 0
  }

  this._block.fill(0, this._blockOffset, 56)
  this._block.writeUInt32LE(this._length[0], 56)
  this._block.writeUInt32LE(this._length[1], 60)
  this._update()

  // produce result
  var buffer = Buffer.alloc ? Buffer.alloc(20) : new Buffer(20)
  buffer.writeInt32LE(this._a, 0)
  buffer.writeInt32LE(this._b, 4)
  buffer.writeInt32LE(this._c, 8)
  buffer.writeInt32LE(this._d, 12)
  buffer.writeInt32LE(this._e, 16)
  return buffer
}

function rotl (x, n) {
  return (x << n) | (x >>> (32 - n))
}

function fn1 (a, b, c, d, e, m, k, s) {
  return (rotl((a + (b ^ c ^ d) + m + k) | 0, s) + e) | 0
}

function fn2 (a, b, c, d, e, m, k, s) {
  return (rotl((a + ((b & c) | ((~b) & d)) + m + k) | 0, s) + e) | 0
}

function fn3 (a, b, c, d, e, m, k, s) {
  return (rotl((a + ((b | (~c)) ^ d) + m + k) | 0, s) + e) | 0
}

function fn4 (a, b, c, d, e, m, k, s) {
  return (rotl((a + ((b & d) | (c & (~d))) + m + k) | 0, s) + e) | 0
}

function fn5 (a, b, c, d, e, m, k, s) {
  return (rotl((a + (b ^ (c | (~d))) + m + k) | 0, s) + e) | 0
}

module.exports = RIPEMD160


/***/ }),

/***/ 145:
/***/ (function(module, exports, __webpack_require__) {

var Buffer = __webpack_require__(22).Buffer

// prototype class for hash functions
function Hash (blockSize, finalSize) {
  this._block = Buffer.alloc(blockSize)
  this._finalSize = finalSize
  this._blockSize = blockSize
  this._len = 0
}

Hash.prototype.update = function (data, enc) {
  if (typeof data === 'string') {
    enc = enc || 'utf8'
    data = Buffer.from(data, enc)
  }

  var block = this._block
  var blockSize = this._blockSize
  var length = data.length
  var accum = this._len

  for (var offset = 0; offset < length;) {
    var assigned = accum % blockSize
    var remainder = Math.min(length - offset, blockSize - assigned)

    for (var i = 0; i < remainder; i++) {
      block[assigned + i] = data[offset + i]
    }

    accum += remainder
    offset += remainder

    if ((accum % blockSize) === 0) {
      this._update(block)
    }
  }

  this._len += length
  return this
}

Hash.prototype.digest = function (enc) {
  var rem = this._len % this._blockSize

  this._block[rem] = 0x80

  // zero (rem + 1) trailing bits, where (rem + 1) is the smallest
  // non-negative solution to the equation (length + 1 + (rem + 1)) === finalSize mod blockSize
  this._block.fill(0, rem + 1)

  if (rem >= this._finalSize) {
    this._update(this._block)
    this._block.fill(0)
  }

  var bits = this._len * 8

  // uint32
  if (bits <= 0xffffffff) {
    this._block.writeUInt32BE(bits, this._blockSize - 4)

  // uint64
  } else {
    var lowBits = (bits & 0xffffffff) >>> 0
    var highBits = (bits - lowBits) / 0x100000000

    this._block.writeUInt32BE(highBits, this._blockSize - 8)
    this._block.writeUInt32BE(lowBits, this._blockSize - 4)
  }

  this._update(this._block)
  var hash = this._hash()

  return enc ? hash.toString(enc) : hash
}

Hash.prototype._update = function () {
  throw new Error('_update must be implemented by subclass')
}

module.exports = Hash


/***/ }),

/***/ 1503:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function (str) {
	return encodeURIComponent(str).replace(/[!'()*]/g, function (c) {
		return '%' + c.charCodeAt(0).toString(16).toUpperCase();
	});
};


/***/ }),

/***/ 156:
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var ClientRequest = __webpack_require__(1069)
var response = __webpack_require__(549)
var extend = __webpack_require__(1071)
var statusCodes = __webpack_require__(1072)
var url = __webpack_require__(154)

var http = exports

http.request = function (opts, cb) {
	if (typeof opts === 'string')
		opts = url.parse(opts)
	else
		opts = extend(opts)

	// Normally, the page is loaded from http or https, so not specifying a protocol
	// will result in a (valid) protocol-relative url. However, this won't work if
	// the protocol is something else, like 'file:'
	var defaultProtocol = global.location.protocol.search(/^https?:$/) === -1 ? 'http:' : ''

	var protocol = opts.protocol || defaultProtocol
	var host = opts.hostname || opts.host
	var port = opts.port
	var path = opts.path || '/'

	// Necessary for IPv6 addresses
	if (host && host.indexOf(':') !== -1)
		host = '[' + host + ']'

	// This may be a relative url. The browser should always be able to interpret it correctly.
	opts.url = (host ? (protocol + '//' + host) : '') + (port ? ':' + port : '') + path
	opts.method = (opts.method || 'GET').toUpperCase()
	opts.headers = opts.headers || {}

	// Also valid opts.auth, opts.mode

	var req = new ClientRequest(opts)
	if (cb)
		req.on('response', cb)
	return req
}

http.get = function get (opts, cb) {
	var req = http.request(opts, cb)
	req.end()
	return req
}

http.ClientRequest = ClientRequest
http.IncomingMessage = response.IncomingMessage

http.Agent = function () {}
http.Agent.defaultMaxSockets = 4

http.globalAgent = new http.Agent()

http.STATUS_CODES = statusCodes

http.METHODS = [
	'CHECKOUT',
	'CONNECT',
	'COPY',
	'DELETE',
	'GET',
	'HEAD',
	'LOCK',
	'M-SEARCH',
	'MERGE',
	'MKACTIVITY',
	'MKCOL',
	'MOVE',
	'NOTIFY',
	'OPTIONS',
	'PATCH',
	'POST',
	'PROPFIND',
	'PROPPATCH',
	'PURGE',
	'PUT',
	'REPORT',
	'SEARCH',
	'SUBSCRIBE',
	'TRACE',
	'UNLOCK',
	'UNSUBSCRIBE'
]
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(11)))

/***/ }),

/***/ 158:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var isProduction = "production" === 'production';
var prefix = 'Invariant failed';
function invariant(condition, message) {
    if (condition) {
        return;
    }
    if (isProduction) {
        throw new Error(prefix);
    }
    throw new Error(prefix + ": " + (message || ''));
}

/* harmony default export */ __webpack_exports__["a"] = (invariant);


/***/ }),

/***/ 1625:
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {/**
 * Convert a typed array to a Buffer without a copy
 *
 * Author:   Feross Aboukhadijeh <https://feross.org>
 * License:  MIT
 *
 * `npm install typedarray-to-buffer`
 */

var isTypedArray = __webpack_require__(1280).strict

module.exports = function typedarrayToBuffer (arr) {
  if (isTypedArray(arr)) {
    // To avoid a copy, use the typed array's underlying ArrayBuffer to back new Buffer
    var buf = Buffer.from(arr.buffer)
    if (arr.byteLength !== arr.buffer.byteLength) {
      // Respect the "view", i.e. byteOffset and byteLength, without doing a copy
      buf = buf.slice(arr.byteOffset, arr.byteOffset + arr.byteLength)
    }
    return buf
  } else {
    // Pass through all other types to `Buffer.from`
    return Buffer.from(arr)
  }
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(4).Buffer))

/***/ }),

/***/ 183:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const encoding_1 = __webpack_require__(86);
const { fromBase64, fromHex } = encoding_1.Encoding;
function isStdTx(txValue) {
    const { memo, msg, fee, signatures } = txValue;
    return (typeof memo === "string" && Array.isArray(msg) && typeof fee === "object" && Array.isArray(signatures));
}
exports.isStdTx = isStdTx;
function isMsgSend(msg) {
    return msg.type === "cosmos-sdk/MsgSend";
}
exports.isMsgSend = isMsgSend;
function isMsgStoreCode(msg) {
    return msg.type === "wasm/MsgStoreCode";
}
exports.isMsgStoreCode = isMsgStoreCode;
function isMsgInstantiateContract(msg) {
    return msg.type === "wasm/MsgInstantiateContract";
}
exports.isMsgInstantiateContract = isMsgInstantiateContract;
function isMsgExecuteContract(msg) {
    return msg.type === "wasm/MsgExecuteContract";
}
exports.isMsgExecuteContract = isMsgExecuteContract;
function extractContractMsg(msg) {
    if (msg.type === "wasm/MsgExecuteContract") {
        return encoding_1.Encoding.fromBase64(msg.value.msg);
    } /*  if (msg.type === "wasm/MsgInstantiateContract")  */
    else {
        return encoding_1.Encoding.fromBase64(msg.value.init_msg);
    }
}
exports.extractContractMsg = extractContractMsg;
exports.pubkeyType = {
    /** @see https://github.com/tendermint/tendermint/blob/v0.33.0/crypto/ed25519/ed25519.go#L22 */
    secp256k1: "tendermint/PubKeySecp256k1",
    /** @see https://github.com/tendermint/tendermint/blob/v0.33.0/crypto/secp256k1/secp256k1.go#L23 */
    ed25519: "tendermint/PubKeyEd25519",
    /** @see https://github.com/tendermint/tendermint/blob/v0.33.0/crypto/sr25519/codec.go#L12 */
    sr25519: "tendermint/PubKeySr25519",
};
exports.pubkeyTypes = [exports.pubkeyType.secp256k1, exports.pubkeyType.ed25519, exports.pubkeyType.sr25519];
function parseWasmData({ key, val }) {
    return {
        key: fromHex(key),
        val: fromBase64(val),
    };
}
exports.parseWasmData = parseWasmData;
//# sourceMappingURL=types.js.map

/***/ }),

/***/ 203:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(setImmediate) {

(function(root) {
    const MAX_VALUE = 0x7fffffff;

    // The SHA256 and PBKDF2 implementation are from scrypt-async-js:
    // See: https://github.com/dchest/scrypt-async-js
    function SHA256(m) {
        const K = new Uint32Array([
           0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b,
           0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01,
           0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7,
           0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
           0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152,
           0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147,
           0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc,
           0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
           0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819,
           0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08,
           0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f,
           0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
           0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
       ]);

        let h0 = 0x6a09e667, h1 = 0xbb67ae85, h2 = 0x3c6ef372, h3 = 0xa54ff53a;
        let h4 = 0x510e527f, h5 = 0x9b05688c, h6 = 0x1f83d9ab, h7 = 0x5be0cd19;
        const w = new Uint32Array(64);

        function blocks(p) {
            let off = 0, len = p.length;
            while (len >= 64) {
                let a = h0, b = h1, c = h2, d = h3, e = h4, f = h5, g = h6, h = h7, u, i, j, t1, t2;

                for (i = 0; i < 16; i++) {
                    j = off + i*4;
                    w[i] = ((p[j] & 0xff)<<24) | ((p[j+1] & 0xff)<<16) |
                    ((p[j+2] & 0xff)<<8) | (p[j+3] & 0xff);
                }

                for (i = 16; i < 64; i++) {
                    u = w[i-2];
                    t1 = ((u>>>17) | (u<<(32-17))) ^ ((u>>>19) | (u<<(32-19))) ^ (u>>>10);

                    u = w[i-15];
                    t2 = ((u>>>7) | (u<<(32-7))) ^ ((u>>>18) | (u<<(32-18))) ^ (u>>>3);

                    w[i] = (((t1 + w[i-7]) | 0) + ((t2 + w[i-16]) | 0)) | 0;
                }

                for (i = 0; i < 64; i++) {
                    t1 = ((((((e>>>6) | (e<<(32-6))) ^ ((e>>>11) | (e<<(32-11))) ^
                             ((e>>>25) | (e<<(32-25)))) + ((e & f) ^ (~e & g))) | 0) +
                          ((h + ((K[i] + w[i]) | 0)) | 0)) | 0;

                    t2 = ((((a>>>2) | (a<<(32-2))) ^ ((a>>>13) | (a<<(32-13))) ^
                           ((a>>>22) | (a<<(32-22)))) + ((a & b) ^ (a & c) ^ (b & c))) | 0;

                    h = g;
                    g = f;
                    f = e;
                    e = (d + t1) | 0;
                    d = c;
                    c = b;
                    b = a;
                    a = (t1 + t2) | 0;
                }

                h0 = (h0 + a) | 0;
                h1 = (h1 + b) | 0;
                h2 = (h2 + c) | 0;
                h3 = (h3 + d) | 0;
                h4 = (h4 + e) | 0;
                h5 = (h5 + f) | 0;
                h6 = (h6 + g) | 0;
                h7 = (h7 + h) | 0;

                off += 64;
                len -= 64;
            }
        }

        blocks(m);

        let i, bytesLeft = m.length % 64,
        bitLenHi = (m.length / 0x20000000) | 0,
        bitLenLo = m.length << 3,
        numZeros = (bytesLeft < 56) ? 56 : 120,
        p = m.slice(m.length - bytesLeft, m.length);

        p.push(0x80);
        for (i = bytesLeft + 1; i < numZeros; i++) { p.push(0); }
        p.push((bitLenHi >>> 24) & 0xff);
        p.push((bitLenHi >>> 16) & 0xff);
        p.push((bitLenHi >>> 8)  & 0xff);
        p.push((bitLenHi >>> 0)  & 0xff);
        p.push((bitLenLo >>> 24) & 0xff);
        p.push((bitLenLo >>> 16) & 0xff);
        p.push((bitLenLo >>> 8)  & 0xff);
        p.push((bitLenLo >>> 0)  & 0xff);

        blocks(p);

        return [
            (h0 >>> 24) & 0xff, (h0 >>> 16) & 0xff, (h0 >>> 8) & 0xff, (h0 >>> 0) & 0xff,
            (h1 >>> 24) & 0xff, (h1 >>> 16) & 0xff, (h1 >>> 8) & 0xff, (h1 >>> 0) & 0xff,
            (h2 >>> 24) & 0xff, (h2 >>> 16) & 0xff, (h2 >>> 8) & 0xff, (h2 >>> 0) & 0xff,
            (h3 >>> 24) & 0xff, (h3 >>> 16) & 0xff, (h3 >>> 8) & 0xff, (h3 >>> 0) & 0xff,
            (h4 >>> 24) & 0xff, (h4 >>> 16) & 0xff, (h4 >>> 8) & 0xff, (h4 >>> 0) & 0xff,
            (h5 >>> 24) & 0xff, (h5 >>> 16) & 0xff, (h5 >>> 8) & 0xff, (h5 >>> 0) & 0xff,
            (h6 >>> 24) & 0xff, (h6 >>> 16) & 0xff, (h6 >>> 8) & 0xff, (h6 >>> 0) & 0xff,
            (h7 >>> 24) & 0xff, (h7 >>> 16) & 0xff, (h7 >>> 8) & 0xff, (h7 >>> 0) & 0xff
        ];
    }

    function PBKDF2_HMAC_SHA256_OneIter(password, salt, dkLen) {
        // compress password if it's longer than hash block length
        password = (password.length <= 64) ? password : SHA256(password);

        const innerLen = 64 + salt.length + 4;
        const inner = new Array(innerLen);
        const outerKey = new Array(64);

        let i;
        let dk = [];

        // inner = (password ^ ipad) || salt || counter
        for (i = 0; i < 64; i++) { inner[i] = 0x36; }
        for (i = 0; i < password.length; i++) { inner[i] ^= password[i]; }
        for (i = 0; i < salt.length; i++) { inner[64 + i] = salt[i]; }
        for (i = innerLen - 4; i < innerLen; i++) { inner[i] = 0; }

        // outerKey = password ^ opad
        for (i = 0; i < 64; i++) outerKey[i] = 0x5c;
        for (i = 0; i < password.length; i++) outerKey[i] ^= password[i];

        // increments counter inside inner
        function incrementCounter() {
            for (let i = innerLen - 1; i >= innerLen - 4; i--) {
                inner[i]++;
                if (inner[i] <= 0xff) return;
                inner[i] = 0;
            }
        }

        // output blocks = SHA256(outerKey || SHA256(inner)) ...
        while (dkLen >= 32) {
            incrementCounter();
            dk = dk.concat(SHA256(outerKey.concat(SHA256(inner))));
            dkLen -= 32;
        }
        if (dkLen > 0) {
            incrementCounter();
            dk = dk.concat(SHA256(outerKey.concat(SHA256(inner))).slice(0, dkLen));
        }

        return dk;
    }

    // The following is an adaptation of scryptsy
    // See: https://www.npmjs.com/package/scryptsy
    function blockmix_salsa8(BY, Yi, r, x, _X) {
        let i;

        arraycopy(BY, (2 * r - 1) * 16, _X, 0, 16);
        for (i = 0; i < 2 * r; i++) {
            blockxor(BY, i * 16, _X, 16);
            salsa20_8(_X, x);
            arraycopy(_X, 0, BY, Yi + (i * 16), 16);
        }

        for (i = 0; i < r; i++) {
            arraycopy(BY, Yi + (i * 2) * 16, BY, (i * 16), 16);
        }

        for (i = 0; i < r; i++) {
            arraycopy(BY, Yi + (i * 2 + 1) * 16, BY, (i + r) * 16, 16);
        }
    }

    function R(a, b) {
        return (a << b) | (a >>> (32 - b));
    }

    function salsa20_8(B, x) {
        arraycopy(B, 0, x, 0, 16);

        for (let i = 8; i > 0; i -= 2) {
            x[ 4] ^= R(x[ 0] + x[12], 7);
            x[ 8] ^= R(x[ 4] + x[ 0], 9);
            x[12] ^= R(x[ 8] + x[ 4], 13);
            x[ 0] ^= R(x[12] + x[ 8], 18);
            x[ 9] ^= R(x[ 5] + x[ 1], 7);
            x[13] ^= R(x[ 9] + x[ 5], 9);
            x[ 1] ^= R(x[13] + x[ 9], 13);
            x[ 5] ^= R(x[ 1] + x[13], 18);
            x[14] ^= R(x[10] + x[ 6], 7);
            x[ 2] ^= R(x[14] + x[10], 9);
            x[ 6] ^= R(x[ 2] + x[14], 13);
            x[10] ^= R(x[ 6] + x[ 2], 18);
            x[ 3] ^= R(x[15] + x[11], 7);
            x[ 7] ^= R(x[ 3] + x[15], 9);
            x[11] ^= R(x[ 7] + x[ 3], 13);
            x[15] ^= R(x[11] + x[ 7], 18);
            x[ 1] ^= R(x[ 0] + x[ 3], 7);
            x[ 2] ^= R(x[ 1] + x[ 0], 9);
            x[ 3] ^= R(x[ 2] + x[ 1], 13);
            x[ 0] ^= R(x[ 3] + x[ 2], 18);
            x[ 6] ^= R(x[ 5] + x[ 4], 7);
            x[ 7] ^= R(x[ 6] + x[ 5], 9);
            x[ 4] ^= R(x[ 7] + x[ 6], 13);
            x[ 5] ^= R(x[ 4] + x[ 7], 18);
            x[11] ^= R(x[10] + x[ 9], 7);
            x[ 8] ^= R(x[11] + x[10], 9);
            x[ 9] ^= R(x[ 8] + x[11], 13);
            x[10] ^= R(x[ 9] + x[ 8], 18);
            x[12] ^= R(x[15] + x[14], 7);
            x[13] ^= R(x[12] + x[15], 9);
            x[14] ^= R(x[13] + x[12], 13);
            x[15] ^= R(x[14] + x[13], 18);
        }

        for (let i = 0; i < 16; ++i) {
            B[i] += x[i];
        }
    }

    // naive approach... going back to loop unrolling may yield additional performance
    function blockxor(S, Si, D, len) {
        for (let i = 0; i < len; i++) {
            D[i] ^= S[Si + i]
        }
    }

    function arraycopy(src, srcPos, dest, destPos, length) {
        while (length--) {
            dest[destPos++] = src[srcPos++];
        }
    }

    function checkBufferish(o) {
        if (!o || typeof(o.length) !== 'number') { return false; }

        for (let i = 0; i < o.length; i++) {
            const v = o[i];
            if (typeof(v) !== 'number' || v % 1 || v < 0 || v >= 256) {
                return false;
            }
        }

        return true;
    }

    function ensureInteger(value, name) {
        if (typeof(value) !== "number" || (value % 1)) { throw new Error('invalid ' + name); }
        return value;
    }

    // N = Cpu cost, r = Memory cost, p = parallelization cost
    // callback(error, progress, key)
    function _scrypt(password, salt, N, r, p, dkLen, callback) {

        N = ensureInteger(N, 'N');
        r = ensureInteger(r, 'r');
        p = ensureInteger(p, 'p');

        dkLen = ensureInteger(dkLen, 'dkLen');

        if (N === 0 || (N & (N - 1)) !== 0) { throw new Error('N must be power of 2'); }

        if (N > MAX_VALUE / 128 / r) { throw new Error('N too large'); }
        if (r > MAX_VALUE / 128 / p) { throw new Error('r too large'); }

        if (!checkBufferish(password)) {
            throw new Error('password must be an array or buffer');
        }
        password = Array.prototype.slice.call(password);

        if (!checkBufferish(salt)) {
            throw new Error('salt must be an array or buffer');
        }
        salt = Array.prototype.slice.call(salt);

        let b = PBKDF2_HMAC_SHA256_OneIter(password, salt, p * 128 * r);
        const B = new Uint32Array(p * 32 * r)
        for (let i = 0; i < B.length; i++) {
            const j = i * 4;
            B[i] = ((b[j + 3] & 0xff) << 24) |
                   ((b[j + 2] & 0xff) << 16) |
                   ((b[j + 1] & 0xff) << 8) |
                   ((b[j + 0] & 0xff) << 0);
        }

        const XY = new Uint32Array(64 * r);
        const V = new Uint32Array(32 * r * N);

        const Yi = 32 * r;

        // scratch space
        const x = new Uint32Array(16);       // salsa20_8
        const _X = new Uint32Array(16);      // blockmix_salsa8

        const totalOps = p * N * 2;
        let currentOp = 0;
        let lastPercent10 = null;

        // Set this to true to abandon the scrypt on the next step
        let stop = false;

        // State information
        let state = 0;
        let i0 = 0, i1;
        let Bi;

        // How many blockmix_salsa8 can we do per step?
        const limit = callback ? parseInt(1000 / r): 0xffffffff;

        // Trick from scrypt-async; if there is a setImmediate shim in place, use it
        const nextTick = (typeof(setImmediate) !== 'undefined') ? setImmediate : setTimeout;

        // This is really all I changed; making scryptsy a state machine so we occasionally
        // stop and give other evnts on the evnt loop a chance to run. ~RicMoo
        const incrementalSMix = function() {
            if (stop) {
                return callback(new Error('cancelled'), currentOp / totalOps);
            }

            let steps;

            switch (state) {
                case 0:
                    // for (var i = 0; i < p; i++)...
                    Bi = i0 * 32 * r;

                    arraycopy(B, Bi, XY, 0, Yi);                       // ROMix - 1

                    state = 1;                                         // Move to ROMix 2
                    i1 = 0;

                    // Fall through

                case 1:

                    // Run up to 1000 steps of the first inner smix loop
                    steps = N - i1;
                    if (steps > limit) { steps = limit; }
                    for (let i = 0; i < steps; i++) {                  // ROMix - 2
                        arraycopy(XY, 0, V, (i1 + i) * Yi, Yi)         // ROMix - 3
                        blockmix_salsa8(XY, Yi, r, x, _X);             // ROMix - 4
                    }

                    // for (var i = 0; i < N; i++)
                    i1 += steps;
                    currentOp += steps;

                    if (callback) {
                        // Call the callback with the progress (optionally stopping us)
                        const percent10 = parseInt(1000 * currentOp / totalOps);
                        if (percent10 !== lastPercent10) {
                            stop = callback(null, currentOp / totalOps);
                            if (stop) { break; }
                            lastPercent10 = percent10;
                        }
                    }

                    if (i1 < N) { break; }

                    i1 = 0;                                          // Move to ROMix 6
                    state = 2;

                    // Fall through

                case 2:

                    // Run up to 1000 steps of the second inner smix loop
                    steps = N - i1;
                    if (steps > limit) { steps = limit; }
                    for (let i = 0; i < steps; i++) {                // ROMix - 6
                        const offset = (2 * r - 1) * 16;             // ROMix - 7
                        const j = XY[offset] & (N - 1);
                        blockxor(V, j * Yi, XY, Yi);                 // ROMix - 8 (inner)
                        blockmix_salsa8(XY, Yi, r, x, _X);           // ROMix - 9 (outer)
                    }

                    // for (var i = 0; i < N; i++)...
                    i1 += steps;
                    currentOp += steps;

                    // Call the callback with the progress (optionally stopping us)
                    if (callback) {
                        const percent10 = parseInt(1000 * currentOp / totalOps);
                        if (percent10 !== lastPercent10) {
                            stop = callback(null, currentOp / totalOps);
                            if (stop) { break; }
                            lastPercent10 = percent10;
                        }
                    }

                    if (i1 < N) { break; }

                    arraycopy(XY, 0, B, Bi, Yi);                     // ROMix - 10

                    // for (var i = 0; i < p; i++)...
                    i0++;
                    if (i0 < p) {
                        state = 0;
                        break;
                    }

                    b = [];
                    for (let i = 0; i < B.length; i++) {
                        b.push((B[i] >>  0) & 0xff);
                        b.push((B[i] >>  8) & 0xff);
                        b.push((B[i] >> 16) & 0xff);
                        b.push((B[i] >> 24) & 0xff);
                    }

                    const derivedKey = PBKDF2_HMAC_SHA256_OneIter(password, b, dkLen);

                    // Send the result to the callback
                    if (callback) { callback(null, 1.0, derivedKey); }

                    // Done; don't break (which would reschedule)
                    return derivedKey;
            }

            // Schedule the next steps
            if (callback) { nextTick(incrementalSMix); }
        }

        // Run the smix state machine until completion
        if (!callback) {
            while (true) {
                const derivedKey = incrementalSMix();
                if (derivedKey != undefined) { return derivedKey; }
            }
        }

        // Bootstrap the async incremental smix
        incrementalSMix();
    }

    const lib = {
        scrypt: function(password, salt, N, r, p, dkLen, progressCallback) {
            return new Promise(function(resolve, reject) {
                let lastProgress = 0;
                if (progressCallback) { progressCallback(0); }
                _scrypt(password, salt, N, r, p, dkLen, function(error, progress, key) {
                    if (error) {
                        reject(error);
                    } else if (key) {
                        if (progressCallback && lastProgress !== 1) {
                            progressCallback(1);
                        }
                        resolve(new Uint8Array(key));
                    } else if (progressCallback && progress !== lastProgress) {
                        lastProgress = progress;
                        return progressCallback(progress);
                    }
                });
            });
        },
        syncScrypt: function(password, salt, N, r, p, dkLen) {
            return new Uint8Array(_scrypt(password, salt, N, r, p, dkLen));
        }
    };

    // node.js
    if (true) {
       module.exports = lib;

    // RequireJS/AMD
    // http://www.requirejs.org/docs/api.html
    // https://github.com/amdjs/amdjs-api/wiki/AMD
    } else {}

})(this);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(417).setImmediate))

/***/ }),

/***/ 206:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "a", function() { return /* binding */ buildSVGAttrs; });
__webpack_require__.d(__webpack_exports__, "b", function() { return /* binding */ buildStyleProperty; });
__webpack_require__.d(__webpack_exports__, "c", function() { return /* binding */ createStyler; });
__webpack_require__.d(__webpack_exports__, "e", function() { return /* binding */ isTransformProp; });
__webpack_require__.d(__webpack_exports__, "f", function() { return /* binding */ transformProps; });

// CONCATENATED MODULE: /Volumes/GameDrive/code/a-mises/mises-wallet/node_modules/stylefire/node_modules/tslib/tslib.es6.js
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    }
    return __assign.apply(this, arguments);
}

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
}

function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

function __createBinding(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}

function __exportStar(m, exports) {
    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) exports[p] = m[p];
}

function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
    return ar;
}

function __spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};

function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

function __asyncDelegator(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
}

function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
}

function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};

function __importStar(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result.default = mod;
    return result;
}

function __importDefault(mod) {
    return (mod && mod.__esModule) ? mod : { default: mod };
}

function __classPrivateFieldGet(receiver, privateMap) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
    }
    return privateMap.get(receiver);
}

function __classPrivateFieldSet(receiver, privateMap, value) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to set private field on non-instance");
    }
    privateMap.set(receiver, value);
    return value;
}

// EXTERNAL MODULE: /Volumes/GameDrive/code/a-mises/mises-wallet/node_modules/framesync/dist/framesync.es.js
var framesync_es = __webpack_require__(48);

// EXTERNAL MODULE: /Volumes/GameDrive/code/a-mises/mises-wallet/node_modules/style-value-types/dist/style-value-types.es.js + 1 modules
var style_value_types_es = __webpack_require__(14);

// EXTERNAL MODULE: /Volumes/GameDrive/code/a-mises/mises-wallet/node_modules/hey-listen/dist/hey-listen.es.js
var hey_listen_es = __webpack_require__(69);

// CONCATENATED MODULE: /Volumes/GameDrive/code/a-mises/mises-wallet/node_modules/stylefire/dist/stylefire.es.js





var createStyler = function (_a) {
    var onRead = _a.onRead,
        onRender = _a.onRender,
        _b = _a.uncachedValues,
        uncachedValues = _b === void 0 ? new Set() : _b,
        _c = _a.useCache,
        useCache = _c === void 0 ? true : _c;
    return function (_a) {
        if (_a === void 0) {
            _a = {};
        }
        var props = __rest(_a, []);
        var state = {};
        var changedValues = [];
        var hasChanged = false;
        function setValue(key, value) {
            if (key.startsWith('--')) {
                props.hasCSSVariable = true;
            }
            var currentValue = state[key];
            state[key] = value;
            if (state[key] === currentValue) return;
            if (changedValues.indexOf(key) === -1) {
                changedValues.push(key);
            }
            if (!hasChanged) {
                hasChanged = true;
                framesync_es["b" /* default */].render(styler.render);
            }
        }
        var styler = {
            get: function (key, forceRead) {
                if (forceRead === void 0) {
                    forceRead = false;
                }
                var useCached = !forceRead && useCache && !uncachedValues.has(key) && state[key] !== undefined;
                return useCached ? state[key] : onRead(key, props);
            },
            set: function (values, value) {
                if (typeof values === 'string') {
                    setValue(values, value);
                } else {
                    for (var key in values) {
                        setValue(key, values[key]);
                    }
                }
                return this;
            },
            render: function (forceRender) {
                if (forceRender === void 0) {
                    forceRender = false;
                }
                if (hasChanged || forceRender === true) {
                    onRender(state, props, changedValues);
                    hasChanged = false;
                    changedValues.length = 0;
                }
                return this;
            }
        };
        return styler;
    };
};

var CAMEL_CASE_PATTERN = /([a-z])([A-Z])/g;
var REPLACE_TEMPLATE = '$1-$2';
var camelToDash = function (str) {
    return str.replace(CAMEL_CASE_PATTERN, REPLACE_TEMPLATE).toLowerCase();
};

var camelCache = /*#__PURE__*/new Map();
var dashCache = /*#__PURE__*/new Map();
var prefixes = ['Webkit', 'Moz', 'O', 'ms', ''];
var numPrefixes = prefixes.length;
var isBrowser = typeof document !== 'undefined';
var testElement;
var setDashPrefix = function (key, prefixed) {
    return dashCache.set(key, camelToDash(prefixed));
};
var testPrefix = function (key) {
    testElement = testElement || document.createElement('div');
    for (var i = 0; i < numPrefixes; i++) {
        var prefix = prefixes[i];
        var noPrefix = prefix === '';
        var prefixedPropertyName = noPrefix ? key : prefix + key.charAt(0).toUpperCase() + key.slice(1);
        if (prefixedPropertyName in testElement.style || noPrefix) {
            if (noPrefix && key === 'clipPath' && dashCache.has(key)) {
                return;
            }
            camelCache.set(key, prefixedPropertyName);
            setDashPrefix(key, "" + (noPrefix ? '' : '-') + camelToDash(prefixedPropertyName));
        }
    }
};
var setServerProperty = function (key) {
    return setDashPrefix(key, key);
};
var prefixer = function (key, asDashCase) {
    if (asDashCase === void 0) {
        asDashCase = false;
    }
    var cache = asDashCase ? dashCache : camelCache;
    if (!cache.has(key)) {
        isBrowser ? testPrefix(key) : setServerProperty(key);
    }
    return cache.get(key) || key;
};

var axes = ['', 'X', 'Y', 'Z'];
var order = ['translate', 'scale', 'rotate', 'skew', 'transformPerspective'];
var transformProps = /*#__PURE__*/order.reduce(function (acc, key) {
    return axes.reduce(function (axesAcc, axesKey) {
        axesAcc.push(key + axesKey);
        return axesAcc;
    }, acc);
}, ['x', 'y', 'z']);
var transformPropDictionary = /*#__PURE__*/transformProps.reduce(function (dict, key) {
    dict[key] = true;
    return dict;
}, {});
function isTransformProp(key) {
    return transformPropDictionary[key] === true;
}
function sortTransformProps(a, b) {
    return transformProps.indexOf(a) - transformProps.indexOf(b);
}
var transformOriginProps = /*#__PURE__*/new Set(['originX', 'originY', 'originZ']);
function isTransformOriginProp(key) {
    return transformOriginProps.has(key);
}

var stylefire_es_int = /*#__PURE__*/__assign( /*#__PURE__*/__assign({}, style_value_types_es["g" /* number */]), { transform: Math.round });
var valueTypes = {
    color: style_value_types_es["b" /* color */],
    backgroundColor: style_value_types_es["b" /* color */],
    outlineColor: style_value_types_es["b" /* color */],
    fill: style_value_types_es["b" /* color */],
    stroke: style_value_types_es["b" /* color */],
    borderColor: style_value_types_es["b" /* color */],
    borderTopColor: style_value_types_es["b" /* color */],
    borderRightColor: style_value_types_es["b" /* color */],
    borderBottomColor: style_value_types_es["b" /* color */],
    borderLeftColor: style_value_types_es["b" /* color */],
    borderWidth: style_value_types_es["j" /* px */],
    borderTopWidth: style_value_types_es["j" /* px */],
    borderRightWidth: style_value_types_es["j" /* px */],
    borderBottomWidth: style_value_types_es["j" /* px */],
    borderLeftWidth: style_value_types_es["j" /* px */],
    borderRadius: style_value_types_es["j" /* px */],
    radius: style_value_types_es["j" /* px */],
    borderTopLeftRadius: style_value_types_es["j" /* px */],
    borderTopRightRadius: style_value_types_es["j" /* px */],
    borderBottomRightRadius: style_value_types_es["j" /* px */],
    borderBottomLeftRadius: style_value_types_es["j" /* px */],
    width: style_value_types_es["j" /* px */],
    maxWidth: style_value_types_es["j" /* px */],
    height: style_value_types_es["j" /* px */],
    maxHeight: style_value_types_es["j" /* px */],
    size: style_value_types_es["j" /* px */],
    top: style_value_types_es["j" /* px */],
    right: style_value_types_es["j" /* px */],
    bottom: style_value_types_es["j" /* px */],
    left: style_value_types_es["j" /* px */],
    padding: style_value_types_es["j" /* px */],
    paddingTop: style_value_types_es["j" /* px */],
    paddingRight: style_value_types_es["j" /* px */],
    paddingBottom: style_value_types_es["j" /* px */],
    paddingLeft: style_value_types_es["j" /* px */],
    margin: style_value_types_es["j" /* px */],
    marginTop: style_value_types_es["j" /* px */],
    marginRight: style_value_types_es["j" /* px */],
    marginBottom: style_value_types_es["j" /* px */],
    marginLeft: style_value_types_es["j" /* px */],
    rotate: style_value_types_es["d" /* degrees */],
    rotateX: style_value_types_es["d" /* degrees */],
    rotateY: style_value_types_es["d" /* degrees */],
    rotateZ: style_value_types_es["d" /* degrees */],
    scale: style_value_types_es["l" /* scale */],
    scaleX: style_value_types_es["l" /* scale */],
    scaleY: style_value_types_es["l" /* scale */],
    scaleZ: style_value_types_es["l" /* scale */],
    skew: style_value_types_es["d" /* degrees */],
    skewX: style_value_types_es["d" /* degrees */],
    skewY: style_value_types_es["d" /* degrees */],
    distance: style_value_types_es["j" /* px */],
    translateX: style_value_types_es["j" /* px */],
    translateY: style_value_types_es["j" /* px */],
    translateZ: style_value_types_es["j" /* px */],
    x: style_value_types_es["j" /* px */],
    y: style_value_types_es["j" /* px */],
    z: style_value_types_es["j" /* px */],
    perspective: style_value_types_es["j" /* px */],
    opacity: style_value_types_es["a" /* alpha */],
    originX: style_value_types_es["i" /* progressPercentage */],
    originY: style_value_types_es["i" /* progressPercentage */],
    originZ: style_value_types_es["j" /* px */],
    zIndex: stylefire_es_int,
    fillOpacity: style_value_types_es["a" /* alpha */],
    strokeOpacity: style_value_types_es["a" /* alpha */],
    numOctaves: stylefire_es_int
};
var getValueType = function (key) {
    return valueTypes[key];
};
var getValueAsType = function (value, type) {
    return type && typeof value === 'number' ? type.transform(value) : value;
};

var SCROLL_LEFT = 'scrollLeft';
var SCROLL_TOP = 'scrollTop';
var scrollKeys = /*#__PURE__*/new Set([SCROLL_LEFT, SCROLL_TOP]);

var blacklist = /*#__PURE__*/new Set([SCROLL_LEFT, SCROLL_TOP, 'transform']);
var translateAlias = {
    x: 'translateX',
    y: 'translateY',
    z: 'translateZ'
};
function isCustomTemplate(v) {
    return typeof v === 'function';
}
function buildTransform(state, transform, transformKeys, transformIsDefault, enableHardwareAcceleration, allowTransformNone) {
    if (allowTransformNone === void 0) {
        allowTransformNone = true;
    }
    var transformString = '';
    var transformHasZ = false;
    transformKeys.sort(sortTransformProps);
    var numTransformKeys = transformKeys.length;
    for (var i = 0; i < numTransformKeys; i++) {
        var key = transformKeys[i];
        transformString += (translateAlias[key] || key) + "(" + transform[key] + ") ";
        transformHasZ = key === 'z' ? true : transformHasZ;
    }
    if (!transformHasZ && enableHardwareAcceleration) {
        transformString += 'translateZ(0)';
    } else {
        transformString = transformString.trim();
    }
    if (isCustomTemplate(state.transform)) {
        transformString = state.transform(transform, transformIsDefault ? '' : transformString);
    } else if (allowTransformNone && transformIsDefault) {
        transformString = 'none';
    }
    return transformString;
}
function buildStyleProperty(state, enableHardwareAcceleration, styles, transform, transformOrigin, transformKeys, isDashCase, allowTransformNone) {
    if (enableHardwareAcceleration === void 0) {
        enableHardwareAcceleration = true;
    }
    if (styles === void 0) {
        styles = {};
    }
    if (transform === void 0) {
        transform = {};
    }
    if (transformOrigin === void 0) {
        transformOrigin = {};
    }
    if (transformKeys === void 0) {
        transformKeys = [];
    }
    if (isDashCase === void 0) {
        isDashCase = false;
    }
    if (allowTransformNone === void 0) {
        allowTransformNone = true;
    }
    var transformIsDefault = true;
    var hasTransform = false;
    var hasTransformOrigin = false;
    for (var key in state) {
        var value = state[key];
        var valueType = getValueType(key);
        var valueAsType = getValueAsType(value, valueType);
        if (isTransformProp(key)) {
            hasTransform = true;
            transform[key] = valueAsType;
            transformKeys.push(key);
            if (transformIsDefault) {
                if (valueType.default && value !== valueType.default || !valueType.default && value !== 0) {
                    transformIsDefault = false;
                }
            }
        } else if (isTransformOriginProp(key)) {
            transformOrigin[key] = valueAsType;
            hasTransformOrigin = true;
        } else if (!blacklist.has(key) || !isCustomTemplate(valueAsType)) {
            styles[prefixer(key, isDashCase)] = valueAsType;
        }
    }
    if (hasTransform || typeof state.transform === 'function') {
        styles.transform = buildTransform(state, transform, transformKeys, transformIsDefault, enableHardwareAcceleration, allowTransformNone);
    }
    if (hasTransformOrigin) {
        styles.transformOrigin = (transformOrigin.originX || '50%') + " " + (transformOrigin.originY || '50%') + " " + (transformOrigin.originZ || 0);
    }
    return styles;
}
function createStyleBuilder(_a) {
    var _b = _a === void 0 ? {} : _a,
        _c = _b.enableHardwareAcceleration,
        enableHardwareAcceleration = _c === void 0 ? true : _c,
        _d = _b.isDashCase,
        isDashCase = _d === void 0 ? true : _d,
        _e = _b.allowTransformNone,
        allowTransformNone = _e === void 0 ? true : _e;
    var styles = {};
    var transform = {};
    var transformOrigin = {};
    var transformKeys = [];
    return function (state) {
        transformKeys.length = 0;
        buildStyleProperty(state, enableHardwareAcceleration, styles, transform, transformOrigin, transformKeys, isDashCase, allowTransformNone);
        return styles;
    };
}

function stylefire_es_onRead(key, options) {
    var element = options.element,
        preparseOutput = options.preparseOutput;
    var defaultValueType = getValueType(key);
    if (isTransformProp(key)) {
        return defaultValueType ? defaultValueType.default || 0 : 0;
    } else if (scrollKeys.has(key)) {
        return element[key];
    } else {
        var domValue = window.getComputedStyle(element, null).getPropertyValue(prefixer(key, true)) || 0;
        return preparseOutput && defaultValueType && defaultValueType.test(domValue) && defaultValueType.parse ? defaultValueType.parse(domValue) : domValue;
    }
}
function stylefire_es_onRender(state, _a, changedValues) {
    var element = _a.element,
        buildStyles = _a.buildStyles,
        hasCSSVariable = _a.hasCSSVariable;
    Object.assign(element.style, buildStyles(state));
    if (hasCSSVariable) {
        var numChangedValues = changedValues.length;
        for (var i = 0; i < numChangedValues; i++) {
            var key = changedValues[i];
            if (key.startsWith('--')) {
                element.style.setProperty(key, state[key]);
            }
        }
    }
    if (changedValues.indexOf(SCROLL_LEFT) !== -1) {
        element[SCROLL_LEFT] = state[SCROLL_LEFT];
    }
    if (changedValues.indexOf(SCROLL_TOP) !== -1) {
        element[SCROLL_TOP] = state[SCROLL_TOP];
    }
}
var cssStyler = /*#__PURE__*/createStyler({
    onRead: stylefire_es_onRead,
    onRender: stylefire_es_onRender,
    uncachedValues: scrollKeys
});
function createCssStyler(element, _a) {
    if (_a === void 0) {
        _a = {};
    }
    var enableHardwareAcceleration = _a.enableHardwareAcceleration,
        allowTransformNone = _a.allowTransformNone,
        props = __rest(_a, ["enableHardwareAcceleration", "allowTransformNone"]);
    return cssStyler(__assign({ element: element, buildStyles: createStyleBuilder({
            enableHardwareAcceleration: enableHardwareAcceleration,
            allowTransformNone: allowTransformNone
        }), preparseOutput: true }, props));
}

var camelCaseAttributes = /*#__PURE__*/new Set(['baseFrequency', 'diffuseConstant', 'kernelMatrix', 'kernelUnitLength', 'keySplines', 'keyTimes', 'limitingConeAngle', 'markerHeight', 'markerWidth', 'numOctaves', 'targetX', 'targetY', 'surfaceScale', 'specularConstant', 'specularExponent', 'stdDeviation', 'tableValues']);

var defaultOrigin = 0.5;
var svgAttrsTemplate = function () {
    return {
        style: {}
    };
};
var progressToPixels = function (progress, length) {
    return style_value_types_es["j" /* px */].transform(progress * length);
};
var unmeasured = { x: 0, y: 0, width: 0, height: 0 };
function calcOrigin(origin, offset, size) {
    return typeof origin === 'string' ? origin : style_value_types_es["j" /* px */].transform(offset + size * origin);
}
function calculateSVGTransformOrigin(dimensions, originX, originY) {
    return calcOrigin(originX, dimensions.x, dimensions.width) + " " + calcOrigin(originY, dimensions.y, dimensions.height);
}
var svgStyleConfig = {
    enableHardwareAcceleration: false,
    isDashCase: false
};
function buildSVGAttrs(_a, dimensions, totalPathLength, cssBuilder, attrs, isDashCase) {
    if (dimensions === void 0) {
        dimensions = unmeasured;
    }
    if (cssBuilder === void 0) {
        cssBuilder = createStyleBuilder(svgStyleConfig);
    }
    if (attrs === void 0) {
        attrs = svgAttrsTemplate();
    }
    if (isDashCase === void 0) {
        isDashCase = true;
    }
    var attrX = _a.attrX,
        attrY = _a.attrY,
        originX = _a.originX,
        originY = _a.originY,
        pathLength = _a.pathLength,
        _b = _a.pathSpacing,
        pathSpacing = _b === void 0 ? 1 : _b,
        _c = _a.pathOffset,
        pathOffset = _c === void 0 ? 0 : _c,
        state = __rest(_a, ["attrX", "attrY", "originX", "originY", "pathLength", "pathSpacing", "pathOffset"]);
    var style = cssBuilder(state);
    for (var key in style) {
        if (key === 'transform') {
            attrs.style.transform = style[key];
        } else {
            var attrKey = isDashCase && !camelCaseAttributes.has(key) ? camelToDash(key) : key;
            attrs[attrKey] = style[key];
        }
    }
    if (originX !== undefined || originY !== undefined || style.transform) {
        attrs.style.transformOrigin = calculateSVGTransformOrigin(dimensions, originX !== undefined ? originX : defaultOrigin, originY !== undefined ? originY : defaultOrigin);
    }
    if (attrX !== undefined) attrs.x = attrX;
    if (attrY !== undefined) attrs.y = attrY;
    if (totalPathLength !== undefined && pathLength !== undefined) {
        attrs[isDashCase ? 'stroke-dashoffset' : 'strokeDashoffset'] = progressToPixels(-pathOffset, totalPathLength);
        attrs[isDashCase ? 'stroke-dasharray' : 'strokeDasharray'] = progressToPixels(pathLength, totalPathLength) + " " + progressToPixels(pathSpacing, totalPathLength);
    }
    return attrs;
}
function createAttrBuilder(dimensions, totalPathLength, isDashCase) {
    if (isDashCase === void 0) {
        isDashCase = true;
    }
    var attrs = svgAttrsTemplate();
    var cssBuilder = createStyleBuilder(svgStyleConfig);
    return function (state) {
        return buildSVGAttrs(state, dimensions, totalPathLength, cssBuilder, attrs, isDashCase);
    };
}

var getDimensions = function (element) {
    return typeof element.getBBox === 'function' ? element.getBBox() : element.getBoundingClientRect();
};
var getSVGElementDimensions = function (element) {
    try {
        return getDimensions(element);
    } catch (e) {
        return { x: 0, y: 0, width: 0, height: 0 };
    }
};

var isPath = function (element) {
    return element.tagName === 'path';
};
var svgStyler = /*#__PURE__*/createStyler({
    onRead: function (key, _a) {
        var element = _a.element;
        key = !camelCaseAttributes.has(key) ? camelToDash(key) : key;
        if (!isTransformProp(key)) {
            return element.getAttribute(key);
        } else {
            var valueType = getValueType(key);
            return valueType ? valueType.default || 0 : 0;
        }
    },
    onRender: function (state, _a) {
        var element = _a.element,
            buildAttrs = _a.buildAttrs;
        var attrs = buildAttrs(state);
        for (var key in attrs) {
            if (key === 'style') {
                Object.assign(element.style, attrs.style);
            } else {
                element.setAttribute(key, attrs[key]);
            }
        }
    }
});
var svg = function (element) {
    var dimensions = getSVGElementDimensions(element);
    var pathLength = isPath(element) && element.getTotalLength ? element.getTotalLength() : undefined;
    return svgStyler({
        element: element,
        buildAttrs: createAttrBuilder(dimensions, pathLength)
    });
};

var viewport = /*#__PURE__*/createStyler({
    useCache: false,
    onRead: function (key) {
        return key === 'scrollTop' ? window.pageYOffset : window.pageXOffset;
    },
    onRender: function (_a) {
        var _b = _a.scrollTop,
            scrollTop = _b === void 0 ? 0 : _b,
            _c = _a.scrollLeft,
            scrollLeft = _c === void 0 ? 0 : _c;
        return window.scrollTo(scrollLeft, scrollTop);
    }
});

var cache = /*#__PURE__*/new WeakMap();
var isHTMLElement = function (node) {
    return node instanceof HTMLElement || typeof node.click === 'function';
};
var isSVGElement = function (node) {
    return node instanceof SVGElement || 'ownerSVGElement' in node;
};
var createDOMStyler = function (node, props) {
    var styler;
    if (node === window) {
        styler = viewport(node);
    } else if (isHTMLElement(node)) {
        styler = createCssStyler(node, props);
    } else if (isSVGElement(node)) {
        styler = svg(node);
    }
    Object(hey_listen_es["a" /* invariant */])(styler !== undefined, 'No valid node provided. Node must be HTMLElement, SVGElement or window.');
    cache.set(node, styler);
    return styler;
};
var getStyler = function (node, props) {
    return cache.has(node) ? cache.get(node) : createDOMStyler(node, props);
};
function index(nodeOrSelector, props) {
    var node = typeof nodeOrSelector === 'string' ? document.querySelector(nodeOrSelector) : nodeOrSelector;
    return getStyler(node, props);
}

/* harmony default export */ var stylefire_es = __webpack_exports__["d"] = (index);



/***/ }),

/***/ 22:
/***/ (function(module, exports, __webpack_require__) {

/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/* eslint-disable node/no-deprecated-api */
var buffer = __webpack_require__(4)
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.prototype = Object.create(Buffer.prototype)

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}


/***/ }),

/***/ 294:
/***/ (function(module, exports) {

var types = {
  Array: function (value) { return value !== null && value !== undefined && value.constructor === Array },
  Boolean: function (value) { return typeof value === 'boolean' },
  Function: function (value) { return typeof value === 'function' },
  Nil: function (value) { return value === undefined || value === null },
  Number: function (value) { return typeof value === 'number' },
  Object: function (value) { return typeof value === 'object' },
  String: function (value) { return typeof value === 'string' },
  '': function () { return true }
}

// TODO: deprecate
types.Null = types.Nil

for (var typeName in types) {
  types[typeName].toJSON = function (t) {
    return t
  }.bind(null, typeName)
}

module.exports = types


/***/ }),

/***/ 300:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/* eslint-disable node/no-deprecated-api */



var buffer = __webpack_require__(4)
var Buffer = buffer.Buffer

var safer = {}

var key

for (key in buffer) {
  if (!buffer.hasOwnProperty(key)) continue
  if (key === 'SlowBuffer' || key === 'Buffer') continue
  safer[key] = buffer[key]
}

var Safer = safer.Buffer = {}
for (key in Buffer) {
  if (!Buffer.hasOwnProperty(key)) continue
  if (key === 'allocUnsafe' || key === 'allocUnsafeSlow') continue
  Safer[key] = Buffer[key]
}

safer.Buffer.prototype = Buffer.prototype

if (!Safer.from || Safer.from === Uint8Array.from) {
  Safer.from = function (value, encodingOrOffset, length) {
    if (typeof value === 'number') {
      throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof value)
    }
    if (value && typeof value.length === 'undefined') {
      throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type ' + typeof value)
    }
    return Buffer(value, encodingOrOffset, length)
  }
}

if (!Safer.alloc) {
  Safer.alloc = function (size, fill, encoding) {
    if (typeof size !== 'number') {
      throw new TypeError('The "size" argument must be of type number. Received type ' + typeof size)
    }
    if (size < 0 || size >= 2 * (1 << 30)) {
      throw new RangeError('The value "' + size + '" is invalid for option "size"')
    }
    var buf = Buffer(size)
    if (!fill || fill.length === 0) {
      buf.fill(0)
    } else if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
    return buf
  }
}

if (!safer.kStringMaxLength) {
  try {
    safer.kStringMaxLength = process.binding('buffer').kStringMaxLength
  } catch (e) {
    // we can't determine kStringMaxLength in environments where process.binding
    // is unsupported, so let's not set it
  }
}

if (!safer.constants) {
  safer.constants = {
    MAX_LENGTH: safer.kMaxLength
  }
  if (safer.kStringMaxLength) {
    safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength
  }
}

module.exports = safer

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(28)))

/***/ }),

/***/ 348:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable @typescript-eslint/camelcase */
const encoding_1 = __webpack_require__(86);
function parseAttribute(input) {
    if (!encoding_1.isNonNullObject(input))
        throw new Error("Attribute must be a non-null object");
    const { key, value } = input;
    if (typeof key !== "string" || !key)
        throw new Error("Attribute's key must be a non-empty string");
    if (typeof value !== "string" && typeof value !== "undefined") {
        throw new Error("Attribute's value must be a string or unset");
    }
    return {
        key: key,
        value: value || "",
    };
}
exports.parseAttribute = parseAttribute;
function parseEvent(input) {
    if (!encoding_1.isNonNullObject(input))
        throw new Error("Event must be a non-null object");
    const { type, attributes } = input;
    if (typeof type !== "string" || type === "") {
        throw new Error(`Event type must be a non-empty string`);
    }
    if (!Array.isArray(attributes))
        throw new Error("Event's attributes must be an array");
    return {
        type: type,
        attributes: attributes.map(parseAttribute),
    };
}
exports.parseEvent = parseEvent;
function parseLog(input) {
    if (!encoding_1.isNonNullObject(input))
        throw new Error("Log must be a non-null object");
    const { msg_index, log, events } = input;
    if (!Array.isArray(events))
        throw new Error("Log's events must be an array");
    return {
        msg_index: 0,
        log: "",
        events: events.map(parseEvent),
    };
}
exports.parseLog = parseLog;
function parseLogs(input) {
    if (!Array.isArray(input))
        throw new Error("Logs must be an array");
    return input.map(parseLog);
}
exports.parseLogs = parseLogs;
/**
 * Searches in logs for the first event of the given event type and in that event
 * for the first first attribute with the given attribute key.
 *
 * Throws if the attribute was not found.
 */
function findAttribute(logs, eventType, attrKey) {
    var _a, _b;
    const firstLogs = logs.find(() => true);
    const out = (_b = (_a = firstLogs) === null || _a === void 0 ? void 0 : _a.events.find((event) => event.type === eventType)) === null || _b === void 0 ? void 0 : _b.attributes.find((attr) => attr.key === attrKey);
    if (!out) {
        throw new Error(`Could not find attribute '${attrKey}' in first event of type '${eventType}' in first log.`);
    }
    return out;
}
exports.findAttribute = findAttribute;
//# sourceMappingURL=logs.js.map

/***/ }),

/***/ 350:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const encoding_1 = __webpack_require__(86);
const { toUtf8 } = encoding_1.Encoding;
function sortJson(json) {
    if (typeof json !== "object" || json === null) {
        return json;
    }
    if (Array.isArray(json)) {
        return json.map(sortJson);
    }
    const sortedKeys = Object.keys(json).sort();
    const result = sortedKeys.reduce((accumulator, key) => (Object.assign(Object.assign({}, accumulator), { [key]: sortJson(json[key]) })), {});
    return result;
}
function marshalTx(tx) {
    const json = JSON.stringify(tx);
    return encoding_1.Encoding.toUtf8(json);
}
exports.marshalTx = marshalTx;
function makeSignBytes(msgs, fee, chainId, memo, accountNumber, sequence) {
    const signJson = {
        // eslint-disable-next-line @typescript-eslint/camelcase
        account_number: accountNumber.toString(),
        // eslint-disable-next-line @typescript-eslint/camelcase
        chain_id: chainId,
        fee: fee,
        memo: memo,
        msgs: msgs,
        sequence: sequence.toString(),
    };
    const signMsg = sortJson(signJson);
    return toUtf8(JSON.stringify(signMsg));
}
exports.makeSignBytes = makeSignBytes;
//# sourceMappingURL=encoding.js.map

/***/ }),

/***/ 351:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const encoding_1 = __webpack_require__(86);
const axios_1 = __importDefault(__webpack_require__(60));
const enigmautils_1 = __importDefault(__webpack_require__(565));
const ProtoEncoding_1 = __webpack_require__(1158);
const v1_4_protos_1 = __webpack_require__(574);
function normalizeArray(backend) {
    return backend || [];
}
/**
 * The mode used to send transaction
 *
 * @see https://cosmos.network/rpc/#/Transactions/post_txs
 */
var BroadcastMode;
(function (BroadcastMode) {
    /** Return after tx commit */
    BroadcastMode["Block"] = "block";
    /** Return afer CheckTx */
    BroadcastMode["Sync"] = "sync";
    /** Return right away */
    BroadcastMode["Async"] = "async";
})(BroadcastMode = exports.BroadcastMode || (exports.BroadcastMode = {}));
function isWasmError(resp) {
    return resp.error !== undefined;
}
function unwrapWasmResponse(response) {
    if (isWasmError(response)) {
        throw new Error(response.error);
    }
    return response.result;
}
// We want to get message data from 500 errors
// https://stackoverflow.com/questions/56577124/how-to-handle-500-error-message-with-axios
// this should be chained to catch one error and throw a more informative one
function parseAxiosError(err) {
    var _a;
    // use the error message sent from server, not default 500 msg
    if ((_a = err.response) === null || _a === void 0 ? void 0 : _a.data) {
        let errorText;
        const data = err.response.data;
        // expect { error: string }, but otherwise dump
        if (data.error && typeof data.error === "string") {
            errorText = data.error;
        }
        else if (typeof data === "string") {
            errorText = data;
        }
        else {
            errorText = JSON.stringify(data);
        }
        throw new Error(`${errorText} (HTTP ${err.response.status})`);
    }
    else {
        throw err;
    }
}
class RestClient {
    /**
     * Creates a new client to interact with a Cosmos SDK light client daemon.
     * This class tries to be a direct mapping onto the API. Some basic decoding and normalizatin is done
     * but things like caching are done at a higher level.
     *
     * When building apps, you should not need to use this class directly. If you do, this indicates a missing feature
     * in higher level components. Feel free to raise an issue in this case.
     *
     * @param apiUrl The URL of a Cosmos SDK light client daemon API (sometimes called REST server or REST API)
     * @param broadcastMode Defines at which point of the transaction processing the postTx method (i.e. transaction broadcasting) returns
     * @param seed - The seed used to generate sender TX encryption key. If empty will generate random new one
     */
    constructor(apiUrl, broadcastMode = BroadcastMode.Block, seed) {
        const headers = {
            post: { "Content-Type": "application/json" },
        };
        this.client = axios_1.default.create({
            baseURL: apiUrl,
            headers: headers,
        });
        this.broadcastMode = broadcastMode;
        this.enigmautils = new enigmautils_1.default(apiUrl, seed);
        this.codeHashCache = new Map();
    }
    async get(path) {
        const { data } = await this.client.get(path).catch(parseAxiosError);
        if (data === null) {
            throw new Error("Received null response from server");
        }
        return data;
    }
    async post(path, params) {
        if (!encoding_1.isNonNullObject(params))
            throw new Error("Got unexpected type of params. Expected object.");
        const { data } = await this.client.post(path, params).catch(parseAxiosError);
        if (data === null) {
            throw new Error("Received null response from server");
        }
        return data;
    }
    // The /auth endpoints
    async authAccounts(address) {
        const [authResp, bankResp] = (await Promise.all([
            this.get(`/auth/accounts/${address}`),
            this.get(`/bank/balances/${address}`),
        ]));
        const result = {
            height: bankResp.height,
            result: {
                type: "cosmos-sdk/Account",
                value: {
                    address: authResp.result.value.address,
                    coins: bankResp.result,
                    public_key: JSON.stringify(authResp.result.value.public_key),
                    account_number: Number(authResp.result.value.account_number || 0),
                    sequence: Number(authResp.result.value.sequence || 0),
                },
            },
        };
        return result;
    }
    // The /blocks endpoints
    async blocksLatest() {
        const responseData = await this.get("/blocks/latest");
        if (!responseData.block) {
            throw new Error("Unexpected response data format");
        }
        return responseData;
    }
    async blocks(height) {
        const responseData = await this.get(`/blocks/${height}`);
        if (!responseData.block) {
            throw new Error("Unexpected response data format");
        }
        return responseData;
    }
    // The /node_info endpoint
    async nodeInfo() {
        const responseData = await this.get("/node_info");
        if (!responseData.node_info) {
            throw new Error("Unexpected response data format");
        }
        return responseData;
    }
    // The /txs endpoints
    async txById(id, tryToDecrypt = true) {
        const responseData = await this.get(`/txs/${id}`);
        if (!responseData.tx) {
            throw new Error("Unexpected response data format");
        }
        if (tryToDecrypt) {
            return this.decryptTxsResponse(responseData);
        }
        else {
            return responseData;
        }
    }
    async txsQuery(query, tryToDecrypt = true) {
        const responseData = await this.get(`/txs?${query}`);
        if (!responseData.txs) {
            throw new Error("Unexpected response data format");
        }
        const resp = responseData;
        if (tryToDecrypt) {
            for (let i = 0; i < resp.txs.length; i++) {
                resp.txs[i] = await this.decryptTxsResponse(resp.txs[i]);
            }
        }
        return resp;
    }
    /** returns the amino-encoding of the transaction performed by the server */
    async encodeTx(tx) {
        const responseData = await this.post("/txs/encode", tx);
        if (!responseData.tx) {
            throw new Error("Unexpected response data format");
        }
        return encoding_1.Encoding.fromBase64(responseData.tx);
    }
    /**
     * Broadcasts a signed transaction to into the transaction pool.
     * Depending on the RestClient's broadcast mode, this might or might
     * wait for checkTx or deliverTx to be executed before returning.
     *
     * @param tx a signed transaction as StdTx (i.e. not wrapped in type/value container)
     */
    async postTx(tx) {
        const params = {
            tx: tx,
            mode: this.broadcastMode,
        };
        const responseData = await this.post("/txs", params);
        if (!responseData.txhash) {
            throw new Error("Unexpected response data format");
        }
        return responseData;
    }
    // The /wasm endpoints
    // wasm rest queries are listed here: https://github.com/cosmwasm/wasmd/blob/master/x/wasm/client/rest/query.go#L19-L27
    async listCodeInfo() {
        const path = `/wasm/code`;
        const responseData = (await this.get(path));
        return normalizeArray(await unwrapWasmResponse(responseData));
    }
    // this will download the original wasm bytecode by code id
    // throws error if no code with this id
    async getCode(id) {
        const path = `/wasm/code/${id}`;
        const responseData = (await this.get(path));
        return await unwrapWasmResponse(responseData);
    }
    async listContractsByCodeId(id) {
        const path = `/wasm/code/${id}/contracts`;
        const responseData = (await this.get(path));
        return normalizeArray(await unwrapWasmResponse(responseData));
    }
    async getCodeHashByCodeId(id) {
        const codeHashFromCache = this.codeHashCache.get(id);
        if (typeof codeHashFromCache === "string") {
            return codeHashFromCache;
        }
        const path = `/wasm/code/${id}/hash`;
        const responseData = (await this.get(path));
        this.codeHashCache.set(id, responseData.result);
        return responseData.result;
    }
    async getCodeHashByContractAddr(addr) {
        const codeHashFromCache = this.codeHashCache.get(addr);
        if (typeof codeHashFromCache === "string") {
            return codeHashFromCache;
        }
        const path = `/wasm/contract/${addr}/code-hash`;
        const responseData = (await this.get(path));
        this.codeHashCache.set(addr, responseData.result);
        return responseData.result;
    }
    /**
     * Returns null when contract was not found at this address.
     */
    async getContractInfo(address) {
        const path = `/wasm/contract/${address}`;
        const response = (await this.get(path));
        return await unwrapWasmResponse(response);
    }
    /**
     * Makes a smart query on the contract and parses the reponse as JSON.
     * Throws error if no such contract exists, the query format is invalid or the response is invalid.
     */
    async queryContractSmart(contractAddress, query, addedParams, contractCodeHash) {
        var _a;
        if (!contractCodeHash) {
            contractCodeHash = await this.getCodeHashByContractAddr(contractAddress);
        }
        else {
            this.codeHashCache.set(contractAddress, contractCodeHash);
        }
        const encrypted = await this.enigmautils.encrypt(contractCodeHash, query);
        const nonce = encrypted.slice(0, 32);
        const encoded = encoding_1.Encoding.toHex(encoding_1.Encoding.toUtf8(encoding_1.Encoding.toBase64(encrypted)));
        // @ts-ignore
        const paramString = new URLSearchParams(addedParams).toString();
        const path = `/wasm/contract/${contractAddress}/query/${encoded}?encoding=hex&${paramString}`;
        let responseData;
        try {
            responseData = (await this.get(path));
        }
        catch (err) {
            try {
                const errorMessageRgx = /encrypted: (.+?): (?:instantiate|execute|query) contract failed \(HTTP 500\)/g;
                // @ts-ignore
                const rgxMatches = errorMessageRgx.exec(err.message);
                if (rgxMatches == null || ((_a = rgxMatches) === null || _a === void 0 ? void 0 : _a.length) != 2) {
                    throw err;
                }
                const errorCipherB64 = rgxMatches[1];
                const errorCipherBz = encoding_1.Encoding.fromBase64(errorCipherB64);
                const errorPlainBz = await this.enigmautils.decrypt(errorCipherBz, nonce);
                //@ts-ignore
                err.message = err.message.replace(errorCipherB64, encoding_1.Encoding.fromUtf8(errorPlainBz));
            }
            catch (decryptionError) {
                //@ts-ignore
                throw new Error(`Failed to decrypt the following error message: ${err.message}.`);
            }
            throw err;
        }
        if (isWasmError(responseData)) {
            throw new Error(JSON.stringify(await this.enigmautils.decrypt(encoding_1.Encoding.fromBase64(responseData.error), nonce)));
        }
        // By convention, smart queries must return a valid JSON document (see https://github.com/CosmWasm/cosmwasm/issues/144)
        return JSON.parse(encoding_1.Encoding.fromUtf8(encoding_1.Encoding.fromBase64(encoding_1.Encoding.fromUtf8(await this.enigmautils.decrypt(encoding_1.Encoding.fromBase64(responseData.result.smart), nonce)))));
    }
    /**
     * Get the consensus keypair for IO encryption
     */
    async getMasterCerts(address, query) {
        return this.get("/register/master-cert");
    }
    async decryptDataField(dataField = "", nonces) {
        const wasmOutputDataCipherBz = encoding_1.Encoding.fromHex(dataField);
        let error;
        for (const nonce of nonces) {
            try {
                const data = encoding_1.Encoding.fromBase64(encoding_1.Encoding.fromUtf8(await this.enigmautils.decrypt(wasmOutputDataCipherBz, nonce)));
                return data;
            }
            catch (e) {
                error = e;
            }
        }
        throw error;
    }
    async decryptLogs(logs, nonces) {
        for (const l of logs) {
            for (const e of l.events) {
                if (e.type === "wasm") {
                    for (const nonce of nonces) {
                        let nonceOk = false;
                        for (const a of e.attributes) {
                            try {
                                a.key = encoding_1.Encoding.fromUtf8(await this.enigmautils.decrypt(encoding_1.Encoding.fromBase64(a.key), nonce));
                                nonceOk = true;
                            }
                            catch (e) { }
                            try {
                                a.value = encoding_1.Encoding.fromUtf8(await this.enigmautils.decrypt(encoding_1.Encoding.fromBase64(a.value), nonce));
                                nonceOk = true;
                            }
                            catch (e) { }
                        }
                        if (nonceOk) {
                            continue;
                        }
                    }
                }
            }
        }
        return logs;
    }
    async decryptTxsResponse(txsResponse) {
        var _a, _b, _c;
        let dataFields;
        let data = Uint8Array.from([]);
        if (txsResponse.data) {
            dataFields = ProtoEncoding_1.decodeTxData(encoding_1.Encoding.fromHex(txsResponse.data));
        }
        let logs = txsResponse.logs;
        if (logs) {
            logs[0].msg_index = 0;
        }
        for (let i = 0; i < ((_a = txsResponse.tx.value.msg) === null || _a === void 0 ? void 0 : _a.length); i++) {
            const msg = txsResponse.tx.value.msg[i];
            let inputMsgEncrypted;
            if (msg.type === "wasm/MsgExecuteContract") {
                inputMsgEncrypted = encoding_1.Encoding.fromBase64(msg.value.msg);
            }
            else if (msg.type === "wasm/MsgInstantiateContract") {
                inputMsgEncrypted = encoding_1.Encoding.fromBase64(msg.value.init_msg);
            }
            else {
                continue;
            }
            const inputMsgPubkey = inputMsgEncrypted.slice(32, 64);
            if (encoding_1.Encoding.toBase64(await this.enigmautils.getPubkey()) === encoding_1.Encoding.toBase64(inputMsgPubkey)) {
                // my pubkey, can decrypt
                const nonce = inputMsgEncrypted.slice(0, 32);
                // decrypt input
                const inputMsg = encoding_1.Encoding.fromUtf8(await this.enigmautils.decrypt(inputMsgEncrypted.slice(64), nonce));
                if (msg.type === "wasm/MsgExecuteContract") {
                    // decrypt input
                    txsResponse.tx.value.msg[i].value.msg = inputMsg;
                    // decrypt output data
                    // stupid workaround because only 1st message data is returned
                    if (dataFields && i == 0 && dataFields[0].data) {
                        const decoded = v1_4_protos_1.MsgExecuteContractResponse.decode(encoding_1.Encoding.fromBase64(dataFields[0].data));
                        data = await this.decryptDataField(encoding_1.Encoding.toHex(decoded.data), [nonce]);
                    }
                }
                else if (msg.type === "wasm/MsgInstantiateContract") {
                    // decrypt input
                    txsResponse.tx.value.msg[i].value.init_msg = inputMsg;
                }
                // decrypt output logs
                if (txsResponse.logs && logs) {
                    if (!((_b = txsResponse.logs[i]) === null || _b === void 0 ? void 0 : _b.log)) {
                        logs[i].log = "";
                    }
                    logs[i] = (await this.decryptLogs([txsResponse.logs[i]], [nonce]))[0];
                }
                // failed to execute message; message index: 0: encrypted: (.+?): (?:instantiate|execute|query) contract failed
                // decrypt error
                const errorMessageRgx = new RegExp(`failed to execute message; message index: ${i}:(?: dispatch: submessages:)* encrypted: (.+?): (?:instantiate|execute|query) contract failed`, "g");
                const rgxMatches = errorMessageRgx.exec(txsResponse.raw_log);
                if (Array.isArray(rgxMatches) && ((_c = rgxMatches) === null || _c === void 0 ? void 0 : _c.length) === 2) {
                    const errorCipherB64 = rgxMatches[1];
                    const errorCipherBz = encoding_1.Encoding.fromBase64(errorCipherB64);
                    const errorPlainBz = await this.enigmautils.decrypt(errorCipherBz, nonce);
                    txsResponse.raw_log = txsResponse.raw_log.replace(errorCipherB64, encoding_1.Encoding.fromUtf8(errorPlainBz));
                }
            }
        }
        txsResponse = Object.assign({}, txsResponse, { logs: logs });
        // @ts-ignore
        txsResponse.data = data;
        return txsResponse;
    }
}
exports.RestClient = RestClient;
//# sourceMappingURL=restclient.js.map

/***/ }),

/***/ 356:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var copy=function copy(I,i){return function(O,o){var oi=o*2;var ii=i*2;O[oi]=I[ii];O[oi+1]=I[ii+1]}};module.exports=copy;

/***/ }),

/***/ 357:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const encoding_1 = __webpack_require__(86);
const pubkey_1 = __webpack_require__(576);
const types_1 = __webpack_require__(183);
/**
 * Takes a binary pubkey and signature to create a signature object
 *
 * @param pubkey a compressed secp256k1 public key
 * @param signature a 64 byte fixed length representation of secp256k1 signature components r and s
 */
function encodeSecp256k1Signature(pubkey, signature) {
    if (signature.length !== 64) {
        throw new Error("Signature must be 64 bytes long. Cosmos SDK uses a 2x32 byte fixed length encoding for the secp256k1 signature integers r and s.");
    }
    return {
        // eslint-disable-next-line @typescript-eslint/camelcase
        pub_key: pubkey_1.encodeSecp256k1Pubkey(pubkey),
        signature: encoding_1.Encoding.toBase64(signature),
    };
}
exports.encodeSecp256k1Signature = encodeSecp256k1Signature;
function decodeSignature(signature) {
    switch (signature.pub_key.type) {
        // Note: please don't add cases here without writing additional unit tests
        case types_1.pubkeyType.secp256k1:
            return {
                pubkey: encoding_1.Encoding.fromBase64(signature.pub_key.value),
                signature: encoding_1.Encoding.fromBase64(signature.signature),
            };
        default:
            throw new Error("Unsupported pubkey type");
    }
}
exports.decodeSignature = decodeSignature;
//# sourceMappingURL=signature.js.map

/***/ }),

/***/ 363:
/***/ (function(module, exports) {

exports.isatty = function () { return false; };

function ReadStream() {
  throw new Error('tty.ReadStream is not implemented');
}
exports.ReadStream = ReadStream;

function WriteStream() {
  throw new Error('tty.ReadStream is not implemented');
}
exports.WriteStream = WriteStream;


/***/ }),

/***/ 381:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function shallowEqualObjects(objA, objB) {
  if (objA === objB) {
    return true;
  }

  if (!objA || !objB) {
    return false;
  }

  var aKeys = Object.keys(objA);
  var bKeys = Object.keys(objB);
  var len = aKeys.length;

  if (bKeys.length !== len) {
    return false;
  }

  for (var i = 0; i < len; i++) {
    var key = aKeys[i];

    if (objA[key] !== objB[key] || !Object.prototype.hasOwnProperty.call(objB, key)) {
      return false;
    }
  }

  return true;
}

module.exports = shallowEqualObjects;


/***/ }),

/***/ 412:
/***/ (function(module, exports, __webpack_require__) {

/**
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
 * in FIPS 180-2
 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 *
 */

var inherits = __webpack_require__(18)
var Hash = __webpack_require__(145)
var Buffer = __webpack_require__(22).Buffer

var K = [
  0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5,
  0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5,
  0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3,
  0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174,
  0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC,
  0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA,
  0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7,
  0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967,
  0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13,
  0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85,
  0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3,
  0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070,
  0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5,
  0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3,
  0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208,
  0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2
]

var W = new Array(64)

function Sha256 () {
  this.init()

  this._w = W // new Array(64)

  Hash.call(this, 64, 56)
}

inherits(Sha256, Hash)

Sha256.prototype.init = function () {
  this._a = 0x6a09e667
  this._b = 0xbb67ae85
  this._c = 0x3c6ef372
  this._d = 0xa54ff53a
  this._e = 0x510e527f
  this._f = 0x9b05688c
  this._g = 0x1f83d9ab
  this._h = 0x5be0cd19

  return this
}

function ch (x, y, z) {
  return z ^ (x & (y ^ z))
}

function maj (x, y, z) {
  return (x & y) | (z & (x | y))
}

function sigma0 (x) {
  return (x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10)
}

function sigma1 (x) {
  return (x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7)
}

function gamma0 (x) {
  return (x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ (x >>> 3)
}

function gamma1 (x) {
  return (x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ (x >>> 10)
}

Sha256.prototype._update = function (M) {
  var W = this._w

  var a = this._a | 0
  var b = this._b | 0
  var c = this._c | 0
  var d = this._d | 0
  var e = this._e | 0
  var f = this._f | 0
  var g = this._g | 0
  var h = this._h | 0

  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)
  for (; i < 64; ++i) W[i] = (gamma1(W[i - 2]) + W[i - 7] + gamma0(W[i - 15]) + W[i - 16]) | 0

  for (var j = 0; j < 64; ++j) {
    var T1 = (h + sigma1(e) + ch(e, f, g) + K[j] + W[j]) | 0
    var T2 = (sigma0(a) + maj(a, b, c)) | 0

    h = g
    g = f
    f = e
    e = (d + T1) | 0
    d = c
    c = b
    b = a
    a = (T1 + T2) | 0
  }

  this._a = (a + this._a) | 0
  this._b = (b + this._b) | 0
  this._c = (c + this._c) | 0
  this._d = (d + this._d) | 0
  this._e = (e + this._e) | 0
  this._f = (f + this._f) | 0
  this._g = (g + this._g) | 0
  this._h = (h + this._h) | 0
}

Sha256.prototype._hash = function () {
  var H = Buffer.allocUnsafe(32)

  H.writeInt32BE(this._a, 0)
  H.writeInt32BE(this._b, 4)
  H.writeInt32BE(this._c, 8)
  H.writeInt32BE(this._d, 12)
  H.writeInt32BE(this._e, 16)
  H.writeInt32BE(this._f, 20)
  H.writeInt32BE(this._g, 24)
  H.writeInt32BE(this._h, 28)

  return H
}

module.exports = Sha256


/***/ }),

/***/ 413:
/***/ (function(module, exports, __webpack_require__) {

var inherits = __webpack_require__(18)
var Hash = __webpack_require__(145)
var Buffer = __webpack_require__(22).Buffer

var K = [
  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
]

var W = new Array(160)

function Sha512 () {
  this.init()
  this._w = W

  Hash.call(this, 128, 112)
}

inherits(Sha512, Hash)

Sha512.prototype.init = function () {
  this._ah = 0x6a09e667
  this._bh = 0xbb67ae85
  this._ch = 0x3c6ef372
  this._dh = 0xa54ff53a
  this._eh = 0x510e527f
  this._fh = 0x9b05688c
  this._gh = 0x1f83d9ab
  this._hh = 0x5be0cd19

  this._al = 0xf3bcc908
  this._bl = 0x84caa73b
  this._cl = 0xfe94f82b
  this._dl = 0x5f1d36f1
  this._el = 0xade682d1
  this._fl = 0x2b3e6c1f
  this._gl = 0xfb41bd6b
  this._hl = 0x137e2179

  return this
}

function Ch (x, y, z) {
  return z ^ (x & (y ^ z))
}

function maj (x, y, z) {
  return (x & y) | (z & (x | y))
}

function sigma0 (x, xl) {
  return (x >>> 28 | xl << 4) ^ (xl >>> 2 | x << 30) ^ (xl >>> 7 | x << 25)
}

function sigma1 (x, xl) {
  return (x >>> 14 | xl << 18) ^ (x >>> 18 | xl << 14) ^ (xl >>> 9 | x << 23)
}

function Gamma0 (x, xl) {
  return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7)
}

function Gamma0l (x, xl) {
  return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7 | xl << 25)
}

function Gamma1 (x, xl) {
  return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6)
}

function Gamma1l (x, xl) {
  return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6 | xl << 26)
}

function getCarry (a, b) {
  return (a >>> 0) < (b >>> 0) ? 1 : 0
}

Sha512.prototype._update = function (M) {
  var W = this._w

  var ah = this._ah | 0
  var bh = this._bh | 0
  var ch = this._ch | 0
  var dh = this._dh | 0
  var eh = this._eh | 0
  var fh = this._fh | 0
  var gh = this._gh | 0
  var hh = this._hh | 0

  var al = this._al | 0
  var bl = this._bl | 0
  var cl = this._cl | 0
  var dl = this._dl | 0
  var el = this._el | 0
  var fl = this._fl | 0
  var gl = this._gl | 0
  var hl = this._hl | 0

  for (var i = 0; i < 32; i += 2) {
    W[i] = M.readInt32BE(i * 4)
    W[i + 1] = M.readInt32BE(i * 4 + 4)
  }
  for (; i < 160; i += 2) {
    var xh = W[i - 15 * 2]
    var xl = W[i - 15 * 2 + 1]
    var gamma0 = Gamma0(xh, xl)
    var gamma0l = Gamma0l(xl, xh)

    xh = W[i - 2 * 2]
    xl = W[i - 2 * 2 + 1]
    var gamma1 = Gamma1(xh, xl)
    var gamma1l = Gamma1l(xl, xh)

    // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]
    var Wi7h = W[i - 7 * 2]
    var Wi7l = W[i - 7 * 2 + 1]

    var Wi16h = W[i - 16 * 2]
    var Wi16l = W[i - 16 * 2 + 1]

    var Wil = (gamma0l + Wi7l) | 0
    var Wih = (gamma0 + Wi7h + getCarry(Wil, gamma0l)) | 0
    Wil = (Wil + gamma1l) | 0
    Wih = (Wih + gamma1 + getCarry(Wil, gamma1l)) | 0
    Wil = (Wil + Wi16l) | 0
    Wih = (Wih + Wi16h + getCarry(Wil, Wi16l)) | 0

    W[i] = Wih
    W[i + 1] = Wil
  }

  for (var j = 0; j < 160; j += 2) {
    Wih = W[j]
    Wil = W[j + 1]

    var majh = maj(ah, bh, ch)
    var majl = maj(al, bl, cl)

    var sigma0h = sigma0(ah, al)
    var sigma0l = sigma0(al, ah)
    var sigma1h = sigma1(eh, el)
    var sigma1l = sigma1(el, eh)

    // t1 = h + sigma1 + ch + K[j] + W[j]
    var Kih = K[j]
    var Kil = K[j + 1]

    var chh = Ch(eh, fh, gh)
    var chl = Ch(el, fl, gl)

    var t1l = (hl + sigma1l) | 0
    var t1h = (hh + sigma1h + getCarry(t1l, hl)) | 0
    t1l = (t1l + chl) | 0
    t1h = (t1h + chh + getCarry(t1l, chl)) | 0
    t1l = (t1l + Kil) | 0
    t1h = (t1h + Kih + getCarry(t1l, Kil)) | 0
    t1l = (t1l + Wil) | 0
    t1h = (t1h + Wih + getCarry(t1l, Wil)) | 0

    // t2 = sigma0 + maj
    var t2l = (sigma0l + majl) | 0
    var t2h = (sigma0h + majh + getCarry(t2l, sigma0l)) | 0

    hh = gh
    hl = gl
    gh = fh
    gl = fl
    fh = eh
    fl = el
    el = (dl + t1l) | 0
    eh = (dh + t1h + getCarry(el, dl)) | 0
    dh = ch
    dl = cl
    ch = bh
    cl = bl
    bh = ah
    bl = al
    al = (t1l + t2l) | 0
    ah = (t1h + t2h + getCarry(al, t1l)) | 0
  }

  this._al = (this._al + al) | 0
  this._bl = (this._bl + bl) | 0
  this._cl = (this._cl + cl) | 0
  this._dl = (this._dl + dl) | 0
  this._el = (this._el + el) | 0
  this._fl = (this._fl + fl) | 0
  this._gl = (this._gl + gl) | 0
  this._hl = (this._hl + hl) | 0

  this._ah = (this._ah + ah + getCarry(this._al, al)) | 0
  this._bh = (this._bh + bh + getCarry(this._bl, bl)) | 0
  this._ch = (this._ch + ch + getCarry(this._cl, cl)) | 0
  this._dh = (this._dh + dh + getCarry(this._dl, dl)) | 0
  this._eh = (this._eh + eh + getCarry(this._el, el)) | 0
  this._fh = (this._fh + fh + getCarry(this._fl, fl)) | 0
  this._gh = (this._gh + gh + getCarry(this._gl, gl)) | 0
  this._hh = (this._hh + hh + getCarry(this._hl, hl)) | 0
}

Sha512.prototype._hash = function () {
  var H = Buffer.allocUnsafe(64)

  function writeInt64BE (h, l, offset) {
    H.writeInt32BE(h, offset)
    H.writeInt32BE(l, offset + 4)
  }

  writeInt64BE(this._ah, this._al, 0)
  writeInt64BE(this._bh, this._bl, 8)
  writeInt64BE(this._ch, this._cl, 16)
  writeInt64BE(this._dh, this._dl, 24)
  writeInt64BE(this._eh, this._el, 32)
  writeInt64BE(this._fh, this._fl, 40)
  writeInt64BE(this._gh, this._gl, 48)
  writeInt64BE(this._hh, this._hl, 56)

  return H
}

module.exports = Sha512


/***/ }),

/***/ 417:
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var scope = (typeof global !== "undefined" && global) ||
            (typeof self !== "undefined" && self) ||
            window;
var apply = Function.prototype.apply;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) {
  if (timeout) {
    timeout.close();
  }
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(scope, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// setimmediate attaches itself to the global object
__webpack_require__(717);
// On some exotic environments, it's not clear which object `setimmediate` was
// able to install onto.  Search each possibility in the same order as the
// `setimmediate` library.
exports.setImmediate = (typeof self !== "undefined" && self.setImmediate) ||
                       (typeof global !== "undefined" && global.setImmediate) ||
                       (this && this.setImmediate);
exports.clearImmediate = (typeof self !== "undefined" && self.clearImmediate) ||
                         (typeof global !== "undefined" && global.clearImmediate) ||
                         (this && this.clearImmediate);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(11)))

/***/ }),

/***/ 429:
/***/ (function(module, exports, __webpack_require__) {

var native = __webpack_require__(294)

function getTypeName (fn) {
  return fn.name || fn.toString().match(/function (.*?)\s*\(/)[1]
}

function getValueTypeName (value) {
  return native.Nil(value) ? '' : getTypeName(value.constructor)
}

function getValue (value) {
  if (native.Function(value)) return ''
  if (native.String(value)) return JSON.stringify(value)
  if (value && native.Object(value)) return ''
  return value
}

function captureStackTrace (e, t) {
  if (Error.captureStackTrace) {
    Error.captureStackTrace(e, t)
  }
}

function tfJSON (type) {
  if (native.Function(type)) return type.toJSON ? type.toJSON() : getTypeName(type)
  if (native.Array(type)) return 'Array'
  if (type && native.Object(type)) return 'Object'

  return type !== undefined ? type : ''
}

function tfErrorString (type, value, valueTypeName) {
  var valueJson = getValue(value)

  return 'Expected ' + tfJSON(type) + ', got' +
    (valueTypeName !== '' ? ' ' + valueTypeName : '') +
    (valueJson !== '' ? ' ' + valueJson : '')
}

function TfTypeError (type, value, valueTypeName) {
  valueTypeName = valueTypeName || getValueTypeName(value)
  this.message = tfErrorString(type, value, valueTypeName)

  captureStackTrace(this, TfTypeError)
  this.__type = type
  this.__value = value
  this.__valueTypeName = valueTypeName
}

TfTypeError.prototype = Object.create(Error.prototype)
TfTypeError.prototype.constructor = TfTypeError

function tfPropertyErrorString (type, label, name, value, valueTypeName) {
  var description = '" of type '
  if (label === 'key') description = '" with key type '

  return tfErrorString('property "' + tfJSON(name) + description + tfJSON(type), value, valueTypeName)
}

function TfPropertyTypeError (type, property, label, value, valueTypeName) {
  if (type) {
    valueTypeName = valueTypeName || getValueTypeName(value)
    this.message = tfPropertyErrorString(type, label, property, value, valueTypeName)
  } else {
    this.message = 'Unexpected property "' + property + '"'
  }

  captureStackTrace(this, TfTypeError)
  this.__label = label
  this.__property = property
  this.__type = type
  this.__value = value
  this.__valueTypeName = valueTypeName
}

TfPropertyTypeError.prototype = Object.create(Error.prototype)
TfPropertyTypeError.prototype.constructor = TfTypeError

function tfCustomError (expected, actual) {
  return new TfTypeError(expected, {}, actual)
}

function tfSubError (e, property, label) {
  // sub child?
  if (e instanceof TfPropertyTypeError) {
    property = property + '.' + e.__property

    e = new TfPropertyTypeError(
      e.__type, property, e.__label, e.__value, e.__valueTypeName
    )

  // child?
  } else if (e instanceof TfTypeError) {
    e = new TfPropertyTypeError(
      e.__type, property, label, e.__value, e.__valueTypeName
    )
  }

  captureStackTrace(e)
  return e
}

module.exports = {
  TfTypeError: TfTypeError,
  TfPropertyTypeError: TfPropertyTypeError,
  tfCustomError: tfCustomError,
  tfSubError: tfSubError,
  tfJSON: tfJSON,
  getValueTypeName: getValueTypeName
}


/***/ }),

/***/ 548:
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {exports.fetch = isFunction(global.fetch) && isFunction(global.ReadableStream)

exports.writableStream = isFunction(global.WritableStream)

exports.abortController = isFunction(global.AbortController)

exports.blobConstructor = false
try {
	new Blob([new ArrayBuffer(1)])
	exports.blobConstructor = true
} catch (e) {}

// The xhr request to example.com may violate some restrictive CSP configurations,
// so if we're running in a browser that supports `fetch`, avoid calling getXHR()
// and assume support for certain features below.
var xhr
function getXHR () {
	// Cache the xhr value
	if (xhr !== undefined) return xhr

	if (global.XMLHttpRequest) {
		xhr = new global.XMLHttpRequest()
		// If XDomainRequest is available (ie only, where xhr might not work
		// cross domain), use the page location. Otherwise use example.com
		// Note: this doesn't actually make an http request.
		try {
			xhr.open('GET', global.XDomainRequest ? '/' : 'https://example.com')
		} catch(e) {
			xhr = null
		}
	} else {
		// Service workers don't have XHR
		xhr = null
	}
	return xhr
}

function checkTypeSupport (type) {
	var xhr = getXHR()
	if (!xhr) return false
	try {
		xhr.responseType = type
		return xhr.responseType === type
	} catch (e) {}
	return false
}

// For some strange reason, Safari 7.0 reports typeof global.ArrayBuffer === 'object'.
// Safari 7.1 appears to have fixed this bug.
var haveArrayBuffer = typeof global.ArrayBuffer !== 'undefined'
var haveSlice = haveArrayBuffer && isFunction(global.ArrayBuffer.prototype.slice)

// If fetch is supported, then arraybuffer will be supported too. Skip calling
// checkTypeSupport(), since that calls getXHR().
exports.arraybuffer = exports.fetch || (haveArrayBuffer && checkTypeSupport('arraybuffer'))

// These next two tests unavoidably show warnings in Chrome. Since fetch will always
// be used if it's available, just return false for these to avoid the warnings.
exports.msstream = !exports.fetch && haveSlice && checkTypeSupport('ms-stream')
exports.mozchunkedarraybuffer = !exports.fetch && haveArrayBuffer &&
	checkTypeSupport('moz-chunked-arraybuffer')

// If fetch is supported, then overrideMimeType will be supported too. Skip calling
// getXHR().
exports.overrideMimeType = exports.fetch || (getXHR() ? isFunction(getXHR().overrideMimeType) : false)

exports.vbArray = isFunction(global.VBArray)

function isFunction (value) {
	return typeof value === 'function'
}

xhr = null // Help gc

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(11)))

/***/ }),

/***/ 549:
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process, Buffer, global) {var capability = __webpack_require__(548)
var inherits = __webpack_require__(18)
var stream = __webpack_require__(174)

var rStates = exports.readyStates = {
	UNSENT: 0,
	OPENED: 1,
	HEADERS_RECEIVED: 2,
	LOADING: 3,
	DONE: 4
}

var IncomingMessage = exports.IncomingMessage = function (xhr, response, mode, fetchTimer) {
	var self = this
	stream.Readable.call(self)

	self._mode = mode
	self.headers = {}
	self.rawHeaders = []
	self.trailers = {}
	self.rawTrailers = []

	// Fake the 'close' event, but only once 'end' fires
	self.on('end', function () {
		// The nextTick is necessary to prevent the 'request' module from causing an infinite loop
		process.nextTick(function () {
			self.emit('close')
		})
	})

	if (mode === 'fetch') {
		self._fetchResponse = response

		self.url = response.url
		self.statusCode = response.status
		self.statusMessage = response.statusText
		
		response.headers.forEach(function (header, key){
			self.headers[key.toLowerCase()] = header
			self.rawHeaders.push(key, header)
		})

		if (capability.writableStream) {
			var writable = new WritableStream({
				write: function (chunk) {
					return new Promise(function (resolve, reject) {
						if (self._destroyed) {
							reject()
						} else if(self.push(new Buffer(chunk))) {
							resolve()
						} else {
							self._resumeFetch = resolve
						}
					})
				},
				close: function () {
					global.clearTimeout(fetchTimer)
					if (!self._destroyed)
						self.push(null)
				},
				abort: function (err) {
					if (!self._destroyed)
						self.emit('error', err)
				}
			})

			try {
				response.body.pipeTo(writable).catch(function (err) {
					global.clearTimeout(fetchTimer)
					if (!self._destroyed)
						self.emit('error', err)
				})
				return
			} catch (e) {} // pipeTo method isn't defined. Can't find a better way to feature test this
		}
		// fallback for when writableStream or pipeTo aren't available
		var reader = response.body.getReader()
		function read () {
			reader.read().then(function (result) {
				if (self._destroyed)
					return
				if (result.done) {
					global.clearTimeout(fetchTimer)
					self.push(null)
					return
				}
				self.push(new Buffer(result.value))
				read()
			}).catch(function (err) {
				global.clearTimeout(fetchTimer)
				if (!self._destroyed)
					self.emit('error', err)
			})
		}
		read()
	} else {
		self._xhr = xhr
		self._pos = 0

		self.url = xhr.responseURL
		self.statusCode = xhr.status
		self.statusMessage = xhr.statusText
		var headers = xhr.getAllResponseHeaders().split(/\r?\n/)
		headers.forEach(function (header) {
			var matches = header.match(/^([^:]+):\s*(.*)/)
			if (matches) {
				var key = matches[1].toLowerCase()
				if (key === 'set-cookie') {
					if (self.headers[key] === undefined) {
						self.headers[key] = []
					}
					self.headers[key].push(matches[2])
				} else if (self.headers[key] !== undefined) {
					self.headers[key] += ', ' + matches[2]
				} else {
					self.headers[key] = matches[2]
				}
				self.rawHeaders.push(matches[1], matches[2])
			}
		})

		self._charset = 'x-user-defined'
		if (!capability.overrideMimeType) {
			var mimeType = self.rawHeaders['mime-type']
			if (mimeType) {
				var charsetMatch = mimeType.match(/;\s*charset=([^;])(;|$)/)
				if (charsetMatch) {
					self._charset = charsetMatch[1].toLowerCase()
				}
			}
			if (!self._charset)
				self._charset = 'utf-8' // best guess
		}
	}
}

inherits(IncomingMessage, stream.Readable)

IncomingMessage.prototype._read = function () {
	var self = this

	var resolve = self._resumeFetch
	if (resolve) {
		self._resumeFetch = null
		resolve()
	}
}

IncomingMessage.prototype._onXHRProgress = function () {
	var self = this

	var xhr = self._xhr

	var response = null
	switch (self._mode) {
		case 'text:vbarray': // For IE9
			if (xhr.readyState !== rStates.DONE)
				break
			try {
				// This fails in IE8
				response = new global.VBArray(xhr.responseBody).toArray()
			} catch (e) {}
			if (response !== null) {
				self.push(new Buffer(response))
				break
			}
			// Falls through in IE8	
		case 'text':
			try { // This will fail when readyState = 3 in IE9. Switch mode and wait for readyState = 4
				response = xhr.responseText
			} catch (e) {
				self._mode = 'text:vbarray'
				break
			}
			if (response.length > self._pos) {
				var newData = response.substr(self._pos)
				if (self._charset === 'x-user-defined') {
					var buffer = new Buffer(newData.length)
					for (var i = 0; i < newData.length; i++)
						buffer[i] = newData.charCodeAt(i) & 0xff

					self.push(buffer)
				} else {
					self.push(newData, self._charset)
				}
				self._pos = response.length
			}
			break
		case 'arraybuffer':
			if (xhr.readyState !== rStates.DONE || !xhr.response)
				break
			response = xhr.response
			self.push(new Buffer(new Uint8Array(response)))
			break
		case 'moz-chunked-arraybuffer': // take whole
			response = xhr.response
			if (xhr.readyState !== rStates.LOADING || !response)
				break
			self.push(new Buffer(new Uint8Array(response)))
			break
		case 'ms-stream':
			response = xhr.response
			if (xhr.readyState !== rStates.LOADING)
				break
			var reader = new global.MSStreamReader()
			reader.onprogress = function () {
				if (reader.result.byteLength > self._pos) {
					self.push(new Buffer(new Uint8Array(reader.result.slice(self._pos))))
					self._pos = reader.result.byteLength
				}
			}
			reader.onload = function () {
				self.push(null)
			}
			// reader.onerror = ??? // TODO: this
			reader.readAsArrayBuffer(response)
			break
	}

	// The ms-stream case handles end separately in reader.onload()
	if (self._xhr.readyState === rStates.DONE && self._mode !== 'ms-stream') {
		self.push(null)
	}
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(28), __webpack_require__(4).Buffer, __webpack_require__(11)))

/***/ }),

/***/ 565:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const miscreant = __webpack_require__(1121);
const encoding_1 = __webpack_require__(86);
const curve25519_js_1 = __webpack_require__(1129);
const secureRandom = __webpack_require__(1130);
const axios_1 = __importDefault(__webpack_require__(60));
const hkdf = __webpack_require__(1132);
const cryptoProvider = new miscreant.PolyfillCryptoProvider();
const hkdfSalt = Uint8Array.from([
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x02,
    0x4b,
    0xea,
    0xd8,
    0xdf,
    0x69,
    0x99,
    0x08,
    0x52,
    0xc2,
    0x02,
    0xdb,
    0x0e,
    0x00,
    0x97,
    0xc1,
    0xa1,
    0x2e,
    0xa6,
    0x37,
    0xd7,
    0xe9,
    0x6d,
]);
class EnigmaUtils {
    constructor(apiUrl, seed) {
        this.consensusIoPubKey = new Uint8Array(); // cache
        this.apiUrl = apiUrl;
        if (!seed) {
            this.seed = EnigmaUtils.GenerateNewSeed();
        }
        else {
            this.seed = seed;
        }
        const { privkey, pubkey } = EnigmaUtils.GenerateNewKeyPairFromSeed(this.seed);
        this.privkey = privkey;
        this.pubkey = pubkey;
    }
    static GenerateNewKeyPair() {
        return EnigmaUtils.GenerateNewKeyPairFromSeed(EnigmaUtils.GenerateNewSeed());
    }
    static GenerateNewSeed() {
        return secureRandom(32, { type: "Uint8Array" });
    }
    static GenerateNewKeyPairFromSeed(seed) {
        const { private: privkey, public: pubkey } = curve25519_js_1.generateKeyPair(seed);
        return { privkey, pubkey };
    }
    async getConsensusIoPubKey() {
        if (this.consensusIoPubKey.length === 32) {
            return this.consensusIoPubKey;
        }
        const { data: { result: { TxKey }, }, } = await axios_1.default.get(this.apiUrl + "/reg/tx-key", {
            headers: { "Content-Type": "application/json" },
        });
        this.consensusIoPubKey = encoding_1.Encoding.fromBase64(TxKey);
        return this.consensusIoPubKey;
    }
    async getTxEncryptionKey(nonce) {
        const consensusIoPubKey = await this.getConsensusIoPubKey();
        const txEncryptionIkm = curve25519_js_1.sharedKey(this.privkey, consensusIoPubKey);
        const { key: txEncryptionKey } = await hkdf.compute(Uint8Array.from([...txEncryptionIkm, ...nonce]), "SHA-256", 32, "", hkdfSalt);
        return txEncryptionKey;
    }
    async encrypt(contractCodeHash, msg) {
        const nonce = secureRandom(32, {
            type: "Uint8Array",
        });
        const txEncryptionKey = await this.getTxEncryptionKey(nonce);
        const siv = await miscreant.SIV.importKey(txEncryptionKey, "AES-SIV", cryptoProvider);
        const plaintext = encoding_1.Encoding.toUtf8(contractCodeHash + JSON.stringify(msg));
        const ciphertext = await siv.seal(plaintext, [new Uint8Array()]);
        // ciphertext = nonce(32) || wallet_pubkey(32) || ciphertext
        return Uint8Array.from([...nonce, ...this.pubkey, ...ciphertext]);
    }
    async decrypt(ciphertext, nonce) {
        var _a;
        if (!((_a = ciphertext) === null || _a === void 0 ? void 0 : _a.length)) {
            return new Uint8Array();
        }
        const txEncryptionKey = await this.getTxEncryptionKey(nonce);
        //console.log(`decrypt tx encryption key: ${Encoding.toHex(txEncryptionKey)}`);
        const siv = await miscreant.SIV.importKey(txEncryptionKey, "AES-SIV", cryptoProvider);
        const plaintext = await siv.open(ciphertext, [new Uint8Array()]);
        return plaintext;
    }
    getPubkey() {
        return Promise.resolve(this.pubkey);
    }
}
exports.default = EnigmaUtils;
module.exports = EnigmaUtils;
//# sourceMappingURL=enigmautils.js.map

/***/ }),

/***/ 574:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const _m0 = __importStar(__webpack_require__(9));
function createBaseMsgInstantiateContractResponse() {
    return { address: "", data: new Uint8Array() };
}
exports.MsgInstantiateContractResponse = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.address !== "") {
            writer.uint32(10).string(message.address);
        }
        if (message.data.length !== 0) {
            writer.uint32(18).bytes(message.data);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgInstantiateContractResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.address = reader.string();
                    break;
                case 2:
                    message.data = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            address: isSet(object.address) ? String(object.address) : "",
            data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(),
        };
    },
    toJSON(message) {
        const obj = {};
        message.address !== undefined && (obj.address = message.address);
        message.data !== undefined &&
            (obj.data = base64FromBytes(message.data !== undefined ? message.data : new Uint8Array()));
        return obj;
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseMsgInstantiateContractResponse();
        message.address = (_a = object.address, (_a !== null && _a !== void 0 ? _a : ""));
        message.data = (_b = object.data, (_b !== null && _b !== void 0 ? _b : new Uint8Array()));
        return message;
    },
};
function createBaseMsgExecuteContractResponse() {
    return { data: new Uint8Array() };
}
exports.MsgExecuteContractResponse = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.data.length !== 0) {
            writer.uint32(10).bytes(message.data);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgExecuteContractResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.data = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(),
        };
    },
    toJSON(message) {
        const obj = {};
        message.data !== undefined &&
            (obj.data = base64FromBytes(message.data !== undefined ? message.data : new Uint8Array()));
        return obj;
    },
    fromPartial(object) {
        var _a;
        const message = createBaseMsgExecuteContractResponse();
        message.data = (_a = object.data, (_a !== null && _a !== void 0 ? _a : new Uint8Array()));
        return message;
    },
};
function isSet(value) {
    return value !== null && value !== undefined;
}
const atob = globalThis.atob || ((b64) => globalThis.Buffer.from(b64, "base64").toString("binary"));
const btoa = globalThis.btoa || ((bin) => globalThis.Buffer.from(bin, "binary").toString("base64"));
function base64FromBytes(arr) {
    const bin = [];
    for (const byte of arr) {
        bin.push(String.fromCharCode(byte));
    }
    return btoa(bin.join(""));
}
function bytesFromBase64(b64) {
    const bin = atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
        arr[i] = bin.charCodeAt(i);
    }
    return arr;
}
function createBaseTxMsgData() {
    return { data: [] };
}
exports.TxMsgData = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.data) {
            exports.MsgData.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTxMsgData();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.data.push(exports.MsgData.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        var _a;
        return {
            data: Array.isArray((_a = object) === null || _a === void 0 ? void 0 : _a.data) ? object.data.map((e) => exports.MsgData.fromJSON(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.data) {
            obj.data = message.data.map((e) => (e ? exports.MsgData.toJSON(e) : undefined));
        }
        else {
            obj.data = [];
        }
        return obj;
    },
    fromPartial(object) {
        var _a;
        const message = createBaseTxMsgData();
        message.data = ((_a = object.data) === null || _a === void 0 ? void 0 : _a.map((e) => exports.MsgData.fromPartial(e))) || [];
        return message;
    },
};
function createBaseMsgData() {
    return { msgType: "", data: new Uint8Array() };
}
exports.MsgData = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.msgType !== "") {
            writer.uint32(10).string(message.msgType);
        }
        if (message.data.length !== 0) {
            writer.uint32(18).bytes(message.data);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgData();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.msgType = reader.string();
                    break;
                case 2:
                    message.data = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            msgType: isSet(object.msgType) ? String(object.msgType) : "",
            data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(),
        };
    },
    toJSON(message) {
        const obj = {};
        message.msgType !== undefined && (obj.msgType = message.msgType);
        message.data !== undefined &&
            (obj.data = base64FromBytes(message.data !== undefined ? message.data : new Uint8Array()));
        return obj;
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseMsgData();
        message.msgType = (_a = object.msgType, (_a !== null && _a !== void 0 ? _a : ""));
        message.data = (_b = object.data, (_b !== null && _b !== void 0 ? _b : new Uint8Array()));
        return message;
    },
};
//# sourceMappingURL=v1.4_protos.js.map

/***/ }),

/***/ 575:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const crypto_1 = __webpack_require__(184);
const encoding_1 = __webpack_require__(86);
const logs_1 = __webpack_require__(348);
const restclient_1 = __webpack_require__(351);
function isSearchByIdQuery(query) {
    return query.id !== undefined;
}
function isSearchByHeightQuery(query) {
    return query.height !== undefined;
}
function isSearchBySentFromOrToQuery(query) {
    return query.sentFromOrTo !== undefined;
}
function isSearchByTagsQuery(query) {
    return query.tags !== undefined;
}
class CosmWasmClient {
    /**
     * Creates a new client to interact with a CosmWasm blockchain.
     *
     * This instance does a lot of caching. In order to benefit from that you should try to use one instance
     * for the lifetime of your application. When switching backends, a new instance must be created.
     *
     * @param apiUrl The URL of a Cosmos SDK light client daemon API (sometimes called REST server or REST API)
     * @param broadcastMode Defines at which point of the transaction processing the postTx method (i.e. transaction broadcasting) returns
     */
    constructor(apiUrl, seed, broadcastMode = restclient_1.BroadcastMode.Block) {
        this.codesCache = new Map();
        this.restClient = new restclient_1.RestClient(apiUrl, broadcastMode, seed);
    }
    async getChainId() {
        if (!this.chainId) {
            const response = await this.restClient.nodeInfo();
            const chainId = response.node_info.network;
            if (!chainId)
                throw new Error("Chain ID must not be empty");
            this.chainId = chainId;
        }
        return this.chainId;
    }
    async getHeight() {
        if (this.anyValidAddress) {
            const { height } = await this.restClient.authAccounts(this.anyValidAddress);
            return parseInt(height, 10);
        }
        else {
            // Note: this gets inefficient when blocks contain a lot of transactions since it
            // requires downloading and deserializing all transactions in the block.
            const latest = await this.restClient.blocksLatest();
            return parseInt(latest.block.header.height, 10);
        }
    }
    /**
     * Returns a 32 byte upper-case hex transaction hash (typically used as the transaction ID)
     */
    async getIdentifier(tx) {
        // We consult the REST API because we don't have a local amino encoder
        const bytes = await this.restClient.encodeTx(tx);
        const hash = new crypto_1.Sha256(bytes).digest();
        return encoding_1.Encoding.toHex(hash).toUpperCase();
    }
    /**
     * Returns account number and sequence.
     *
     * Throws if the account does not exist on chain.
     *
     * @param address returns data for this address. When unset, the client's sender adddress is used.
     */
    async getNonce(address) {
        const account = await this.getAccount(address);
        if (!account || !account.address) {
            throw new Error("Account does not exist on chain. Send some tokens there before trying to query nonces.");
        }
        return {
            accountNumber: account.accountNumber,
            sequence: account.sequence,
        };
    }
    async getAccount(address) {
        var _a;
        const account = await this.restClient.authAccounts(address);
        const value = account.result.value;
        if (value.address === undefined || value.address === "") {
            return undefined;
        }
        else {
            this.anyValidAddress = value.address;
            return {
                address: value.address,
                balance: value.coins,
                pubkey: !!((_a = value) === null || _a === void 0 ? void 0 : _a.public_key) ? JSON.parse(value.public_key) : undefined,
                accountNumber: value.account_number,
                sequence: value.sequence,
            };
        }
    }
    /**
     * Gets block header and meta
     *
     * @param height The height of the block. If undefined, the latest height is used.
     */
    async getBlock(height) {
        const response = height !== undefined ? await this.restClient.blocks(height) : await this.restClient.blocksLatest();
        return {
            id: response.block_id.hash,
            header: {
                version: response.block.header.version,
                time: response.block.header.time,
                height: parseInt(response.block.header.height, 10),
                chainId: response.block.header.chain_id,
            },
            txs: (response.block.data.txs || []).map((encoded) => encoding_1.Encoding.fromBase64(encoded)),
        };
    }
    async searchTx(query, filter = {}) {
        const minHeight = filter.minHeight || 0;
        const maxHeight = filter.maxHeight || Number.MAX_SAFE_INTEGER;
        if (maxHeight < minHeight)
            return []; // optional optimization
        function withFilters(originalQuery) {
            return `${originalQuery}&tx.minheight=${minHeight}&tx.maxheight=${maxHeight}`;
        }
        let txs;
        if (isSearchByIdQuery(query)) {
            txs = await this.txsQuery(`tx.hash=${query.id}`);
        }
        else if (isSearchByHeightQuery(query)) {
            // optional optimization to avoid network request
            if (query.height < minHeight || query.height > maxHeight) {
                txs = [];
            }
            else {
                txs = await this.txsQuery(`tx.height=${query.height}`);
            }
        }
        else if (isSearchBySentFromOrToQuery(query)) {
            // We cannot get both in one request (see https://github.com/cosmos/gaia/issues/75)
            const sentQuery = withFilters(`message.module=bank&message.sender=${query.sentFromOrTo}`);
            const receivedQuery = withFilters(`message.module=bank&transfer.recipient=${query.sentFromOrTo}`);
            const sent = await this.txsQuery(sentQuery);
            const received = await this.txsQuery(receivedQuery);
            const sentHashes = sent.map((t) => t.hash);
            txs = [...sent, ...received.filter((t) => !sentHashes.includes(t.hash))];
        }
        else if (isSearchByTagsQuery(query)) {
            const rawQuery = withFilters(query.tags.map((t) => `${t.key}=${t.value}`).join("&"));
            txs = await this.txsQuery(rawQuery);
        }
        else {
            throw new Error("Unknown query type");
        }
        // backend sometimes messes up with min/max height filtering
        const filtered = txs.filter((tx) => tx.height >= minHeight && tx.height <= maxHeight);
        return filtered;
    }
    async postTx(tx) {
        const result = await this.restClient.postTx(tx);
        if (!result.txhash.match(/^([0-9A-F][0-9A-F])+$/)) {
            throw new Error("Received ill-formatted txhash. Must be non-empty upper-case hex");
        }
        if (result.code) {
            throw new Error(`Error when posting tx ${result.txhash}. Code: ${result.code}; Raw log: ${result.raw_log}`);
        }
        return {
            logs: result.logs ? logs_1.parseLogs(result.logs) : [],
            rawLog: result.raw_log || "",
            transactionHash: result.txhash,
            data: result.data || "",
        };
    }
    async getCodes() {
        const result = await this.restClient.listCodeInfo();
        return result.map((entry) => {
            this.anyValidAddress = entry.creator;
            return {
                id: entry.code_id,
                creator: entry.creator,
                checksum: encoding_1.Encoding.toHex(encoding_1.Encoding.fromHex(entry.code_hash)),
                source: entry.source || undefined,
                builder: entry.builder || undefined,
            };
        });
    }
    async getCodeDetails(codeId) {
        const cached = this.codesCache.get(codeId);
        if (cached)
            return cached;
        const getCodeResult = await this.restClient.getCode(codeId);
        const codeDetails = {
            id: getCodeResult.code_id,
            creator: getCodeResult.creator,
            checksum: encoding_1.Encoding.toHex(encoding_1.Encoding.fromHex(getCodeResult.code_hash)),
            source: getCodeResult.source || undefined,
            builder: getCodeResult.builder || undefined,
            data: encoding_1.Encoding.fromBase64(getCodeResult.wasm),
        };
        this.codesCache.set(codeId, codeDetails);
        return codeDetails;
    }
    async getContracts(codeId) {
        const result = await this.restClient.listContractsByCodeId(codeId);
        return result.map((entry) => ({
            address: entry.contract_address,
            codeId: entry.code_id,
            creator: entry.creator,
            label: entry.label,
        }));
    }
    /**
     * Throws an error if no contract was found at the address
     */
    async getContract(address) {
        const result = await this.restClient.getContractInfo(address);
        if (!result)
            throw new Error(`No contract found at address "${address}"`);
        return {
            address: result.contract_address,
            codeId: result.code_id,
            creator: result.creator,
            label: result.label,
            initMsg: result.init_msg,
        };
    }
    /**
     * Makes a smart query on the contract, returns the parsed JSON document.
     *
     * Promise is rejected when contract does not exist.
     * Promise is rejected for invalid query format.
     * Promise is rejected for invalid response format.
     *
     * Note: addedParams allows for query string additions such as "&height=1234567"
     */
    async queryContractSmart(contractAddress, queryMsg, addedParams, contractCodeHash) {
        try {
            return await this.restClient.queryContractSmart(contractAddress, queryMsg, addedParams, contractCodeHash);
        }
        catch (error) {
            if (error instanceof Error) {
                if (error.message.startsWith("not found: contract")) {
                    throw new Error(`No contract found at address "${contractAddress}"`);
                }
                else {
                    throw error;
                }
            }
            else {
                throw error;
            }
        }
    }
    async txsQuery(query) {
        // TODO: we need proper pagination support
        const limit = 100;
        const result = await this.restClient.txsQuery(`${query}&limit=${limit}`);
        const pages = parseInt(result.page_total, 10);
        if (pages > 1) {
            throw new Error(`Found more results on the backend than we can process currently. Results: ${result.total_count}, supported: ${limit}`);
        }
        return result.txs.map((restItem) => ({
            height: parseInt(restItem.height, 10),
            hash: restItem.txhash,
            code: restItem.code || 0,
            rawLog: restItem.raw_log,
            logs: logs_1.parseLogs(restItem.logs || []),
            tx: restItem.tx,
            timestamp: restItem.timestamp,
        }));
    }
    getCodeHashByCodeId(id) {
        return this.restClient.getCodeHashByCodeId(id);
    }
    getCodeHashByContractAddr(addr) {
        return this.restClient.getCodeHashByContractAddr(addr);
    }
    async getNonceByTxId(txhash) {
        const txResponse = await this.restClient.txById(txhash, false);
        const msgs = txResponse.tx.value.msg;
        const result = [];
        for (const msg of msgs) {
            let nonce;
            if (msg.type === "wasm/MsgExecuteContract") {
                nonce = encoding_1.Encoding.fromBase64(msg.value.msg).slice(0, 32);
            }
            else if (msg.type === "wasm/MsgInstantiateContract") {
                nonce = encoding_1.Encoding.fromBase64(msg.value.init_msg).slice(0, 32);
            }
            else {
                nonce = null;
            }
            result.push(nonce);
        }
        return result;
    }
}
exports.CosmWasmClient = CosmWasmClient;
//# sourceMappingURL=cosmwasmclient.js.map

/***/ }),

/***/ 576:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const encoding_1 = __webpack_require__(86);
const fast_deep_equal_1 = __importDefault(__webpack_require__(1161));
const types_1 = __webpack_require__(183);
function encodeSecp256k1Pubkey(pubkey) {
    if (pubkey.length !== 33 || (pubkey[0] !== 0x02 && pubkey[0] !== 0x03)) {
        throw new Error("Public key must be compressed secp256k1, i.e. 33 bytes starting with 0x02 or 0x03");
    }
    return {
        type: types_1.pubkeyType.secp256k1,
        value: encoding_1.Encoding.toBase64(pubkey),
    };
}
exports.encodeSecp256k1Pubkey = encodeSecp256k1Pubkey;
// As discussed in https://github.com/binance-chain/javascript-sdk/issues/163
// Prefixes listed here: https://github.com/tendermint/tendermint/blob/d419fffe18531317c28c29a292ad7d253f6cafdf/docs/spec/blockchain/encoding.md#public-key-cryptography
// Last bytes is varint-encoded length prefix
const pubkeyAminoPrefixSecp256k1 = encoding_1.Encoding.fromHex("eb5ae98721");
const pubkeyAminoPrefixEd25519 = encoding_1.Encoding.fromHex("1624de6420");
const pubkeyAminoPrefixSr25519 = encoding_1.Encoding.fromHex("0dfb1005");
const pubkeyAminoPrefixLength = pubkeyAminoPrefixSecp256k1.length;
function decodeBech32Pubkey(bechEncoded) {
    const { data } = encoding_1.Bech32.decode(bechEncoded);
    const aminoPrefix = data.slice(0, pubkeyAminoPrefixLength);
    const rest = data.slice(pubkeyAminoPrefixLength);
    if (fast_deep_equal_1.default(aminoPrefix, pubkeyAminoPrefixSecp256k1)) {
        if (rest.length !== 33) {
            throw new Error("Invalid rest data length. Expected 33 bytes (compressed secp256k1 pubkey).");
        }
        return {
            type: types_1.pubkeyType.secp256k1,
            value: encoding_1.Encoding.toBase64(rest),
        };
    }
    else if (fast_deep_equal_1.default(aminoPrefix, pubkeyAminoPrefixEd25519)) {
        if (rest.length !== 32) {
            throw new Error("Invalid rest data length. Expected 32 bytes (Ed25519 pubkey).");
        }
        return {
            type: types_1.pubkeyType.ed25519,
            value: encoding_1.Encoding.toBase64(rest),
        };
    }
    else if (fast_deep_equal_1.default(aminoPrefix, pubkeyAminoPrefixSr25519)) {
        if (rest.length !== 32) {
            throw new Error("Invalid rest data length. Expected 32 bytes (Sr25519 pubkey).");
        }
        return {
            type: types_1.pubkeyType.sr25519,
            value: encoding_1.Encoding.toBase64(rest),
        };
    }
    else {
        throw new Error("Unsupported Pubkey type. Amino prefix: " + encoding_1.Encoding.toHex(aminoPrefix));
    }
}
exports.decodeBech32Pubkey = decodeBech32Pubkey;
function encodeBech32Pubkey(pubkey, prefix) {
    let aminoPrefix;
    switch (pubkey.type) {
        // Note: please don't add cases here without writing additional unit tests
        case types_1.pubkeyType.secp256k1:
            aminoPrefix = pubkeyAminoPrefixSecp256k1;
            break;
        default:
            throw new Error("Unsupported pubkey type");
    }
    const data = new Uint8Array([...aminoPrefix, ...encoding_1.Encoding.fromBase64(pubkey.value)]);
    return encoding_1.Bech32.encode(prefix, data);
}
exports.encodeBech32Pubkey = encodeBech32Pubkey;
//# sourceMappingURL=pubkey.js.map

/***/ }),

/***/ 710:
/***/ (function(module, exports, __webpack_require__) {

/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-0, as defined
 * in FIPS PUB 180-1
 * This source code is derived from sha1.js of the same repository.
 * The difference between SHA-0 and SHA-1 is just a bitwise rotate left
 * operation was added.
 */

var inherits = __webpack_require__(18)
var Hash = __webpack_require__(145)
var Buffer = __webpack_require__(22).Buffer

var K = [
  0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0
]

var W = new Array(80)

function Sha () {
  this.init()
  this._w = W

  Hash.call(this, 64, 56)
}

inherits(Sha, Hash)

Sha.prototype.init = function () {
  this._a = 0x67452301
  this._b = 0xefcdab89
  this._c = 0x98badcfe
  this._d = 0x10325476
  this._e = 0xc3d2e1f0

  return this
}

function rotl5 (num) {
  return (num << 5) | (num >>> 27)
}

function rotl30 (num) {
  return (num << 30) | (num >>> 2)
}

function ft (s, b, c, d) {
  if (s === 0) return (b & c) | ((~b) & d)
  if (s === 2) return (b & c) | (b & d) | (c & d)
  return b ^ c ^ d
}

Sha.prototype._update = function (M) {
  var W = this._w

  var a = this._a | 0
  var b = this._b | 0
  var c = this._c | 0
  var d = this._d | 0
  var e = this._e | 0

  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)
  for (; i < 80; ++i) W[i] = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16]

  for (var j = 0; j < 80; ++j) {
    var s = ~~(j / 20)
    var t = (rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s]) | 0

    e = d
    d = c
    c = rotl30(b)
    b = a
    a = t
  }

  this._a = (a + this._a) | 0
  this._b = (b + this._b) | 0
  this._c = (c + this._c) | 0
  this._d = (d + this._d) | 0
  this._e = (e + this._e) | 0
}

Sha.prototype._hash = function () {
  var H = Buffer.allocUnsafe(20)

  H.writeInt32BE(this._a | 0, 0)
  H.writeInt32BE(this._b | 0, 4)
  H.writeInt32BE(this._c | 0, 8)
  H.writeInt32BE(this._d | 0, 12)
  H.writeInt32BE(this._e | 0, 16)

  return H
}

module.exports = Sha


/***/ }),

/***/ 711:
/***/ (function(module, exports, __webpack_require__) {

/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS PUB 180-1
 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for details.
 */

var inherits = __webpack_require__(18)
var Hash = __webpack_require__(145)
var Buffer = __webpack_require__(22).Buffer

var K = [
  0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0
]

var W = new Array(80)

function Sha1 () {
  this.init()
  this._w = W

  Hash.call(this, 64, 56)
}

inherits(Sha1, Hash)

Sha1.prototype.init = function () {
  this._a = 0x67452301
  this._b = 0xefcdab89
  this._c = 0x98badcfe
  this._d = 0x10325476
  this._e = 0xc3d2e1f0

  return this
}

function rotl1 (num) {
  return (num << 1) | (num >>> 31)
}

function rotl5 (num) {
  return (num << 5) | (num >>> 27)
}

function rotl30 (num) {
  return (num << 30) | (num >>> 2)
}

function ft (s, b, c, d) {
  if (s === 0) return (b & c) | ((~b) & d)
  if (s === 2) return (b & c) | (b & d) | (c & d)
  return b ^ c ^ d
}

Sha1.prototype._update = function (M) {
  var W = this._w

  var a = this._a | 0
  var b = this._b | 0
  var c = this._c | 0
  var d = this._d | 0
  var e = this._e | 0

  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)
  for (; i < 80; ++i) W[i] = rotl1(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16])

  for (var j = 0; j < 80; ++j) {
    var s = ~~(j / 20)
    var t = (rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s]) | 0

    e = d
    d = c
    c = rotl30(b)
    b = a
    a = t
  }

  this._a = (a + this._a) | 0
  this._b = (b + this._b) | 0
  this._c = (c + this._c) | 0
  this._d = (d + this._d) | 0
  this._e = (e + this._e) | 0
}

Sha1.prototype._hash = function () {
  var H = Buffer.allocUnsafe(20)

  H.writeInt32BE(this._a | 0, 0)
  H.writeInt32BE(this._b | 0, 4)
  H.writeInt32BE(this._c | 0, 8)
  H.writeInt32BE(this._d | 0, 12)
  H.writeInt32BE(this._e | 0, 16)

  return H
}

module.exports = Sha1


/***/ }),

/***/ 712:
/***/ (function(module, exports, __webpack_require__) {

/**
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
 * in FIPS 180-2
 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 *
 */

var inherits = __webpack_require__(18)
var Sha256 = __webpack_require__(412)
var Hash = __webpack_require__(145)
var Buffer = __webpack_require__(22).Buffer

var W = new Array(64)

function Sha224 () {
  this.init()

  this._w = W // new Array(64)

  Hash.call(this, 64, 56)
}

inherits(Sha224, Sha256)

Sha224.prototype.init = function () {
  this._a = 0xc1059ed8
  this._b = 0x367cd507
  this._c = 0x3070dd17
  this._d = 0xf70e5939
  this._e = 0xffc00b31
  this._f = 0x68581511
  this._g = 0x64f98fa7
  this._h = 0xbefa4fa4

  return this
}

Sha224.prototype._hash = function () {
  var H = Buffer.allocUnsafe(28)

  H.writeInt32BE(this._a, 0)
  H.writeInt32BE(this._b, 4)
  H.writeInt32BE(this._c, 8)
  H.writeInt32BE(this._d, 12)
  H.writeInt32BE(this._e, 16)
  H.writeInt32BE(this._f, 20)
  H.writeInt32BE(this._g, 24)

  return H
}

module.exports = Sha224


/***/ }),

/***/ 713:
/***/ (function(module, exports, __webpack_require__) {

var inherits = __webpack_require__(18)
var SHA512 = __webpack_require__(413)
var Hash = __webpack_require__(145)
var Buffer = __webpack_require__(22).Buffer

var W = new Array(160)

function Sha384 () {
  this.init()
  this._w = W

  Hash.call(this, 128, 112)
}

inherits(Sha384, SHA512)

Sha384.prototype.init = function () {
  this._ah = 0xcbbb9d5d
  this._bh = 0x629a292a
  this._ch = 0x9159015a
  this._dh = 0x152fecd8
  this._eh = 0x67332667
  this._fh = 0x8eb44a87
  this._gh = 0xdb0c2e0d
  this._hh = 0x47b5481d

  this._al = 0xc1059ed8
  this._bl = 0x367cd507
  this._cl = 0x3070dd17
  this._dl = 0xf70e5939
  this._el = 0xffc00b31
  this._fl = 0x68581511
  this._gl = 0x64f98fa7
  this._hl = 0xbefa4fa4

  return this
}

Sha384.prototype._hash = function () {
  var H = Buffer.allocUnsafe(48)

  function writeInt64BE (h, l, offset) {
    H.writeInt32BE(h, offset)
    H.writeInt32BE(l, offset + 4)
  }

  writeInt64BE(this._ah, this._al, 0)
  writeInt64BE(this._bh, this._bl, 8)
  writeInt64BE(this._ch, this._cl, 16)
  writeInt64BE(this._dh, this._dl, 24)
  writeInt64BE(this._eh, this._el, 32)
  writeInt64BE(this._fh, this._fl, 40)

  return H
}

module.exports = Sha384


/***/ }),

/***/ 717:
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {
    "use strict";

    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var registerImmediate;

    function setImmediate(callback) {
      // Callback can either be a function or a string
      if (typeof callback !== "function") {
        callback = new Function("" + callback);
      }
      // Copy function arguments
      var args = new Array(arguments.length - 1);
      for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i + 1];
      }
      // Store and register the task
      var task = { callback: callback, args: args };
      tasksByHandle[nextHandle] = task;
      registerImmediate(nextHandle);
      return nextHandle++;
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function run(task) {
        var callback = task.callback;
        var args = task.args;
        switch (args.length) {
        case 0:
            callback();
            break;
        case 1:
            callback(args[0]);
            break;
        case 2:
            callback(args[0], args[1]);
            break;
        case 3:
            callback(args[0], args[1], args[2]);
            break;
        default:
            callback.apply(undefined, args);
            break;
        }
    }

    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // "too much recursion" error.
            setTimeout(runIfPresent, 0, handle);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    run(task);
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    function installNextTickImplementation() {
        registerImmediate = function(handle) {
            process.nextTick(function () { runIfPresent(handle); });
        };
    }

    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function() {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }

    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function(event) {
            if (event.source === global &&
                typeof event.data === "string" &&
                event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        if (global.addEventListener) {
            global.addEventListener("message", onGlobalMessage, false);
        } else {
            global.attachEvent("onmessage", onGlobalMessage);
        }

        registerImmediate = function(handle) {
            global.postMessage(messagePrefix + handle, "*");
        };
    }

    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function(event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        registerImmediate = function(handle) {
            channel.port2.postMessage(handle);
        };
    }

    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        registerImmediate = function(handle) {
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function () {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
        };
    }

    function installSetTimeoutImplementation() {
        registerImmediate = function(handle) {
            setTimeout(runIfPresent, 0, handle);
        };
    }

    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    // Don't get fooled by e.g. browserify environments.
    if ({}.toString.call(global.process) === "[object process]") {
        // For Node.js before 0.9
        installNextTickImplementation();

    } else if (canUsePostMessage()) {
        // For non-IE10 modern browsers
        installPostMessageImplementation();

    } else if (global.MessageChannel) {
        // For web workers, where supported
        installMessageChannelImplementation();

    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        // For IE 68
        installReadyStateChangeImplementation();

    } else {
        // For older browsers
        installSetTimeoutImplementation();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
}(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(11), __webpack_require__(28)))

/***/ }),

/***/ 740:
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {const BN = __webpack_require__(34)
const EC = __webpack_require__(97).ec
const secp256k1 = new EC('secp256k1')
const deterministicGenerateK = __webpack_require__(760)

const ZERO32 = Buffer.alloc(32, 0)
const EC_GROUP_ORDER = Buffer.from('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141', 'hex')
const EC_P = Buffer.from('fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f', 'hex')

const n = secp256k1.curve.n
const nDiv2 = n.shrn(1)
const G = secp256k1.curve.g

const THROW_BAD_PRIVATE = 'Expected Private'
const THROW_BAD_POINT = 'Expected Point'
const THROW_BAD_TWEAK = 'Expected Tweak'
const THROW_BAD_HASH = 'Expected Hash'
const THROW_BAD_SIGNATURE = 'Expected Signature'
const THROW_BAD_EXTRA_DATA = 'Expected Extra Data (32 bytes)'

function isScalar (x) {
  return Buffer.isBuffer(x) && x.length === 32
}

function isOrderScalar (x) {
  if (!isScalar(x)) return false
  return x.compare(EC_GROUP_ORDER) < 0 // < G
}

function isPoint (p) {
  if (!Buffer.isBuffer(p)) return false
  if (p.length < 33) return false

  const t = p[0]
  const x = p.slice(1, 33)
  if (x.compare(ZERO32) === 0) return false
  if (x.compare(EC_P) >= 0) return false
  if ((t === 0x02 || t === 0x03) && p.length === 33) {
    try { decodeFrom(p) } catch (e) { return false } // TODO: temporary
    return true
  }

  const y = p.slice(33)
  if (y.compare(ZERO32) === 0) return false
  if (y.compare(EC_P) >= 0) return false
  if (t === 0x04 && p.length === 65) return true
  return false
}

function __isPointCompressed (p) {
  return p[0] !== 0x04
}

function isPointCompressed (p) {
  if (!isPoint(p)) return false
  return __isPointCompressed(p)
}

function isPrivate (x) {
  if (!isScalar(x)) return false
  return x.compare(ZERO32) > 0 && // > 0
    x.compare(EC_GROUP_ORDER) < 0 // < G
}

function isSignature (value) {
  const r = value.slice(0, 32)
  const s = value.slice(32, 64)
  return Buffer.isBuffer(value) && value.length === 64 &&
    r.compare(EC_GROUP_ORDER) < 0 &&
    s.compare(EC_GROUP_ORDER) < 0
}

function assumeCompression (value, pubkey) {
  if (value === undefined && pubkey !== undefined) return __isPointCompressed(pubkey)
  if (value === undefined) return true
  return value
}

function fromBuffer (d) { return new BN(d) }
function toBuffer (d) { return d.toArrayLike(Buffer, 'be', 32) }
function decodeFrom (P) { return secp256k1.curve.decodePoint(P) }
function getEncoded (P, compressed) { return Buffer.from(P._encode(compressed)) }

function pointAdd (pA, pB, __compressed) {
  if (!isPoint(pA)) throw new TypeError(THROW_BAD_POINT)
  if (!isPoint(pB)) throw new TypeError(THROW_BAD_POINT)

  const a = decodeFrom(pA)
  const b = decodeFrom(pB)
  const pp = a.add(b)
  if (pp.isInfinity()) return null

  const compressed = assumeCompression(__compressed, pA)
  return getEncoded(pp, compressed)
}

function pointAddScalar (p, tweak, __compressed) {
  if (!isPoint(p)) throw new TypeError(THROW_BAD_POINT)
  if (!isOrderScalar(tweak)) throw new TypeError(THROW_BAD_TWEAK)

  const compressed = assumeCompression(__compressed, p)
  const pp = decodeFrom(p)
  if (tweak.compare(ZERO32) === 0) return getEncoded(pp, compressed)

  const tt = fromBuffer(tweak)
  const qq = G.mul(tt)
  const uu = pp.add(qq)
  if (uu.isInfinity()) return null

  return getEncoded(uu, compressed)
}

function pointCompress (p, __compressed) {
  if (!isPoint(p)) throw new TypeError(THROW_BAD_POINT)

  const pp = decodeFrom(p)
  if (pp.isInfinity()) throw new TypeError(THROW_BAD_POINT)

  const compressed = assumeCompression(__compressed, p)

  return getEncoded(pp, compressed)
}

function pointFromScalar (d, __compressed) {
  if (!isPrivate(d)) throw new TypeError(THROW_BAD_PRIVATE)

  const dd = fromBuffer(d)
  const pp = G.mul(dd)
  if (pp.isInfinity()) return null

  const compressed = assumeCompression(__compressed)
  return getEncoded(pp, compressed)
}

function pointMultiply (p, tweak, __compressed) {
  if (!isPoint(p)) throw new TypeError(THROW_BAD_POINT)
  if (!isOrderScalar(tweak)) throw new TypeError(THROW_BAD_TWEAK)

  const compressed = assumeCompression(__compressed, p)
  const pp = decodeFrom(p)
  const tt = fromBuffer(tweak)
  const qq = pp.mul(tt)
  if (qq.isInfinity()) return null

  return getEncoded(qq, compressed)
}

function privateAdd (d, tweak) {
  if (!isPrivate(d)) throw new TypeError(THROW_BAD_PRIVATE)
  if (!isOrderScalar(tweak)) throw new TypeError(THROW_BAD_TWEAK)

  const dd = fromBuffer(d)
  const tt = fromBuffer(tweak)
  const dt = toBuffer(dd.add(tt).umod(n))
  if (!isPrivate(dt)) return null

  return dt
}

function privateSub (d, tweak) {
  if (!isPrivate(d)) throw new TypeError(THROW_BAD_PRIVATE)
  if (!isOrderScalar(tweak)) throw new TypeError(THROW_BAD_TWEAK)

  const dd = fromBuffer(d)
  const tt = fromBuffer(tweak)
  const dt = toBuffer(dd.sub(tt).umod(n))
  if (!isPrivate(dt)) return null

  return dt
}

function sign (hash, x) {
  return __sign(hash, x)
}

function signWithEntropy (hash, x, addData) {
  return __sign(hash, x, addData)
}

function __sign (hash, x, addData) {
  if (!isScalar(hash)) throw new TypeError(THROW_BAD_HASH)
  if (!isPrivate(x)) throw new TypeError(THROW_BAD_PRIVATE)
  if (addData !== undefined && !isScalar(addData)) throw new TypeError(THROW_BAD_EXTRA_DATA)

  const d = fromBuffer(x)
  const e = fromBuffer(hash)

  let r, s
  const checkSig = function (k) {
    const kI = fromBuffer(k)
    const Q = G.mul(kI)

    if (Q.isInfinity()) return false

    r = Q.x.umod(n)
    if (r.isZero() === 0) return false

    s = kI
      .invm(n)
      .mul(e.add(d.mul(r)))
      .umod(n)
    if (s.isZero() === 0) return false

    return true
  }

  deterministicGenerateK(hash, x, checkSig, isPrivate, addData)

  // enforce low S values, see bip62: 'low s values in signatures'
  if (s.cmp(nDiv2) > 0) {
    s = n.sub(s)
  }

  const buffer = Buffer.allocUnsafe(64)
  toBuffer(r).copy(buffer, 0)
  toBuffer(s).copy(buffer, 32)
  return buffer
}

function verify (hash, q, signature, strict) {
  if (!isScalar(hash)) throw new TypeError(THROW_BAD_HASH)
  if (!isPoint(q)) throw new TypeError(THROW_BAD_POINT)

  // 1.4.1 Enforce r and s are both integers in the interval [1, n  1] (1, isSignature enforces '< n - 1')
  if (!isSignature(signature)) throw new TypeError(THROW_BAD_SIGNATURE)

  const Q = decodeFrom(q)
  const r = fromBuffer(signature.slice(0, 32))
  const s = fromBuffer(signature.slice(32, 64))

  if (strict && s.cmp(nDiv2) > 0) {
    return false
  }

  // 1.4.1 Enforce r and s are both integers in the interval [1, n  1] (2, enforces '> 0')
  if (r.gtn(0) <= 0 /* || r.compareTo(n) >= 0 */) return false
  if (s.gtn(0) <= 0 /* || s.compareTo(n) >= 0 */) return false

  // 1.4.2 H = Hash(M), already done by the user
  // 1.4.3 e = H
  const e = fromBuffer(hash)

  // Compute s^-1
  const sInv = s.invm(n)

  // 1.4.4 Compute u1 = es^1 mod n
  //               u2 = rs^1 mod n
  const u1 = e.mul(sInv).umod(n)
  const u2 = r.mul(sInv).umod(n)

  // 1.4.5 Compute R = (xR, yR)
  //               R = u1G + u2Q
  const R = G.mulAdd(u1, Q, u2)

  // 1.4.5 (cont.) Enforce R is not at infinity
  if (R.isInfinity()) return false

  // 1.4.6 Convert the field element R.x to an integer
  const xR = R.x

  // 1.4.7 Set v = xR mod n
  const v = xR.umod(n)

  // 1.4.8 If v = r, output "valid", and if v != r, output "invalid"
  return v.eq(r)
}

module.exports = {
  isPoint,
  isPointCompressed,
  isPrivate,
  pointAdd,
  pointAddScalar,
  pointCompress,
  pointFromScalar,
  pointMultiply,
  privateAdd,
  privateSub,
  sign,
  signWithEntropy,
  verify
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(4).Buffer))

/***/ }),

/***/ 760:
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {const createHmac = __webpack_require__(213)

const ONE1 = Buffer.alloc(1, 1)
const ZERO1 = Buffer.alloc(1, 0)

// https://tools.ietf.org/html/rfc6979#section-3.2
function deterministicGenerateK (hash, x, checkSig, isPrivate, extraEntropy) {
  // Step A, ignored as hash already provided
  // Step B
  // Step C
  let k = Buffer.alloc(32, 0)
  let v = Buffer.alloc(32, 1)

  // Step D
  k = createHmac('sha256', k)
    .update(v)
    .update(ZERO1)
    .update(x)
    .update(hash)
    .update(extraEntropy || '')
    .digest()

  // Step E
  v = createHmac('sha256', k).update(v).digest()

  // Step F
  k = createHmac('sha256', k)
    .update(v)
    .update(ONE1)
    .update(x)
    .update(hash)
    .update(extraEntropy || '')
    .digest()

  // Step G
  v = createHmac('sha256', k).update(v).digest()

  // Step H1/H2a, ignored as tlen === qlen (256 bit)
  // Step H2b
  v = createHmac('sha256', k).update(v).digest()

  let T = v

  // Step H3, repeat until T is within the interval [1, n - 1] and is suitable for ECDSA
  while (!isPrivate(T) || !checkSig(T)) {
    k = createHmac('sha256', k)
      .update(v)
      .update(ZERO1)
      .digest()

    v = createHmac('sha256', k).update(v).digest()

    // Step H1/H2a, again, ignored as tlen === qlen (256 bit)
    // Step H2b again
    v = createHmac('sha256', k).update(v).digest()
    T = v
  }

  return T
}

module.exports = deterministicGenerateK

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(4).Buffer))

/***/ }),

/***/ 761:
/***/ (function(module, exports, __webpack_require__) {

var ERRORS = __webpack_require__(429)
var NATIVE = __webpack_require__(294)

// short-hand
var tfJSON = ERRORS.tfJSON
var TfTypeError = ERRORS.TfTypeError
var TfPropertyTypeError = ERRORS.TfPropertyTypeError
var tfSubError = ERRORS.tfSubError
var getValueTypeName = ERRORS.getValueTypeName

var TYPES = {
  arrayOf: function arrayOf (type, options) {
    type = compile(type)
    options = options || {}

    function _arrayOf (array, strict) {
      if (!NATIVE.Array(array)) return false
      if (NATIVE.Nil(array)) return false
      if (options.minLength !== undefined && array.length < options.minLength) return false
      if (options.maxLength !== undefined && array.length > options.maxLength) return false
      if (options.length !== undefined && array.length !== options.length) return false

      return array.every(function (value, i) {
        try {
          return typeforce(type, value, strict)
        } catch (e) {
          throw tfSubError(e, i)
        }
      })
    }
    _arrayOf.toJSON = function () {
      var str = '[' + tfJSON(type) + ']'
      if (options.length !== undefined) {
        str += '{' + options.length + '}'
      } else if (options.minLength !== undefined || options.maxLength !== undefined) {
        str += '{' +
          (options.minLength === undefined ? 0 : options.minLength) + ',' +
          (options.maxLength === undefined ? Infinity : options.maxLength) + '}'
      }
      return str
    }

    return _arrayOf
  },

  maybe: function maybe (type) {
    type = compile(type)

    function _maybe (value, strict) {
      return NATIVE.Nil(value) || type(value, strict, maybe)
    }
    _maybe.toJSON = function () { return '?' + tfJSON(type) }

    return _maybe
  },

  map: function map (propertyType, propertyKeyType) {
    propertyType = compile(propertyType)
    if (propertyKeyType) propertyKeyType = compile(propertyKeyType)

    function _map (value, strict) {
      if (!NATIVE.Object(value)) return false
      if (NATIVE.Nil(value)) return false

      for (var propertyName in value) {
        try {
          if (propertyKeyType) {
            typeforce(propertyKeyType, propertyName, strict)
          }
        } catch (e) {
          throw tfSubError(e, propertyName, 'key')
        }

        try {
          var propertyValue = value[propertyName]
          typeforce(propertyType, propertyValue, strict)
        } catch (e) {
          throw tfSubError(e, propertyName)
        }
      }

      return true
    }

    if (propertyKeyType) {
      _map.toJSON = function () {
        return '{' + tfJSON(propertyKeyType) + ': ' + tfJSON(propertyType) + '}'
      }
    } else {
      _map.toJSON = function () { return '{' + tfJSON(propertyType) + '}' }
    }

    return _map
  },

  object: function object (uncompiled) {
    var type = {}

    for (var typePropertyName in uncompiled) {
      type[typePropertyName] = compile(uncompiled[typePropertyName])
    }

    function _object (value, strict) {
      if (!NATIVE.Object(value)) return false
      if (NATIVE.Nil(value)) return false

      var propertyName

      try {
        for (propertyName in type) {
          var propertyType = type[propertyName]
          var propertyValue = value[propertyName]

          typeforce(propertyType, propertyValue, strict)
        }
      } catch (e) {
        throw tfSubError(e, propertyName)
      }

      if (strict) {
        for (propertyName in value) {
          if (type[propertyName]) continue

          throw new TfPropertyTypeError(undefined, propertyName)
        }
      }

      return true
    }
    _object.toJSON = function () { return tfJSON(type) }

    return _object
  },

  anyOf: function anyOf () {
    var types = [].slice.call(arguments).map(compile)

    function _anyOf (value, strict) {
      return types.some(function (type) {
        try {
          return typeforce(type, value, strict)
        } catch (e) {
          return false
        }
      })
    }
    _anyOf.toJSON = function () { return types.map(tfJSON).join('|') }

    return _anyOf
  },

  allOf: function allOf () {
    var types = [].slice.call(arguments).map(compile)

    function _allOf (value, strict) {
      return types.every(function (type) {
        try {
          return typeforce(type, value, strict)
        } catch (e) {
          return false
        }
      })
    }
    _allOf.toJSON = function () { return types.map(tfJSON).join(' & ') }

    return _allOf
  },

  quacksLike: function quacksLike (type) {
    function _quacksLike (value) {
      return type === getValueTypeName(value)
    }
    _quacksLike.toJSON = function () { return type }

    return _quacksLike
  },

  tuple: function tuple () {
    var types = [].slice.call(arguments).map(compile)

    function _tuple (values, strict) {
      if (NATIVE.Nil(values)) return false
      if (NATIVE.Nil(values.length)) return false
      if (strict && (values.length !== types.length)) return false

      return types.every(function (type, i) {
        try {
          return typeforce(type, values[i], strict)
        } catch (e) {
          throw tfSubError(e, i)
        }
      })
    }
    _tuple.toJSON = function () { return '(' + types.map(tfJSON).join(', ') + ')' }

    return _tuple
  },

  value: function value (expected) {
    function _value (actual) {
      return actual === expected
    }
    _value.toJSON = function () { return expected }

    return _value
  }
}

// TODO: deprecate
TYPES.oneOf = TYPES.anyOf

function compile (type) {
  if (NATIVE.String(type)) {
    if (type[0] === '?') return TYPES.maybe(type.slice(1))

    return NATIVE[type] || TYPES.quacksLike(type)
  } else if (type && NATIVE.Object(type)) {
    if (NATIVE.Array(type)) {
      if (type.length !== 1) throw new TypeError('Expected compile() parameter of type Array of length 1')
      return TYPES.arrayOf(type[0])
    }

    return TYPES.object(type)
  } else if (NATIVE.Function(type)) {
    return type
  }

  return TYPES.value(type)
}

function typeforce (type, value, strict, surrogate) {
  if (NATIVE.Function(type)) {
    if (type(value, strict)) return true

    throw new TfTypeError(surrogate || type, value)
  }

  // JIT
  return typeforce(compile(type), value, strict)
}

// assign types to typeforce function
for (var typeName in NATIVE) {
  typeforce[typeName] = NATIVE[typeName]
}

for (typeName in TYPES) {
  typeforce[typeName] = TYPES[typeName]
}

var EXTRA = __webpack_require__(762)
for (typeName in EXTRA) {
  typeforce[typeName] = EXTRA[typeName]
}

typeforce.compile = compile
typeforce.TfTypeError = TfTypeError
typeforce.TfPropertyTypeError = TfPropertyTypeError

module.exports = typeforce


/***/ }),

/***/ 762:
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var NATIVE = __webpack_require__(294)
var ERRORS = __webpack_require__(429)

function _Buffer (value) {
  return Buffer.isBuffer(value)
}

function Hex (value) {
  return typeof value === 'string' && /^([0-9a-f]{2})+$/i.test(value)
}

function _LengthN (type, length) {
  var name = type.toJSON()

  function Length (value) {
    if (!type(value)) return false
    if (value.length === length) return true

    throw ERRORS.tfCustomError(name + '(Length: ' + length + ')', name + '(Length: ' + value.length + ')')
  }
  Length.toJSON = function () { return name }

  return Length
}

var _ArrayN = _LengthN.bind(null, NATIVE.Array)
var _BufferN = _LengthN.bind(null, _Buffer)
var _HexN = _LengthN.bind(null, Hex)
var _StringN = _LengthN.bind(null, NATIVE.String)

function Range (a, b, f) {
  f = f || NATIVE.Number
  function _range (value, strict) {
    return f(value, strict) && (value > a) && (value < b)
  }
  _range.toJSON = function () {
    return `${f.toJSON()} between [${a}, ${b}]`
  }
  return _range
}

var INT53_MAX = Math.pow(2, 53) - 1

function Finite (value) {
  return typeof value === 'number' && isFinite(value)
}
function Int8 (value) { return ((value << 24) >> 24) === value }
function Int16 (value) { return ((value << 16) >> 16) === value }
function Int32 (value) { return (value | 0) === value }
function Int53 (value) {
  return typeof value === 'number' &&
    value >= -INT53_MAX &&
    value <= INT53_MAX &&
    Math.floor(value) === value
}
function UInt8 (value) { return (value & 0xff) === value }
function UInt16 (value) { return (value & 0xffff) === value }
function UInt32 (value) { return (value >>> 0) === value }
function UInt53 (value) {
  return typeof value === 'number' &&
    value >= 0 &&
    value <= INT53_MAX &&
    Math.floor(value) === value
}

var types = {
  ArrayN: _ArrayN,
  Buffer: _Buffer,
  BufferN: _BufferN,
  Finite: Finite,
  Hex: Hex,
  HexN: _HexN,
  Int8: Int8,
  Int16: Int16,
  Int32: Int32,
  Int53: Int53,
  Range: Range,
  StringN: _StringN,
  UInt8: UInt8,
  UInt16: UInt16,
  UInt32: UInt32,
  UInt53: UInt53
}

for (var typeName in types) {
  types[typeName].toJSON = function (t) {
    return t
  }.bind(null, typeName)
}

module.exports = types

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(4).Buffer))

/***/ }),

/***/ 945:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(946);


/***/ }),

/***/ 946:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports['default'] = symbolObservablePonyfill;
function symbolObservablePonyfill(root) {
	var result;
	var _Symbol = root.Symbol;

	if (typeof _Symbol === 'function') {
		if (_Symbol.observable) {
			result = _Symbol.observable;
		} else {

			// This just needs to be something that won't trample other user's Symbol.for use
			// It also will guide people to the source of their issues, if this is problematic.
			// META: It's a resource locator!
			result = _Symbol['for']('https://github.com/benlesh/symbol-observable');
			try {
				_Symbol.observable = result;
			} catch (err) {
				// Do nothing. In some environments, users have frozen `Symbol` for security reasons,
				// if it is frozen assigning to it will throw. In this case, we don't care, because
				// they will need to use the returned value from the ponyfill.
			}
		}
	} else {
		result = '@@observable';
	}

	return result;
};

/***/ })

}]);